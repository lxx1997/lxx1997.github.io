---
title: 个人整理的比较全的知识 - 方便自己回顾
cover: /assets/blogCover/202039_80006038.png
date: 2023-04-04 17:15:19
updated: 2023-04-04 17:15:19
tags:
    - interview
    - promise
---

## HTML

#### 新增的 h5 属性

* 标签类 `header`,`footer`,`aside`,`nav`,`article`
* 媒体播放标签 `audio`,`video`
* canvas svg 等
* 存储属性 localStorage,sessionStorage
* input 标签新增type 属性 `email`,`password`,`file`,`tel`,`date`,`url` 等

## CSS

#### BFC 块级格式化上下文

是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

特性：
* 块级元素会在垂直方向一个接一个排列
* 避免子元素的margin 属性影响父元素
* 保证子元素的属性只在BFC盒内起作用，不会影响盒外的其他元素
* 如果子元素有 float 或者 

触发方式：
* float: left/right
* position: absolute/fixed
* overflow: hidden/hidden-x/hidden-y
* display: inline-block/flex/gid

#### 如何解决高度塌陷

* :after { clear: both;} 或者在父元素内部最后新增一个元素设置 style  clear: both;
* 设置 position: absolute
* overflow: hidden

#### 元素水平垂直居中的方法

* `display: flex; align-items: center;justify-content: space-around;`
* `position:absolute; top:50%;left:50%;transform: translate(-50%, -50%)`
* `display: grid; align-items: center;justify-content: space-around;`
* `margin-top:50%;margin-left:50%;transform: translate(-50%, -50%)`
* 定高的话可以使用 margin-left偏移自身一般宽度和高度

#### flex 布局

有哪些属性
* flex-direction  布局方向 row/row-reverse/column/column-reverse
* flex-wrap 是否换行
* flex-flow flex-direction 和 flex-wrap 的简写模式
* justify-content  主轴上的对齐方式 flex-start/flex-end/space-around/space-between/space-evenly/center
* align-items: 交叉轴 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch
* align-content 多根轴线对齐 flex-start/flex-end/space-around/space-between/space-evenly/center

子元素属性
* order 定义项目排列顺序，数值越大越靠后
* flex 设置 flex-grow/flex-shrik/flex-basic 的缩写
* flex-grow 是否放大 默认为0
* flex-shrink 是否缩小  默认为1
* flex-basic 占据主轴空间
* align-self 单独设置子元素的对齐方式,可以使部分子元素与其他子元素对齐方式不同 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch

#### css 选择器优先级

css 选择器有以下几种
* ID 选择器 `id="abc"`
* 类（class）选择器 `class="abc"`
* 标签选择器  `div`
* 标签属性选择器  `div[title="abc"]`
* 伪类和伪元素 `after,before,selection,focus,hover,active,`
* 父子选择器 `div > p`  

其中 ID 选择器的权重最高，接着是类选择器，最后是标签选择器

## JavaScript

#### 数据类型

基础数据类型有
* Number
* String
* Boolean
* Null
* Undefined
* Symbol
* Bigint (新增的，因为是为了兼容大数)

引用数据
* Object

如何判断数据类型

* typeof  需要注意的是 typeof null = object, typeof func() {} = function
* instanceof 原理是根据原型链来查找的
* Object.prototype.toString.call() 会返回对应元素类型 `[object Object/Array/RegExp/...]`

#### 闭包

闭包是一个函数及其捆绑的周边环境状态的引用的组合，闭包可以使开发者从内部函数访问外部函数的作用域。

* 可以用来实现函数柯里化（将多个参数转变成单个参数传入`func(a,b,c) => func(a)(b)(c)`）
* 可以用来模拟私有方法，因为闭包内部的部分变量和方法，函数外部无法访问
* 闭包还可以用来解决变量提升的问题。

使用闭包需要注意内存泄露问题，因为这些作用域不会随着函数的执行而清除掉

#### 原型链

javascript对象上有一个属性，可以通过这个属性查找到她的原型，而且原型上也有这个属性，可以一级一级的向上查找

~~~js
let obj = new Object()
obj.prototype === undefined
obj.__proto__ === Object.prototype
Object.prototype.__proto__ === null

function func () {

}
let f = new func()
f.__proto__ === func.prototype
func.prototype.__proto__ === Object.prototype 
~~~

当我们在查找一个对象的属性的时候，如果当前对象不存在这个属性，则会沿着原型链一级一级的向上查找，直查找到最后一级，也就是 Object 对象上

**需要注意的是在原型链上查找比较耗时和消耗性能，如果层级比较深的话，可以选择暂存下来**

**原型链上的属性和方法最好不要随意修改，否则可能会影响其他继承于该原型的函数**

#### this 指向

* 直接执行 this 指向 window
~~~js
  function func() {

  }
  func() // window
  const obj = {
    func: function() {

    }
  }
  let f1 = obj.func
  f1() // window
~~~

* 挂载到对象上执行  this指向当前对象
~~~js
  const obj = {
    func: function() {

    }
  }
  obj.func() // obj
~~~

* new 
  使用new 的时候会执行以下几个操作
  1. 创建一个新的空对象
  2. 将当前空对象的 prototype 指向当前函数的 prototype
  3. 将前端对象替换当前函数的执行上下文（this）
  4. 判断函数是否存在返回值，返回值如果是基础数据类型，则this 还是 创建的空对象，否则是return 的对象

* call，bind，apply
  call 和 apply 会立即执行函数，同时将函数的this 指向传入的this
  bind 不会立刻执行，而且参数可以不用一次性传入
  * call(this, ...args) 
  * bind(this, ...args) 
  * apply(this, args)

#### 事件循环 (Event Loop)

* 宏任务（setTimeout，setInterval，script，ajax）
* 微任务（Promise.then, requestAnimationFrame， process.nextTic, Object.observer, MutationObserver(监察dom节点变化)）
* 同步任务 正常js解析，js代码执行等

函数的执行顺序是
* 如果存在同步任务，会先执行同步任务
* 同步任务执行完成后，先查找微任务队列中是否包含任务，如果包含需要执行的任务，会立即执行
* 微任务队列执行完成之后才会去判断宏任务中是否存在需要执行的任务，宏任务每次执行的时候都需要判断微任务队列中是否包含需要执行的任务

#### Promise

* Promise.resolve() 返回一个以给定值解析后的 Promise 对象
* Promise.reject() 返回一个带有拒绝原因的 Promise 对象。
* Promise.then() 返回一个 Promise 对象，有两个回调函数，一个成功的回调，一个失败情况的回调
* Promise.catch() 返回一个 Promise 对象，只有一个失败情况的回调
* Promise.finally() 无论成功和失败都会执行
* Promise.all() 当所有的 Promise 成功后才回返回成功，结果按顺序返回，有一个失败就返回失败
* Promise.race() 只要有一个 Promise 成功或者失败，就是返回一个成功或者失败的结果
* Promise.allSettled() 当所有的 Promise 的结果都获取到才返回，不管成功还是失败
* Promise.any() 只要有一个 Promise 成功就会返回成功的结果，全部失败才会返回失败的结果

[手写一个 Promise 方法](https://lxx1997.github.io/2023/03/13/web/hand-write-promise/)

#### Proxy/Rflect

Proxy 对象用于创建一个对象的代理，实现对基本操作的拦截

*类似于 Object.defineProperties,但是比她的功能更强大*

~~~js
let obj = {
  a: 1
}
let o = new Proxy(obj, {
  set: function(obj, key, value) {
    console.log(obj, key, value)
  },
  get: function(obj, key, value) {
    console.log(obj, key, value)
    return obj[key]
  },
})
obj.a = 20
o.a
o.a = 30
~~~

**需要注意的是，只有通过代理后的对象修改和获取属性时，才会触发代理，原对象修改和删除并不会触发**

**handler 配置属性**

* get   属性读取操作
* set   属性设置操作
* has   in操作符 
* deleteProperty  delete 操作符
* ownKeys Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。
* apply   函数调用时触发
* construct   使用 new 操作符触发
* getPrototypeOf  获取原型对象扑捉器 Object.getPrototypeOf
* setPrototypeOf  设置原型对象扑捉器 Object.setPrototypeOf
* isExensible   Object.isExtensible 方法的捕捉器 是否是可扩展的
* preventExtensible   Object.preventExtensions 方法的捕捉器。设置对象不可扩展
* getOwnPropertyDescriptor  获取对象的属性描述（value,configurable,writable,get,set,enumerable）
* defineProperty  Object.defineProperty 方法的捕捉器。

Reflect 方法同理，主要用来对 Proxy 对应属性的映射

## 浏览器

#### 垃圾回收

* 引用计数
  引用计数的原理当创建和引用对象时，都会给该对象的引用次数加1，当给变量重新赋值或者执行的上下文清除时，引用次数 -1，当引用次数为0的时候，会被清除的。

  缺点是当出现循环引用的时候，由于引用计数一直不为0，所以无法被清除

* 标记清除
  当变量进入执行环境时，会标记状态为进入，当弹出执行环境时，会标记状态为清除，标记状态为清除的会自动被js引擎清除

  缺点是容易造成内存碎片化

* 标记整理法
  同标记清除，会在清除后重新整理内存地址

* 垃圾回收优化
  将内存分为 新生代和老生代，新生代缓存的是存活时间比较短的地址，老生代缓存的是存活时间久的地址

  同时新生代又分为使用区和空闲区（双缓存），在进行清除时，会将使用区的变量的标记进行判断，如果被标记，则放到空闲区内，并且进行内存整理，最后将使用区的内存清空，并将使用区变成空闲区，空闲区变成使用区，并重复上述操作

* 内存泄露

  * 循环引用
  * 闭包
  * 没有终止的 setInterval 

#### 性能优化

[最全的页面性能优化](https://lxx1997.github.io/2022/06/24/web/how-to-make-pagespeed-fast/)

#### 输入一个链接地址到显示到页面上具体经过了那些步骤

* 浏览器首先会根据输入的网址，进行 DNS 域名解析找到对应服务器的ip地址

* 建立连接 （TCP/IP 协议）三次握手 客户端向服务端发送SYN 服务器恢复 SYN-ACK,最后客户端发送 ACK 报文

* 发送请求（请求头，请求体）到服务器，服务器会根据传入的地址，找到对应的文件返回到客户端

* 客户端下载文件后，会解析文件，将标签和样式通过对应的parse 转化为 dom 树和 CSSOM 树

* 如果在解析的过程中遇到 script 标签，如果script 标签没有引用外部文件，则会停止文件解析，等待 script 内部代码执行完成后才会继续解析，如果引入了外部文件，则会根据 defer 属性和 async 属性，来判断是否延迟加载 js文件。

* 将生成的 DOM 树和 CSSOM 树合并形成渲染树，进行布局计算，将计算结果会渲染屏幕上

* 渲染时涉及到图层的概念（position，translae3d，will-change, transform）,启动GPU加速，将所有图层最后组合到页面上正成最终结果


#### 浏览器缓存

* `cache-control`
  * `max-age` 最大缓存时间
  * `no-store`  浏览器不会进行缓存，也不会进行协商缓存
  * `no-cache`  浏览器进行协商缓存通过 `ETag/If-Match` 和 `last-modified`
  * `public` 可以被任何缓存例如共有缓存（CDN）和私有缓存（浏览器）
  * `private` 仅可被私有缓存（浏览器）缓存

* 强缓存：
  强缓存主要是向浏览器缓存区获取文件，并且根据文件是否失效（`max-age`/`exproes`）来判断是否需要重新重服务器拿取文件

* 协商缓存：
  当强缓存失效时，会走协商缓存，协商缓存不会直接从浏览器缓存中拿取数据，而是直接向服务器发送请求，服务器根据 ETag 和 last-Modified 参数和服务器文件进行对比，如果发生变更，则代表文件已修改，返回给客户端最新的文件，如果没有变更再去读取本地缓存的文件

* 缓存类型
  * server-work （sw.js）走的是server-work 的缓存逻辑
  * memory cache  存在内存中，如果关闭tab页缓存会失效
  * disk cache  存在磁盘缓存中


#### 重绘和重排(回流)

* 重绘 是指元素自身属性发生变化时，并不会影响其他元素位置和属性变化，例如：color，opciaty，backgound等
* 重排是指元素本身的物理尺寸发生变化时，引起页面重新排列，列如修改宽，高，外边距，内边距，边框，添加和删除元素，display: none等

**如何避免频繁触发重绘和重排**

* 如果涉及到频繁修改样式，可以采用统一修改的方式，例如，添加 class 或者 cssText
* 设置 position: absolute 脱离文档流
* 这是 transform 和 will-change 属性，启动 gpu加速

* 修改元素时批量修改
  * 设置 display: none;修改完成后在显示出来
  * 使用文档片段 （document.createDocumentFragment()）
  * 创建一个熄灯节点，用来更新内容，更新换成后替换旧节点

* 获取以下属性和方法时，页面会被强制更新，因为这些属性需要根据页面上元素的最新状态进行更新
  offsetTop、offsetLeft、offsetWidth、offsetHeight
  scrollTop、scrollLeft、scrollWidth、scrollHeight
  clientTop、clientLeft、clientWidth、clientHeight
  getComputedStyle()
  getBoundingClientRect

#### HTTP1/HTTP2

## Vue2

#### 常用指令

* v-if
* v-else
* v-else-if
* v-show
* v-for
* v-html
* v-text
* v-bind
* v-on
* v-model
* v-once
* v-slot 插件

#### 常用修饰符

* number
* .lazy v-model 监听change 而非 input
* keyup/keydown
* trim
* prevent/stop 阻止默认事件
* once 只执行一次
* right/left 鼠标左右键点击触发
* camel 将属性转驼峰

#### 生命周期

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestory
destoryed
errorCaptured 错误监听
activited  keep-alive
deactivited keep-alive

#### 组件通讯

* 父子组件通讯
  * props
  * provide/inject
  * $emit
  * $parent/$children
  * $ref
  * event bus
* 兄弟组件
  * 通过父组件传值
  * $parent
  * event bus
* 不相关组件
  * event bus
  * Vuex

[Vue 组件之间通讯的各种情况](https://lxx1997.github.io/2021/01/07/vue/vue-components-transfer-data/)

#### computed 和 watch

* computed 计算属性，计算后的结果值会被缓存下来，如果相关联的属性没有发生变化时，会取缓存后的结果
* watch 监听属性，当属性发生变化时，会重新执行监听函数，针对对象可以使用 immediate 和 deep 来启动立即监听和深度监听

在日常使用中更推介使用computed 属性，因为会对得到的结果进行缓存，减少计算量

#### diff 算法

当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom

对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程

在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较

在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的

具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。

在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。

这样一直递归的遍历下去，直到整棵树完成对比。

[请阐述vue的diff算法](https://juejin.cn/post/6958292554047553549)

**Vue diff 算法双指针逻辑总结**

新创建的 子节点数组 和 旧的子节点数组分别有一个 头节点指针和尾结点指针。

针对旧节点的两个指针，如果新节点的两个指针有匹配到的，则将该指针所对应的 Vnode 转移到对应的位置（头对头，尾队尾），对应头结点和尾结点的位置进行变化（头结点后移，尾结点前移）

知道头尾节点均不符合匹配时，这样就筛选出来两类节点，一种是旧子节点数组上需要删除的子节点，一种是新的子节点上需要新增的子节点。

这样做的目的是最大可能性的复用已有的真实dom节点，对于新增的，需要创建新的 dom节点。



#### MVVM 框架

MVVM 是指双向数据流，即 View-Model 之间的双向通信，由 ViewModel 作桥接

[Mvvm 前端数据流框架精讲](https://juejin.cn/post/6844903590448857096)

#### v-for 和 v-if

v-for 的优先级比v-if 的优先级要高，页面会首先根据 v-for 渲染列表，然后在根据 v-if 来判断列表元素是否显示和隐藏，因此会造成性能浪费

因此推荐使用 computed 属性，提前过滤需要隐藏后的数据后，在使用 v-for 进行渲染

#### v-show 和 v-if

v-show 会进行dom 树的构建，但是 display 属性为 none

v-if 不会进行组件渲染，自然也不会构建 dom 树，对性能有优化

#### v-for 循环时 key的作用是什么

进行diff 算法时，方便进行对比组件是否更新，以及组件复用

#### $nextTick 原理

主要是利用了 javascript 引擎的时间循环机制，是的 $nextTick 传入的参数在同步事件之后触发，可以拿到 修改后的dom和 data 里面的值

使用 `Promise.then`,`setImediate`, `setTimeout`, `mutationObserve` 来实现

#### Vue 是如何监听属性变化的

使用 `Object.defineProperty` 来监听属性的变化，重写get，set 方法，当

#### data 为什么要用一个函数的模式

是因为组件是可以重复使用的，如果data 不用一个函数模式的话，可以会造成数据混乱，无法获取到想要的数据

#### Vuex 有几个模块
* module
* state
* mutations
* actions
* getters

Vuex 提供了 mapGetters，mapState，mapActions 等方法，方便我们快速获取Vuex 的值

#### Vue-router 有几个模式

设置 router 的 mode 属性，默认为 hash 模式，设置 history 后，为history模式
* hash模式
在网址后面以 # 模式
* history 模式
直接跟在网址后面

#### Vue 项目如何优化

* 路由懒加载 () => import("")
* 组件懒加载 () => import("")
* v-if 和 v-for 避免一起使用，可以用计算属性过滤部分数据
* 针对经常显示隐藏的页面结构，可以使用 v-show，否则应使用 v-if

等等

## Vue3

## React

#### 生命周期


挂载阶段
* constructor
* componentWillMount（新版 getDerivedtateFromProps）
* render
* componentDidMount

更新阶段
* componentWillReceiveProps （getDerivedtateFromProps））
* shouldComponentUpdate
* componentWillUpdate （null）
* render
* （getSnapshotBeforeUpdate）
* componentDidUpdate

卸载阶段
* componentWillUnmount

**为什么新版的react 的生命周期要加上 UNSAFE_ 前缀**

这个是因为这个函数不安全，原因是因为 react 16 以后 react 支持 fiber 切片后，组件会根据执行优先级来进行编译和渲染，因此可能会出现一个组件正在执行更新或者创建操作时，有一个优先级更高的任务插进来，这个时候，当前任务会被暂停掉，更换优先级更高的任务执行操作，操作完成后，才会回到之前的操作，继续执行，这个时候，部分生命周期有可能会执行两次，造成数据混乱

#### diff 算法
[React技术揭秘-卡颂](https://react.iamkasong.com/diff/multi.html#demo2)
React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中n是树中元素的数量

React diff 算法做了以下优化
1. 只进行同级比较，如果一个节点在更新前后层级不一样，则不会进行比较
2. 不同类型的子元素是一个新的树，旧的树会被直接销毁，新的树会被创建
3. 可以通过key 值来判断那些子元素保持稳定

react 在进行 diff 算法时，会首先针对 节点的 类型，key进行对比，如果都一样，在对比传入的 props，state 等属性是否有变化，有变化执行更新操作，没有变化就直接复用，不过不一样，则会创建一个新的节点

~~~js
// 之前
abcd

// 之后
dabc

===第一轮遍历开始===
d（之后）vs a（之前）  
key改变，不能复用，跳出遍历
===第一轮遍历结束===

===第二轮遍历开始===
newChildren === dabc，没用完，不需要执行删除旧节点
oldFiber === abcd，没用完，不需要执行插入新节点

将剩余oldFiber（abcd）保存为map

继续遍历剩余newChildren

// 当前oldFiber：abcd
// 当前newChildren dabc

key === d 在 oldFiber中存在
const oldIndex = d（之前）.index;
此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3
比较 oldIndex 与 lastPlacedIndex;
oldIndex 3 > lastPlacedIndex 0
则 lastPlacedIndex = 3;
d节点位置不变

继续遍历剩余newChildren

// 当前oldFiber：abc
// 当前newChildren abc

key === a 在 oldFiber中存在
const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0
此时 oldIndex === 0;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 0 < lastPlacedIndex 3
则 a节点需要向右移动

继续遍历剩余newChildren

// 当前oldFiber：bc
// 当前newChildren bc

key === b 在 oldFiber中存在
const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1
此时 oldIndex === 1;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 1 < lastPlacedIndex 3
则 b节点需要向右移动

继续遍历剩余newChildren

// 当前oldFiber：c
// 当前newChildren c

key === c 在 oldFiber中存在
const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2
此时 oldIndex === 2;
比较 oldIndex 与 lastPlacedIndex;
oldIndex 2 < lastPlacedIndex 3
则 c节点需要向右移动

===第二轮遍历结束===
~~~

#### fiber 分片

#### 常用 hooks

* useState

* useEffect

* useLayoutEffect

* useRef

* useMemo  缓存

* useCallback 缓存

* useContext

* useReducer

* useImperativeHandle/forwardRef

  useImperativeHandle 可以将子组件中部分函数暴露给父组件的 ref使用 

#### 组件通讯

* mobx/redux 等状态管理工具
* props
* ref/useImperativeHandle
* 发布订阅模式

#### React 如何监听数据变化

主要是通过 setState，useState，forceUpdate，会生成一个 Update 对象，会和原属性的值进行对比，如果发生改变，则会触发更新

## Webpack

## Other
