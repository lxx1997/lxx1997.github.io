---
title: leetcode 百天解题 - day 20 - 636. 函数的独占时间
cover: /assets/cover/全図鑑達成_61337726_p20.png
date: 2022-08-07 22:31:39
updated: 2022-08-07 22:31:39
hide: true
categories:
    - leetcode
tags:
    - leetcode
    - JavaScript
------
## 题目名称

有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于  0 和 n-1 之间的唯一标识符。

函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。

给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 "{function_id}:{"start" | "end"}:{timestamp}" 进行格式化的字符串。例如，"0:start:3" 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 "1:end:2" 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。

函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。

以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。


## 示例

输入：n = 2, logs = ["0:start:0","1:start:2","1:end:5","0:end:6"]

输出：[3,4]

解释：

函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 

函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 

函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。 
所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。

输入：n = 1, logs = ["0:start:0","0:start:2","0:end:5","0:start:6","0:end:6","0:end:7"]

输出：[8]

解释：

函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。

函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。

函数 0（初始调用）恢复执行，并立刻再次调用它自身。

函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。

函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。

所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。

## 题解

这道题主要考察的就是堆栈的方法

首先我们先创建一个空栈，这里用数组模拟，以及一个时间字段，用来存储当前时间，任务id 对应执行时间数组，默认时间为0

针对输入的数组数据进行遍历操作

1. 根据输入的内容拿取到以下关键内容：**任务id**，**任务状态**， **时间**

2. 判断任务状态是 `start` 还是 `end`,如果是 `start` 执行步骤三操作，否则执行步骤四

3. 判断栈的长度，如果栈内有值，说明栈内的最后一个元素代表的函数执行到当前时间时被暂停，并更新对应任务的执行时间，如果无值，说明该函数开始执行。并且将时间重置为当前时间，向堆栈中插入当前输入内容

4. 当前任务状态为 结束时，获取当前任务的结束时间，更新对应任务执行时间，并且将时间重置为当前时间

最后输入任务执行时间列表

## 答案

~~~js
var exclusiveTime = function(n, logs) {
    let logArray = new Array(n).fill(0)
    let stack = [], currentTime = 0
    for(let i = 0; i < logs.length; i++) {
        let log = logs[i].split(":")
        log[0] = +log[0]
        log[2] = +log[2]
        if(log[1] ==="end") {
            stack.pop()
            logArray[log[0]] += log[2] - currentTime + 1
            currentTime = log[2] + 1
        } else {
            let length = stack.length
            if(length) {
                logArray[stack[length - 1][0]] += log[2] - currentTime
            }
            currentTime = log[2]
            stack.push(log)
        }
    }
    return logArray
};
~~~
