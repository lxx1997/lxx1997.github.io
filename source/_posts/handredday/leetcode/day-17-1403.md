---
title: leetcode 百天解题 - day 17 - 1403. 非递增顺序的最小子序列
cover: /assets/cover/全図鑑達成_61337726_p17.png
date: 2022-08-04 22:22:40
updated: 2022-08-04 22:22:40
categories:
    - leetcode
tags:
    - leetcode
    - JavaScript
------
## 题目名称

给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。


## 示例

输入：nums = [4,3,10,9,8]

输出：[10,9] 

解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。

## 题解

这道题其实只是一个简单难度的题，最开始没有仔细读题，看到子序列数组，以为是连续的，所以就采用`滑动窗口`的思路去做，结果提交的时候发现和用例不对。

然后仔细读了一下题发现以下重点 **不强调元素在原数组中的连续性** 和 **答案应当按 非递增顺序 排列**

这个时候思路就十分清晰了，既然答案需要按非递增序列排序，我们就先把传进来的数组按照非递增顺序排序，然后计算数组的和，从头开始遍历数组，将数组的每一项加起来和数组剩余的数进行对比，如果满足要求，则代表这一部分数组是我们要的结果，而且也不需要再去对比不同子序列的长度和和的大小，因为数组开头的元素是最大的，得到的子序列是一定满足最后的结果的

## 答案

~~~js
var minSubsequence = function(nums) {
    nums = nums.sort((a,b) => b - a)
    let total = nums.reduce((total, item) => total += item, 0)
    let index = 0, mix = 0
    for(let i = 0; i < nums.length; i++) {
        mix += nums[i]
        if(mix > total - mix) {
            index = i
            break;
        }
    }
    return nums.splice(0, index + 1)
};
~~~


