{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Tue, 09 Aug 2022 13:40:50 GMT","lastBuildDate":"Tue, 09 Aug 2022 23:49:13 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"leetcode 百天解题 - day 22 - 1413. 逐步求和得到正数的最小值","link":"https://lxx1997.github.io/2022/08/09/handredday/leetcode/day-22-1413/","description":"题目名称给你一个整数数组 nums 。你可以选定任意的 正数 startValue 作为初始值。 你需要从左到右遍历 nums 数组，并将 startValue 依次累加上 nums 数组中的值。 请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 正数 作为 startValue 。 示例输入：nums = [-3,2,-3,4,2]输出：5解释：如果你选择 startValue = 4，在第三次累加时，和小于 1 。累加求和 startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 题解这道题无难点，需要注意的就是正数是大于0的 答案1234567891011var minStartValue = function(nums) &#123; let startValue = 1, total = 0 for(let i = 0; i &lt; nums.length; i++) &#123; total += nums[i] if(total &lt; 1) &#123; startValue = Math.max(startValue, Math.abs(total) + 1) &#125; &#125; return startValue&#125;;","pubDate":"Tue, 09 Aug 2022 13:40:50 GMT","guid":"https://lxx1997.github.io/2022/08/09/handredday/leetcode/day-22-1413/","category":"leetcode"},{"title":"leetcode 百天解题 - day 21 - 17. 电话号码的字母组合","link":"https://lxx1997.github.io/2022/08/08/handredday/leetcode/day-21-17/","description":"题目名称给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母 示例输入：digits = “23” 输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”] 题解这道题 主要把每个数对应的字符一一列出来，然后遍历传入的内容，每取一组新的字符，都需要根据已有的字母组合进行新的组合，并且替换原有的组合 答案12345678910111213141516171819202122232425 var letterCombinations = function(digits) &#123; let defaultCode = &#123; &quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;qprs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;: &quot;wxyz&quot; &#125;, strs = [] for(let i = 0; i &lt; digits.length; i++) &#123; let s = defaultCode[digits[i]] if(strs.length === 0) &#123; strs = s.split(&quot;&quot;) &#125; else &#123; let newStr = [] for(let j = 0; j &lt; strs.length; j++) &#123; newStr.push(...s.split(&quot;&quot;).map(item =&gt; strs[j] + item)) &#125; strs = newStr &#125; &#125; return strs&#125;;","pubDate":"Mon, 08 Aug 2022 14:01:32 GMT","guid":"https://lxx1997.github.io/2022/08/08/handredday/leetcode/day-21-17/","category":"leetcode"},{"title":"leetcode 百天解题 - day 20 - 636. 函数的独占时间","link":"https://lxx1997.github.io/2022/08/07/handredday/leetcode/day-20-636/","description":"题目名称有一个 单线程 CPU 正在运行一个含有 n 道函数的程序。每道函数都有一个位于 0 和 n-1 之间的唯一标识符。 函数调用 存储在一个 调用栈 上 ：当一个函数调用开始时，它的标识符将会推入栈中。而当一个函数调用结束时，它的标识符将会从栈中弹出。标识符位于栈顶的函数是 当前正在执行的函数 。每当一个函数开始或者结束时，将会记录一条日志，包括函数标识符、是开始还是结束、以及相应的时间戳。 给你一个由日志组成的列表 logs ，其中 logs[i] 表示第 i 条日志消息，该消息是一个按 “{function_id}:{“start” | “end”}:{timestamp}” 进行格式化的字符串。例如，”0:start:3” 意味着标识符为 0 的函数调用在时间戳 3 的 起始开始执行 ；而 “1:end:2” 意味着标识符为 1 的函数调用在时间戳 2 的 末尾结束执行。注意，函数可以 调用多次，可能存在递归调用 。 函数的 独占时间 定义是在这个函数在程序所有函数调用中执行时间的总和，调用其他函数花费的时间不算该函数的独占时间。例如，如果一个函数被调用两次，一次调用执行 2 单位时间，另一次调用执行 1 单位时间，那么该函数的 独占时间 为 2 + 1 = 3 。 以数组形式返回每个函数的 独占时间 ，其中第 i 个下标对应的值表示标识符 i 的函数的独占时间。 示例输入：n = 2, logs = [“0:start:0”,”1:start:2”,”1:end:5”,”0:end:6”] 输出：[3,4] 解释： 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，于时间戳 1 的末尾结束执行。 函数 1 在时间戳 2 的起始开始执行，执行 4 个单位时间，于时间戳 5 的末尾结束执行。 函数 0 在时间戳 6 的开始恢复执行，执行 1 个单位时间。所以函数 0 总共执行 2 + 1 = 3 个单位时间，函数 1 总共执行 4 个单位时间。 输入：n = 1, logs = [“0:start:0”,”0:start:2”,”0:end:5”,”0:start:6”,”0:end:6”,”0:end:7”] 输出：[8] 解释： 函数 0 在时间戳 0 的起始开始执行，执行 2 个单位时间，并递归调用它自身。 函数 0（递归调用）在时间戳 2 的起始开始执行，执行 4 个单位时间。 函数 0（初始调用）恢复执行，并立刻再次调用它自身。 函数 0（第二次递归调用）在时间戳 6 的起始开始执行，执行 1 个单位时间。 函数 0（初始调用）在时间戳 7 的起始恢复执行，执行 1 个单位时间。 所以函数 0 总共执行 2 + 4 + 1 + 1 = 8 个单位时间。 题解这道题主要考察的就是堆栈的方法 首先我们先创建一个空栈，这里用数组模拟，以及一个时间字段，用来存储当前时间，任务id 对应执行时间数组，默认时间为0 针对输入的数组数据进行遍历操作 根据输入的内容拿取到以下关键内容：任务id，任务状态， 时间 判断任务状态是 start 还是 end,如果是 start 执行步骤三操作，否则执行步骤四 判断栈的长度，如果栈内有值，说明栈内的最后一个元素代表的函数执行到当前时间时被暂停，并更新对应任务的执行时间，如果无值，说明该函数开始执行。并且将时间重置为当前时间，向堆栈中插入当前输入内容 当前任务状态为 结束时，获取当前任务的结束时间，更新对应任务执行时间，并且将时间重置为当前时间 最后输入任务执行时间列表 答案12345678910111213141516171819202122var exclusiveTime = function(n, logs) &#123; let logArray = new Array(n).fill(0) let stack = [], currentTime = 0 for(let i = 0; i &lt; logs.length; i++) &#123; let log = logs[i].split(&quot;:&quot;) log[0] = +log[0] log[2] = +log[2] if(log[1] ===&quot;end&quot;) &#123; stack.pop() logArray[log[0]] += log[2] - currentTime + 1 currentTime = log[2] + 1 &#125; else &#123; let length = stack.length if(length) &#123; logArray[stack[length - 1][0]] += log[2] - currentTime &#125; currentTime = log[2] stack.push(log) &#125; &#125; return logArray&#125;;","pubDate":"Sun, 07 Aug 2022 14:31:39 GMT","guid":"https://lxx1997.github.io/2022/08/07/handredday/leetcode/day-20-636/","category":"leetcode"},{"title":"leetcode 百天解题 - day 19 - 1408. 数组中的字符串匹配","link":"https://lxx1997.github.io/2022/08/06/handredday/leetcode/day-19-1408/","description":"题目名称给你一个字符串数组 words ，数组中的每个字符串都可以看作是一个单词。请你按 任意 顺序返回 words 中是其他单词的子字符串的所有单词。 如果你可以删除 words[j] 最左侧和/或最右侧的若干字符得到 word[i] ，那么字符串 words[i] 就是 words[j] 的一个子字符串。 示例输入：words = [“mass”,”as”,”hero”,”superhero”] 输出：[“as”,”hero”] 解释：”as” 是 “mass” 的子字符串，”hero” 是 “superhero” 的子字符串。 [“hero”,”as”] 也是有效的答案。 题解无难点，略 答案1234567891011121314var stringMatching = function(words) &#123; words = words.sort((a,b) =&gt; a.length - b.length) let arr = [] for(let i = 0; i &lt; words.length - 1; i++) &#123; let word = words[i], flag = false for(let j = i + 1; j &lt; words.length &amp;&amp; !flag; j++) &#123; if(words[j].includes(word)) &#123; flag = true; arr.push(word) &#125; &#125; &#125; return arr&#125;;","pubDate":"Sat, 06 Aug 2022 04:20:13 GMT","guid":"https://lxx1997.github.io/2022/08/06/handredday/leetcode/day-19-1408/","category":"leetcode"},{"title":"leetcode 百天解题 - day 18 - 623. 在二叉树中增加一行","link":"https://lxx1997.github.io/2022/08/05/handredday/leetcode/day-18-623/","description":"题目名称给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。cur 原来的左子树应该是新的左子树根的左子树。cur 原来的右子树应该是新的右子树根的右子树。如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例输入: root = [4,2,6,3,1,5], val = 1, depth = 2 输出: [4,1,1,2,null,null,6,3,1,5] 题解这道题主要还是考察二叉树的遍历，首先根据二叉树的层级遍历出一个二维数组（或者只要遍历到depth 所需要的深度即可，无需完全遍历），二维数组中的元素对应着每一层的节点及节点数 depth 实际上是获取 depth - 1 层的节点数，然后在根据获取到的节点及节点的左右子节点来添加新的左右子节点以及旧左右子节点的位置 答案123456789101112131415161718192021222324252627282930313233343536var addOneRow = function(root, val, depth) &#123; let rootRow = flatRoot([[root]]) if(depth === 1) &#123; let r = &#123; val: val, left: root, right: null&#125; return r &#125; let row = rootRow[depth - 2] for(let i = 0; i &lt; row.length; i++) &#123; let item = row[i] let &#123; left, right &#125; = item let l = &#123; val, left: null, right: null&#125;, r = &#123; val, left: null, right: null &#125; if(left &amp;&amp; right) &#123; l.left = left r.right = right &#125; else if(left &amp;&amp; !right) &#123; l.left = left &#125; else if(!left &amp;&amp; right) &#123; r.right = right &#125; item.left = l item.right = r &#125; return root&#125;;var flatRoot = (arr) =&gt; &#123; let root = arr[arr.length - 1], newArr = [] for(let i = 0; i &lt; root.length; i++) &#123; let item = root[i] item.left &amp;&amp; newArr.push(item.left) item.right &amp;&amp; newArr.push(item.right) &#125; if(newArr.length === 0) return arr arr.push(newArr) return flatRoot(arr)&#125;","pubDate":"Fri, 05 Aug 2022 14:27:39 GMT","guid":"https://lxx1997.github.io/2022/08/05/handredday/leetcode/day-18-623/","category":"leetcode"},{"title":"leetcode 百天解题 - day 17 - 1403. 非递增顺序的最小子序列","link":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","description":"题目名称给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 题解这道题其实只是一个简单难度的题，最开始没有仔细读题，看到子序列数组，以为是连续的，所以就采用滑动窗口的思路去做，结果提交的时候发现和用例不对。 然后仔细读了一下题发现以下重点 不强调元素在原数组中的连续性 和 答案应当按 非递增顺序 排列 这个时候思路就十分清晰了，既然答案需要按非递增序列排序，我们就先把传进来的数组按照非递增顺序排序，然后计算数组的和，从头开始遍历数组，将数组的每一项加起来和数组剩余的数进行对比，如果满足要求，则代表这一部分数组是我们要的结果，而且也不需要再去对比不同子序列的长度和和的大小，因为数组开头的元素是最大的，得到的子序列是一定满足最后的结果的 答案12345678910111213var minSubsequence = function(nums) &#123; nums = nums.sort((a,b) =&gt; b - a) let total = nums.reduce((total, item) =&gt; total += item, 0) let index = 0, mix = 0 for(let i = 0; i &lt; nums.length; i++) &#123; mix += nums[i] if(mix &gt; total - mix) &#123; index = i break; &#125; &#125; return nums.splice(0, index + 1)&#125;;","pubDate":"Thu, 04 Aug 2022 14:22:40 GMT","guid":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","category":"leetcode"},{"title":"leetcode 百天解题 - day 16 - 16. 最接近的三数之和","link":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","description":"题目名称给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 题解这道题其实和 12天的三数之和类似，如果采用粗暴的三次遍历的方式的话，提交结果测试的时候肯定是会发生超时的，所以这里还是采用双指针的方式 首先先判断长度，如果数组长度等于3，那么可以肯定的是这三个数的和就是我们需要的值 如果长度大于三，这个时候我们先把数组按照从小到大的顺序排列，然后针对第一个数进行 for 循环，另外两个数采用指针的方式进行循环，计算三个数的和，是否与target 最小，如果不是，根据差的正负值来判断是移动左指针还是右指针，最后返回最接近的值 答案123456789101112131415161718192021var threeSumClosest = function(nums, target) &#123; nums = nums.sort((a, b) =&gt; a - b) if(nums.length === 3) return nums.reduce((total, item) =&gt; total += item, 0) let mixSum = target, smallest = Infinity for(let i = 0; i &lt; nums.length - 2; i++) &#123; let total = nums[i] let left = i + 1, right = nums.length - 1 while(left &lt; right) &#123; let sum = total + nums[left] + nums[right] let deffer = target - sum, absDeffer = Math.abs(deffer) if(absDeffer &gt; smallest) &#123; deffer &lt; 0 ? right-- : left++ &#125; else &#123; smallest = absDeffer mixSum = sum deffer &lt; 0 ? right-- : left++ &#125; &#125; &#125; return mixSum;&#125;;","pubDate":"Wed, 03 Aug 2022 14:57:28 GMT","guid":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","category":"leetcode"},{"title":"leetcode 百天解题 - day 15 - 622. 设计循环队列","link":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","description":"题目名称设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 题解这道题主要考察队列的实现，这里的队列采用的先进先出原则，我们在这里可以使用数组来模拟，当我们添加一个元素的时候使用 Array.push 方法向数组末尾添加一个元素，删除元素时，使用 Array.shift 删除数组开始的元素模拟出队列的先进先出原则 答案123456789101112131415161718192021222324252627282930313233343536373839404142434445var MyCircularQueue = function(k) &#123; this.queue = [] this.length = k this.index = 0&#125;;MyCircularQueue.prototype.enQueue = function(value) &#123; if(this.index &lt; this.length) &#123; this.queue.push(value) this.index++ return true &#125; return false&#125;;MyCircularQueue.prototype.deQueue = function() &#123; if(this.index &gt; 0) &#123; this.queue.shift() this.index-- return true &#125; return false&#125;;MyCircularQueue.prototype.Front = function() &#123; if(this.index &gt; 0) &#123; return this.queue[0] &#125; return -1&#125;;MyCircularQueue.prototype.Rear = function() &#123; if(this.index &gt; 0) &#123; return this.queue[this.index - 1] &#125; return -1&#125;;MyCircularQueue.prototype.isEmpty = function() &#123; return this.index === 0&#125;;MyCircularQueue.prototype.isFull = function() &#123; return this.index === this.length&#125;;","pubDate":"Tue, 02 Aug 2022 13:15:19 GMT","guid":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","category":"leetcode"},{"title":"vue3 组合式Api setup","link":"https://lxx1997.github.io/2022/08/02/vue3-composition-api-setup/","description":"什么是组合式API组合式API 主要是为了把相同的逻辑关注点收集在一起，使得逻辑处理更加清晰和方便。 针对 vue2 的组件选项来说，（data, computed, methods, watch）等组件存在，导致我们在修改同一个逻辑关注点的之后需要不停地跳转相关的代码块，代码碎片化，使得我们理解和维护复杂组件变得困难。 在 vue3组件中，这个位置称为 setup 这个是 Vue3 新增的一个选项 setup 选项会在组件被创建之前执行，一旦 props 解析完成，setup 就会被作为 组合式Api 的入口，也就是说 setup 执行的时机要比 vue2 的 beforeCreate 要早，此外 setup 中应避免使用 this 且因为调用发生在 data，computed，methods 之前，所以无法在 setup 中获取 既然 setup 中无法获取到 data，computed 中的内容，那么我们怎么创建和监控变量变化，且组件内能获取到呢？ setup 接收 props 和 context props 是父元素传递过来的 props context 是当前组件实例上下文 setup 函数 return 出一个对象，这个对象可以被组件直接获取到，相当于 data 和 methods 的集团体 怎么保证 setup 返回的变量是响应式的呢？ vue3 提供了一些 hooks，可以让我们创建响应式的变量 参数propssetup 接受两个参数，第一个参数是props，且是响应式的，传入新的props 时，会被一起更新 因为是响应式的，所以无法直接使用解构赋值，会失去响应式 12345678910111213141516171819202122232425262728293031323334353637383940// 父组件/** * 父组件向子组件传递一个 props title 属性，并且这个属性会在 3s 后发生变化 */export default &#123; setup() &#123; const title = ref(&quot;hhhhhh&quot;) setTimeout(() =&gt; &#123; title.value = &quot;this is new title&quot; &#125;, 3000); watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125; &#125;&#125;// 子组件/** * 子组件这里必须要在props 属性上添加需要接受的属性，否则setup 中的 props 无法接受到 * 当props 属性发生变化时，使用 watch 监听可以再次被触发，但是页面上内容不会发生变化，这是因为我们直接取的 props 里面的属性值，不具备响应式 */export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = props return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果我们想要对 props 进行解构操作，可以使用 toRefs 函数来完成此操作 下面代码我们会发现当 props 中的 title 属性发生变化后， 组件内 title 并不会跟随变化，而 computedTitle 则会跟随props 中的 title 属性发生变化 12345678910111213141516171819export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = toRefs(props) return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它 toRef 的作用相当于把 对象中的属性转化为 ref 类的属性，且与对象相关联，当对象中对应属性发生变化时, toRef 中的内容会同步发生改变 123456setup(props, context) &#123; let name = toRef(props, &quot;name&quot;) // name 会跟随 props 中的 name 属性变化而同步更新 return &#123; name: name &#125;&#125; contextcontext 是一个普通 JavaScript 对象，不是响应式的，因此可以使用 解构操作 暴露了其它可能在 setup 中有用的值： attrs 类似于 $attrs slots 类似于 $slots emit 类似于 $emit expose 公共property slots 和 attrs 是有状态的对象，跟随组件本身的更新而更新，避免使用解构赋值，如果想要根据 attrs 和 solts 更改应用富足用，应该在 onBeforeUpdate 钩子中执行操作 returnsetup return 出来的值可以在模板和组件中直接使用 如果父组件想要访问子组件 setup 中的 property，可以使用 expose 方法暴露出去 123456789101112export default &#123; setup(props, &#123; expose &#125;)&#123; let count = ref(0) const changeCount = () =&gt; ++count.value expose(&#123; changeCount &#125;) return &#123; count &#125; &#125;&#125; hookssetup 内部的钩子函数 onBeforeMount // 页面挂载钩子函数 onMounted onBeforeUpdate // 页面更新钩子函数 onUpdated onBeforeUnmount // 页面销毁钩子函数 onUnmounted onErrorCaptured // 页面错误事件钩子函数 onRenderTracked onRenderTriggered // 跟踪虚拟 DOM 重新渲染时调用 onActivated // keep-alive 缓存的组件激活时调用 onDeactivated // keep-alive 缓存的组件失活时调用 这些钩子函数的触发时机和在组件内部触发时机一致 这些钩子函数接受一个回调函数，当钩子函数被调用时，将会被执行 带 ref 的响应式变量在 Vue3 中，我们可以通过 ref hooks 创建一个响应式变量，ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值 之所以把值封装在对象中，主要是因为字符串和数字这些基本类型时通过值传递的，通过对象封装后，可以在整个对象安全的传递，不用担心失去响应式 1&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; 123456789101112131415setup(props, context) &#123; const title = ref(&quot;setup component&quot;) const changeTitle = function(val) &#123; title.value = val &#125; setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) return &#123; title, changeTitle &#125;&#125; 在上述实例中，我们可以发现，在3s 过后，页面上显示的内容发生变化，而且setup return 出来的属性和方法在组件的其他选项中都可以通过 this 来访问到 watch 响应式处理如果我们想要在 setup 选项中监听属性的变化，可以通过 watch hooks 方法监听属性变化 watch 接受三个参数，监听对象，回调函数，配置选项 配置选项同组件中的 watch 选项，同样包含 deep 和 immediate 属性，而且还额外接受一个 flush 选项 flush 选项有三个值 pre 默认值，指定回调在渲染前被调用 post 将回调推迟到渲染之后，这时候可以获取页面 dom 元素 sync 回调同步调用，不过会比较消耗性能 1watch(obj, (newValue, oldValue) =&gt; &#123;&#125;, &#123;deep?: true, immediate?: true, flush?: &quot;pre&quot; | &quot;post&quot; | &quot;sync&quot;&#125;) 下面这个例子，当 setTimeout 方法执行完成后，由于改变了 title 的值， 触发了 watch 函数，我们打开 console 就可以发现打印了title 改变之前的值和 修改之后的值 1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125;&#125; 如果我们想要监控多个数据源的变化，可以在watch 的时候 watch 监听对象传入一个数组，同理，当数组内的任意一个元素发生变化时，都会触发watch 函数，而且 watch 回调函数中传入的值也是以数组的形式存在的 123456789const firstName = ref(&#x27;&#x27;)const lastName = ref(&#x27;&#x27;)watch([firstName, lastName], (newValues, prevValues) =&gt; &#123; console.log(newValues, prevValues)&#125;)firstName.value = &#x27;John&#x27; // logs: [&quot;John&quot;, &quot;&quot;] [&quot;&quot;, &quot;&quot;]lastName.value = &#x27;Smith&#x27; // logs: [&quot;John&quot;, &quot;Smith&quot;] [&quot;John&quot;, &quot;&quot;] 如果在监控多个数据源变化时，针对多个数据源修改时是同步修改，并不涉及到 setTimeout 等异步操作时，watch 会把这些更改合并成一次操作，会将所有修改的值一起返回给回调函数 watch hooks 还可以通过回调函数的第三个参数来清除副作用，这个参数会在 watch hooks 被停止或者销毁时，或者副作用重新执行时触发 1234567891011121314151617setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o, onInvalidate) =&gt; &#123; console.log(n, o) onInvalidate(() =&gt; &#123; // 处理副作用方法 &#125;) &#125;) return &#123; title &#125;&#125; 类似的方式还有一个 watchEffect 方法 watchEffect在使用 watchEffect 的时候，会自动执行传入的函数，并且响应式的追踪依赖，并且在依赖发生变更操作时，重新运行传入的函数 1234567891011121314151617181920export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) watchEffect(() =&gt; &#123; console.log(title.value) &#125;) return &#123; title &#125; &#125;&#125; 上述代码执行完成后，我们会发现在控制台会首先输出 setup component， 然后 3s 过程会同时输出 setup component changed，这个是因为 watchEffect 会立即执行，但是因为依赖没有变更，所以就是初始值，3s 后，依赖发生了变更，这时 watch 和 watchEffect 同时触发 watchEffect 在执行完成后，会有一个返回值，我们可以通过这个返回值来停止监听,但是需要注意的是，watchEffect 还是会立即执行，只是当依赖方式变化时，不会再次触发 1234567891011121314151617export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) const stop = watchEffect(() =&gt; &#123; console.log(title.value) &#125;) stop() return &#123; title &#125; &#125;&#125; computed 计算属性1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) let computedTitle = computed(() =&gt; title.value + &quot;abcd&quot;) return &#123; title, computedTitle &#125;&#125; 访问 computed 值的时候和 访问响应式变量的值一样，都是通过 .value 来获取到 provide &amp;&amp; injectvue3 暴露出了两个方法 provide 和 inject 两个方法，这两个方法和 组件内的 provide和inject 方法等同 provide 传入两个参数，第一个参数是属性名，第二个参数是属性值1234setup(props, context) &#123; provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, 26)&#125; inject 传入两个参数，第一个参数是属性名，第二个参数是默认值1234setup(props, context) &#123; inject(&quot;name&quot;, &quot;lxx&quot;) inject(&quot;age&quot;)&#125; 但是通过上述创建的 provide 和 inject 之间不是响应式的，也就是说如果provide 的值改变并不会触发 inject 的值变化，provide 可以使用 ref 和 reactive 方法创建响应式的 provide 12345setup(props, context) &#123; const count = ref(0) provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, count)&#125; 模板引用(ref=””)12345678910111213141516171819202122&lt;template&gt; &lt;div :ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const root = ref(null) onMounted(() =&gt; &#123; // DOM 元素将在初始渲染后分配给 ref console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt; &#125;) return &#123; root &#125; &#125; &#125;&lt;/script&gt; 当页面加载完成后，会自动将 div 绑定给 root 如果需要使用 v-for 绑定多个标签，可以创建响应式数组或者响应式对象来实现","pubDate":"Tue, 02 Aug 2022 07:03:31 GMT","guid":"https://lxx1997.github.io/2022/08/02/vue3-composition-api-setup/","category":"Vue3"},{"title":"leetcode 百天解题 - day 14 - 1374. 生成每种字符都是奇数个的字符串","link":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","description":"题目名称给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可 示例输入：n = 4 输出：”pppz” 解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love” 题解这道题没有什么难点，可以取巧，如果输入的数是奇数，就可以全部输出同一个单词，输入为偶数时，可以是两个字母 答案123var generateTheString = function(n) &#123; return n % 2 === 1 ? new Array(n).fill(&quot;a&quot;).join(&quot;&quot;) : (new Array(n-1).fill(&quot;a&quot;).join(&quot;&quot;) + &quot;b&quot;)&#125;;","pubDate":"Mon, 01 Aug 2022 13:21:36 GMT","guid":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","category":"leetcode"},{"title":"leetcode 百天解题 - day 13 - 1161. 最大层内元素和","link":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","description":"题目名称给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例输入：root = [1,7,0,7,-8,null,null] 输出：2 解释： 第 1 层各元素之和为 1， 第 2 层各元素之和为 7 + 0 = 7， 第 3 层各元素之和为 7 + -8 = -1， 所以我们返回第 2 层的层号，它的层内元素之和最大。 题解这道题主要考察树的广度优先遍历，将数一层一级的分割开来，然后分别计算每层的和，比较大小 答案123456789101112131415161718192021222324252627282930313233var maxLevelSum = function(root) &#123; let rootArr = changeTreeToArray([[root]]) let max = -Infinity, floor = 1 for(let i = 0; i &lt; rootArr.length; i++) &#123; let sum = getSum(rootArr[i]) if(max &lt; sum) &#123; max = sum; floor = i + 1 &#125; &#125; return floor&#125;;function getSum(arr) &#123; let total = 0 arr.forEach(item =&gt; &#123; total += item.val &#125;); return total&#125;function changeTreeToArray(arr, index = 0) &#123; let newArr = [], root = arr[index] for(let i = 0; i &lt; root.length; i++) &#123; let r = root[i] r.left &amp;&amp; newArr.push(r.left); r.right &amp;&amp; newArr.push(r.right) &#125; if(newArr.length === 0) return arr arr.push(newArr); index++ return changeTreeToArray(arr, index)&#125;","pubDate":"Sun, 31 Jul 2022 10:15:26 GMT","guid":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","category":"leetcode"},{"title":"leetcode 百天解题 - day 12 - 15. 三数之和","link":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","description":"题目名称给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解这道题有几个点需要注意一下 最后返回的数据是去重后的数组，也就是说按照从小到大排列后，没有包含同样序列的子元素，数组去重同样是一个难点 注意执行时间，如果强行去循环的话，因为复杂度是 O(n^3),所以最后一定是会超时的 数组去重的话可以采用 Set 来存储得到的数组，不过需要把数组排序之后，转成字符串存放 循环的采用双指针的方式 在最开始先把原数组按照从小到大排列，这样我们就不必再对得到的结果进行排序操作，而且再循环时还可以排除第一个元素大于0的循环， 接下来采用双指针的方式，从数组的两端进行和的对比，因为第一个数的大小已经固定，所以只需要确保剩余两个数加上第一个数的和为0就可以了，如果和小于0，说明负数过大，所以左指针右移,如果和大于0，说明正数过大，所以右指针左移 最后将得到的结果数组转化成能够识别的内容 答案123456789101112131415161718192021var threeSum = function(nums) &#123; let sum = [], hash = new Set(); if(nums.length &lt; 3) return sum nums = nums.sort((a, b) =&gt; a - b) for(let i = 0; i &lt; nums.length - 2; i++) &#123; let first = nums[i] if(first &gt; 0) break; let l = i + 1, r = nums.length - 1 while(l &lt; r) &#123; let second = nums[l], third = nums[r] let s = first + second + third if(s &lt; 0)&#123; l++; continue;&#125;// 和小于0，说明负数过大，所以左指针右移，减少 if(s &gt; 0)&#123; r--; continue;&#125;// 和大于0，说明正数过大，所以右指针左移，减少 hash.add(`$&#123;first&#125;,$&#123;second&#125;,$&#123;third&#125;`) l++; r--; &#125; &#125; return Array.from(hash).map(item =&gt; item.split(&quot;,&quot;).map(item =&gt; +item))&#125;;","pubDate":"Sat, 30 Jul 2022 09:55:44 GMT","guid":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","category":"leetcode"},{"title":"leetcode 百天解题 - day 11 - 593. 有效的正方形","link":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","description":"题目名称给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。 一个 有效的正方形 有四条等边和四个等角(90度角)。 示例输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] 输出: True 输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12] 输出：false 输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1] 输出：true 题解第一种方法我们可以知道正方形都是等边的，且四个角都是直角，因此随机选三个点，然后判断这三个点组成的三角形是否是等腰直角三角形 判断三个点是否是等腰三角形，只需要判断三个点之间的距离是否其中两个点与另一个点的距离相等，且两个点之间的距离是到另一个点距离的根号2倍 答案12345678910111213141516171819202122var validSquare = function(p1, p2, p3, p4) &#123; return checkTrangle(p1,p2,p3) &amp;&amp; checkTrangle(p4,p2,p3) &amp;&amp; checkTrangle(p1,p2,p4) &amp;&amp; checkTrangle(p1,p3,p4)&#125;;function checkTrangle(p1, p2, p3) &#123; let a = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2) let b = Math.pow(p3[0] - p1[0], 2) + Math.pow(p3[1] - p1[1], 2) let c = Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2) if(a === 0 || b === 0 || c === 0) return false let max= Math.max(a,b,c) if(max === c) &#123; return a === b &amp;&amp; a + b === c &#125; if(max === b) &#123; return a === c &amp;&amp; a + c === b &#125; if(max === a) &#123; return c === b &amp;&amp; c + b === a &#125; return false&#125;","pubDate":"Fri, 29 Jul 2022 14:38:01 GMT","guid":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","category":"leetcode"},{"title":"leetcode 百天解题 - day 10 - 1331. 数组序号转换","link":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","description":"题目名称给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。 示例输入：arr = [40,10,20,30] 输出：[4,1,2,3] 题解这个就相对来说较为简单了 首先针对原数组进行去重操作后，得到一个新的数组，然后在对这个不包含重复元素的数组进行从小到大排序 然后对原数组进行遍历操作，针对每一个原数组的元素，找到其在排序后的数组中的位置，替换原数组对应元素位置，最后的得到的新数组就是，原数组的数组序号转换 答案1234var arrayRankTransform = function(arr) &#123; let arrSort = Array.from(new Set(arr)).sort((a, b) =&gt; a - b) return arr.map(item =&gt; arrSort.indexOf(item) + 1)&#125;;","pubDate":"Thu, 28 Jul 2022 14:48:43 GMT","guid":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","category":"leetcode"},{"title":"leetcode 百天解题 - day 09 - 592. 分数加减运算","link":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","description":"题目名称给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。 示例输入: expression = “-1/2+1/2”输出: “0/1” 输入: expression = “-1/2+1/2+1/3”输出: “1/3” 输入: expression = “1/3-1/2”输出: “-1/6” 题解死办法，把分子分母单独提取出来，进行数值运行，最后提取出公约数后，将分子分母简化到最简 分数的加减法则x1/y1 + x2/y2 = (x1y2+x2y1)/y1y2x1/y1 - x2/y2 = (x1y2-x2y1)/y1y2 最大公约数用a和b求余，如果余数为0，则最大公约数为b，否则用 b 与 a%b 的进行求余比较，最后当余数为0时，剩余的数则是这两个数的最大公约数 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var fractionAddition = function(expression) &#123; let denominator = 0, numerator = 1; // 分子，分母 let index = 0, n = expression.length; while (index &lt; n) &#123; // 读取分子 let denominator1 = 0, sign = 1; if (expression[index] === &#x27;-&#x27; || expression[index] === &#x27;+&#x27;) &#123; sign = expression[index] === &#x27;-&#x27; ? -1 : 1; index++; &#125; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; denominator1 = denominator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator1 = sign * denominator1; index++; // 读取分母 let numerator1 = 0; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; numerator1 = numerator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator = denominator * numerator1 + denominator1 * numerator; numerator *= numerator1; &#125; if (denominator === 0) &#123; return &quot;0/1&quot;; &#125; const g = gcd(Math.abs(denominator), numerator); // 获取最大公约数 return Math.floor(denominator / g) + &quot;/&quot; + Math.floor(numerator / g);&#125;const gcd = (a, b) =&gt; &#123; let remainder = a % b; while (remainder !== 0) &#123; a = b; b = remainder; remainder = a % b; &#125; return b;&#125;;const isDigit = (ch) =&gt; &#123; return parseFloat(ch).toString() === &quot;NaN&quot; ? false : true;&#125;","pubDate":"Wed, 27 Jul 2022 14:21:01 GMT","guid":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","category":"leetcode"},{"title":"leetcode 百天解题 - day 08 - 14. 最长公共前缀","link":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","description":"题目名称编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例输入：strs = [“flower”,”flow”,”flight”] 输出：”fl” 输入：strs = [“dog”,”racecar”,”car”] 输出：”” 题解这道题没有什么难点，主要就是取一个参照值（例如数组的第一个元素）然后从第一个字符到最后一个字符和数组中元素对比，直到出现不完全相同的字符的时候，这个时候便是公共的前缀 答案1234567891011121314var longestCommonPrefix = function(strs) &#123; if(strs.length === 1) return strs[0] let suffix = &quot;&quot; const compareStr = strs[0] for(let i = 1;i &lt; compareStr.length; i++) &#123; let s = compareStr[i] if(strs.every(item =&gt; item[i] === s)) &#123; suffix += s &#125; else &#123; return suffix &#125; &#125; return suffix&#125;;","pubDate":"Tue, 26 Jul 2022 13:35:55 GMT","guid":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","category":"leetcode"},{"title":"leetcode 百天解题 - day 07 - 919. 完全二叉树插入器","link":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","description":"题目名称完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。 实现 CBTInserter 类: CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例输入[“CBTInserter”, “insert”, “insert”, “get_root”][[[1, 2]], [3], [4], []] 输出[null, 1, 2, [1, 2, 3, 4]] 题解这道题主要考察树的 广度优先遍历（bfs） 我们需要从树中取出非完全二叉树的节点，所以最重要的就是如何取出这个节点，这里采用的是 广度优先遍历的方法，首先将树根据节点顺序转化成为一个数组，然后在数组中找出第一个不完全二叉树节点 但是目前由于需要操作的步骤过多，性能较差，有待优化 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var CBTInserter = function(root) &#123; this.root = root this.incompleteNode = getFirstIncompleteTree(root)&#125;;CBTInserter.prototype.insert = function(val) &#123; if(!this.incompleteNode.left) &#123; this.incompleteNode.left = &#123; val: val &#125; &#125; else if(!this.incompleteNode.right) &#123; this.incompleteNode.right = &#123; val: val &#125; &#125; let parent = this.incompleteNode if(this.incompleteNode.left &amp;&amp; this.incompleteNode.right) &#123; this.incompleteNode = getFirstIncompleteTree(this.root) &#125; return parent.val&#125;;function getFirstIncompleteTree(root) &#123; let nodeList = getTreeNodes([root]) for(let i = 0; i &lt; nodeList.length; i++) &#123; let node = checkIncompleteTree(nodeList[i]) if(node) return nodeList[i] &#125; return null&#125;function getTreeNodes(arr = [root]) &#123; let newArr = [...arr] for(let i = 0; i &lt; arr.length; i++) &#123; let root = arr[i] root.left &amp;&amp; newArr.push(root.left) root.right &amp;&amp; newArr.push(root.right) if(!root.left || !root.right) return newArr &#125; return getTreeNodes(newArr)&#125;function checkIncompleteTree(node) &#123; return !node.left || !node.right&#125;CBTInserter.prototype.get_root = function() &#123; return this.root&#125;;","pubDate":"Mon, 25 Jul 2022 14:44:26 GMT","guid":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","category":"leetcode"},{"title":"leetcode 百天解题 - day 06 - 1184. 公交站间的距离","link":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","description":"题目名称环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 题解这道题主要考察我们对于数组的操作，根据题目，我们可以得知 公交可以按照顺序针和逆时针运动，也就是说方向并不固定，其次就是没有规定 出发点一定在目的站的前面（这个是重点） 所以这个时候就有两种类型，一种是出发点在目的地前面，还有一种是出发点在目的地的后面 针对第一种，我们可以先计算出所有站的距离的和 total，然后在计算出两站之间顺时针的距离 dis，然后对比 dis 和 total - dis 的距离哪个最小 第二种同样，只不过是将出发点和目的地翻转一下 答案1234567891011121314151617var distanceBetweenBusStops = function(distance, start, destination) &#123; if(start === destination) return 0 let total = distance.reduce((total, item) =&gt; &#123; return total + item &#125;, 0) let dis = 0 if(destination &lt; start) &#123; dis = distance.slice(destination, start).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; else &#123; dis = distance.slice(start, destination).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; return Math.min(dis, total - dis)&#125;;","pubDate":"Sun, 24 Jul 2022 11:34:47 GMT","guid":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","category":"leetcode"},{"title":"leetcode 百天解题 - day 05 - 13. 罗马数字转整数","link":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","description":"题目名称罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例输入: s = “LVIII”输出: 58 输入: s = “MCMXCIV”输出: 1994 题解这道题主要考察我们对于字符串的处理方式；根据题目我们可以找到以下几种组合 &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 根据上面我们列出的组合，现针对字符串中的复杂字符进行替换，并且对应的数字进行加法操作 之所以返回 &quot; &quot; 是为了避免返回空字符串或者原字符，会对最后的结果造成影响 1234567function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s&#125; 最后将我们替换之后的，只剩下单个字符的组合，这时只需要将字符对应的数字进行加法操作，就得出最后的数了 答案1234567891011121314151617181920212223242526272829303132333435var romanToInt = function(s) &#123; let NumHash = &#123; &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 &#125; let num = 0, arr = [&quot;IV&quot;, &quot;IX&quot;, &quot;XL&quot;, &quot;XC&quot;, &quot;CD&quot;, &quot;CM&quot;]; arr.map(item =&gt; &#123; s = repalceValue(s, item) &#125;); for(let i = 0; i &lt; s.length; i++) &#123; if(s[i] !== &quot; &quot;) &#123; num += NumHash[s[i]] &#125; &#125; function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s &#125; return num&#125;;","pubDate":"Sat, 23 Jul 2022 15:12:40 GMT","guid":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","category":"leetcode"},{"title":"leetcode 百天解题 - day 04 - 8 字符串转换整数 (atoi)","link":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","description":"题目名称请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例输入：s = “42” 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：”42”（当前没有读入字符，因为没有前导空格） 第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’） 第 3 步：”42”（读入 “42”） 解析得到整数 42 。 由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。 题解这道题其实并不麻烦，主要是考察我们的边界处理能力还有就是题目理解能力 首先看题目，题目最开始说去除多余的空格，去除空格的话我们可以采用for循环，也可以采用字符串的 trim 方法 然后就是判断去除空格后的第一个字符是否是 “+” 或者 “-“,如果是，则标记对应的正负符号 如果不是则判断这个字符是否是属于 0 - 9 的数字，如果是，则继续判断下一个字符，如果不是，返回0（我就是在这一步卡了，没有注意的第一个字符就必须是0-9及+- 中的一位） 继续判断下一个字符，直到出现 0 - 9 以外的字符或者直到字符串结尾 然后在拿得到的字符串转为数字后，在与 32位进行比较，得出区间内的数字 答案1234567891011121314151617181920212223242526272829303132var myAtoi = function(s) &#123; let symbol = true, numList = new Array(10).fill(0).map((item,index) =&gt; index + &quot;&quot;), all = [&quot;+&quot;, &quot;-&quot;].concat(numList) s = s.trim() for(let i = 0; i &lt; s.length; i++) &#123; if(all.includes(s[i])) &#123; if(s[i] === &quot;+&quot;) &#123; s = s.slice(i + 1) &#125; else if(s[i] === &quot;-&quot;) &#123; s = s.slice(i + 1) symbol = false &#125; else &#123; s = s.slice(i) &#125; break &#125; else &#123; return 0 &#125; &#125; if(!numList.includes(s[0])) return 0 let ns = &quot;&quot; for(let i = 0; i &lt; s.length; i++) &#123; if (numList.includes(s[i])) &#123; ns +=s[i] &#125; else &#123; if(s.length) &#123; break; &#125; &#125; &#125; if(symbol) return Math.min(+ns, Math.pow(2, 31) - 1) return Math.max(-Number(ns), -Math.pow(2, 31))&#125;;","pubDate":"Fri, 22 Jul 2022 15:23:47 GMT","guid":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","category":"leetcode"},{"title":"leetcode 百天解题 - day 03 - 814 二叉树剪枝","link":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","description":"题目名称给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例 输入：root = [1,null,0,0,1]输出：[1,null,0,null,1] 题解暴力计算法本道题主要考察二叉树和递归的使用，针对二叉树的左右节点进行递归操作，一旦有一个节点符合 既没有子节点，且当前节点值为 0，则去除此节点，然后将空值传给父节点，父节点再进行相同判断，直到最后的结果中不包含不包含1的子节点 答案123456789101112var pruneTree = function(root) &#123; if(root.left) &#123; root.left = pruneTree(root.left) &#125; if(root.right) &#123; root.right = pruneTree(root.right) &#125; if(root.val === 0 &amp;&amp; !root.left &amp;&amp; !root.right) &#123; return undefined &#125; return root&#125;;","pubDate":"Thu, 21 Jul 2022 14:41:48 GMT","guid":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","category":"leetcode"},{"title":"leetcode 百天解题 - day 02 - 1260 二维网格迁移","link":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","description":"题目名称给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。请你返回 k 次迁移操作后最终得到的 二维网格。 示例 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 题解暴力计算法这道题相对来说较为简单，从示例可以看出，所谓的移动k个元素，其实就是二维网格内的所有元素同步的移动k个元素，然后和二维数组内元素的总长度求余，所得余数便是二维网格内元素的位置 所以首先最重要的就是将二维网格平铺成为一个一维数组，可以使用数组的 flat 方法，当前也可以使用递归的方式来遍历出二维数组中的所有元素。 将二维数组平铺之后，然后根据传入的k值得出需要平移的元素个数，然后将不需要移动的元素和移动之后的元素拼接成一个新的数组，最后在根据原二维数组的长度得出新的二维数组 答案12345678910 var shiftGrid = function(grid, k) &#123; let arr = grid.flat(Infinity) let index = arr.length - k % arr.length let newArr = arr.slice(index).concat(arr.slice(0, index)) let length = grid[0].length, ngrid = [] for(let i = 0; i &lt; newArr.length; i += length) &#123; ngrid.push(newArr.slice(i, i + length)) &#125; return ngrid&#125;;","pubDate":"Wed, 20 Jul 2022 13:50:13 GMT","guid":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","category":"leetcode"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","category":"hexo"},{"title":"leetcode 百天解题 - day 01 - 731 我的日程安排表 II","link":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","description":"题目名称实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true解释：前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 题解暴力计算法 算法思想解析 最简单的一种方法就是暴力计算法，直接遍历已有的日历时间，然后计算出时间中两次重叠的时间区间，每次添加新的日历时，查看时间区间是否包含在两次重叠的时间区间内，如果包含在里面，则会造成三重重叠，不可添加进日历，如果不包含，则可以添加到日历，此时需要重新计算双重重叠的区间 算法步骤解析 首先我们需要创建一个 MyCalendarTwo 函数，并且定义日历数组（calenderList）和双重重复区间数组（doubleList） 在函数实例上创建 添加日历方法（book） 方法内部首先会去遍历双重重复区间数组，然后对比时间区间是否在双重区间内，只有不在双重区间内才可通过，否则返回false 具体对比方法其实就像两条线段，如果想要两条线段有重叠，只需要满足一个条件即可 其中一条线段的最右边的点一定是大于另一条线段的最左边的点，且最左边的点一定是小于另一条线段最右边的点 接下来就是和日历中的时间进行比较，计算出所有双重重叠区间，然后将新添加的时间区间添加到日历数组中 答案1234567891011121314151617181920var MyCalendarTwo = function() &#123; this.calenderList = [] this.doubleList = []&#125;;MyCalendarTwo.prototype.book = function(start, end) &#123; for(let i = 0; i &lt; this.doubleList.length; i++) &#123; let l = this.doubleList[i][0], r = this.doubleList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; return false &#125; &#125; for(let i = 0; i &lt; this.calenderList.length; i++) &#123; let l = this.calenderList[i][0], r = this.calenderList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; this.doubleList.push([Math.max(l, start), Math.min(r, end)]) &#125; &#125; this.calenderList.push([start, end]) return false&#125;;","pubDate":"Tue, 19 Jul 2022 13:31:34 GMT","guid":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","category":"leetcode"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","category":"vue"}]}