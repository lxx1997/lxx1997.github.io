{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Sun, 24 Jul 2022 11:34:47 GMT","lastBuildDate":"Sun, 24 Jul 2022 15:06:52 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"leetcode 百天解题 - day 05 - 1184. 公交站间的距离","link":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-05-1184/","description":"题目名称环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 题解这道题主要考察我们对于数组的操作，根据题目，我们可以得知 公交可以按照顺序针和逆时针运动，也就是说方向并不固定，其次就是没有规定 出发点一定在目的站的前面（这个是重点） 所以这个时候就有两种类型，一种是出发点在目的地前面，还有一种是出发点在目的地的后面 针对第一种，我们可以先计算出所有站的距离的和 total，然后在计算出两站之间顺时针的距离 dis，然后对比 dis 和 total - dis 的距离哪个最小 第二种同样，只不过是将出发点和目的地翻转一下 答案1234567891011121314151617var distanceBetweenBusStops = function(distance, start, destination) &#123; if(start === destination) return 0 let total = distance.reduce((total, item) =&gt; &#123; return total + item &#125;, 0) let dis = 0 if(destination &lt; start) &#123; dis = distance.slice(destination, start).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; else &#123; dis = distance.slice(start, destination).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; return Math.min(dis, total - dis)&#125;;","pubDate":"Sun, 24 Jul 2022 11:34:47 GMT","guid":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-05-1184/","category":"leetcode"},{"title":"leetcode 百天解题 - day 05 - 13. 罗马数字转整数","link":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","description":"题目名称罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例输入: s = “LVIII”输出: 58 输入: s = “MCMXCIV”输出: 1994 题解这道题主要考察我们对于字符串的处理方式；根据题目我们可以找到以下几种组合 &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 根据上面我们列出的组合，现针对字符串中的复杂字符进行替换，并且对应的数字进行加法操作 之所以返回 &quot; &quot; 是为了避免返回空字符串或者原字符，会对最后的结果造成影响 1234567function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s&#125; 最后将我们替换之后的，只剩下单个字符的组合，这时只需要将字符对应的数字进行加法操作，就得出最后的数了 答案1234567891011121314151617181920212223242526272829303132333435var romanToInt = function(s) &#123; let NumHash = &#123; &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 &#125; let num = 0, arr = [&quot;IV&quot;, &quot;IX&quot;, &quot;XL&quot;, &quot;XC&quot;, &quot;CD&quot;, &quot;CM&quot;]; arr.map(item =&gt; &#123; s = repalceValue(s, item) &#125;); for(let i = 0; i &lt; s.length; i++) &#123; if(s[i] !== &quot; &quot;) &#123; num += NumHash[s[i]] &#125; &#125; function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s &#125; return num&#125;;","pubDate":"Sat, 23 Jul 2022 15:12:40 GMT","guid":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","category":"leetcode"},{"title":"leetcode 百天解题 - day 04 - 8 字符串转换整数 (atoi)","link":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","description":"题目名称请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例输入：s = “42” 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：”42”（当前没有读入字符，因为没有前导空格） 第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’） 第 3 步：”42”（读入 “42”） 解析得到整数 42 。 由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。 题解这道题其实并不麻烦，主要是考察我们的边界处理能力还有就是题目理解能力 首先看题目，题目最开始说去除多余的空格，去除空格的话我们可以采用for循环，也可以采用字符串的 trim 方法 然后就是判断去除空格后的第一个字符是否是 “+” 或者 “-“,如果是，则标记对应的正负符号 如果不是则判断这个字符是否是属于 0 - 9 的数字，如果是，则继续判断下一个字符，如果不是，返回0（我就是在这一步卡了，没有注意的第一个字符就必须是0-9及+- 中的一位） 继续判断下一个字符，直到出现 0 - 9 以外的字符或者直到字符串结尾 然后在拿得到的字符串转为数字后，在与 32位进行比较，得出区间内的数字 答案1234567891011121314151617181920212223242526272829303132var myAtoi = function(s) &#123; let symbol = true, numList = new Array(10).fill(0).map((item,index) =&gt; index + &quot;&quot;), all = [&quot;+&quot;, &quot;-&quot;].concat(numList) s = s.trim() for(let i = 0; i &lt; s.length; i++) &#123; if(all.includes(s[i])) &#123; if(s[i] === &quot;+&quot;) &#123; s = s.slice(i + 1) &#125; else if(s[i] === &quot;-&quot;) &#123; s = s.slice(i + 1) symbol = false &#125; else &#123; s = s.slice(i) &#125; break &#125; else &#123; return 0 &#125; &#125; if(!numList.includes(s[0])) return 0 let ns = &quot;&quot; for(let i = 0; i &lt; s.length; i++) &#123; if (numList.includes(s[i])) &#123; ns +=s[i] &#125; else &#123; if(s.length) &#123; break; &#125; &#125; &#125; if(symbol) return Math.min(+ns, Math.pow(2, 31) - 1) return Math.max(-Number(ns), -Math.pow(2, 31))&#125;;","pubDate":"Fri, 22 Jul 2022 15:23:47 GMT","guid":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","category":"leetcode"},{"title":"leetcode 百天解题 - day 03 - 814 二叉树剪枝","link":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","description":"题目名称给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例 输入：root = [1,null,0,0,1]输出：[1,null,0,null,1] 题解暴力计算法本道题主要考察二叉树和递归的使用，针对二叉树的左右节点进行递归操作，一旦有一个节点符合 既没有子节点，且当前节点值为 0，则去除此节点，然后将空值传给父节点，父节点再进行相同判断，直到最后的结果中不包含不包含1的子节点 答案123456789101112var pruneTree = function(root) &#123; if(root.left) &#123; root.left = pruneTree(root.left) &#125; if(root.right) &#123; root.right = pruneTree(root.right) &#125; if(root.val === 0 &amp;&amp; !root.left &amp;&amp; !root.right) &#123; return undefined &#125; return root&#125;;","pubDate":"Thu, 21 Jul 2022 14:41:48 GMT","guid":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","category":"leetcode"},{"title":"leetcode 百天解题 - day 02 - 1260 二维网格迁移","link":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","description":"题目名称给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。请你返回 k 次迁移操作后最终得到的 二维网格。 示例 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 题解暴力计算法这道题相对来说较为简单，从示例可以看出，所谓的移动k个元素，其实就是二维网格内的所有元素同步的移动k个元素，然后和二维数组内元素的总长度求余，所得余数便是二维网格内元素的位置 所以首先最重要的就是将二维网格平铺成为一个一维数组，可以使用数组的 flat 方法，当前也可以使用递归的方式来遍历出二维数组中的所有元素。 将二维数组平铺之后，然后根据传入的k值得出需要平移的元素个数，然后将不需要移动的元素和移动之后的元素拼接成一个新的数组，最后在根据原二维数组的长度得出新的二维数组 答案12345678910 var shiftGrid = function(grid, k) &#123; let arr = grid.flat(Infinity) let index = arr.length - k % arr.length let newArr = arr.slice(index).concat(arr.slice(0, index)) let length = grid[0].length, ngrid = [] for(let i = 0; i &lt; newArr.length; i += length) &#123; ngrid.push(newArr.slice(i, i + length)) &#125; return ngrid&#125;;","pubDate":"Wed, 20 Jul 2022 13:50:13 GMT","guid":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","category":"leetcode"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","category":"hexo"},{"title":"leetcode 百天解题 - day 01 - 731 我的日程安排表 II","link":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","description":"题目名称实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true解释：前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 题解暴力计算法 算法思想解析 最简单的一种方法就是暴力计算法，直接遍历已有的日历时间，然后计算出时间中两次重叠的时间区间，每次添加新的日历时，查看时间区间是否包含在两次重叠的时间区间内，如果包含在里面，则会造成三重重叠，不可添加进日历，如果不包含，则可以添加到日历，此时需要重新计算双重重叠的区间 算法步骤解析 首先我们需要创建一个 MyCalendarTwo 函数，并且定义日历数组（calenderList）和双重重复区间数组（doubleList） 在函数实例上创建 添加日历方法（book） 方法内部首先会去遍历双重重复区间数组，然后对比时间区间是否在双重区间内，只有不在双重区间内才可通过，否则返回false 具体对比方法其实就像两条线段，如果想要两条线段有重叠，只需要满足一个条件即可 其中一条线段的最右边的点一定是大于另一条线段的最左边的点，且最左边的点一定是小于另一条线段最右边的点 接下来就是和日历中的时间进行比较，计算出所有双重重叠区间，然后将新添加的时间区间添加到日历数组中 答案1234567891011121314151617181920var MyCalendarTwo = function() &#123; this.calenderList = [] this.doubleList = []&#125;;MyCalendarTwo.prototype.book = function(start, end) &#123; for(let i = 0; i &lt; this.doubleList.length; i++) &#123; let l = this.doubleList[i][0], r = this.doubleList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; return false &#125; &#125; for(let i = 0; i &lt; this.calenderList.length; i++) &#123; let l = this.calenderList[i][0], r = this.calenderList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; this.doubleList.push([Math.max(l, start), Math.min(r, end)]) &#125; &#125; this.calenderList.push([start, end]) return false&#125;;","pubDate":"Tue, 19 Jul 2022 13:31:34 GMT","guid":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","category":"leetcode"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","category":"JavaScript,vue,relearn"},{"title":"html-webpack-plugin 的使用与进阶","link":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","description":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","pubDate":"Wed, 13 Jul 2022 03:19:44 GMT","guid":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","category":"JavaScript,html,react,webpack"},{"title":"常用的前端动画库","link":"https://lxx1997.github.io/2022/07/12/web-animation-package/","description":"Lottie 文档 都2022年了，一个还不知道Lottie动画的前端已经OUT啦！ svga SVGA在前端方面的使用","pubDate":"Tue, 12 Jul 2022 08:58:08 GMT","guid":"https://lxx1997.github.io/2022/07/12/web-animation-package/","category":""},{"title":"2022-下半年目标","link":"https://lxx1997.github.io/2022/07/12/2022-second-half-year-task/","description":"7月 任務名稱 完成進度 看完 vue2 文档 5% vue transition 0%","pubDate":"Tue, 12 Jul 2022 02:02:10 GMT","guid":"https://lxx1997.github.io/2022/07/12/2022-second-half-year-task/","category":"planning"},{"title":"生成 github SSH key","link":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","description":"生成 SSH key打开 git bash 命令行工具 输入一下命令，自动生成 ssh key 地址 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 可以通过命令行直接复制 ssh key 的内容 1clip &lt; ~/.ssh/id_ed25519.pub 复制成功之后，可以将 ssh key 复制到 github 的ssh key 上 和 github 链接执行以下命令 1234ssh-add ~/.ssh/id_ed25519// 或者echo $SSH_AGENT_SOCK 如果执行不成功，可能是 ssh-add 未开启，可以通过命令行查看是否开启ssh-add 服务1ps -ef | grep ssh 开启 ssh-add 服务12cd ~/.ssheval $(ssh-agent) 执行完上述命令后就可以进行ssh 链接","pubDate":"Fri, 08 Jul 2022 06:19:07 GMT","guid":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","category":"git"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part1","link":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","description":"computed 属性默认是只有 getter 属性的，也就是说我们只能获取到computed 属性的值，但是无法修改它，但是我们可以手动的设置 setter 属性，这样就可以手动赋值了 1234567891011121314export default &#123; computed() &#123; fullName: &#123; set: function (val) &#123; let name = val.split(&quot; &quot;) this.firstName = name[0] this.secondName = name[1] &#125;, get: function () &#123; return this.firstName + &quot; &quot; + this.secondName &#125; &#125; &#125;&#125; v-for 和 v-if 为什么不推介一起使用 这个是因为 v-for 和 v-if 的优先级问题，vue 会先进行 v-for 循环渲染元素，最后在进行 v-if 控制是否显示元素，会造成无谓的资源浪费 可以采用 v-show 代替 v-if 或者使用计算属性来代替 v-if， 只渲染我们想渲染的元素 key attribute 用来表示这个元素是完全独立的，和其他元素不同，在日常操作中可以用来强制刷新元素内容，只需要修改元素的key，就会重新去渲染元素 我之前用过 v-if 和 $nextTick 来强制重新渲染元素内容，很明显使用上述方法是一种很方便的操作 v-for 可以使用 in 或者 of 来作为分隔符 v-for 遍历对象时 v-for=&quot;(value, name, index) in obj&quot; 三个值 分别为 值，键，和 索引 vue 中可以使用 template 标签，该标签类似 react 中的&lt;&gt;&lt;/&gt;和React.Fragment,在实际渲染中并不会被渲染出来 如果我们想要在点击事件中访问原始的 dom 时间，可以将特殊的变量 $event 传到方法中 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 事件捕获的时候触发，如果点击的是子元素，会先于子元素事件触发 .self 只有当 event.target 是元素自身时触发，点击子元素时不会触发 .once 只会触发一次 .passive 和 .prevent 相反，不会阻止默认事件触发 使用修饰符的时候，顺序很重要，代码会以同样的顺序产生，例如v-on:click.prevent.self 会阻止所有点击，而 v-on:click.slef.prevent 只会阻止元素对自身的点击 按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 支持按键码 可以通过全局的 config.keyCodes 自定义按键修饰符别名1Vue.config.keyCodes.f1 = 112 系统修饰键 (修饰键在和其他事件一起使用的时候，需要同时触发才行，否则并不会单独触发修饰键) .ctrl .alt .shift .meta .exact 精确修饰符，允许我们控制精确的系统修饰符组合触发的事件 &lt;input v-model=&quot;toggle&quot; type=&quot;checkbox&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; 此时 toggle 会取 对应的 true-value 和 false-value 的值 v-model.lazy 默认情况下，v-model 会在input 事件触发后将输入框的值与数据同步，添加lazy 修饰符后，从而转为在 change 事件之后触发 v-model.number 会自动将用户输入的值转为数值类型 v-model.trim 会自动去除用户输入内容两端的空格 自定义组件中的 data 必须是一个函数，是为了保证每次创建组件的时候都能拿到一个独立的数据，否则，重复创建组件时，组件内的数据由于有同一个引用地址，会互相干扰 v-model 在自定义组件中使用相当于 v-bind:value 和 v-on:change 的组合 可以通过组件的 model 属性改变 v-model 的默认属性和事件绑定 12345678910export default &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27; &#125;, mounted() &#123; console.log(this.checked) this.$emit(&quot;change&quot;, &quot;val&quot;) &#125;,&#125; &lt;component v-bind:is=&quot;CustomComponent&quot;&gt;&lt;/component&gt; 通过 v-bind:is 可以自定义组件，组件会跟随 CustomComponent 的值变化而变化 传入一个对象的所有 property, 组件内部可以直接通过 示例中 post 拿到对应的属性 1&lt;component v-bind=&quot;post&quot;&gt;&lt;/component&gt; props 验证 123456789101112export default &#123; props: &#123; propA: &#123; type: String, default: &quot;&quot;, require: false, validator() &#123; &#125; &#125; &#125;&#125; type props 参数类型 String, Number, Boolean, Array, Object, Date, Function, Symbol, 或者自定义的构造函数 default 默认值，引用类型数据 需要使用函数并且通过return 返回默认引用类型 require 是否必须传 默认为 false validator 自定义效验规则 禁用 Attribute 继承，可以设置 inheritAttrs false 来之根元素继承 Attribute 具体表现为 如果设置为 false 子组件不会渲染 attribute， true 会在子组件上渲染 attribute 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 slot 缩写 v-slot: -&gt; # 后备内容 如果我们没有向插槽内提供内容，此时将会显示后备内容 &lt;slot&gt;默认内容&lt;/slot&gt; 具名插槽 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot-component v-slot:header&gt;&lt;/slot-component&gt; 作用域插槽 插槽内部 123456&lt;template&gt; &lt;div&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 外部使用 1234567&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 如果有多个插槽 12345678910&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;slot v-slot:other=&quot;otherSlotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 子组件可以通过 $root 来访问和修改根组件的实例及方法 provide, inject provide 选项允许和指定提供给后代组件的数据和方法 123456provide: function() &#123; return &#123; a: function() &#123;&#125;, b: 0 &#125;&#125; inject 允许子元素接受 provide 提供的 provide 1inject: [&#x27;a&#x27;, &#x27;b&#x27;] 但是出于设计考虑， 这些数据不是响应式的，而且会对重构及代码复用有很大的影响 X-Template x-template 需要定义在 Vue 所属的 DOM 元素外。 123&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component(&#x27;hello-world&#x27;, &#123; template: &#x27;#hello-world-template&#x27;&#125;) transition 过渡动画 v-enter 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义动画类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 显性的过渡持续时间 &lt;transition :duration=&quot;1000&quot; /&gt; &lt;transition :duration=&quot;&#123;enter: 500, leave: 800&#125;&quot; /&gt; JavaScript 钩子 123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; mixins 混入选项合并 数组对象会在内部进行合并，例如 data,属性名发生冲突时，以组件内属性优先 钩子函数合并成数组，都会被调用，混入对象的钩子函数优先于组件内钩子函数调用 值为对象时,将会被合并成为一个对象，且组件对象的键值对优先级更高 Vue.config.optionMergeStrategies 可以通过次宣讲自定义逻辑合并逻辑 自定义指令 1234567directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus /&gt; 钩子函数 bind 绑定时调用，只调用一次 inserted 被绑定元素插入父节点时调用 update 所在组件更新时调用，可能发生在子组件更新之前 componentUpdated 所在组件和子组件全部更新后调用 unbind 指令与元素解绑时调用 钩子函数参数 el 绑定的元素，可以用来操作 DOM binding name 指令名 value 指令绑定的值 oldValue 制定绑定的前一个值 expression 字符串形式的指令表达式 =&quot;1 + 1&quot; arg 传给指令的参数 :foo modifiers 指令修饰符 .foo vnode 当前虚拟节点 oldVnode 上一个虚拟节点 functional 函数式组件函数式组件没有响应式数据，也没有实例（没有 this 上下文）相反会有一个 context 参数 包含如下字段 props children slots scopedSlots data parent listeners injections","pubDate":"Thu, 07 Jul 2022 07:56:07 GMT","guid":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","category":"JavaScript,vue,relearn"},{"title":"好用的浏览器页面测试页面性能工具","link":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","description":"pagespeed地址： https://pagespeed.web.dev/ gtmetrix地址： https://gtmetrix.com/ web.dev地址： https://web.dev/measure/","pubDate":"Thu, 07 Jul 2022 03:29:14 GMT","guid":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","category":""},{"title":"最全的页面性能优化","link":"https://lxx1997.github.io/2022/06/24/how-to-make-pagespeed-fast/","description":"为什么要进行性能优化我们会在什么时候对页面性能进行优化呢，在我的观点里大致有以下几个方面 页面加载时间较长，导致部分用户在页面还未加载完成之后便离开了页面，增加了用户的跳出率 因为 google 的搜索算法，对页面性能这一块有一定要求，如果页面性能较差，那么当用户搜索工具关键词时，页面的顺序就越靠下，这样针对用户自然搜索流量这一块会有很大影响 用户在使用工具时，可能会由于部分操作及代码实现的影响，导致用户使用时会比较卡顿，用户体验较差，降低用户留存 如果想要提高用户的留存率这一块的数据，那么增加用户流量及降低用户跳出率就比较重要了 怎么进行性能优化我认为可以从以下几个方面来进行性能优化 html 解析阶段 javascript 加载阶段 页面渲染阶段 用户操作过程中 下面来分别介绍一下在各个阶段要具体要怎么做 html 解析阶段当浏览器请求到页面 html 的时候，会对html 进行解析，如果中间遇到 link 标签 或者 script 标签时，会去请求对应资源，并进行解析，在解析 css 文件的过程中，并不会阻止浏览器解析 html 文件，但是要注意，javascript 文件会阻止 css 和 html 文件的解析，所以尽量要把 javascript 文件访问 body 标签的最后，不要阻止html 和 css 的解析 在这个阶段我们可以通过以下几种方法提高页面速度 prefetch &amp;&amp; preload使用 prefetch 和 preload 方式 预加载文件，但是要注意这两个方法加载文件的优先级程度不同， prefetch 的优先级最低，浏览器不会立即下载文件，而是会在空闲时间去下载文件， preload 的优先级最高，会立即去下载文件，但是这两个方式都不会去解析文件，只是下载文件后存放本地，如果我们需要使用时就不必再次下载 注意：由于浏览器对于同一个域名下请求的个数有限制，所以要谨慎使用prefetch 和preload 方法，如果一次性加载文件过多，反而会影响后续资源的获取，起到反优化的效果 12345&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt; DNS Prefetch，即DNS预获取当浏览器加载文件时，会对地址进行 DNS 解析,获取地址对用的IP地址，虽然浏览器内部对这一部分操作进行过优化，会在一定时间内缓存 DNS 解析结果，但是 DNS 解析的时间还是比较长的，大概需要 20ms - 120ms 左右的时间，我们可以针对会使用的域名开启 dns 预解析操作，在浏览器空闲的时候，去解析 DNS,当我们使用的时候，就可以减少 dns 解析的时间操作，提高接口请求时间 123&lt;!-- 开启 DNS 解析 content: off 关闭 on 打开 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.template.com&quot;&gt; 但是要注意不要滥用预解析，如果短时间不需要的域名，可以不需要 dns 预解析 script 标签位置浏览器在遇到script 标签时，会暂停解析 html 和 css 文件，转而去解析 js 内容，这样就阻止了页面的解析和渲染，所以尽量保证script 标签在 body 标签的末尾，减少 js 文件对html 文件解析的影响 骨架屏可以采用骨架屏的方式，防止用户因为看不到内容，从而离开页面 JavaScript 解析阶段在这个阶段，浏览器回去下载页面渲染所需要的 javascript 文件，解析，然后渲染到页面上，在这个阶段影响页面加载速度主要有以下几个方面： 单个 js 文件过大，请求及解析文件耗时过大 同一时间请求了过多的资源，导致网络被占用，进一步影响了页面加载 采用不同域名加载静态资源我们都知道浏览器对同一个域名下的请求个数有一定的限制，例如google 浏览器限制最大并发个数是6个，当同时发起的请求的个数超过6个时，只会有有6个发起请求，其他的处于 padding 状态，只有当请求完成时，才会有下一个请求开发发起请求。 因此我们可以采用通过不同域名来请求静态资源，例如 所有的 js 资源可以单独采用一个域名来进行，图片等媒体资源可以采用一个域名来访问，这个就不会因为同一时间内请求的资源过多，影响页面加载速度 CDN 缓存当浏览器下载资源，会先通过 DNS 解析解析出资源所在主机的ip地址，然后去拉取资源，如果服务器刚好在用户所在城市附近，那么资源的加载速度并不会有多大影响，但如果距离过远，例如你人在北京，想要访问在美国的一台服务器上的资源，这个时候由于网络传输的印象，回导致资源获取延迟比较大。 这个时候就需要使用 CDN 缓存了， 这就是CDN的由来，分布式缓存服务器，主要功能是在转发、传输、链路抖动等情况下，最小化资源的时延，并保证信息的连续性和速度。 当我们访问资源，会首先向距离我们最近的 DNS 服务器发出资源请求，如果 这个DNS 服务器缓存有我们想要的资源，如果没有，则会向原服务器请求资源，然后返回给我们，这样一般就降低了资源在请求链路传输的延迟问题。 但是使用 DNS 缓存也会有一些弊端，因为资源都是已经缓存到 DNS 服务器上了，如果在资源缓存未失效的请求，资源进行了变更，这个时候用户访问到的又可能还是旧版资源，这个时候我们可以手动请求 DNS 缓存，但是这个方法不太方便，所以我们可以通过打包的方式，对静态资源添加 hash 后缀，这样每次发版或者更换资源，都会把地址专项新的地址，这样 CDN 就会重新对资源进行缓存针对不能添加 hash 的文件，我们可以通过修改参数的方式来使 CDN 重新刷新缓存，例如123// package.version 为 package.json 的版本号let url = `http://www.example.com/useinfo?_v=$&#123;package.version&#125;`axios.get*(url) 这样当我们每次发版的时候，只需要修改一下版本号，就可以刷新 CDN 缓存了 减少 javascript 包的体积当 js 文件体积过大时，我们需要减少 javascript 包的大小，来减少js 加载时间和解析时间。 可以通过一下几种方式减少包的体积 分包 我们可以通过打包的方式，来将一些第三方资源包打包到一个文件，因为这部分资源我们通常并不会经常修改，这样当我们发版的时候，如果第三方资源并没有发生变化，那么这一块的资源并不会清空 CDN 缓存 1234567891011121314151617181920module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &quot;vendors&quot;, priority: -10 &#125;, utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 这样所有的 node_modules 下需要打包的资源都会打包到 vendors js 文件里面 如果是多页面应用还可以吧多次使用的资源的资源打包到同一个包里面，这样多个页面就可以共用这一个包 123456789101112131415module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 资源懒加载 这里主要以 vue 项目举例 假如我们的页面有多个路由，我们在访问其中一个路由的时候其实是不需要加载其他路由所需要的内容，这个时候可以使用懒加载的方式来减少首屏需要加载的资源 1234&#123; name: &quot;/home&quot;, component: () =&gt; import(&quot;./home.vue&quot;)&#125; 这个时候只有我们访问 /home 这个路由的时候才会加载 home 所需要的资源， 针对同一个路由中 也需要懒加载的组件的组件可以使用以下方式 1234567891011121314&lt;tempalte&gt; &lt;LazyLoad v-if=&quot;lazy&quot; /&gt;&lt;/tempalte&gt;&lt;script&gt;const LazyLoad = () =&gt; import(&quot;./LazyLoad.vue&quot;)export default &#123; data() &#123; return &#123; lazy: false &#125; &#125;&#125;&lt;/script&gt; vue 在内部做过处理，只有当 lazy = true， 需要渲染 LazyLoad 组件时，才会加载对应资源 通过以上操作，我们可以极大减少首屏加载所需要的资源大小，提高页面加载速度 Tree Shaking tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。 使用了 tree shaking后， 如果一段代码我们并没有通过 import 方式引入，这段代码在打包的时候就不会打包进去，但是这个时候也会出现其他问题，因为在迭代过程中，可能之前我们引入了一些资源，但这些资源在后期迭代的过程中不在使用了，但是并没有从代码中移除，这个时候，这些资源也会被打包到代码中，并且项目越大，这种问题出现的几率越大。 因此webpack 扩展了这个检测能力，主要通过 package.json 的 sideEffect 属性来标记 当我们把 sideEffect 设置为 false 时， 代表所有的代码都不包含副作用，告诉 webpack 可以安全的删除所有的未使用的 export 导出。 如果部分代码存在副作用，我们通过一个数组来过滤掉这部分存在副作用的代码。 123456789101112&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: false&#125;&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot; ]&#125; 我在对 vue 项目进行代码 treeshaking 的时候遇到过这样一个问题，打包没有问题，但是发到测试环境后看，页面样式发生了混乱，推测是 可能是由于 vue 文件进行 treeshaking 时，所以 就把 vue 文件标为 副作用文件，不进行treeshaking 12345678&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot;， &quot;*.vue&quot;, &quot;*.less&quot; ]&#125; gzip 压缩 资源在经过网关的时候可以开启 gzip 压缩，使用了 gzip 后，静态文件可以被压缩 3 - 10 倍左右 经过以上操作，可以极大减少用户请求页面加载资源大小，减少服务器带宽压力 页面渲染阶段在页面渲染阶段 主要是用户让用户能够更快的看到页面，以及可操作，所以这个阶段就需要我们根据需求调整 资源加载 及 js 执行时间长度 延迟加载资源 对于部分第三方组件，例如支付，广告这些全局共用的js，可以等到使用的时候再去加载 从产品设计方面 针对部分阻塞页面加载及用户操作的资源可以通过用户的主动操作触发，而非页面一加载就执行 用户操作过程再用户操作过程中，可能有些操作会需要大量计算，由于浏览器是单线程操作，长时间的计算将会阻止用户操作，造成页面出现卡顿的现状,我们可以通过采用分段计算和优化计算消毒，或者采用替代方法。 使用全局加载动画，告诉用户当前属于什么状态。 canvas.toDataURL 可以采用 canvas.toBlob 方法替代（如果有使用的话） setTimeout， setInterval， requestAnimationFrame 等方式实现异步操作","pubDate":"Fri, 24 Jun 2022 14:20:06 GMT","guid":"https://lxx1997.github.io/2022/06/24/how-to-make-pagespeed-fast/","category":"JavaScript,性能优化"},{"title":"SPA-prerender","link":"https://lxx1997.github.io/2022/04/23/SPA-prerender/","description":"由于单页面应用只生成了一个HTML 文件，如果想要做 SEO 的话， H 标签，img 标签的 alt 这些并不会被爬虫抓取到，所以需要我们做预渲染，使得生成的html文件中包含需要 爬虫抓取的内容， react-snap 插件可以帮助实现这个操作 使用安装1yarn add --dev react-snap package.json123&quot;scripts&quot;: &#123;&quot;postbuild&quot;: &quot;react-snap&quot;&#125; 入口 (src/index.js)12345678import &#123; hydrate, render &#125; from &quot;react-dom&quot;;const rootElement = document.getElementById(&quot;root&quot;);if (rootElement.hasChildNodes()) &#123;hydrate(&lt;App /&gt;, rootElement);&#125; else &#123;render(&lt;App /&gt;, rootElement);&#125; 在使用 build 打包的时候，打包完成之后会执行我们添加的 postbuild 命令，然后将root下面的内容添加到 #root dom 里面，这样爬虫就可以从页面上抓取到关键词 问题 Q: 在日常发版过程中通常会采用自动化发版，我们公司采用的是 gitlab 的 CI/CD 环境进行发版，最后进行postbuild 操作的时候 发现无法预渲染，要怎么解决 A: 虚拟环境的话，可以采用 puppeteer 来模拟浏览器环境puppeteer 是 Node.js 的一个库可以用来模拟 chrome 环境12// gitlab-ci.ymlapt-get install -yq gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget #install dependencies for puppeteer, which is a dependency for react-snap運行自定義腳本以更改 react-snap 上的選項以使其工作123# modifies react-snap defaultOptions to add the --no-sandbox and --disable-setuid-sandbox flags so that puppeteer/chromium can run in the codebuild standard imagesed -i &quot;s/puppeteerArgs: \\[\\],/puppeteerArgs: \\[\\&quot;--no-sandbox\\&quot;, \\&quot;--disable-setuid-sandbox\\&quot;\\],/&quot; ./node_modules/react-snap/index.jsecho changed arguments in react-snap 123456789101112131415161718192021&quot;reactSnap&quot;: &#123; &quot;include&quot;: [ // 需要进行预渲染的页面 &quot;/prerender.html&quot;, ], &quot;puppeteerArgs&quot;: [ &quot;--no-sandbox&quot;, &quot;--disable-setuid-sandbox&quot;, &quot;--disable-web-security&quot; // 允许 接口跨域进行请求 ], &quot;viewport&quot;: &#123; // 预渲染的页面宽高，可以控制移动端适配和web端适配 &quot;width&quot;: 1400, &quot;height&quot;: 850 &#125;, &quot;userAgent&quot;: &quot;ReactSnap&quot;, // 环境，可以通过这个来区分是否是处于预渲染环境 &quot;crawl&quot;: false, &quot;concurrency&quot;: 1, &quot;inlineCss&quot;: false, &quot;removeStyleTags&quot;: true, &quot;skipThirdPartyRequests&quot;: false, &quot;puppeteerIgnoreHTTPSErrors&quot;: true&#125; Q: 页面存在国际化语言，页面再进行预渲染之后，在线上环境会出现文字先消失在出现的问题要怎么解决 A: 因为预渲染主要是把 页面渲染完成之后的内容重新写到html 里面，并不包含js文件，加载页面时，会去获取多语言文件，在多语言文件获取之前，通过key 去拿对应的文案时会获取不到，所以就变成了空白，文件加载完成之后，这个时候多语言文案就可以正常拿到了 可以采用先加载多语言文件再渲染页面的方式，或者再打包时就把对应多语言打包进去，放到window 对象上 12345678910111213loadLanguageJson(language).then(() =&gt; &#123; const rootElement:HTMLElement = document.getElementById(&quot;root&quot;)!; if (rootElement.hasChildNodes()) &#123; hydrate(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; else &#123; render(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; &#125;)","pubDate":"Sat, 23 Apr 2022 14:39:08 GMT","guid":"https://lxx1997.github.io/2022/04/23/SPA-prerender/","category":"react,vue,seo,Javascript"},{"title":"window.IntersectionObserver","link":"https://lxx1997.github.io/2022/04/05/window-IntersectionObserver/","description":"window.IntersectionObserverIntersectionObserver 提供了一种异步观察观察目标元素与其祖先元素或者顶级文档交叉状态的方法，即目标元素元素出现或者隐藏的时候就会触发 使用1var observe = new IntersectionObserver(callback， options) callback 回调函数，当我们监听的元素触发到阈值的时候会触发回调函数，callback 会有两个参数 entries 和 observer， entries 是一个数组返回触发监听的目标元素 options root root 属性是目标元素的祖先元素，如果未传入值则默认使用顶级文档视窗 rootMarign 计算交叉时添加到root边界和的矩形偏移量，所有偏移量均可用像素或者百分比 主要作用是缩小或者扩大根元素的判定范围 thresholds 一个包含阈值的列表，按照升序排列，列表中每个阈值都是监听对象的交叉区域与边界区域的比率，当监听对象的任何阈值被越过时，都会生成一个通知，如果未传入值，则默认为0 例如 [0, 0.25, 0.5, 0.75, 1]表示当目标对应比例在目标元素可见时，触发回调函数 方法 disconnect 停止监听工作 observe 添加监听目标元素并进行监听 takeRecords 返回所有观察目标的 intersectionObserverEntry 对象数组 unobserve 停止监听特定目标元素 IntersectionObserverEntry12345678910111213141516171819&#123; time: 3893.92, // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target: element // 被观察的目标元素，是一个 DOM 节点对象 rootBounds: ClientRect &#123; // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // 目标元素的矩形区域的信息 // ... &#125;, intersectionRect: ClientRect &#123; // 目标元素与视口（或根元素）的交叉区域的信息 // ... &#125;, intersectionRatio: 0.54, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0&#125; 使用 IntersectionObserver1234567891011121314151617// 创建 IntersectionObserver 实例var observe = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;, &#123; root: document.getElementById(&quot;app&quot;), rootMargin: &quot;0px 0px 0px 0px&quot;, thresholds: [0, 0.25, 0.5, 0.75, 1]&#125;)// 添加目标对象observe.observe(element)// 停止监听observe.unobserve(element)// 断开链接observe.disconnect() 我们可以解决什么问题 图片或者资源懒加载问题，使用 IntersectionObserver 可以监听到图片元素是否滚动到页面上，从而可以实现预加载和懒加载 元素曝光统计，我们在实际需求中可能需要统计或者计算元素是否曝光在页面上，然后向后台发送统计事件，这样可以方便产品对页面内容进行调整 其他计算，比如我们可能需要判断某个元素是否出现在页面上，然后再进行特殊的计算，如果这些计算数量较少，我们可以不做任何关注，但是如果页面上存在大量的这样的计算，我们需要实现按需计算，这个时候就可以使用 IntersectionObserver 监听元素是否出现在页面，来进行计算，从而减少浏览器内存消耗，提高用户体验","pubDate":"Tue, 05 Apr 2022 12:51:06 GMT","guid":"https://lxx1997.github.io/2022/04/05/window-IntersectionObserver/","category":"JavaScript"},{"title":"高性能JavaScript","link":"https://lxx1997.github.io/2022/03/26/index/","description":"最近读了一本关于如果写出性能更优的JavaScript的书，提取了一些相关的知识点 JavaScript 文件加载及执行我们都知道一个完整前端页面想要展示出来，需要包含 html， css，和JavaScript 文件，其中 html 是框架，css是样式，JavaScript负责交互。但是多数浏览器采用单一进程来处理用户界面ui和JavaScript脚本执行，同一时刻只能做一件事，所以JavaScript执行的时间越久浏览器等待的时间就会越久 浏览器页面在获取到页面时首先会先解析html元素，在解析的过程中，如果遇到css文件或者js文件的时候会去下载文件，下载完成之后然后再去解析文件，但是针对JavaScript文件来说，其实浏览器并不知道js有没有执行改变页面元素的操作，因此浏览器在下载和解析文件的时候，其实是一个暂停的操作，所以当 js 文件执行时间越久，页面空白的时间就越长 解决方式： 将script 脚本尽量放在页面的最下方，保证页面解析完成之后才回去解析JavaScript脚本 针对script 脚本的数量做限制，每遇到一个script标签，浏览器都会停止其他操作去解析script脚本,而script脚本越大，下载时间越长，数量越多，http链接的额外请求的消耗越大。 script 标签的async 属性和 defer 属性，async 属性可以让资源在下载过程中不阻塞浏览器的解析，当下载完成之后在解析脚本文件，defer 属性则是延迟加载 script 文件，当页面解析完成之后才会去加载脚本文件 动态加载脚本文件。对于首屏加载不需要的脚本文件，我们可以在使用的时候再去加载文件。我们可以动态创建script标签，当js文件加载完成之后，再把script标签 append 到html文档中 数据存储方式JavaScript中有四种基本数据存储位置 字面量 字面量代表自身，不存储在特定位置，JavaScript中的字面量有字符串、数字、布尔值、对象、数组、函数、正则表达式、null、undefined 本地变量 开发人员使用关键字 var，let const 定义的数据存储单元 数组元素 存储在JavaScript数组对象内部，以数字作为索引 对象成员 存储在JavaScript对象内部，以字符串作为索引 大多数情况下，从字面量和本地变量存取数据性能是微不足道的，访问数组元素和对象成员的代价则高一些 作用域作用域决定了那些数据能够被访问，作用域内的每个对象都被成为一个可变对象，每个对象以键值对的形式存在，当函数创建后，作用域链就会被创建此函数的作用域中科访问的数据对象所填充，在函数内部表现为 [[Scope]] 属性 函数在被执行的时候，就会创建一个执行环境，函数每次执行时对应的执行环境都是独一无二的，同时调用一个函数会创建多个执行环境，函数调用完成后，执行环境就会被销毁 函数的作用域链是以栈的形式存在的，当一个函数被创建时，会创建一个局部作用域放到栈的顶端，当函数执行完成后，作用域会从栈顶删除，当在函数中想要寻找一个变量时，执行环境会沿着作用域链向下寻找，最后到全局作用域，如果找到了变量，就返回变量所存储的内容，否则返回 undefined 因此如果我们查找的对象在作用域链中越深，查找就越耗费时间，因此我们可以在函数的局部作用域链中，创建一个新的变量来存储我们查找的对象 使用 with 和 try...catch... 方法可以修改函数的作用域链对象，但是实际并不推介这样做 闭包 闭包时 JavaScript 最强大的特性之一，它允许函数访问余部作用域链之外的数据，但是频繁的使用闭包有可能会造成问题。 平时我们使用函数时，会创建一个局部作用域，当函数执行完成后，这个局部作用域会被删除，但是由于引入了闭包，引用依然存在，导致这个局部作用域无法被销毁掉，造成了更多的内存开销，造成内存泄漏 对象 JavaScript的对象是基于原型，原型定义并实现了一个新创建的对象所必须包含的成员泪飙，原型对象为所有对象实例共享。 因此对象中有两种成员类型：实例成员和原型成员，可以用 hasOwnProperty 方法来判断对象是否包含特性的实例成员 当我们存取对象的属性或者方法时，会先查找对象的实例成员是否存在，如果不存在，则会沿着原型链进行查找，因此，对象在原型链存在的位置越深，查找起来越慢 因此我们要学会缓存对象成员的值，尽量避免在同一个函数中多次读取同一个实验对象 DOM对象DOM 是浏览器对象，是浏览器提供给JavaScript用于访问文档中的数据API,由于javascript和dom两个相互独立的功能只能通过接口彼此连接，因此会产生消耗。 我们每一次访问或者修改dom属性都会产生性能消耗，因此我们可以减少DOM的访问次数，把大部分的运算留在 ECMAScript 这一端 innerHTML 和 DOM方法 innerHTML相对来说要快一点，因为它在绝大部分浏览器中都运行的很快，但是对于大部分的日常操作而言，并没有太大区别，我们更应该根据可读性，稳定性，团队习惯和代码风格来综合决定使用哪种方式 HTML集合 document.getELementsByName() document.getELementsByClassName() document.getELementsByTagName() document.images document.links document.forms 这些集合的长度会随着页面元素的变动而变动，所以我们不能简单的使用集合的长度来作为判断，我们可以把集合拷贝一个普通数组，在普通数组上进行操作 在方位内集合属性可以采用局部变量的方式存储集合元素的部分属性，避免多次重复读取，浪费性能 重绘和重排 引起重绘的方法： 元素的颜色等非几何属性发生变化 引起重排的方法： 添加或者删除可见dom元素 元素的位置发生改变 元素的几何尺寸发生变化 内容发生改变 页面初始化 浏览器窗口改变以上这些改变都会造成浏览器需要重新计算页面元素的位置，而重绘则不需要重新计算页面元素位置，重排一定会引起重绘，但是重绘不一定会引起重排 我们在操作页面元素时，要尽量减少页面重绘及重排次数，每一次重排都需要大量的计算，消耗浏览器性能，可以将多次重绘重排整合成一次进行操作 将页面元素变为不可见元素，在修改元素的属性，此时只需要发生两次重排 使用 文档碎片在DOM外创建子树再拷贝回文档 拷贝元素，修改副本，在替换原始元素 浏览器尝试通过队列化修改和批量执行的方式最小化重排次数，当你查询布局信息时，比如偏移量，滚动位置，浏览器为了返回最新的值，会刷新队列并应用所有变更，因此我们可以设置局部变量用来存储布局信息，避免重复获取 使用事件委托 当页面存在大量需要一次或者多次绑定事件的元素，会占用更多的内存，我们可以事件委托，只需要在外层元素绑定一个处理器，就可以处理起子元素上的所有事件 算法及流程控制 减少迭代的工作量，对于常用且不便的数据进行缓存处理 减少迭代次数（达夫设备：循环展开技术，使得一次迭代中实际执行力多次迭代） 优化if...else...语句，最常用的判断放在最前面，这样可以减少对比次数 递归操作，根据情况缓存每一次递归操作的值 使用对象或者数组来缓存数据 快速响应的用户界面 任何javascript任务都不应当执行超过 100 ms 过长的运行时间会导致UI更新出现明显的延迟，从而对用户的体验造成负面影响 使用定时器来安排代码的延迟执行，把长时间运行脚本分解成一系列的小任务 使用web worker 开启新的 javascript线程","pubDate":"Sat, 26 Mar 2022 14:21:26 GMT","guid":"https://lxx1997.github.io/2022/03/26/index/","category":"读后感"},{"title":"高性能JavaScript","link":"https://lxx1997.github.io/2022/03/26/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/","description":"最近读了一本关于如果写出性能更优的JavaScript的书，提取了一些相关的知识点 JavaScript 文件加载及执行我们都知道一个完整前端页面想要展示出来，需要包含 html， css，和JavaScript 文件，其中 html 是框架，css是样式，JavaScript负责交互。但是多数浏览器采用单一进程来处理用户界面ui和JavaScript脚本执行，同一时刻只能做一件事，所以JavaScript执行的时间越久浏览器等待的时间就会越久 浏览器页面在获取到页面时首先会先解析html元素，在解析的过程中，如果遇到css文件或者js文件的时候会去下载文件，下载完成之后然后再去解析文件，但是针对JavaScript文件来说，其实浏览器并不知道js有没有执行改变页面元素的操作，因此浏览器在下载和解析文件的时候，其实是一个暂停的操作，所以当 js 文件执行时间越久，页面空白的时间就越长 解决方式： 将script 脚本尽量放在页面的最下方，保证页面解析完成之后才回去解析JavaScript脚本 针对script 脚本的数量做限制，每遇到一个script标签，浏览器都会停止其他操作去解析script脚本,而script脚本越大，下载时间越长，数量越多，http链接的额外请求的消耗越大。 script 标签的async 属性和 defer 属性，async 属性可以让资源在下载过程中不阻塞浏览器的解析，当下载完成之后在解析脚本文件，defer 属性则是延迟加载 script 文件，当页面解析完成之后才会去加载脚本文件 动态加载脚本文件。对于首屏加载不需要的脚本文件，我们可以在使用的时候再去加载文件。我们可以动态创建script标签，当js文件加载完成之后，再把script标签 append 到html文档中 数据存储方式JavaScript中有四种基本数据存储位置 字面量 字面量代表自身，不存储在特定位置，JavaScript中的字面量有字符串、数字、布尔值、对象、数组、函数、正则表达式、null、undefined 本地变量 开发人员使用关键字 var，let const 定义的数据存储单元 数组元素 存储在JavaScript数组对象内部，以数字作为索引 对象成员 存储在JavaScript对象内部，以字符串作为索引 大多数情况下，从字面量和本地变量存取数据性能是微不足道的，访问数组元素和对象成员的代价则高一些 作用域作用域决定了那些数据能够被访问，作用域内的每个对象都被成为一个可变对象，每个对象以键值对的形式存在，当函数创建后，作用域链就会被创建此函数的作用域中科访问的数据对象所填充，在函数内部表现为 [[Scope]] 属性 函数在被执行的时候，就会创建一个执行环境，函数每次执行时对应的执行环境都是独一无二的，同时调用一个函数会创建多个执行环境，函数调用完成后，执行环境就会被销毁 函数的作用域链是以栈的形式存在的，当一个函数被创建时，会创建一个局部作用域放到栈的顶端，当函数执行完成后，作用域会从栈顶删除，当在函数中想要寻找一个变量时，执行环境会沿着作用域链向下寻找，最后到全局作用域，如果找到了变量，就返回变量所存储的内容，否则返回 undefined 因此如果我们查找的对象在作用域链中越深，查找就越耗费时间，因此我们可以在函数的局部作用域链中，创建一个新的变量来存储我们查找的对象 使用 with 和 try...catch... 方法可以修改函数的作用域链对象，但是实际并不推介这样做 闭包 闭包时 JavaScript 最强大的特性之一，它允许函数访问余部作用域链之外的数据，但是频繁的使用闭包有可能会造成问题。 平时我们使用函数时，会创建一个局部作用域，当函数执行完成后，这个局部作用域会被删除，但是由于引入了闭包，引用依然存在，导致这个局部作用域无法被销毁掉，造成了更多的内存开销，造成内存泄漏 对象 JavaScript的对象是基于原型，原型定义并实现了一个新创建的对象所必须包含的成员泪飙，原型对象为所有对象实例共享。 因此对象中有两种成员类型：实例成员和原型成员，可以用 hasOwnProperty 方法来判断对象是否包含特性的实例成员 当我们存取对象的属性或者方法时，会先查找对象的实例成员是否存在，如果不存在，则会沿着原型链进行查找，因此，对象在原型链存在的位置越深，查找起来越慢 因此我们要学会缓存对象成员的值，尽量避免在同一个函数中多次读取同一个实验对象 DOM对象DOM 是浏览器对象，是浏览器提供给JavaScript用于访问文档中的数据API,由于javascript和dom两个相互独立的功能只能通过接口彼此连接，因此会产生消耗。 我们每一次访问或者修改dom属性都会产生性能消耗，因此我们可以减少DOM的访问次数，把大部分的运算留在 ECMAScript 这一端 innerHTML 和 DOM方法 innerHTML相对来说要快一点，因为它在绝大部分浏览器中都运行的很快，但是对于大部分的日常操作而言，并没有太大区别，我们更应该根据可读性，稳定性，团队习惯和代码风格来综合决定使用哪种方式 HTML集合 document.getELementsByName() document.getELementsByClassName() document.getELementsByTagName() document.images document.links document.forms 这些集合的长度会随着页面元素的变动而变动，所以我们不能简单的使用集合的长度来作为判断，我们可以把集合拷贝一个普通数组，在普通数组上进行操作 在方位内集合属性可以采用局部变量的方式存储集合元素的部分属性，避免多次重复读取，浪费性能 重绘和重排 引起重绘的方法： 元素的颜色等非几何属性发生变化 引起重排的方法： 添加或者删除可见dom元素 元素的位置发生改变 元素的几何尺寸发生变化 内容发生改变 页面初始化 浏览器窗口改变以上这些改变都会造成浏览器需要重新计算页面元素的位置，而重绘则不需要重新计算页面元素位置，重排一定会引起重绘，但是重绘不一定会引起重排 我们在操作页面元素时，要尽量减少页面重绘及重排次数，每一次重排都需要大量的计算，消耗浏览器性能，可以将多次重绘重排整合成一次进行操作 将页面元素变为不可见元素，在修改元素的属性，此时只需要发生两次重排 使用 文档碎片在DOM外创建子树再拷贝回文档 拷贝元素，修改副本，在替换原始元素 浏览器尝试通过队列化修改和批量执行的方式最小化重排次数，当你查询布局信息时，比如偏移量，滚动位置，浏览器为了返回最新的值，会刷新队列并应用所有变更，因此我们可以设置局部变量用来存储布局信息，避免重复获取 使用事件委托 当页面存在大量需要一次或者多次绑定事件的元素，会占用更多的内存，我们可以事件委托，只需要在外层元素绑定一个处理器，就可以处理起子元素上的所有事件 算法及流程控制 减少迭代的工作量，对于常用且不便的数据进行缓存处理 减少迭代次数（达夫设备：循环展开技术，使得一次迭代中实际执行力多次迭代） 优化if...else...语句，最常用的判断放在最前面，这样可以减少对比次数 递归操作，根据情况缓存每一次递归操作的值 使用对象或者数组来缓存数据 快速响应的用户界面 任何javascript任务都不应当执行超过 100 ms 过长的运行时间会导致UI更新出现明显的延迟，从而对用户的体验造成负面影响 使用定时器来安排代码的延迟执行，把长时间运行脚本分解成一系列的小任务 使用web worker 开启新的 javascript线程","pubDate":"Sat, 26 Mar 2022 14:21:26 GMT","guid":"https://lxx1997.github.io/2022/03/26/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/","category":"读后感"},{"title":"服务端 渲染 - nextjs","link":"https://lxx1997.github.io/2021/09/14/ssr-nextjs-01/","description":"初始化项目123npx create-next-app# oryarn create next-app 如果想要添加特殊配置有以下选择 --ts，--typescript 使用TypeScript -e，--example [name][github-url]使用样例 --example-path --use-npm 应用页面路由 Routernextjs 路由匹配规则 /pages/example.js | /pages/example/index.js 匹配路由 /example /pages/example/[id].js 匹配路由 /example/1 /pages/example/[...args].js 匹配路由 /example/1/2.../n /pages/example/[[...args]].js 匹配路由 /example/.../n 12345678// /example/[id].js// 路由为 /example/1import &#123; useRouter &#125; from &quot;next/dist/client/router&quot;;const Index = (): JSX.Element =&gt; &#123; const router = useRouter() const query = router.query // &#123;id: 1&#125;&#125;","pubDate":"Tue, 14 Sep 2021 14:31:56 GMT","guid":"https://lxx1997.github.io/2021/09/14/ssr-nextjs-01/","category":"JavaScript,SSR,nextJs,React"},{"title":"threeJs 学习之路 - API 及 参数传递","link":"https://lxx1997.github.io/2021/08/15/threeJs-study-api/","description":"THREE.Scene() 创建场景对象方法 add 添加物体，会被添加到坐标为 (0, 0, 0)的位置上 THREE.PerspectiveCamera() 这个对象是 threeJs 中相机的其中一种 透视摄像机参数有四个 视野角度 表示在显示器上看到的场景的范围，值是一个角度（值会 mod 360） 长宽比 长宽比的值会影响我们渲染物体的是否是正常的还是拉伸的，压扁的 远剪切面 近剪切面 物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中，根据我们渲染的物体的z轴的值和摄像机的z轴位置来决定的 THREE.WebGLRenderer() 创建一个渲染器实例属性 domElement 渲染器生成的dom元素，通过 appendChild 方法插入到页面中 setSize(width, height, updateStyle) 第二个参数决定是否以较低的分辨率来渲染 render(scene, camera) 渲染场景和摄像机","pubDate":"Sun, 15 Aug 2021 01:53:24 GMT","guid":"https://lxx1997.github.io/2021/08/15/threeJs-study-api/","category":""},{"title":"threeJs 学习之路 - 创建画布及绘制图形","link":"https://lxx1997.github.io/2021/08/15/threeJs-study-01/","description":"因为threeJs 版本在不断更新，所以本文可能部分 api 被替换，如果出现问题，请百度或者查找官方文档对应api 初始化引入引入的话可以采用 npm 引入 或者直接通过 CDN 方式引入 npm 引入 123456npm install three// 引入const THREE = require(&quot;three&quot;)import THREE from &quot;three&quot; CDN 方式引入 CDN地址 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js&quot;&gt;&lt;/script&gt; 创建画布 12345678910// 创建场景const scene = new THREE.Scene()// 创建一个摄像机const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000)// 实例化渲染器const renderer = new THREE.WebGLRenderer()// 设置渲染大小renderer.setSize(window.innerWidth, window.innerHeight)renderer.render(scene, camera)document.body.appendChild(renderer.domElement) 编写完上述代码后应该会出现一个黑色区域，这个就是threeJs创建的 canvas 画布 绘制元素绘制一个正方体 创建一个立方体 需要一个 BoxGeometry 对象，这个对象包含了立方体所有的定点(vertices)和面(faces) 然后对于这个立方体给一个材质，这里我们采用 MeshBasicMaterial 方法，并设置一个默认颜色 接下来需要一个网格（Mesh），这个网格包含了 几何体及其材质的对象，然后通过 Scene 中的 add 方法添加到页面上，如果与摄像机重叠，还需要移动摄像机的位置 最后通过 WebGLRenderer 的 render 方法渲染 如果想要动起来，这个时候需要我们更改摄像机或者立方体的位置,并通过定时器函数，重新渲染 123456789101112131415161718var geometry = new THREE.BoxGeometry()var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;)let cube = new THREE.Mesh(geometry, material)camera.position.z = 5// scene 为之前创建的 THREE.Scene() 实例scene.add(cube)// renderer.render(scene, camera)function render() &#123; requestAnimationFrame(render) // 立方体旋转 旋转速度 cube.rotation.x += 0.1 cube.rotation.y += 0.1 // 修改摄像机的位置 // camera.position.set(x, y, z) renderer.render(scene, camera)&#125;render() 绘制线条 对于绘制线条 我们可以选择的材质只有 LineBasicMaterial 和 LineDashedMaterial 定义好材质之后，我们需要一个带有定点的 Geometry 或者 BufferGeometry 然后通过 THREE.Vector3(x, y, z) 定义线条的顶点，线条是画在连续的顶点之间的 最后 通过 THREE.Line(geometry, material) 将材质和顶点联系起来 ~~~js // LineDashedMaterial 创建 虚线性的 线条 // LineBasicMaterial 创建 实线线条 const material = new THREE.LineDashedMaterial({color: 0x0000ff}) const points = [] // 创建 3d 线条的各个顶点 points.push(new THREE.Vector3(-10, 0, 20)) points.push(new THREE.Vector3(0, 10, 20)) points.push(new THREE.Vector3(10, 0, 20)) // 通过 setFromPoints 设置线条的顶点 const geometry = new THREE.BufferGeometry().setFromPoints(points) // 创建线条治理 const line = new THREE.Line(geometry, material) ~~·","pubDate":"Sun, 15 Aug 2021 01:38:18 GMT","guid":"https://lxx1997.github.io/2021/08/15/threeJs-study-01/","category":"JavaScript,threeJs,webgl"},{"title":"JavaScript 设计模式联系  -  创建型设计模式","link":"https://lxx1997.github.io/2021/06/14/design-parttern-01/","description":"简单工厂模式 简单工厂模式(Simple Factory) 又叫静态工厂模式，由一个工厂对象决定创建摸一种产品对象类的实例 简单工厂模式的理念就是创建对象，提取多个类似需求中相同部分，针对不同的地方进行特殊处理 1234567891011121314151617181920function factory(object) &#123; const Factory = new Object() // 相同的部分 Factory.name = object.name Factory.age = object.name // 不同的部分 switch(object.type) &#123; case &#x27;type1&#x27;: // 特殊处理 break; case &#x27;type2&#x27;: // 特殊处理 break; default: break; &#125; return Factory&#125; 工厂方法模式 工厂方法模式(Factory Methods) 通过对产品类的抽象使其创建业务，主要负责用于创建多累产品的实例 工厂方法模式的本意是将时间创建对象工作推迟到了子类当中，这样核心类就成为了抽象类，在使用工厂方法模式时，需要使用安全策略来防止我们每次获取到的不是想要的对象 安全策略1234567function Factory() &#123; if(this instanceof Factory) &#123; return this &#125; else &#123; return new Factory() &#125;&#125; 通过以上代码在实例化对象的时候判断一下是否是创建对象实例，如果不是则返回一个新的实例，以便能获取到预期的对象 工厂方式模式代码1234567891011121314151617function Factory(type, content) &#123; if(this instanceof Factory) &#123; return this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype.Car = &#123;&#125;Factory.prototype.Pat = &#123; &#125;Factory.prototype.Clothes = &#123; &#125; 抽象工厂模式 抽象工厂模式(Abstract Factory) 通过对类的工厂抽象使其业务用于产品类簇的创建，而不是创建某一类产品的实例 抽象类工厂其实是实现子类继承父类的方法，我们需要通过传递子类以及要继承父类的名称，并且在抽象工厂方法中增加一次对抽象类存在性的判断，如果存在，子类继承父类的方法。子类继承了父类的所有的属性和方法，如果子类中没有方法或者属性覆盖父类方法，当调用的时候，会直接返回父类的属性和方法。 抽象类工厂的主要作用是，当子类调用了自己本身不存在且不需要的方法是，会给予提示 12345678910111213141516171819202122232425262728293031323334353637function Abstract(child, parent) &#123; if(typeof Abstract[parent] === &#x27;function&#x27;) &#123; // 定义一个空的父类 function F() &#123;&#125; F.prototype = new Abstract[parent]() child.constructor = child child.prototype = new F() &#125; else &#123; throw new Error(&#x27;未找到改抽象类&#x27;) &#125;&#125;Abstract.Car = function() &#123; this.type = &#x27;car&#x27;&#125;Abstract.Car.prototype = &#123; getName: function () &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;, getPrice: function() &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;&#125;function Aodis() &#123; this.name = &#x27;aodi&#x27; this.price = 12312&#125;Abstract(Aodis, &#x27;Car&#x27;)console.log(Aodis)Aodis.prototype.getName = function() &#123; console.log(this.name)&#125;const aodi = new Aodis()aodi.getName()aodi.getPrice() 抽象类 抽象类是一种声明了但是无法使用的类，当你调用抽象类的方法时就会报错，我们可以手动在类型的方法中进行错误提示 123456789function Abstract() &#123;&#125;Abstract.prototype = &#123; getName() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;, getPrice() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;&#125; 当我们通过继承或者直接使用的方式来调用抽象类中方法时，会直接抛出错误","pubDate":"Mon, 14 Jun 2021 10:25:20 GMT","guid":"https://lxx1997.github.io/2021/06/14/design-parttern-01/","category":"JavaScript"},{"title":"window.postMessage跨域的使用方式","link":"https://lxx1997.github.io/2021/05/04/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","description":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","pubDate":"Tue, 04 May 2021 15:23:18 GMT","guid":"https://lxx1997.github.io/2021/05/04/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","category":"JavaScript"},{"title":"记一次在面试过程中遇到的 promise 编程题","link":"https://lxx1997.github.io/2021/04/01/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","description":"当时面试的时候遇到了这两个函数编程题，但是该死的是完全没有思路(悲伤) 利用 Promise 完成一个队列，队列中的任务数满了的话，后续任务不执行，当队列中的任务有完成的状态，才会添加新的任务进入队列 利用 Promise 完成一个 retry 函数，传入一个执行函数和一个计数器，在一定次数范围内，如果函数执行失败的话会再次尝试执行该函数，直到执行成功 面试结束之后，我上网上搜索了一下类似的问题，接下来是我总结之后的思路，以及最后成功的代码 Promise 队列 这个问题有以下几个重点 队列： 存放未执行的任务队列 计数器： 存放当前正在执行的任务数量 任务执行最大数量 添加任务函数 执行任务函数 接下根据我们上述描述的重点来创建一个任务队列执行类 1234567891011121314class Scheduler &#123; // 初始化任务队列，以及根据传入的数量来限制最大执行数量 constructor(maxCount) &#123; this.maxCount = count this.list = [] this.count = 0 &#125; add() &#123; &#125; start() &#123; &#125;&#125; 接下我们就要来编写添加函数了，在写添加函数之前我们首先思考一下这个添加函数里面应该注意那些东西 首先，如果我们想要在任务执行完成之后对执行结果操作的话，这个 add 函数必须返回一个 promise 函数 12345add(task) &#123; return new Promise(resolve =&gt; &#123; resolve() &#125;)&#125; 添加一个任务的时候，我们需要把这个任务添加到未执行的任务队列的存放起来 1234567add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(task()) &#125;) &#125;)&#125; 这个时候就出现了一个问题，我们应该怎样监控这个任务是否已经执行完成，这个时候 promise 的作用就来了，我们在 then 中就可以判断到函数是否执行成功 123456789add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(Promise.resolve(task()).then()) // 如果 task 执行之后的返回值是一个promise对象则可以修改成以下形式 // this.list.push(task().then()) &#125;) &#125;)&#125; 添加函数先写到这里，然后我们来写执行函数，在start函数中我们需要做的就是判断一下正在执行任务数是否小于最大执行数，然后从待执行队列中取出一个任务并执行，然后将正在执行的任务数加上1 123456start() &#123; if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list.shift()() &#125;&#125; 接下来修改 add 函数 为当我们添加一个任务时，在最后执行一下执行函数，在执行任务完成之后，减少执行队列数，并触发执行函数，最后把任务的返回值 return 出来 123456789101112add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;)&#125; 接下来实例化任务队列，并创建一个异步执行方法和一个添加任务函数 123456789101112let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Scheduler &#123; constructor(count) &#123; this.list = [] this.maxCount = count this.count = 0 &#125; add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;) &#125; start() &#123; console.log(this.count) if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list[0]() this.list.shift() &#125; &#125;&#125;let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125;addTask(5000,&#x27;1&#x27;)addTask(1100,&#x27;2&#x27;)addTask(2200,&#x27;3&#x27;)addTask(3300,&#x27;4&#x27;)addTask(3300,&#x27;5&#x27;)addTask(3300,&#x27;6&#x27;)addTask(3300,&#x27;7&#x27;)addTask(2200,&#x27;8&#x27;) Promise retry 函数 function retry(fun, count) { if(count === 0) return let val = fun() if(val &gt; 3) { return val } else { return retry(fun, –count) }} function random() { return Math.random() * 5}console.log(retry(random, 5)) 这个问题现在看起来挺简单的，但是当时估计相差了，思路都理解错了，难受","pubDate":"Thu, 01 Apr 2021 08:25:13 GMT","guid":"https://lxx1997.github.io/2021/04/01/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","category":"promise,面试"}]}