{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Mon, 13 Mar 2023 08:22:04 GMT","lastBuildDate":"Wed, 15 Mar 2023 04:09:01 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"JavaScript - 手写一个 Promise 方法","link":"https://lxx1997.github.io/2023/03/13/web/hand-write-promise/","description":"手动实现 promise, 下面hi全部的代码,写了差不多有两个小时，并且附上示例 之前也有一版，不过我觉得这一版更好理解一些123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294// this code for create a new promiseconst PROMISE_PADDING = &quot;padding&quot;const PROMISE_FULLFILLED = &quot;fullfilled&quot;const PROMISE_REJECTED = &quot;rejected&quot;class newPromise &#123; constructor(func) &#123; this.status = PROMISE_PADDING this.value = undefined this.resolveCB = [] this.rejectCB = [] const resolve = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_FULLFILLED this.resolveCB &amp;&amp; this.resolveCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; const reject = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_REJECTED this.rejectCB &amp;&amp; this.rejectCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; try &#123; func(resolve, reject) &#125; catch (error) &#123; reject(error.message) &#125; &#125; then(res, rej) &#123; res = typeof res !== &quot;function&quot; ? (val) =&gt; val : res rej = typeof rej !== &quot;function&quot; ? (val) =&gt; val : rej return new newPromise((resolve, reject) =&gt; &#123; if(this.status === PROMISE_PADDING) &#123; // 这里之所以用 个函数包围住，主要是因为多次使用 .then 的时候，后面的 then 拿到的是前一个then 返回的实例，所以会出现，后面的then，无法执行 // 使用函数包裹之后，然后调用 resolve 和reject 保证后续 then 方法能够拿到正确的值 this.rejectCB.push(() =&gt; &#123; try &#123; let val = rej(this.value) reject(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) this.resolveCB.push(() =&gt; &#123; try &#123; let val = res(this.value) resolve(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; if(this.status === PROMISE_FULLFILLED) &#123; try &#123; this.value = res(this.value) resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; if(this.status === PROMISE_REJECTED) &#123; try &#123; this.value = rej(this.value) reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; &#125;) &#125; catch(rej) &#123; return this.then(undefined, rej) &#125; static resolve(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static reject(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static all(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; console.log(item instanceof newPromise) item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; reject(rej) &#125;) &#125; &#125;) &#125; static allSettled(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_REJECTED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;) &#125; &#125;) &#125; static race(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; rej(arr) &#125;) &#125; &#125;) &#125; static any(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; reject(arr) &#125; &#125;) &#125; &#125;) &#125;&#125;// new newPromise((resolve, reject) =&gt; &#123;// setTimeout(() =&gt; &#123;// resolve(1000)// &#125;, 2000);// &#125;).then((res =&gt; &#123;// console.log(res, &quot;res1&quot;)// &#125;)).then(res =&gt; &#123;// console.log(res, &quot;res4&quot;)// &#125;)// new newPromise((resolve, reject) =&gt; &#123;// // resolve(1000)// throw new Error(12345)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res2&quot;)// return res// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res3&quot;)// &#125;).catch(err =&gt; &#123;// console.log(err, &quot;err&quot;)// &#125;)// newPromise.resolve(() =&gt; &#123;// return 10000// &#125;).then(res =&gt; &#123;// console.log(res)// &#125;)// newPromise.all(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.allSettled(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.race(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)Promise.race([new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(3234), 500)&#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(1000), 1000)&#125;)]).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)newPromise.any(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// promise.then((res) =&gt; &#123;// console.log(res)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res&quot;)// throw new Error(&quot;1234&quot;)// &#125;).catch((err) =&gt; &#123;// console.log(err, &quot;1234&quot;)// &#125;)// Promise.resolve(100).then((res) =&gt; &#123;// console.log(res, &quot;promise&quot;)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;promise res&quot;)// &#125;)","pubDate":"Mon, 13 Mar 2023 08:22:04 GMT","guid":"https://lxx1997.github.io/2023/03/13/web/hand-write-promise/","category":"JavaScript"},{"title":"学习目标","link":"https://lxx1997.github.io/2023/03/03/learning-target-list/","description":"2023-03 项目 进度 单元测试 未开始 vue2 未开始 vue3 未开始 react 未开始","pubDate":"Fri, 03 Mar 2023 01:28:36 GMT","guid":"https://lxx1997.github.io/2023/03/03/learning-target-list/","category":"learning"},{"title":"React 多页面应用 - 实现多页面应用每个页面可以单独打包 及 gitlab CI/CD 发版配置","link":"https://lxx1997.github.io/2023/02/23/webpack/react-multiple-page-pack-separately/","description":"书接上回 React 多页面应用 - 路由配置 这次我们来实现一些不一样的需求，这是在日常工作中遇到的 首先我们来描述一下我们想要实现的需求 首先在这个项目中有多个项目（a,b,c,d…）,假如我只改了a项目的代码，按照我们之前的配置，发版的时候会把所有的项目都一起发上去，这样一个问题是会造成资源浪费（CDN 需要重新缓存），另一个问题是如果有修改到公共方法，会对未修改的项目造成影响，这个时候的需求是只发a项目相关的代码，其他项目的代码不会发上去。 接下来我们来看实现这个需求 实现项目单独打包在上一个项目的基础上，我们可以发现多页面打包的基础是在 打包的时候配置的多入口，那么只需要把原来的多入口变成单入口，就可以实现按需打包了 所以在上一个项目的基础上，把 config.entry 和 config.plugins 的内容单独抽离出来，然后在 overrideConfig 方法内动态传入需要打包的组件入口名称，然后根据传入的组件名称动态获取 entry 和 plugins 的内容。具体实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = (paths) =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig([&quot;page1&quot;, &quot;main&quot;])) 通过上述操作，我们可以实现根据传入的项目包的名称进行按需运行及按需打包 但是，这并不是最终的解决方案,我们不可能每次发版或者每次进行开发都要修改这个文件，这个操作太过繁琐，一旦忘了修改，就会发生比较严重的问题，这个时候需要对这个功能进行优化 项目单独打包优化在经过诸多讨论后，最后敲定的优化方案是 本地开发时，运行所有的项目，在进行发版的时候根据 tag 名进行各个项目发版 package.json 文件修改首先在 script 内新增一个命令 set:env，这个命令会在 发版的时候用到，和 tag 一起用来设置发版的项目 12345&#123; &quot;script&quot;: &#123; &quot;set:env&quot;: &quot;REACT_APP_PROJECT=&quot; &#125;&#125; 执行 set:env 时会向 process.env 新增变量 REACT_APP_PROJECT 可以用来判断当前发版项目，可以在项目全局进行访问，这里主要在config-overrides 文件里进行访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = () =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; let paths = [&quot;main&quot;, &quot;page1&quot;, &quot;page2&quot;] // 这里根据设置的变量来判断打包项目，如果没传则全量打包，主要针对本地开发使用 if(process.env.REACT_APP_PROJECT) &#123; paths = [process.env.REACT_APP_PROJECT, &quot;main&quot;] &#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig()) gitlab-ci.yml 文件修改首先需要修改 gitlab-ci 文件内容，使其由原先的通过判断分支来发版，更改为判断 tag 名称发版，tag 需要定一个规则，用于区分正式，测试环境，我这边定义的规则 V-[环境名称]-[version]-[project] 在 gitlab CI/CD 进行发版时，首先需要获取到 tag 名，gitlab-ci 提供了 $CI_COMMIT_REF_NAME 可以访问到 tag 名 123456789test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - echo $&#123;CI_COMMIT_REF_NAME##*-&#125; #获取最后一个 - 后面的内容 修改了上述代码后，当我们打好以 V-T-US- 开头的 tag 后，会自动触发gitlab 的发版流程，执行过程中，会输出 当前tag 名称以及 project 名称。 获取完成之后，就需要根据获取到的工程名称，编写 node 代码，修改 package.json 与发包相关的 代码 首先创建 updatePackage.sh 1234567# updatePackage.shPROJECT_NAME=defaultif [ &quot;$1&quot; ];then PROJECT_NAME=$1fi node ./update.js $PROJECT_NAME ./package.json 在执行 updatePackage.sh 文件的时候，如果传入的有参数，则会 自动复制 PROJECT_NAME 变量，然后通过 node 执行 node 文件，并将传入的内容以及需要修改的文件路径传过去 需要注意的是，这里的路径都是基于执行 updatePackage.sh 的位置来说的，而不是updatePackage.sh 文件的位置 然后创建 update.js 文件，用来读取和修改 package.json 12345678910// update.jsconst fs = require(&#x27;fs&#x27;); // 引入 fs 函数，用来读取文件const arg = process.argv.splice(2); // 获取node 执行文件时传入的参数const r = arg[arg.length - 1] // 获取 node 执行文件时传入的文件地址const c = fs.readFileSync(r);const json = JSON.parse(c);const set_env = json.scripts[&#x27;set:env&#x27;]const build_env = json.scripts[&#x27;build:test&#x27;]json.scripts[&quot;build:test&quot;] = set_env + arg[0] + &quot; &quot; + build_env // 修改 package.json 的打包命令fs.writeFileSync(r, JSON.stringify(json, null, 2)); 修改 gitlab-ci.yml 文件 执行 updatePackage.sh 文件 12345678910test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName 执行完上述命令后，gitlab 发版服务上拉取到的tag 代码，就会自动修改package.json 的内容，然后执行 打包命令的时候就会按照我们想要的发版的内容进行发版 扩展 如果有预渲染页面的，也可以同 updatePackage.sh 文件来动态的修改需要预渲染的页面，修改 gitlab-ci.yml 文件来更新对应文件 1234567891011test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName - aws s3 cp build/$&#123;projectName&#125;.html s3://bucket_path/$&#123;projectName&#125;.html # 上传对应文件到服务器 参考文章 在gitLab-CI-YML中獲取package.json的值 添加自定義環境變量 脚本实现版本号自动更新，不传参加1","pubDate":"Thu, 23 Feb 2023 07:30:48 GMT","guid":"https://lxx1997.github.io/2023/02/23/webpack/react-multiple-page-pack-separately/","category":"webpack,react,gitlab"},{"title":"React 多页面应用 - 路由配置","link":"https://lxx1997.github.io/2023/02/20/webpack/react-multiple-page-router/","description":"项目地址 创建项目1create-react-app react-multiple-page-router 打包环境配置1yarn add customize-cra react-app-rewired -D 修改 package.json 1234567891011121314151617// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;&#125;,// 更换为&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-app-rewired eject&quot;&#125;, 添加 config.overrides.js 12345const &#123; override &#125; = require(&quot;customize-cra&quot;);const overrideConfig = () =&gt; (config) =&gt; &#123; return config&#125;module.exports = override(overrideConfig()) 多页面配置在 src 目录下新建 pages 文件夹用来存放多页面入口 在 pages 目录下新建 pages1, pages2 目录，并创建入口文件 引入 HtmlWebpackPlugin 组件 1yarn add html-webpack-plugin -D 修改 config.overrides.js 配置多页面打包 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const overrideConfig = () =&gt; (config) =&gt; &#123; config.entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot; &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push( new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;) ) return config&#125;module.exports = override(overrideConfig()) 路由配置引入 react-router-dom 1yarn add react-router-dom -D 在 pages1,pages2 页面添加路由组件 123456789101112131415161718192021// page1/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718// page1/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import Test from &#x27;../../components/Test&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/test&quot;&#125;&gt;Test&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/test&quot; element=&#123;&lt;Test /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718192021// page2/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718192021// page2/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import About from &#x27;../../components/About&#x27;;import Home from &#x27;../../components/Home&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/home&quot;&#125;&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&#123;&quot;/about&quot;&#125;&gt;About&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 这样就可以切换路由了 存在问题 路由跳转后，刷新页面后，可能会无法定位到对应的路由","pubDate":"Mon, 20 Feb 2023 02:41:26 GMT","guid":"https://lxx1997.github.io/2023/02/20/webpack/react-multiple-page-router/","category":"webpack,react"},{"title":"window.postMessage跨域的使用方式","link":"https://lxx1997.github.io/2023/02/14/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","description":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","pubDate":"Tue, 14 Feb 2023 02:55:18 GMT","guid":"https://lxx1997.github.io/2023/02/14/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","category":"JavaScript"},{"title":"window.IntersectionObserver","link":"https://lxx1997.github.io/2023/02/14/web/window-IntersectionObserver/","description":"window.IntersectionObserverIntersectionObserver 提供了一种异步观察观察目标元素与其祖先元素或者顶级文档交叉状态的方法，即目标元素元素出现或者隐藏的时候就会触发 使用1var observe = new IntersectionObserver(callback， options) callback 回调函数，当我们监听的元素触发到阈值的时候会触发回调函数，callback 会有两个参数 entries 和 observer， entries 是一个数组返回触发监听的目标元素 options root root 属性是目标元素的祖先元素，如果未传入值则默认使用顶级文档视窗 rootMarign 计算交叉时添加到root边界和的矩形偏移量，所有偏移量均可用像素或者百分比 主要作用是缩小或者扩大根元素的判定范围 thresholds 一个包含阈值的列表，按照升序排列，列表中每个阈值都是监听对象的交叉区域与边界区域的比率，当监听对象的任何阈值被越过时，都会生成一个通知，如果未传入值，则默认为0 例如 [0, 0.25, 0.5, 0.75, 1]表示当目标对应比例在目标元素可见时，触发回调函数 方法 disconnect 停止监听工作 observe 添加监听目标元素并进行监听 takeRecords 返回所有观察目标的 intersectionObserverEntry 对象数组 unobserve 停止监听特定目标元素 IntersectionObserverEntry12345678910111213141516171819&#123; time: 3893.92, // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target: element // 被观察的目标元素，是一个 DOM 节点对象 rootBounds: ClientRect &#123; // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // 目标元素的矩形区域的信息 // ... &#125;, intersectionRect: ClientRect &#123; // 目标元素与视口（或根元素）的交叉区域的信息 // ... &#125;, intersectionRatio: 0.54, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0&#125; 使用 IntersectionObserver1234567891011121314151617// 创建 IntersectionObserver 实例var observe = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;, &#123; root: document.getElementById(&quot;app&quot;), rootMargin: &quot;0px 0px 0px 0px&quot;, thresholds: [0, 0.25, 0.5, 0.75, 1]&#125;)// 添加目标对象observe.observe(element)// 停止监听observe.unobserve(element)// 断开链接observe.disconnect() 我们可以解决什么问题 图片或者资源懒加载问题，使用 IntersectionObserver 可以监听到图片元素是否滚动到页面上，从而可以实现预加载和懒加载 元素曝光统计，我们在实际需求中可能需要统计或者计算元素是否曝光在页面上，然后向后台发送统计事件，这样可以方便产品对页面内容进行调整 其他计算，比如我们可能需要判断某个元素是否出现在页面上，然后再进行特殊的计算，如果这些计算数量较少，我们可以不做任何关注，但是如果页面上存在大量的这样的计算，我们需要实现按需计算，这个时候就可以使用 IntersectionObserver 监听元素是否出现在页面，来进行计算，从而减少浏览器内存消耗，提高用户体验","pubDate":"Tue, 14 Feb 2023 02:54:06 GMT","guid":"https://lxx1997.github.io/2023/02/14/web/window-IntersectionObserver/","category":"JavaScript"},{"title":"一些精品的前端学习网站","link":"https://lxx1997.github.io/2023/02/02/frontend-learning-website/","description":"网站名称 跳转链接 状态 web全栈体系 点击跳转 正在学习中 前端技能图谱 点击跳转 未学习 JavaScript MDN doc 点击跳转 正在学习中 卡颂 React React技术揭秘 点击跳转 正在学习中","pubDate":"Thu, 02 Feb 2023 01:32:37 GMT","guid":"https://lxx1997.github.io/2023/02/02/frontend-learning-website/","category":"web"},{"title":"杂谈 - 短视频对现实生活的影响","link":"https://lxx1997.github.io/2023/01/26/thinking/social/short-video-about-social/","description":"最近这一年左右经常在 b站 刷短视频，也看过多种多样的视频类型，例如分享个人生活，做饭，讲解历史等，也有男女对立，带货，以及虚假新闻等会对人的判断造成影响的短视频。最近突发感想，记录下来 短视频的崛起感兴趣的可以看一下这篇文章短视频行业是怎么火起来的？聊聊中美短视频行业的前世今生 我这边就不过多介绍了 短视频的优缺点这几年涌现出了许多家短视频平台，快手，抖音，西瓜，甚至于许多视频网站也开始向短视频平台进发，例如 b站，也开发出了短视频模式。 优点 短视频一般可能是十几秒到三四分钟不等，视频内容精炼，我们可以完全可以在空闲时间刷两到三个短视频，极大加快了我们获取新知识的速度 短视频更容易吸引人的注意力 缺点 容易沉迷，由于推送算法的影响，刷到的短视频经常都是自己喜欢看的，很容易长时间沉迷进去，从而占据人们大部分的娱乐时间 由于周围人都在刷短视频，人与人之间的交流逐渐减少，虽然之前也有类似的情况，但是短视频的更加显著一些 部分人群无法分辨高质量视频，容易被一些低质量视频或者三观不正的视频带偏，个人思想容易受到影响 为用户基数大，所以信息传递起来更快，这样就会被一部分不怀好意的人影响，传播虚假消息，挑拨社会问题，引发社会上的信任危机 视频比较短，部分内容可能无法完全展示，会造成断章取义的影响 反思 要学会分辨有用的知识和无用的知识 增强自控能力，避免沉迷","pubDate":"Thu, 26 Jan 2023 11:29:40 GMT","guid":"https://lxx1997.github.io/2023/01/26/thinking/social/short-video-about-social/","category":"thinking"},{"title":"Swiper - 一些常用的属性及方法","link":"https://lxx1997.github.io/2023/01/18/thirdPartPlugin/swiper-use-methods/","description":"介绍Swiper - is the free and most modern mobile touch slider with hardware accelerated transitions and amazing native behavior. It is intended to be used in mobile websites, mobile web apps, and mobile native/hybrid apps. Swiper - 是免費且最現代的移動觸摸滑塊，具有硬件加速轉換和驚人的本機行為。它旨在用於移動網站、移動網絡應用程序和移動原生/混合應用程序。 Swiper is not compatible with all platforms, it is a modern touch slider which is focused only on modern apps/platforms to bring the best experience and simplicity. Swiper 並非與所有平台兼容，它是一種現代觸摸滑塊，僅專注於現代應用程序/平台，以帶來最佳體驗和簡單性。 更多细节的使用可以查看官网，有 demo 且所有的api 使用Swiper 应该是最常用的滑块插件了，兼容了 Vue， react， Angular， solid， svelte 等三方框架，里面有很多属性和方法，里面有很多方法我们其实并不会遇到，有些方法很长用到，如果每次去查文档会浪费很多时间，在这里把一些常用的方法记录一下，方便下次查阅 属性 slidesPerView: number 在屏幕内显示多少个组件，组件宽度会平分当前屏幕宽度 slidesPerGroup: number 每次滚动滚动滑块个数 spaceBetween: number 组件之间的距离 initialSlide: number 当前选中 (活跃) 的组件 loop: boolean 是否循环 centeredSlides: boolean 是否居中显示，如果设置为 true 的 在滑动时最开始和最后的组件可以滑动到页面中央 isBeginning: boolean 可以用来判断是否是开头 isEnd: boolean 可以判断是否结尾123456const onSlideChange = (slider: any) =&gt; &#123; if(slider) &#123; setShowStart(!slider.isBeginning) setShowEnd(!slider.isEnd) &#125;&#125; breakpoints 不同屏幕尺寸下的适配，会替换掉原来的属性值 方法 slideTo 跳转到第几个滑块 onSwiper 可以获取 Swiper 实例（vue 和 react 中）","pubDate":"Wed, 18 Jan 2023 06:45:31 GMT","guid":"https://lxx1997.github.io/2023/01/18/thirdPartPlugin/swiper-use-methods/","category":"web,thirdPartPlugin"},{"title":"前端 - 文字换行","link":"https://lxx1997.github.io/2023/01/18/web/font-wrap/","description":"white-sapcewhite-sapce 可以通过 nowrap 或者 wrap 来控制一行文字在超出文本框长度时是否换行 normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 pre-wrap: 保留空白符序列，但是正常地进行换行。 pre-line: 合并空白符序列，但是保留换行符。 inherit: 规定应该从父元素继承 white-space 属性的值。 word-break 可以设置文字换行时是 自动换行还是 强制换行 normal: 只在允许的断字点换行(浏览器保持默认处理) break-word: 在长单词或URL地址内部进行换行 break-all: 强制换行，会打断英文单词 文本超出隐藏123white-space: nowrap;overflow: hidden;text-overflow: hidden; 文本超出显示省略号123white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 多行文本超出显示省略号12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 但是这种操作具有浏览器兼容性问题，在部分浏览器上并不适用，所以还有另一种解决方案，可以通过计算的方式来添加省略号这是代码 12345import clamp from &quot;clamp&quot; // 首先引入jsclamp(domEle, &#123; clamp: 2, splitOnChars: [&quot;。&quot;, &quot;.&quot;, &quot;-&quot;, &quot;–&quot;, &quot;—&quot;, &quot; &quot;]&#125;) 通过以上操作，会将domEle 里面的文本超出两行时会显示省略号，如果遇到一行无法完整显示的词，会根据splitOnChars 里面的参数判断是否需要将单词拆开换行 也可以通过修改 clamp 参数来控制显示行数","pubDate":"Wed, 18 Jan 2023 01:38:33 GMT","guid":"https://lxx1997.github.io/2023/01/18/web/font-wrap/","category":"web"},{"title":"杂谈 - 从一个前端的角度来看什么才是一个合格的产品","link":"https://lxx1997.github.io/2023/01/13/thinking/code/working-process-problems/","description":"产品经理（PM）也称产品企划，是指在公司中针对某一项或是某一类的产品进行规划和管理的人员，主要负责产品的研发、制造、营销、渠道等工作。产品经理是很难定义的一个角色，如果非要一句话定义，那么产品经理是为终端用户服务，负责产品整个生命周期的人。 但是事实上，部分产品并不专业，主要体现在以下几个方面 需求方面。产品主要负责编写需求文档以及原型图，方便UI,测试，开发等了解需求详细内容，但是实际上大部分产品并不会编写需求文档，可能只会有原型图，而且原型图并不完善，很多细节都没有标注，还有就是没有考虑到对程序其他功能之间的影响以及不同端之间的影响，而作为一个开发人员或者测试人员，本身无法从全局方面来分析需求，即使向产品提出遗漏的部分，但是也会有遗漏的地方，这些遗漏的地方，运气好的话可能会在开发以及测试阶段被查找出来，但是更多的时候则是会被用户发现。 任务排期。如果是一个做自营产品的公司，产品经理除了自己需要进行迭代的任务外，还需要收集市场部分，老板的需求，以及现场用户遇到的问题。然后根据任务的紧急度进行排期，而不是任务提出来了就要立即更改，打乱了原本正常的迭代流程。 但是实际上部分产品经理根本不会过滤需求，也不会根据需求的紧急度进行排期，经常是来了一个任务后，如果优先级比较高的话，可能会暂停当前迭代，开发新的需求，但是优先级不高的需求则会被插入当前迭代任务内，而且基本上不会给你增加时间，这就导致了开发和测试需要经常加班才能按时完成任务。 而且我还遇到更加蛇皮的操作，有了新需求后，直接和我说要加个什么需求，然后我加完之后，需要进行测试了，发现测试人员根本就不知道有这个需求；有时候也会遇到我都已经将所有需求都提测了，在测试阶段又给我提出了新的需求。 需求评审产品经理需要将当前迭代的内容以及详细的交互逻辑需要给UI，测试，前端，后端等相关人员讲解清楚，针对提出的疑问，要给出合理的解决办法，针对 UI 设计图，需要讲解一下页面的交互逻辑，以及交互动画，特效等，针对一些不合理的 UI 设计，需要进行修改。 但是在实际开发中，可能并不会有这一种流程，经常是产品提出需求，画出原型图后，开发就需要进行拆分任务和预估时间。然后基本上和 UI 同一时间进行开发。这也会造成开发在时间上的滞后。 每个人也不是生来就会的，不会的可以去学，可以从每次的失败中总结教训，下一次争取做的更好，但是有些产品来来回回做了那么多次迭代，流程上还是老样子，这样就不免得让人觉得十分心烦了","pubDate":"Fri, 13 Jan 2023 15:17:09 GMT","guid":"https://lxx1997.github.io/2023/01/13/thinking/code/working-process-problems/","category":"thinking"},{"title":"CANVAS 绘图小技巧 - 绘制一个带有圆角的矩形","link":"https://lxx1997.github.io/2023/01/11/web/canvas-draw-border-radius-rect/","description":"在工作中遇到了这样的一个问题，需要在下载的图片添加一些文字描述，这些文字有一个带有圆角的矩形背景。 主要实现方式是使用 Canvas 的 lineTo 方法和 arcTo 方法通过线条绘制出一个圆角矩形 moveTo(x, y)moveTo 主要是将一个新的子路径的起始点移动到 (x, y) 坐标的方法。 它代表我们绘制的线条的起点 lineTo(x, y)lineTo 主要是从当前绘制线条终点，连接到 (x, y) 坐标，绘制的是一条直线 arcTo(x1, y1, x2, y2, r)arcTo 则是用来绘制圆弧的，将会根据 (x1, y1), (x2, y2) 点的相对位置以点 (x1, y1) 偏移半径 R 的距离画一个圆弧，这个圆弧与 (x1, y1)，(x2, y2) 的连线相切，并从切点连线到(x2,y2), 接下来上代码，可以画出一个 左上角和右下角都是圆角的矩形 12345678910111213141516171819202122const drawRoundRect = (ctx, x, y, w, h, r, color) =&gt; &#123; var min_size = Math.min(w, h); if (r &gt; min_size / 2) r = min_size / 2; // 开始绘制 ctx.save() // 开始绘制 ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w, y) ctx.lineTo(x + w, y + h - r) ctx.arcTo(x + w, y + h, x + w - r, y + h, r) ctx.lineTo(x + w - r, y + h) ctx.lineTo(x, y + h) ctx.arcTo(x, y, x + w, y, r) ctx.closePath(); ctx.fillStyle = color ctx.fill() ctx.restore()&#125;let canvas = document.getElementById(&quot;canvas&quot;)let ctx = canvas.getContext(&quot;2d&quot;)drawRoundRect(ctx, 20, 20, 50, 50, 8, &quot;rgba(0,0,0,0.3)&quot;) 我们只需要传入canvas 的 context 属性以及起始点坐标，以及矩形宽高和圆角半径","pubDate":"Wed, 11 Jan 2023 09:59:18 GMT","guid":"https://lxx1997.github.io/2023/01/11/web/canvas-draw-border-radius-rect/","category":"web,canvas"},{"title":"移动端适配 - IOS 高版本无法下载之 navigator.share 使用","link":"https://lxx1997.github.io/2023/01/01/web/navigator-share-ios-chrome-download/","description":"在生产环境中，leader 发现了这样一个问题，在生产环境中，部分 IOS 用户在使用 chrome 时，无法正常下载，点击下载按钮时，没有反应，图片无法正常存储到用户手机上，经过排查后发现基本存在与 ios 15 版本以上 前因之前我们的网站一直主打的是pc端浏览器的使用，但是现在移动端访问网站的用户，也占有一定比例，为了使这一部分能够正常使用，所以针对移动端浏览器访问的时进行了一定的适配和功能调整，以保证用户正常使用，文件下载采用的 file-saver 的 saveAs 方法来下载文件。在线上环境也正常运行了一年的时间 现象针对 Android 用户基本上都能正常下载，但是针对 IOS 15 版本以上的用户，在使用 chrome 时无法正常下载，在针对竞品进行调研后发现他们使用的是 navigator.share 方法，调用浏览器的分享功能来保证能正常下载 使用 navigator.share在 MDN 上是这样介绍的 Navigator.share() 方法通过调用本机的共享机制作为 Web Share API 的一部分。但是由于这是一个实验性的功能，所以浏览器兼容版本比较高，并不是所有浏览都支持，所以需要做一下兼容，不支持 navigator.share, 就使用之前的下载方法 1const sharePromise = window.navigator.share(data); data 包含要共享的数据的对象。必须至少指定以下字段之一。可用选项包括： url: 要共享的 URL text: 要共享的文本 title: 要共享的标题（标题必传，否则无法正常使用） files: 要共享的文件(注意，这是一个数组) 分享文件之前，先使用 navigator.canShare() 判断这个文件能否被分享 在使用中还需要注意 IOS 版本，我在使用中发现， 15 版本一下的 navigator.canShare() 可以通过，但是 navigator.share 会报错，所以在使用之前还需要做一下判断 完整代码1234567891011121314151617181920212223let userAgent = navigator.userAgent.toLocaleLowerCase()let ios = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)let android = navigator.userAgent.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1let versionArray = userAgent.match(/version\\/([\\d.]+).*mobile/)// 获取当前ios 版本let version = Number(versionArray &amp;&amp; versionArray[1] &amp;&amp; versionArray[1].split(&quot;.&quot;)[0])let options = &#123; title: &quot;hello word&quot;, files: files&#125;if(navigator.canShare &amp;&amp; navigator.canShare(options) &amp;&amp; navigator.share &amp;&amp; (ios &amp;&amp; version &gt;= 15 || android)) &#123; try &#123; navigator.share(options).then(res =&gt; &#123; // 成功之后的其他操作 &#125;).catch(() =&gt; &#123; // 旧版本的下载 &#125;) &#125; catch(error) &#123; // 旧版本的下载 &#125;&#125; else &#123; // 旧版本的下载&#125; 补充一点：navigator.share在不刷新页面的时候只能调用一次，再次调用时 navigator.share 方法会拒绝此操作，所以需要做兼容","pubDate":"Sun, 01 Jan 2023 02:30:26 GMT","guid":"https://lxx1997.github.io/2023/01/01/web/navigator-share-ios-chrome-download/","category":"web,IOS,mobile,MobileAdaptation"},{"title":"基于 electron 实现一个记录用户粘贴历史记录应用程序 之 基础环境搭建","link":"https://lxx1997.github.io/2022/12/15/frame/electron-vue3-vite-ts-copyright/","description":"之前一直使用 utools 工具中的 剪贴板，感觉这个功能十分好用，不用在费劲的去寻找自己之前copy 的记录，十分的方便 但是由于几个月前收费了，本着能白嫖就付钱的心理，所以就没有继续使用了。 最近偶然想要做一下这个功能，也可以学习一个 electron 和 vue3 的新知识 环境搭建可以参考一下这个文章，这里有完整的搭建流程。 但是由于各个电脑的环境以及node， electron 等版本不一样的，所以还是会有一些不同，我只在这里简单的记录一下，并标注一下不同之处 环境 插件 版本 node v16.14.0 yarn v1.22.19 vue v3.2.45 @vitejs/plugin-vue 4.0.0 electron 22.0.0 electron-builder 23.6.0 electron-devtools-installer 3.2.0 rimraf 3.0.2 typescript 4.9.3 vite 4.0.0 vite-plugin-electron 0.10.4 vite-plugin-electron-renderer 0.11.3 vue-tsc 1.0.11 环境搭建初始化 vue3 + vite + ts 环境1yarn create vite todolist --template vue-ts 初始化 electron 环境1yarn add -D electron electron-builder rimraf vite-plugin-electron electron-devtools-installer 插件说明 electron-builder：打包工具 rimraf：快速删除文件或目录工具 vite-plugin-electron：vite 结合 electron 的库，关于这个插件可以参见 Vite 与 Electron 无缝衔接 electron-devtools-installer：electron 开发工具 vite-plugin-electron 插件是将 vite 和 electron 结合在一起的，可以让我们非常方便的结合 electron 和 vue，需要做一些指定的配置。 创建 electron 入口文件 electron.ts 和 预渲染 preload.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// electron.tsconst &#123; app, BrowserWindow, Menu, globalShortcut &#125; = require(&#x27;electron&#x27;);const path = require(&#x27;path&#x27;);const createWindow = () =&gt; &#123; // 隐藏顶部菜单 Menu.setApplicationMenu(null) const win = new BrowserWindow(&#123; webPreferences: &#123; contextIsolation: false, nodeIntegration: true, preload: path.join(__dirname, &#x27;./preload.ts&#x27;), &#125;, &#125;); if (app.isPackaged) &#123; win.loadFile(path.join(__dirname, &#x27;./index.html&#x27;)); &#125; else &#123; // Use [&#x27;ENV_NAME&#x27;] avoid vite:define plugin const url = `http://127.0.0.1:5173/`; win.loadURL(url); // 添加快捷键 globalShortcut.unregisterAll() globalShortcut.register(&#x27;ctrl+q&#x27;, function() &#123; app.quit() &#125;) globalShortcut.register(&#x27;ctrl+shift+i&#x27;, function() &#123; // 添加 devtools win.webContents.openDevTools() &#125;) &#125;&#125;;app.whenReady().then(() =&gt; &#123; createWindow(); app.on(&#x27;activate&#x27;, () =&gt; &#123; // On macOS it&#x27;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (BrowserWindow.getAllWindows().length === 0) createWindow(); &#125;);&#125;);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit(); &#125;&#125;); 1234// electron-preload/index.tsconst os = require(&#x27;os&#x27;);console.log(os.platform()); // 测试打印一下系统平台 配置 electron在 tsconfig.json 中监听 electron 相关文件和提示 这个没有发生变化1&quot;include&quot;: [..., &quot;electron-main/**/*.ts&quot;, &quot;electron-preload/**/*.ts&quot;],vite.config.ts 变化比较明显，首先 electronRenderer 引入插件变成了 vite-plugin-electron-renderer,其次是初始化的时候 electron 传入实例对象有变化123456789101112131415161718192021// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import * as path from &#x27;path&#x27;;import electron from &#x27;vite-plugin-electron&#x27;;import electronRenderer from &#x27;vite-plugin-electron-renderer&#x27;;export default defineConfig(&#123; plugins: [ vue(), electron(&#123; entry: &#123; main: &#x27;./electron.ts&#x27;, &#125;, &#125;), electronRenderer(), ], build: &#123; emptyOutDir: false, // 必须配置，否则electron相关文件将不会生成build后的文件 &#125;,&#125;); 配置打包命令1234// package.json&quot;script&quot;: &#123; &quot;build-electron&quot;: &quot;rimraf dist &amp;&amp; vite build &amp;&amp; electron-builder&quot;&#125; 其实在执行完上述内容后，基本上就可以正常运行和打包了","pubDate":"Thu, 15 Dec 2022 01:59:59 GMT","guid":"https://lxx1997.github.io/2022/12/15/frame/electron-vue3-vite-ts-copyright/","category":"vite,TypeScript,web,electron,vue3"},{"title":"TypeScript 高级类型","link":"https://lxx1997.github.io/2022/12/06/web/typescript-advanced-type/","description":"TypeScript 有许多高级类型，方便系统更好判断代码是否存在不合理的点，也更方便用户来排查错误和编写代码，下面介绍一些常用的高级类型，这些高级类型在日常开发中可能没有机会用到，但是了解一下对我们并没有任务坏处 交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性 相当于混入（mixin）,在新的类型中，可以拥有合并的所有类型中的成员 使用 &amp; 来表示交叉 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());var n = jim.name;jim.log(); 通过上述例子,我们利用泛型创建一个 extend 方法用来合并两个对象，通过交叉符号 &amp; 判断函数返回类型是传入类型的合并类型 这样我们在访问 extend 返回的对象时，如果获取到不存在的属性，就会贴心的为我们提示错误 联合类型联合类型与交叉类型很有关联，但是使用上却完全不同. 交叉类型 是将多个类型合并成一个新的类型 联合类型 是满足多个类型中的一个，这些类型可以是基础类型(string, number …) 也可以是用户定义的类或者接口","pubDate":"Tue, 06 Dec 2022 06:39:19 GMT","guid":"https://lxx1997.github.io/2022/12/06/web/typescript-advanced-type/","category":"TypeScript"},{"title":"css 选择器","link":"https://lxx1997.github.io/2022/12/02/web/css-selector/","description":"选择器 例子 例子描述 .class .intro 选择 class=”intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id=”firstname” 的元素。 * * 选择所有元素。 element p 选择所有 &lt;p&gt; 元素。 element.class p.intro 选择 class=”intro” 的所有 &lt;p&gt; 元素。 element,element div, p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。 element&gt;element div &gt; p 选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。 element+element div + p 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。 element1~element2 p ~ ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 [attribute] [target] 选择带有 target 属性的所有元素。 [attribute=value] [target=_blank] 选择带有 target=&quot;_blank&quot; 属性的所有元素。 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute =value] [lang =en] 选择 lang 属性值以 “en” 开头的所有元素。 [attribute^=value] a[href^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 [attribute$=value] a[href$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 [attribute=value] a[href=”w3schools”] 选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 &lt;p&gt; 的内容之后插入内容。 ::before p::before 在每个 &lt;p&gt; 的内容之前插入内容。 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :default input:default 选择默认的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个被禁用的 &lt;input&gt; 元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :focus input:focus 选择获得焦点的 input 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 input 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 input 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。","pubDate":"Fri, 02 Dec 2022 07:23:57 GMT","guid":"https://lxx1997.github.io/2022/12/02/web/css-selector/","category":"web"},{"title":"hexo 常用命令语句","link":"https://lxx1997.github.io/2022/12/02/extend/hexo-common-commands/","description":"创建一个博客到指定文件夹1hexo new page --path [folder-path]/[blog-name] create leetcode 练习（专用）1npx hexo new page --path handredday/leetcode/day-101-2283","pubDate":"Fri, 02 Dec 2022 02:46:41 GMT","guid":"https://lxx1997.github.io/2022/12/02/extend/hexo-common-commands/","category":"extends"},{"title":"web - H5 移动端适配问题","link":"https://lxx1997.github.io/2022/11/23/web/mobile-web-adaptation-problems/","description":"IOS 移动端适配唤起键盘输入时，页面底部的输入框无法浮动到键盘上方参考文章 这个出现的原因主要是 IOS 和 Andriod 的 适配不同 Andriod 的情况比较好理解。软键盘弹出后，实际webview被挤压了，变短了，相当于浏览器变小了，变成 原本高度 - 软键盘高 IOS 发布了 8.2 版本之后，与androids的不同，软键盘弹出，并不是挤压webview，webview的高度不会发生变化，而软键盘更像是一个悬浮在weview上的东西，并不会影响webview的实际高度，是“盖”上去的。这样就造成了我们目前所看到的情况，输入框被键盘遮挡，无法看到用户输入的内容 所以可以看到，我们在IOS上聚焦某个输入框，是会自动让页面发生滚动，以展示聚焦的输入框，此时页面的滚动，实际上是webview自身发生了移动。 这里可以采用的方法有两种 第一种是用户聚焦于输入框的时候，设置window 或者页面区域主动向上方滚动一定距离（例如软键盘高度），当用户失去焦点时，在滚动回原来的位置 第二种是改变 输入框所在元素的高度，使得输入框能够正常显示出来，当用户失去焦点时，在还原回原来的高度 12345678910111213141516171819const handleBlur = (e: any) =&gt; &#123; // 获取浏览器类型 let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123; element.style.height = &quot;100%&quot; &#125;, 100) &#125;&#125;const handleFocus = (e: any) =&gt; &#123; let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123;//设置一个计时器，时间设置与软键盘弹出所需时间相近 element.style.height = (window.innerHeight - 330) + &quot;px&quot; &#125;, 100) &#125;i IOS Safari 浏览器 canvas 写入图片过大，会造成页面重复刷新 参考文章 您的網頁在桌面上表現良好並不能保證它在 iOS 上也能表現良好。請記住，iOS 使用 EDGE（低帶寬、高延遲）、3G（高帶寬、高延遲）和 Wi-Fi（高帶寬、低延遲）連接到互聯網。因此，您需要最小化網頁的大小。在您的網頁中包含未使用或不必要的圖像、CSS 和 JavaScript 會對您的網站在 iOS 上的性能產生不利影響。 由於 iOS 上的可用內存，它可以處理的資源數量有限制： 解碼後的 GIF、PNG 和 TIFF 圖像的最大尺寸對於內存小於 256 MB 的設備是 3 兆像素，對於內存大於或等於 256 MB 的設備是 5 兆像素。也就是說，確保 width * height ≤ 3 * 1024 * 1024 適用於 RAM 小於 256 MB 的設備。請注意，解碼後的尺寸遠大於圖像的編碼尺寸。 使用子採樣時，JPEG 的最大解碼圖像大小為 32 兆像素。由於二次採樣，JPEG 圖像可以高達 32 兆像素，這允許 JPEG 圖像解碼為像素數的十六分之一的大小。大於 2 兆像素的 JPEG 圖像被二次採樣，即解碼為縮小的尺寸。JPEG 子採樣允許用戶查看來自最新數碼相機的圖像。 對於內存小於 256 MB 的設備，畫布元素的最大尺寸為 3 兆像素，對於內存大於或等於 256 MB 的設備，畫布元素的最大尺寸為 5 兆像素。如果未指定，畫布對象的高度和寬度為 150 x 300 像素。 每個頂級入口點的 JavaScript 執行時間限制為 10 秒。如果您的腳本執行時間超過 10 秒，iOS 上的 Safari 會在您代碼中的隨機位置停止執行腳本，因此可能會導致意外後果。施加此限制是因為 JavaScript 執行可能會導致主線程阻塞，因此當腳本運行時，用戶無法與網頁進行交互。閱讀“在 iOS 上調試 Web 內容”了解如何在 iOS 上調試 JavaScript。 一次可以打開的最大文檔數在iPhone 上是八個，在iPad 上是九個。 Andriod 移动端适配共用的适配方式在滚动的元素内部 有 pisition: fixed; 元素，点击到改元素，无法进行滑动在 IOS 可以采用在 pisition: fixed; 元素外包一层 pisition: sticky; div，可以实现 其他的话要触发浏览器默认的滚动（window，document.body）而非 元素的 overflow 属性才可以滑动","pubDate":"Wed, 23 Nov 2022 08:09:03 GMT","guid":"https://lxx1997.github.io/2022/11/23/web/mobile-web-adaptation-problems/","category":"web,IOS,mobile,MobileAdaptation"},{"title":"一些不常用的事件监听方法","link":"https://lxx1997.github.io/2022/10/27/web/document-eventListener-uncommon-use/","description":"documentselectionchange可以获取到点击的文字所在元素对象及点击或者选中文字起始位置和结束位置 应该是只针对 文字，我点击图片没有触发时间，点击文字时间正常触发12345678910111213141516171819202122// addEventListener versiondocument.addEventListener(&#x27;selectionchange&#x27;, () =&gt; &#123; console.log(document.getSelection()); /** * anchorNode: text * anchorOffset: 4 * baseNode: text * baseOffset: 4 选中起始位置 * extentNode: text 选中起始元素 * extentOffset: 4 选中结束位置 * focusNode: text 选中结束元素 * focusOffset: 4 * isCollapsed: true * rangeCount: 1 * type: &quot;Caret&quot; */&#125;);// onselectionchange versiondocument.onselectionchange = () =&gt; &#123; console.log(document.getSelection());&#125;; 通过下方代码操作可以改变选中位置12345678let selection = document.getSelection()!const range = document.createRange();selection.removeAllRanges();range.selectNodeContents(node);range.setStart(textNode,start)range.setEnd(textNode,start)range.collapse(false);selection.addRange(range); compositionStart可以监控到用户使用中文输入法输入 CompositionEnd可以监控到用户结束中文输入法输入 input元素添加了 contenteditable 属性后，可以监控到用户输入nativeEvent 上的 inputType 可以判断用户当前输入状态 deleteContentBackward 删除鼠标选中的字符或后方字符 deleteContentForward 删除鼠标选中的字符或前方字符 insertText 添加文字","pubDate":"Thu, 27 Oct 2022 03:22:40 GMT","guid":"https://lxx1997.github.io/2022/10/27/web/document-eventListener-uncommon-use/","category":"web document"},{"title":"vue3 状态管理工具 - pinia","link":"https://lxx1997.github.io/2022/08/11/vue/vue-pinia-state-manager/","description":"Vue3 出来都有一年多了，生态系统相对来说都慢慢变得完善起来了，像针对 vue2 的 vue-router 路由组件，vuex 状态管理工具都开始适应 vue3 了 这里就介绍 针对 vue3 的状态管理工具 vuex5 又叫 pinia 与 vuex4 和 vuex3 对比 mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。 无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。 不再需要注入、导入函数、调用函数、享受自动完成功能！ 无需动态添加 Store，默认情况下它们都是动态的，您甚至都不会注意到。请注意，您仍然可以随时手动使用 Store 进行注册，但因为它是自动的，您无需担心。 不再有 modules 的嵌套结构。您仍然可以通过在另一个 Store 中导入和 使用 来隐式嵌套 Store，但 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 您甚至可以拥有 Store 的循环依赖关系。 没有 命名空间模块。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的。 使用安装 pinia123npm install piniayarn add pinia 在 Vue 中注册123import &#123; createPinia &#125; from &quot;pinia&quot;createApp(App).use(createPinia()).mount(&#x27;#app&#x27;) 创建一个storepinia 提供了一个方法 defineStore 来定义一个 Store defineStore 需要我们传入两个参数，第一个参数是 name, 这个值是唯一的，第二个参数是 Store 的值，包含 state, getters, actions 1234567891011121314151617181920import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;, getters: &#123; getCount(state) &#123; return state.count &#125; &#125;, actions: &#123; addCount() &#123; this.count++ &#125; &#125;&#125;) 组件内使用 setup components在 setup component 内可以直接使用 1234567&lt;script setup&gt; const countStore = useCountStore() console.log(countStore.count) // 1 console.log(countStore.getCount) // 1 countStore.addCount()&lt;/script&gt; 需要注意的是，不能对 store 进行解构赋值，因为这会破坏 store 的响应式 如果想要对 store 进行解构赋值，可以采用 storeToRefs,它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用12345&lt;script setup&gt; import &#123; storeToRefs &#125; from &quot;pinia&quot; const countStore = useCountStore() const &#123; count, getCount &#125; = storeToRefs(countStore)&lt;/script&gt; 属性statestate 用来定义应用程序状态开始，在 pinia 中状态是一个返回初始状态函数 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;&#125;) 如果想要重置 Store 的状态，可以调用 $reset 方法 1useCountStore.$reset() 不在 setup() 中使用 可以使用 mapState 将状态映射为只读属性 12345export default &#123; computed: &#123; ...mapState(useCountStore, options) &#125;&#125; options 有两种类型 数组类型 如果是数组类型的话，其内的元素是需要映射的属性名，例如我们想要映射 state 的 count 的值 ...mapState(useCountStore, [&quot;count&quot;]),组件内可以直接使用 this.count 访问 对象类型 对象类型的话，key 是组件内访问时的属性名，key 所对应的值是 Store state 里面的值 12345678export default &#123; computed: &#123; ...mapState(useCountStore, &#123; aliasCount: &quot;count&quot;, // 组件内访问时 this.aliasCount,相当于访问 store 的 count 属性 doubleCount: (state) =&gt; state.count * 2 // 类似于 Store 的 getters 属性 &#125;) &#125;&#125; 如果想要直接修改这些状态属性，类似 this.count++,可以使用 mapWritableState API gettersgetters 的使用 类似于 state，但是创建方式略有不同 getters 是一个有具体返回值的函数，这个函数可以是有 state的值或者其他 getters 中的值计算出来的结果 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; getters: &#123; doubleCount: (state) =&gt; state.count * 2, othercount(state) &#123; return this.doubleCount * state.count &#125; &#125;&#125;) 在 setup 函数中使用时，可以直接通过 store 访问 非 setup 函数可以通过 mapState 方法注册到 computed 属性中 actionsactions 中的方法适合用来定义业务逻辑，而且是可以进行异步操作 在非 setup 函数中使用的时候可以通过 mapActions 映射出来 1234567export default &#123; methods: &#123; ...mapActions(useCountStore, &#123; changeCount: &quot;count&quot;, &#125;) &#125;&#125; 第二个参数传递的类型可以参考 mapState 在 setup 函数中，可以直接在 setup 中使用，也可以在组件中通过 store 对象调用 1234567891011121314151617181920212223242526272829export default &#123; setup(props) &#123; let &#123; todoItem &#125; = toRefs(props) const todoList = useTodoListStore() const handleEdit = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; isEditing: true &#125;) &#125; const handleDelete = () =&gt; &#123; todoList.removeTodoList(todoItem.value.id) &#125; const handleConfirm = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; content: value.value &#125;) &#125; return &#123; value, handleEdit, handleDelete, handleConfirm &#125; &#125;&#125; 另外，针对 actions vuex 提供了一个 $onAction 方法来订阅action 及结果 当我们订阅一个 store 后，每触发一次 store 内部的 action 执行，都会触发一次回调函数，传递给它的回调在 action 之前执行。 after 处理 Promise 并允许您在 action 完成后执行函数。 以类似的方式，onError 允许您在处理中抛出错误。 123456789101112131415161718192021222324252627282930313233const unsubscribe = todoListStore.$onAction( (&#123; name, // action 的名字 store, // store 实例 args, // 调用这个 action 的参数 after, // 在这个 action 执行完毕之后，执行这个函数 onError, // 在这个 action 抛出异常的时候，执行这个函数 &#125;) =&gt; &#123; // 记录开始的时间变量 const startTime = Date.now() // 这将在 `store` 上的操作执行之前触发 console.log(`Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#x27;, &#x27;)&#125;].`) // 如果 action 成功并且完全运行后，after 将触发。 // 它将等待任何返回的 promise after((result) =&gt; &#123; console.log( `Finished &quot;$&#123;name&#125;&quot; after $&#123; Date.now() - startTime &#125;ms.\\nResult: $&#123;result&#125;.` ) &#125;) // 如果 action 抛出或返回 Promise.reject ，onError 将触发 onError((error) =&gt; &#123; console.warn( `Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.` ) &#125;) &#125;)unsubscribe()","pubDate":"Thu, 11 Aug 2022 07:19:53 GMT","guid":"https://lxx1997.github.io/2022/08/11/vue/vue-pinia-state-manager/","category":"Vue3"},{"title":"React Hooks - 自定义hooks","link":"https://lxx1997.github.io/2022/08/09/react/react-custom-hooks/","description":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React react hooksuseEffectuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力 它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途 在使用时我们传递一个数组，useEffect 会在数组内的数据发生变化时重新执行 useEffect 函数需返回一个清除函数，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除 12345useEffect(() =&gt; &#123; return () =&gt; &#123; // 在此执行当前useEffect 的副作用清除，例如监听函数，定时器等操作 &#125;&#125;, [obj1, obj2]) // 仅在 obj1， obj2 改变的时候触发 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。 useStateuseState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。 更新函数操作是完全替换，而非合并操作 1234const [count, setCount] = useState(0) // 初始化 countsetCount(1) // 改变 count 值setCount(x =&gt; x + 1) // 改变 count 值 会基于原count 值的基础上 +1 useContext 上下文对象用来接收由React.createContext() 创建的 context对象，并返回context对象的当前值，父组件需要有 &lt;MyContext.Provider&gt; 包裹着，值由 value 确定 12345678910111213141516171819202122232425262728293031323334353637const themes = &#123; light: &#123; foreground: &quot;#000000&quot;, background: &quot;#eeeeee&quot; &#125;, dark: &#123; foreground: &quot;#ffffff&quot;, background: &quot;#222222&quot; &#125;&#125;;const ThemeContext = React.createContext(themes.light);function App() &#123; return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; const theme = useContext(ThemeContext); return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125; useReduceruseReducer 是 useState 的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 在上述例子中，当修改 state 里面的值的时候，会通过dispatch 传递一个比较复杂的值作为 reducer 方法中的 action，在reducer 内部通过 action 的值来进行代码运算，返回出新的值 useCallbackReact useCallbackHook 返回一個記憶化的回調函數。這使我們能夠隔離資源密集型功能，以便它們不會在每次渲染時自動運行。 使用useCallback鉤子來防止函數被重新創建，除非有必要。 123const addTodo = useCallback(() =&gt; &#123; setTodos((t) =&gt; [...t, &quot;New Todo&quot;]);&#125;, [todos]); 当组件内容发生变化重新渲染的时候，如果 todos 没有发生变化的话，addTodo 函数不会重新创建 useMemoReact useCallbackHook 返回一個記憶化的值，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作 123456789const Todo = (&#123; todos &#125;) =&gt; &#123; return &lt;div&gt;&#123; todos.map(item =&gt; &lt;div&gt; &#123;item.name&#125; &lt;/div&gt;) &#125;&lt;/div&gt;&#125;export default useMemo(Todo) 以上 Todo 组件仅会在 todos 参数发生变化时才会重新计算渲染，如果传入内容有函数，可以和 useCallback 接合，实现值的缓存 useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。 useRef 既可以用来存储 dom 对象，也可以用来存储单个的值 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。 1234const ref = useRef(1)console.log(ref.current)ref.current = 2console.log(ref.current) useImperativeHandle 和 forwardRefuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 父组件使用 forwardRef 来接收子组件暴露出的实例值 123456789101112131415161718function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;function App() &#123; FancyInput = forwardRef(FancyInput); function focus() &#123; inputRef.current.focus() &#125; return &lt;FancyInput ref=&#123;inputRef&#125; /&gt;&#125; useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;); return isOnline;&#125; useDeferredValueuseDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。 该 hook 与使用防抖和节流去延迟更新的用户空间 hooks 类似。使用 useDeferredValue 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，并且像 startTransition 一样，延迟值可以暂停，而不会触发现有内容的意外降级。 1234567891011121314151617181920function Typeahead() &#123; const query = useSearchQuery(&#x27;&#x27;); const deferredQuery = useDeferredValue(query); // Memoizing 告诉 React 仅当 deferredQuery 改变， // 而不是 query 改变的时候才重新渲染 const suggestions = useMemo(() =&gt; &lt;SearchSuggestions query=&#123;deferredQuery&#125; /&gt;, [deferredQuery] ); return ( &lt;&gt; &lt;SearchInput query=&#123;query&#125; /&gt; &lt;Suspense fallback=&quot;Loading results...&quot;&gt; &#123;suggestions&#125; &lt;/Suspense&gt; &lt;/&gt; );&#125; useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。 isPending 指示过渡任务何时活跃以显示一个等待状态：startTransition 用来启动过渡任务 1234567891011121314151617function App() &#123; const [isPending, startTransition] = useTransition(); const [count, setCount] = useState(0); function handleClick() &#123; startTransition(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;) &#125; return ( &lt;div&gt; &#123;isPending &amp;&amp; &lt;Spinner /&gt;&#125; &lt;button onClick=&#123;handleClick&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;/div&gt; );&#125; useIduseId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。 自定义 Hooks在知道上述 hooks 之后，react 也支持我们自定义 hooks 操作。 自定义 hooks 主要是用来 提取共享逻辑，优化代码结构。 1234567891011const useUserInfo = () =&gt; &#123; const [useInfo, setUseInfo] = useState(null) useEffect(() =&gt; &#123; // 这里做处理用户的个人信息 &#125;) return useInfo&#125;const useInfo = useUserInfo()","pubDate":"Tue, 09 Aug 2022 01:55:31 GMT","guid":"https://lxx1997.github.io/2022/08/09/react/react-custom-hooks/","category":"react,hooks"},{"title":"vue3 组合式Api setup","link":"https://lxx1997.github.io/2022/08/02/vue/vue3-composition-api-setup/","description":"什么是组合式API组合式API 主要是为了把相同的逻辑关注点收集在一起，使得逻辑处理更加清晰和方便。 针对 vue2 的组件选项来说，（data, computed, methods, watch）等组件存在，导致我们在修改同一个逻辑关注点的之后需要不停地跳转相关的代码块，代码碎片化，使得我们理解和维护复杂组件变得困难。 在 vue3组件中，这个位置称为 setup 这个是 Vue3 新增的一个选项 setup 选项会在组件被创建之前执行，一旦 props 解析完成，setup 就会被作为 组合式Api 的入口，也就是说 setup 执行的时机要比 vue2 的 beforeCreate 要早，此外 setup 中应避免使用 this 且因为调用发生在 data，computed，methods 之前，所以无法在 setup 中获取 既然 setup 中无法获取到 data，computed 中的内容，那么我们怎么创建和监控变量变化，且组件内能获取到呢？ setup 接收 props 和 context props 是父元素传递过来的 props context 是当前组件实例上下文 setup 函数 return 出一个对象，这个对象可以被组件直接获取到，相当于 data 和 methods 的集团体 怎么保证 setup 返回的变量是响应式的呢？ vue3 提供了一些 hooks，可以让我们创建响应式的变量 参数propssetup 接受两个参数，第一个参数是props，且是响应式的，传入新的props 时，会被一起更新 因为是响应式的，所以无法直接使用解构赋值，会失去响应式 12345678910111213141516171819202122232425262728293031323334353637383940// 父组件/** * 父组件向子组件传递一个 props title 属性，并且这个属性会在 3s 后发生变化 */export default &#123; setup() &#123; const title = ref(&quot;hhhhhh&quot;) setTimeout(() =&gt; &#123; title.value = &quot;this is new title&quot; &#125;, 3000); watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125; &#125;&#125;// 子组件/** * 子组件这里必须要在props 属性上添加需要接受的属性，否则setup 中的 props 无法接受到 * 当props 属性发生变化时，使用 watch 监听可以再次被触发，但是页面上内容不会发生变化，这是因为我们直接取的 props 里面的属性值，不具备响应式 */export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = props return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果我们想要对 props 进行解构操作，可以使用 toRefs 函数来完成此操作 下面代码我们会发现当 props 中的 title 属性发生变化后， 组件内 title 并不会跟随变化，而 computedTitle 则会跟随props 中的 title 属性发生变化 12345678910111213141516171819export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = toRefs(props) return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它 toRef 的作用相当于把 对象中的属性转化为 ref 类的属性，且与对象相关联，当对象中对应属性发生变化时, toRef 中的内容会同步发生改变 123456setup(props, context) &#123; let name = toRef(props, &quot;name&quot;) // name 会跟随 props 中的 name 属性变化而同步更新 return &#123; name: name &#125;&#125; contextcontext 是一个普通 JavaScript 对象，不是响应式的，因此可以使用 解构操作 暴露了其它可能在 setup 中有用的值： attrs 类似于 $attrs slots 类似于 $slots emit 类似于 $emit expose 公共property slots 和 attrs 是有状态的对象，跟随组件本身的更新而更新，避免使用解构赋值，如果想要根据 attrs 和 solts 更改应用富足用，应该在 onBeforeUpdate 钩子中执行操作 returnsetup return 出来的值可以在模板和组件中直接使用 如果父组件想要访问子组件 setup 中的 property，可以使用 expose 方法暴露出去 123456789101112export default &#123; setup(props, &#123; expose &#125;)&#123; let count = ref(0) const changeCount = () =&gt; ++count.value expose(&#123; changeCount &#125;) return &#123; count &#125; &#125;&#125; hookssetup 内部的钩子函数 onBeforeMount // 页面挂载钩子函数 onMounted onBeforeUpdate // 页面更新钩子函数 onUpdated onBeforeUnmount // 页面销毁钩子函数 onUnmounted onErrorCaptured // 页面错误事件钩子函数 onRenderTracked onRenderTriggered // 跟踪虚拟 DOM 重新渲染时调用 onActivated // keep-alive 缓存的组件激活时调用 onDeactivated // keep-alive 缓存的组件失活时调用 这些钩子函数的触发时机和在组件内部触发时机一致 这些钩子函数接受一个回调函数，当钩子函数被调用时，将会被执行 带 ref 的响应式变量在 Vue3 中，我们可以通过 ref hooks 创建一个响应式变量，ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值 之所以把值封装在对象中，主要是因为字符串和数字这些基本类型时通过值传递的，通过对象封装后，可以在整个对象安全的传递，不用担心失去响应式 1&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; 123456789101112131415setup(props, context) &#123; const title = ref(&quot;setup component&quot;) const changeTitle = function(val) &#123; title.value = val &#125; setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) return &#123; title, changeTitle &#125;&#125; 在上述实例中，我们可以发现，在3s 过后，页面上显示的内容发生变化，而且setup return 出来的属性和方法在组件的其他选项中都可以通过 this 来访问到 watch 响应式处理如果我们想要在 setup 选项中监听属性的变化，可以通过 watch hooks 方法监听属性变化 watch 接受三个参数，监听对象，回调函数，配置选项 配置选项同组件中的 watch 选项，同样包含 deep 和 immediate 属性，而且还额外接受一个 flush 选项 flush 选项有三个值 pre 默认值，指定回调在渲染前被调用 post 将回调推迟到渲染之后，这时候可以获取页面 dom 元素 sync 回调同步调用，不过会比较消耗性能 1watch(obj, (newValue, oldValue) =&gt; &#123;&#125;, &#123;deep?: true, immediate?: true, flush?: &quot;pre&quot; | &quot;post&quot; | &quot;sync&quot;&#125;) 下面这个例子，当 setTimeout 方法执行完成后，由于改变了 title 的值， 触发了 watch 函数，我们打开 console 就可以发现打印了title 改变之前的值和 修改之后的值 1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125;&#125; 如果我们想要监控多个数据源的变化，可以在watch 的时候 watch 监听对象传入一个数组，同理，当数组内的任意一个元素发生变化时，都会触发watch 函数，而且 watch 回调函数中传入的值也是以数组的形式存在的 123456789const firstName = ref(&#x27;&#x27;)const lastName = ref(&#x27;&#x27;)watch([firstName, lastName], (newValues, prevValues) =&gt; &#123; console.log(newValues, prevValues)&#125;)firstName.value = &#x27;John&#x27; // logs: [&quot;John&quot;, &quot;&quot;] [&quot;&quot;, &quot;&quot;]lastName.value = &#x27;Smith&#x27; // logs: [&quot;John&quot;, &quot;Smith&quot;] [&quot;John&quot;, &quot;&quot;] 如果在监控多个数据源变化时，针对多个数据源修改时是同步修改，并不涉及到 setTimeout 等异步操作时，watch 会把这些更改合并成一次操作，会将所有修改的值一起返回给回调函数 watch hooks 还可以通过回调函数的第三个参数来清除副作用，这个参数会在 watch hooks 被停止或者销毁时，或者副作用重新执行时触发 1234567891011121314151617setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o, onInvalidate) =&gt; &#123; console.log(n, o) onInvalidate(() =&gt; &#123; // 处理副作用方法 &#125;) &#125;) return &#123; title &#125;&#125; 类似的方式还有一个 watchEffect 方法 watchEffect在使用 watchEffect 的时候，会自动执行传入的函数，并且响应式的追踪依赖，并且在依赖发生变更操作时，重新运行传入的函数 1234567891011121314151617181920export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) watchEffect(() =&gt; &#123; console.log(title.value) &#125;) return &#123; title &#125; &#125;&#125; 上述代码执行完成后，我们会发现在控制台会首先输出 setup component， 然后 3s 过程会同时输出 setup component changed，这个是因为 watchEffect 会立即执行，但是因为依赖没有变更，所以就是初始值，3s 后，依赖发生了变更，这时 watch 和 watchEffect 同时触发 watchEffect 在执行完成后，会有一个返回值，我们可以通过这个返回值来停止监听,但是需要注意的是，watchEffect 还是会立即执行，只是当依赖方式变化时，不会再次触发 1234567891011121314151617export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) const stop = watchEffect(() =&gt; &#123; console.log(title.value) &#125;) stop() return &#123; title &#125; &#125;&#125; computed 计算属性1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) let computedTitle = computed(() =&gt; title.value + &quot;abcd&quot;) return &#123; title, computedTitle &#125;&#125; 访问 computed 值的时候和 访问响应式变量的值一样，都是通过 .value 来获取到 provide &amp;&amp; injectvue3 暴露出了两个方法 provide 和 inject 两个方法，这两个方法和 组件内的 provide和inject 方法等同 provide 传入两个参数，第一个参数是属性名，第二个参数是属性值1234setup(props, context) &#123; provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, 26)&#125; inject 传入两个参数，第一个参数是属性名，第二个参数是默认值1234setup(props, context) &#123; inject(&quot;name&quot;, &quot;lxx&quot;) inject(&quot;age&quot;)&#125; 但是通过上述创建的 provide 和 inject 之间不是响应式的，也就是说如果provide 的值改变并不会触发 inject 的值变化，provide 可以使用 ref 和 reactive 方法创建响应式的 provide 12345setup(props, context) &#123; const count = ref(0) provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, count)&#125; 模板引用(ref=””)12345678910111213141516171819202122&lt;template&gt; &lt;div :ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const root = ref(null) onMounted(() =&gt; &#123; // DOM 元素将在初始渲染后分配给 ref console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt; &#125;) return &#123; root &#125; &#125; &#125;&lt;/script&gt; 当页面加载完成后，会自动将 div 绑定给 root 如果需要使用 v-for 绑定多个标签，可以创建响应式数组或者响应式对象来实现","pubDate":"Tue, 02 Aug 2022 07:03:31 GMT","guid":"https://lxx1997.github.io/2022/08/02/vue/vue3-composition-api-setup/","category":"Vue3"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/extend/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/extend/hexo-create-categories-pages/","category":"hexo"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/vue/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/vue/relearn-vue2-02/","category":"Vue"},{"title":"html-webpack-plugin 的使用与进阶","link":"https://lxx1997.github.io/2022/07/13/webpack/html-webpack-plugin/","description":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","pubDate":"Wed, 13 Jul 2022 03:19:44 GMT","guid":"https://lxx1997.github.io/2022/07/13/webpack/html-webpack-plugin/","category":"webpack"}]}