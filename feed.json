{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Fri, 05 Aug 2022 14:27:39 GMT","lastBuildDate":"Sat, 06 Aug 2022 01:48:14 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"leetcode 百天解题 - day 18 - 623. 在二叉树中增加一行","link":"https://lxx1997.github.io/2022/08/05/handredday/leetcode/day-18-623/","description":"题目名称给定一个二叉树的根 root 和两个整数 val 和 depth ，在给定的深度 depth 处添加一个值为 val 的节点行。 注意，根节点 root 位于深度 1 。 加法规则如下: 给定整数 depth，对于深度为 depth - 1 的每个非空树节点 cur ，创建两个值为 val 的树节点作为 cur 的左子树根和右子树根。cur 原来的左子树应该是新的左子树根的左子树。cur 原来的右子树应该是新的右子树根的右子树。如果 depth == 1 意味着 depth - 1 根本没有深度，那么创建一个树节点，值 val 作为整个原始树的新根，而原始树就是新根的左子树。 示例输入: root = [4,2,6,3,1,5], val = 1, depth = 2 输出: [4,1,1,2,null,null,6,3,1,5] 题解这道题主要还是考察二叉树的遍历，首先根据二叉树的层级遍历出一个二维数组（或者只要遍历到depth 所需要的深度即可，无需完全遍历），二维数组中的元素对应着每一层的节点及节点数 depth 实际上是获取 depth - 1 层的节点数，然后在根据获取到的节点及节点的左右子节点来添加新的左右子节点以及旧左右子节点的位置 答案123456789101112131415161718192021222324252627282930313233343536var addOneRow = function(root, val, depth) &#123; let rootRow = flatRoot([[root]]) if(depth === 1) &#123; let r = &#123; val: val, left: root, right: null&#125; return r &#125; let row = rootRow[depth - 2] for(let i = 0; i &lt; row.length; i++) &#123; let item = row[i] let &#123; left, right &#125; = item let l = &#123; val, left: null, right: null&#125;, r = &#123; val, left: null, right: null &#125; if(left &amp;&amp; right) &#123; l.left = left r.right = right &#125; else if(left &amp;&amp; !right) &#123; l.left = left &#125; else if(!left &amp;&amp; right) &#123; r.right = right &#125; item.left = l item.right = r &#125; return root&#125;;var flatRoot = (arr) =&gt; &#123; let root = arr[arr.length - 1], newArr = [] for(let i = 0; i &lt; root.length; i++) &#123; let item = root[i] item.left &amp;&amp; newArr.push(item.left) item.right &amp;&amp; newArr.push(item.right) &#125; if(newArr.length === 0) return arr arr.push(newArr) return flatRoot(arr)&#125;","pubDate":"Fri, 05 Aug 2022 14:27:39 GMT","guid":"https://lxx1997.github.io/2022/08/05/handredday/leetcode/day-18-623/","category":"leetcode"},{"title":"leetcode 百天解题 - day 17 - 1403. 非递增顺序的最小子序列","link":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","description":"题目名称给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 题解这道题其实只是一个简单难度的题，最开始没有仔细读题，看到子序列数组，以为是连续的，所以就采用滑动窗口的思路去做，结果提交的时候发现和用例不对。 然后仔细读了一下题发现以下重点 不强调元素在原数组中的连续性 和 答案应当按 非递增顺序 排列 这个时候思路就十分清晰了，既然答案需要按非递增序列排序，我们就先把传进来的数组按照非递增顺序排序，然后计算数组的和，从头开始遍历数组，将数组的每一项加起来和数组剩余的数进行对比，如果满足要求，则代表这一部分数组是我们要的结果，而且也不需要再去对比不同子序列的长度和和的大小，因为数组开头的元素是最大的，得到的子序列是一定满足最后的结果的 答案12345678910111213var minSubsequence = function(nums) &#123; nums = nums.sort((a,b) =&gt; b - a) let total = nums.reduce((total, item) =&gt; total += item, 0) let index = 0, mix = 0 for(let i = 0; i &lt; nums.length; i++) &#123; mix += nums[i] if(mix &gt; total - mix) &#123; index = i break; &#125; &#125; return nums.splice(0, index + 1)&#125;;","pubDate":"Thu, 04 Aug 2022 14:22:40 GMT","guid":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","category":"leetcode"},{"title":"leetcode 百天解题 - day 16 - 16. 最接近的三数之和","link":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","description":"题目名称给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 题解这道题其实和 12天的三数之和类似，如果采用粗暴的三次遍历的方式的话，提交结果测试的时候肯定是会发生超时的，所以这里还是采用双指针的方式 首先先判断长度，如果数组长度等于3，那么可以肯定的是这三个数的和就是我们需要的值 如果长度大于三，这个时候我们先把数组按照从小到大的顺序排列，然后针对第一个数进行 for 循环，另外两个数采用指针的方式进行循环，计算三个数的和，是否与target 最小，如果不是，根据差的正负值来判断是移动左指针还是右指针，最后返回最接近的值 答案123456789101112131415161718192021var threeSumClosest = function(nums, target) &#123; nums = nums.sort((a, b) =&gt; a - b) if(nums.length === 3) return nums.reduce((total, item) =&gt; total += item, 0) let mixSum = target, smallest = Infinity for(let i = 0; i &lt; nums.length - 2; i++) &#123; let total = nums[i] let left = i + 1, right = nums.length - 1 while(left &lt; right) &#123; let sum = total + nums[left] + nums[right] let deffer = target - sum, absDeffer = Math.abs(deffer) if(absDeffer &gt; smallest) &#123; deffer &lt; 0 ? right-- : left++ &#125; else &#123; smallest = absDeffer mixSum = sum deffer &lt; 0 ? right-- : left++ &#125; &#125; &#125; return mixSum;&#125;;","pubDate":"Wed, 03 Aug 2022 14:57:28 GMT","guid":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","category":"leetcode"},{"title":"leetcode 百天解题 - day 15 - 622. 设计循环队列","link":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","description":"题目名称设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 题解这道题主要考察队列的实现，这里的队列采用的先进先出原则，我们在这里可以使用数组来模拟，当我们添加一个元素的时候使用 Array.push 方法向数组末尾添加一个元素，删除元素时，使用 Array.shift 删除数组开始的元素模拟出队列的先进先出原则 答案123456789101112131415161718192021222324252627282930313233343536373839404142434445var MyCircularQueue = function(k) &#123; this.queue = [] this.length = k this.index = 0&#125;;MyCircularQueue.prototype.enQueue = function(value) &#123; if(this.index &lt; this.length) &#123; this.queue.push(value) this.index++ return true &#125; return false&#125;;MyCircularQueue.prototype.deQueue = function() &#123; if(this.index &gt; 0) &#123; this.queue.shift() this.index-- return true &#125; return false&#125;;MyCircularQueue.prototype.Front = function() &#123; if(this.index &gt; 0) &#123; return this.queue[0] &#125; return -1&#125;;MyCircularQueue.prototype.Rear = function() &#123; if(this.index &gt; 0) &#123; return this.queue[this.index - 1] &#125; return -1&#125;;MyCircularQueue.prototype.isEmpty = function() &#123; return this.index === 0&#125;;MyCircularQueue.prototype.isFull = function() &#123; return this.index === this.length&#125;;","pubDate":"Tue, 02 Aug 2022 13:15:19 GMT","guid":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","category":"leetcode"},{"title":"leetcode 百天解题 - day 14 - 1374. 生成每种字符都是奇数个的字符串","link":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","description":"题目名称给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可 示例输入：n = 4 输出：”pppz” 解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love” 题解这道题没有什么难点，可以取巧，如果输入的数是奇数，就可以全部输出同一个单词，输入为偶数时，可以是两个字母 答案123var generateTheString = function(n) &#123; return n % 2 === 1 ? new Array(n).fill(&quot;a&quot;).join(&quot;&quot;) : (new Array(n-1).fill(&quot;a&quot;).join(&quot;&quot;) + &quot;b&quot;)&#125;;","pubDate":"Mon, 01 Aug 2022 13:21:36 GMT","guid":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","category":"leetcode"},{"title":"leetcode 百天解题 - day 13 - 1161. 最大层内元素和","link":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","description":"题目名称给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例输入：root = [1,7,0,7,-8,null,null] 输出：2 解释： 第 1 层各元素之和为 1， 第 2 层各元素之和为 7 + 0 = 7， 第 3 层各元素之和为 7 + -8 = -1， 所以我们返回第 2 层的层号，它的层内元素之和最大。 题解这道题主要考察树的广度优先遍历，将数一层一级的分割开来，然后分别计算每层的和，比较大小 答案123456789101112131415161718192021222324252627282930313233var maxLevelSum = function(root) &#123; let rootArr = changeTreeToArray([[root]]) let max = -Infinity, floor = 1 for(let i = 0; i &lt; rootArr.length; i++) &#123; let sum = getSum(rootArr[i]) if(max &lt; sum) &#123; max = sum; floor = i + 1 &#125; &#125; return floor&#125;;function getSum(arr) &#123; let total = 0 arr.forEach(item =&gt; &#123; total += item.val &#125;); return total&#125;function changeTreeToArray(arr, index = 0) &#123; let newArr = [], root = arr[index] for(let i = 0; i &lt; root.length; i++) &#123; let r = root[i] r.left &amp;&amp; newArr.push(r.left); r.right &amp;&amp; newArr.push(r.right) &#125; if(newArr.length === 0) return arr arr.push(newArr); index++ return changeTreeToArray(arr, index)&#125;","pubDate":"Sun, 31 Jul 2022 10:15:26 GMT","guid":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","category":"leetcode"},{"title":"leetcode 百天解题 - day 12 - 15. 三数之和","link":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","description":"题目名称给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解这道题有几个点需要注意一下 最后返回的数据是去重后的数组，也就是说按照从小到大排列后，没有包含同样序列的子元素，数组去重同样是一个难点 注意执行时间，如果强行去循环的话，因为复杂度是 O(n^3),所以最后一定是会超时的 数组去重的话可以采用 Set 来存储得到的数组，不过需要把数组排序之后，转成字符串存放 循环的采用双指针的方式 在最开始先把原数组按照从小到大排列，这样我们就不必再对得到的结果进行排序操作，而且再循环时还可以排除第一个元素大于0的循环， 接下来采用双指针的方式，从数组的两端进行和的对比，因为第一个数的大小已经固定，所以只需要确保剩余两个数加上第一个数的和为0就可以了，如果和小于0，说明负数过大，所以左指针右移,如果和大于0，说明正数过大，所以右指针左移 最后将得到的结果数组转化成能够识别的内容 答案123456789101112131415161718192021var threeSum = function(nums) &#123; let sum = [], hash = new Set(); if(nums.length &lt; 3) return sum nums = nums.sort((a, b) =&gt; a - b) for(let i = 0; i &lt; nums.length - 2; i++) &#123; let first = nums[i] if(first &gt; 0) break; let l = i + 1, r = nums.length - 1 while(l &lt; r) &#123; let second = nums[l], third = nums[r] let s = first + second + third if(s &lt; 0)&#123; l++; continue;&#125;// 和小于0，说明负数过大，所以左指针右移，减少 if(s &gt; 0)&#123; r--; continue;&#125;// 和大于0，说明正数过大，所以右指针左移，减少 hash.add(`$&#123;first&#125;,$&#123;second&#125;,$&#123;third&#125;`) l++; r--; &#125; &#125; return Array.from(hash).map(item =&gt; item.split(&quot;,&quot;).map(item =&gt; +item))&#125;;","pubDate":"Sat, 30 Jul 2022 09:55:44 GMT","guid":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","category":"leetcode"},{"title":"leetcode 百天解题 - day 11 - 593. 有效的正方形","link":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","description":"题目名称给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。 一个 有效的正方形 有四条等边和四个等角(90度角)。 示例输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] 输出: True 输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12] 输出：false 输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1] 输出：true 题解第一种方法我们可以知道正方形都是等边的，且四个角都是直角，因此随机选三个点，然后判断这三个点组成的三角形是否是等腰直角三角形 判断三个点是否是等腰三角形，只需要判断三个点之间的距离是否其中两个点与另一个点的距离相等，且两个点之间的距离是到另一个点距离的根号2倍 答案12345678910111213141516171819202122var validSquare = function(p1, p2, p3, p4) &#123; return checkTrangle(p1,p2,p3) &amp;&amp; checkTrangle(p4,p2,p3) &amp;&amp; checkTrangle(p1,p2,p4) &amp;&amp; checkTrangle(p1,p3,p4)&#125;;function checkTrangle(p1, p2, p3) &#123; let a = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2) let b = Math.pow(p3[0] - p1[0], 2) + Math.pow(p3[1] - p1[1], 2) let c = Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2) if(a === 0 || b === 0 || c === 0) return false let max= Math.max(a,b,c) if(max === c) &#123; return a === b &amp;&amp; a + b === c &#125; if(max === b) &#123; return a === c &amp;&amp; a + c === b &#125; if(max === a) &#123; return c === b &amp;&amp; c + b === a &#125; return false&#125;","pubDate":"Fri, 29 Jul 2022 14:38:01 GMT","guid":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","category":"leetcode"},{"title":"leetcode 百天解题 - day 10 - 1331. 数组序号转换","link":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","description":"题目名称给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。 示例输入：arr = [40,10,20,30] 输出：[4,1,2,3] 题解这个就相对来说较为简单了 首先针对原数组进行去重操作后，得到一个新的数组，然后在对这个不包含重复元素的数组进行从小到大排序 然后对原数组进行遍历操作，针对每一个原数组的元素，找到其在排序后的数组中的位置，替换原数组对应元素位置，最后的得到的新数组就是，原数组的数组序号转换 答案1234var arrayRankTransform = function(arr) &#123; let arrSort = Array.from(new Set(arr)).sort((a, b) =&gt; a - b) return arr.map(item =&gt; arrSort.indexOf(item) + 1)&#125;;","pubDate":"Thu, 28 Jul 2022 14:48:43 GMT","guid":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","category":"leetcode"},{"title":"leetcode 百天解题 - day 09 - 592. 分数加减运算","link":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","description":"题目名称给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。 示例输入: expression = “-1/2+1/2”输出: “0/1” 输入: expression = “-1/2+1/2+1/3”输出: “1/3” 输入: expression = “1/3-1/2”输出: “-1/6” 题解死办法，把分子分母单独提取出来，进行数值运行，最后提取出公约数后，将分子分母简化到最简 分数的加减法则x1/y1 + x2/y2 = (x1y2+x2y1)/y1y2x1/y1 - x2/y2 = (x1y2-x2y1)/y1y2 最大公约数用a和b求余，如果余数为0，则最大公约数为b，否则用 b 与 a%b 的进行求余比较，最后当余数为0时，剩余的数则是这两个数的最大公约数 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var fractionAddition = function(expression) &#123; let denominator = 0, numerator = 1; // 分子，分母 let index = 0, n = expression.length; while (index &lt; n) &#123; // 读取分子 let denominator1 = 0, sign = 1; if (expression[index] === &#x27;-&#x27; || expression[index] === &#x27;+&#x27;) &#123; sign = expression[index] === &#x27;-&#x27; ? -1 : 1; index++; &#125; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; denominator1 = denominator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator1 = sign * denominator1; index++; // 读取分母 let numerator1 = 0; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; numerator1 = numerator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator = denominator * numerator1 + denominator1 * numerator; numerator *= numerator1; &#125; if (denominator === 0) &#123; return &quot;0/1&quot;; &#125; const g = gcd(Math.abs(denominator), numerator); // 获取最大公约数 return Math.floor(denominator / g) + &quot;/&quot; + Math.floor(numerator / g);&#125;const gcd = (a, b) =&gt; &#123; let remainder = a % b; while (remainder !== 0) &#123; a = b; b = remainder; remainder = a % b; &#125; return b;&#125;;const isDigit = (ch) =&gt; &#123; return parseFloat(ch).toString() === &quot;NaN&quot; ? false : true;&#125;","pubDate":"Wed, 27 Jul 2022 14:21:01 GMT","guid":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","category":"leetcode"},{"title":"leetcode 百天解题 - day 08 - 14. 最长公共前缀","link":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","description":"题目名称编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例输入：strs = [“flower”,”flow”,”flight”] 输出：”fl” 输入：strs = [“dog”,”racecar”,”car”] 输出：”” 题解这道题没有什么难点，主要就是取一个参照值（例如数组的第一个元素）然后从第一个字符到最后一个字符和数组中元素对比，直到出现不完全相同的字符的时候，这个时候便是公共的前缀 答案1234567891011121314var longestCommonPrefix = function(strs) &#123; if(strs.length === 1) return strs[0] let suffix = &quot;&quot; const compareStr = strs[0] for(let i = 1;i &lt; compareStr.length; i++) &#123; let s = compareStr[i] if(strs.every(item =&gt; item[i] === s)) &#123; suffix += s &#125; else &#123; return suffix &#125; &#125; return suffix&#125;;","pubDate":"Tue, 26 Jul 2022 13:35:55 GMT","guid":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","category":"leetcode"},{"title":"leetcode 百天解题 - day 07 - 919. 完全二叉树插入器","link":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","description":"题目名称完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。 实现 CBTInserter 类: CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例输入[“CBTInserter”, “insert”, “insert”, “get_root”][[[1, 2]], [3], [4], []] 输出[null, 1, 2, [1, 2, 3, 4]] 题解这道题主要考察树的 广度优先遍历（bfs） 我们需要从树中取出非完全二叉树的节点，所以最重要的就是如何取出这个节点，这里采用的是 广度优先遍历的方法，首先将树根据节点顺序转化成为一个数组，然后在数组中找出第一个不完全二叉树节点 但是目前由于需要操作的步骤过多，性能较差，有待优化 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var CBTInserter = function(root) &#123; this.root = root this.incompleteNode = getFirstIncompleteTree(root)&#125;;CBTInserter.prototype.insert = function(val) &#123; if(!this.incompleteNode.left) &#123; this.incompleteNode.left = &#123; val: val &#125; &#125; else if(!this.incompleteNode.right) &#123; this.incompleteNode.right = &#123; val: val &#125; &#125; let parent = this.incompleteNode if(this.incompleteNode.left &amp;&amp; this.incompleteNode.right) &#123; this.incompleteNode = getFirstIncompleteTree(this.root) &#125; return parent.val&#125;;function getFirstIncompleteTree(root) &#123; let nodeList = getTreeNodes([root]) for(let i = 0; i &lt; nodeList.length; i++) &#123; let node = checkIncompleteTree(nodeList[i]) if(node) return nodeList[i] &#125; return null&#125;function getTreeNodes(arr = [root]) &#123; let newArr = [...arr] for(let i = 0; i &lt; arr.length; i++) &#123; let root = arr[i] root.left &amp;&amp; newArr.push(root.left) root.right &amp;&amp; newArr.push(root.right) if(!root.left || !root.right) return newArr &#125; return getTreeNodes(newArr)&#125;function checkIncompleteTree(node) &#123; return !node.left || !node.right&#125;CBTInserter.prototype.get_root = function() &#123; return this.root&#125;;","pubDate":"Mon, 25 Jul 2022 14:44:26 GMT","guid":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","category":"leetcode"},{"title":"leetcode 百天解题 - day 06 - 1184. 公交站间的距离","link":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","description":"题目名称环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 题解这道题主要考察我们对于数组的操作，根据题目，我们可以得知 公交可以按照顺序针和逆时针运动，也就是说方向并不固定，其次就是没有规定 出发点一定在目的站的前面（这个是重点） 所以这个时候就有两种类型，一种是出发点在目的地前面，还有一种是出发点在目的地的后面 针对第一种，我们可以先计算出所有站的距离的和 total，然后在计算出两站之间顺时针的距离 dis，然后对比 dis 和 total - dis 的距离哪个最小 第二种同样，只不过是将出发点和目的地翻转一下 答案1234567891011121314151617var distanceBetweenBusStops = function(distance, start, destination) &#123; if(start === destination) return 0 let total = distance.reduce((total, item) =&gt; &#123; return total + item &#125;, 0) let dis = 0 if(destination &lt; start) &#123; dis = distance.slice(destination, start).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; else &#123; dis = distance.slice(start, destination).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; return Math.min(dis, total - dis)&#125;;","pubDate":"Sun, 24 Jul 2022 11:34:47 GMT","guid":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","category":"leetcode"},{"title":"leetcode 百天解题 - day 05 - 13. 罗马数字转整数","link":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","description":"题目名称罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例输入: s = “LVIII”输出: 58 输入: s = “MCMXCIV”输出: 1994 题解这道题主要考察我们对于字符串的处理方式；根据题目我们可以找到以下几种组合 &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 根据上面我们列出的组合，现针对字符串中的复杂字符进行替换，并且对应的数字进行加法操作 之所以返回 &quot; &quot; 是为了避免返回空字符串或者原字符，会对最后的结果造成影响 1234567function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s&#125; 最后将我们替换之后的，只剩下单个字符的组合，这时只需要将字符对应的数字进行加法操作，就得出最后的数了 答案1234567891011121314151617181920212223242526272829303132333435var romanToInt = function(s) &#123; let NumHash = &#123; &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 &#125; let num = 0, arr = [&quot;IV&quot;, &quot;IX&quot;, &quot;XL&quot;, &quot;XC&quot;, &quot;CD&quot;, &quot;CM&quot;]; arr.map(item =&gt; &#123; s = repalceValue(s, item) &#125;); for(let i = 0; i &lt; s.length; i++) &#123; if(s[i] !== &quot; &quot;) &#123; num += NumHash[s[i]] &#125; &#125; function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s &#125; return num&#125;;","pubDate":"Sat, 23 Jul 2022 15:12:40 GMT","guid":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","category":"leetcode"},{"title":"leetcode 百天解题 - day 04 - 8 字符串转换整数 (atoi)","link":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","description":"题目名称请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例输入：s = “42” 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：”42”（当前没有读入字符，因为没有前导空格） 第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’） 第 3 步：”42”（读入 “42”） 解析得到整数 42 。 由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。 题解这道题其实并不麻烦，主要是考察我们的边界处理能力还有就是题目理解能力 首先看题目，题目最开始说去除多余的空格，去除空格的话我们可以采用for循环，也可以采用字符串的 trim 方法 然后就是判断去除空格后的第一个字符是否是 “+” 或者 “-“,如果是，则标记对应的正负符号 如果不是则判断这个字符是否是属于 0 - 9 的数字，如果是，则继续判断下一个字符，如果不是，返回0（我就是在这一步卡了，没有注意的第一个字符就必须是0-9及+- 中的一位） 继续判断下一个字符，直到出现 0 - 9 以外的字符或者直到字符串结尾 然后在拿得到的字符串转为数字后，在与 32位进行比较，得出区间内的数字 答案1234567891011121314151617181920212223242526272829303132var myAtoi = function(s) &#123; let symbol = true, numList = new Array(10).fill(0).map((item,index) =&gt; index + &quot;&quot;), all = [&quot;+&quot;, &quot;-&quot;].concat(numList) s = s.trim() for(let i = 0; i &lt; s.length; i++) &#123; if(all.includes(s[i])) &#123; if(s[i] === &quot;+&quot;) &#123; s = s.slice(i + 1) &#125; else if(s[i] === &quot;-&quot;) &#123; s = s.slice(i + 1) symbol = false &#125; else &#123; s = s.slice(i) &#125; break &#125; else &#123; return 0 &#125; &#125; if(!numList.includes(s[0])) return 0 let ns = &quot;&quot; for(let i = 0; i &lt; s.length; i++) &#123; if (numList.includes(s[i])) &#123; ns +=s[i] &#125; else &#123; if(s.length) &#123; break; &#125; &#125; &#125; if(symbol) return Math.min(+ns, Math.pow(2, 31) - 1) return Math.max(-Number(ns), -Math.pow(2, 31))&#125;;","pubDate":"Fri, 22 Jul 2022 15:23:47 GMT","guid":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","category":"leetcode"},{"title":"leetcode 百天解题 - day 03 - 814 二叉树剪枝","link":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","description":"题目名称给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例 输入：root = [1,null,0,0,1]输出：[1,null,0,null,1] 题解暴力计算法本道题主要考察二叉树和递归的使用，针对二叉树的左右节点进行递归操作，一旦有一个节点符合 既没有子节点，且当前节点值为 0，则去除此节点，然后将空值传给父节点，父节点再进行相同判断，直到最后的结果中不包含不包含1的子节点 答案123456789101112var pruneTree = function(root) &#123; if(root.left) &#123; root.left = pruneTree(root.left) &#125; if(root.right) &#123; root.right = pruneTree(root.right) &#125; if(root.val === 0 &amp;&amp; !root.left &amp;&amp; !root.right) &#123; return undefined &#125; return root&#125;;","pubDate":"Thu, 21 Jul 2022 14:41:48 GMT","guid":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","category":"leetcode"},{"title":"leetcode 百天解题 - day 02 - 1260 二维网格迁移","link":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","description":"题目名称给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。请你返回 k 次迁移操作后最终得到的 二维网格。 示例 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 题解暴力计算法这道题相对来说较为简单，从示例可以看出，所谓的移动k个元素，其实就是二维网格内的所有元素同步的移动k个元素，然后和二维数组内元素的总长度求余，所得余数便是二维网格内元素的位置 所以首先最重要的就是将二维网格平铺成为一个一维数组，可以使用数组的 flat 方法，当前也可以使用递归的方式来遍历出二维数组中的所有元素。 将二维数组平铺之后，然后根据传入的k值得出需要平移的元素个数，然后将不需要移动的元素和移动之后的元素拼接成一个新的数组，最后在根据原二维数组的长度得出新的二维数组 答案12345678910 var shiftGrid = function(grid, k) &#123; let arr = grid.flat(Infinity) let index = arr.length - k % arr.length let newArr = arr.slice(index).concat(arr.slice(0, index)) let length = grid[0].length, ngrid = [] for(let i = 0; i &lt; newArr.length; i += length) &#123; ngrid.push(newArr.slice(i, i + length)) &#125; return ngrid&#125;;","pubDate":"Wed, 20 Jul 2022 13:50:13 GMT","guid":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","category":"leetcode"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","category":"hexo"},{"title":"leetcode 百天解题 - day 01 - 731 我的日程安排表 II","link":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","description":"题目名称实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true解释：前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 题解暴力计算法 算法思想解析 最简单的一种方法就是暴力计算法，直接遍历已有的日历时间，然后计算出时间中两次重叠的时间区间，每次添加新的日历时，查看时间区间是否包含在两次重叠的时间区间内，如果包含在里面，则会造成三重重叠，不可添加进日历，如果不包含，则可以添加到日历，此时需要重新计算双重重叠的区间 算法步骤解析 首先我们需要创建一个 MyCalendarTwo 函数，并且定义日历数组（calenderList）和双重重复区间数组（doubleList） 在函数实例上创建 添加日历方法（book） 方法内部首先会去遍历双重重复区间数组，然后对比时间区间是否在双重区间内，只有不在双重区间内才可通过，否则返回false 具体对比方法其实就像两条线段，如果想要两条线段有重叠，只需要满足一个条件即可 其中一条线段的最右边的点一定是大于另一条线段的最左边的点，且最左边的点一定是小于另一条线段最右边的点 接下来就是和日历中的时间进行比较，计算出所有双重重叠区间，然后将新添加的时间区间添加到日历数组中 答案1234567891011121314151617181920var MyCalendarTwo = function() &#123; this.calenderList = [] this.doubleList = []&#125;;MyCalendarTwo.prototype.book = function(start, end) &#123; for(let i = 0; i &lt; this.doubleList.length; i++) &#123; let l = this.doubleList[i][0], r = this.doubleList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; return false &#125; &#125; for(let i = 0; i &lt; this.calenderList.length; i++) &#123; let l = this.calenderList[i][0], r = this.calenderList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; this.doubleList.push([Math.max(l, start), Math.min(r, end)]) &#125; &#125; this.calenderList.push([start, end]) return false&#125;;","pubDate":"Tue, 19 Jul 2022 13:31:34 GMT","guid":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","category":"leetcode"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","category":"vue"},{"title":"html-webpack-plugin 的使用与进阶","link":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","description":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","pubDate":"Wed, 13 Jul 2022 03:19:44 GMT","guid":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","category":"webpack"},{"title":"常用的前端动画库","link":"https://lxx1997.github.io/2022/07/12/web-animation-package/","description":"Lottie 文档 都2022年了，一个还不知道Lottie动画的前端已经OUT啦！ svga SVGA在前端方面的使用","pubDate":"Tue, 12 Jul 2022 08:58:08 GMT","guid":"https://lxx1997.github.io/2022/07/12/web-animation-package/","category":""},{"title":"生成 github SSH key","link":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","description":"生成 SSH key打开 git bash 命令行工具 输入一下命令，自动生成 ssh key 地址 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 可以通过命令行直接复制 ssh key 的内容 1clip &lt; ~/.ssh/id_ed25519.pub 复制成功之后，可以将 ssh key 复制到 github 的ssh key 上 和 github 链接执行以下命令 1234ssh-add ~/.ssh/id_ed25519// 或者echo $SSH_AGENT_SOCK 如果执行不成功，可能是 ssh-add 未开启，可以通过命令行查看是否开启ssh-add 服务1ps -ef | grep ssh 开启 ssh-add 服务12cd ~/.ssheval $(ssh-agent) 执行完上述命令后就可以进行ssh 链接","pubDate":"Fri, 08 Jul 2022 06:19:07 GMT","guid":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","category":"git"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part1","link":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","description":"computed 属性默认是只有 getter 属性的，也就是说我们只能获取到computed 属性的值，但是无法修改它，但是我们可以手动的设置 setter 属性，这样就可以手动赋值了 1234567891011121314export default &#123; computed() &#123; fullName: &#123; set: function (val) &#123; let name = val.split(&quot; &quot;) this.firstName = name[0] this.secondName = name[1] &#125;, get: function () &#123; return this.firstName + &quot; &quot; + this.secondName &#125; &#125; &#125;&#125; v-for 和 v-if 为什么不推介一起使用 这个是因为 v-for 和 v-if 的优先级问题，vue 会先进行 v-for 循环渲染元素，最后在进行 v-if 控制是否显示元素，会造成无谓的资源浪费 可以采用 v-show 代替 v-if 或者使用计算属性来代替 v-if， 只渲染我们想渲染的元素 key attribute 用来表示这个元素是完全独立的，和其他元素不同，在日常操作中可以用来强制刷新元素内容，只需要修改元素的key，就会重新去渲染元素 我之前用过 v-if 和 $nextTick 来强制重新渲染元素内容，很明显使用上述方法是一种很方便的操作 v-for 可以使用 in 或者 of 来作为分隔符 v-for 遍历对象时 v-for=&quot;(value, name, index) in obj&quot; 三个值 分别为 值，键，和 索引 vue 中可以使用 template 标签，该标签类似 react 中的&lt;&gt;&lt;/&gt;和React.Fragment,在实际渲染中并不会被渲染出来 如果我们想要在点击事件中访问原始的 dom 时间，可以将特殊的变量 $event 传到方法中 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 事件捕获的时候触发，如果点击的是子元素，会先于子元素事件触发 .self 只有当 event.target 是元素自身时触发，点击子元素时不会触发 .once 只会触发一次 .passive 和 .prevent 相反，不会阻止默认事件触发 使用修饰符的时候，顺序很重要，代码会以同样的顺序产生，例如v-on:click.prevent.self 会阻止所有点击，而 v-on:click.slef.prevent 只会阻止元素对自身的点击 按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 支持按键码 可以通过全局的 config.keyCodes 自定义按键修饰符别名1Vue.config.keyCodes.f1 = 112 系统修饰键 (修饰键在和其他事件一起使用的时候，需要同时触发才行，否则并不会单独触发修饰键) .ctrl .alt .shift .meta .exact 精确修饰符，允许我们控制精确的系统修饰符组合触发的事件 &lt;input v-model=&quot;toggle&quot; type=&quot;checkbox&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; 此时 toggle 会取 对应的 true-value 和 false-value 的值 v-model.lazy 默认情况下，v-model 会在input 事件触发后将输入框的值与数据同步，添加lazy 修饰符后，从而转为在 change 事件之后触发 v-model.number 会自动将用户输入的值转为数值类型 v-model.trim 会自动去除用户输入内容两端的空格 自定义组件中的 data 必须是一个函数，是为了保证每次创建组件的时候都能拿到一个独立的数据，否则，重复创建组件时，组件内的数据由于有同一个引用地址，会互相干扰 v-model 在自定义组件中使用相当于 v-bind:value 和 v-on:change 的组合 可以通过组件的 model 属性改变 v-model 的默认属性和事件绑定 12345678910export default &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27; &#125;, mounted() &#123; console.log(this.checked) this.$emit(&quot;change&quot;, &quot;val&quot;) &#125;,&#125; &lt;component v-bind:is=&quot;CustomComponent&quot;&gt;&lt;/component&gt; 通过 v-bind:is 可以自定义组件，组件会跟随 CustomComponent 的值变化而变化 传入一个对象的所有 property, 组件内部可以直接通过 示例中 post 拿到对应的属性 1&lt;component v-bind=&quot;post&quot;&gt;&lt;/component&gt; props 验证 123456789101112export default &#123; props: &#123; propA: &#123; type: String, default: &quot;&quot;, require: false, validator() &#123; &#125; &#125; &#125;&#125; type props 参数类型 String, Number, Boolean, Array, Object, Date, Function, Symbol, 或者自定义的构造函数 default 默认值，引用类型数据 需要使用函数并且通过return 返回默认引用类型 require 是否必须传 默认为 false validator 自定义效验规则 禁用 Attribute 继承，可以设置 inheritAttrs false 来之根元素继承 Attribute 具体表现为 如果设置为 false 子组件不会渲染 attribute， true 会在子组件上渲染 attribute 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 slot 缩写 v-slot: -&gt; # 后备内容 如果我们没有向插槽内提供内容，此时将会显示后备内容 &lt;slot&gt;默认内容&lt;/slot&gt; 具名插槽 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot-component v-slot:header&gt;&lt;/slot-component&gt; 作用域插槽 插槽内部 123456&lt;template&gt; &lt;div&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 外部使用 1234567&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 如果有多个插槽 12345678910&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;slot v-slot:other=&quot;otherSlotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 子组件可以通过 $root 来访问和修改根组件的实例及方法 provide, inject provide 选项允许和指定提供给后代组件的数据和方法 123456provide: function() &#123; return &#123; a: function() &#123;&#125;, b: 0 &#125;&#125; inject 允许子元素接受 provide 提供的 provide 1inject: [&#x27;a&#x27;, &#x27;b&#x27;] 但是出于设计考虑， 这些数据不是响应式的，而且会对重构及代码复用有很大的影响 X-Template x-template 需要定义在 Vue 所属的 DOM 元素外。 123&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component(&#x27;hello-world&#x27;, &#123; template: &#x27;#hello-world-template&#x27;&#125;) transition 过渡动画 v-enter 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义动画类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 显性的过渡持续时间 &lt;transition :duration=&quot;1000&quot; /&gt; &lt;transition :duration=&quot;&#123;enter: 500, leave: 800&#125;&quot; /&gt; JavaScript 钩子 123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; mixins 混入选项合并 数组对象会在内部进行合并，例如 data,属性名发生冲突时，以组件内属性优先 钩子函数合并成数组，都会被调用，混入对象的钩子函数优先于组件内钩子函数调用 值为对象时,将会被合并成为一个对象，且组件对象的键值对优先级更高 Vue.config.optionMergeStrategies 可以通过次宣讲自定义逻辑合并逻辑 自定义指令 1234567directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus /&gt; 钩子函数 bind 绑定时调用，只调用一次 inserted 被绑定元素插入父节点时调用 update 所在组件更新时调用，可能发生在子组件更新之前 componentUpdated 所在组件和子组件全部更新后调用 unbind 指令与元素解绑时调用 钩子函数参数 el 绑定的元素，可以用来操作 DOM binding name 指令名 value 指令绑定的值 oldValue 制定绑定的前一个值 expression 字符串形式的指令表达式 =&quot;1 + 1&quot; arg 传给指令的参数 :foo modifiers 指令修饰符 .foo vnode 当前虚拟节点 oldVnode 上一个虚拟节点 functional 函数式组件函数式组件没有响应式数据，也没有实例（没有 this 上下文）相反会有一个 context 参数 包含如下字段 props children slots scopedSlots data parent listeners injections","pubDate":"Thu, 07 Jul 2022 07:56:07 GMT","guid":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","category":"vue"},{"title":"好用的浏览器页面测试页面性能工具","link":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","description":"pagespeed地址： https://pagespeed.web.dev/ gtmetrix地址： https://gtmetrix.com/ web.dev地址： https://web.dev/measure/","pubDate":"Thu, 07 Jul 2022 03:29:14 GMT","guid":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","category":"performance"}]}