{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxxstar987.gitee.io/lxx1997.github.io","pubDate":"Tue, 14 Sep 2021 14:31:56 GMT","lastBuildDate":"Sat, 26 Mar 2022 13:30:32 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"服务端 渲染 - nextjs","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/09/14/ssr-nextjs-01/","description":"初始化项目123npx create-next-app# oryarn create next-app 如果想要添加特殊配置有以下选择 --ts，--typescript 使用TypeScript -e，--example [name][github-url]使用样例 --example-path --use-npm 应用页面路由 Routernextjs 路由匹配规则 /pages/example.js | /pages/example/index.js 匹配路由 /example /pages/example/[id].js 匹配路由 /example/1 /pages/example/[...args].js 匹配路由 /example/1/2.../n /pages/example/[[...args]].js 匹配路由 /example/.../n 12345678// /example/[id].js// 路由为 /example/1import &#123; useRouter &#125; from &quot;next/dist/client/router&quot;;const Index = (): JSX.Element =&gt; &#123; const router = useRouter() const query = router.query // &#123;id: 1&#125;&#125;","pubDate":"Tue, 14 Sep 2021 14:31:56 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/09/14/ssr-nextjs-01/","category":"JavaScript,SSR,nextJs,React"},{"title":"threeJs 学习之路 - API 及 参数传递","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/08/15/threeJs-study-api/","description":"THREE.Scene() 创建场景对象方法 add 添加物体，会被添加到坐标为 (0, 0, 0)的位置上 THREE.PerspectiveCamera() 这个对象是 threeJs 中相机的其中一种 透视摄像机参数有四个 视野角度 表示在显示器上看到的场景的范围，值是一个角度（值会 mod 360） 长宽比 长宽比的值会影响我们渲染物体的是否是正常的还是拉伸的，压扁的 远剪切面 近剪切面 物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中，根据我们渲染的物体的z轴的值和摄像机的z轴位置来决定的 THREE.WebGLRenderer() 创建一个渲染器实例属性 domElement 渲染器生成的dom元素，通过 appendChild 方法插入到页面中 setSize(width, height, updateStyle) 第二个参数决定是否以较低的分辨率来渲染 render(scene, camera) 渲染场景和摄像机","pubDate":"Sun, 15 Aug 2021 01:53:24 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/08/15/threeJs-study-api/","category":""},{"title":"threeJs 学习之路 - 创建画布及绘制图形","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/08/15/threeJs-study-01/","description":"因为threeJs 版本在不断更新，所以本文可能部分 api 被替换，如果出现问题，请百度或者查找官方文档对应api 初始化引入引入的话可以采用 npm 引入 或者直接通过 CDN 方式引入 npm 引入 123456npm install three// 引入const THREE = require(&quot;three&quot;)import THREE from &quot;three&quot; CDN 方式引入 CDN地址 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js&quot;&gt;&lt;/script&gt; 创建画布 12345678910// 创建场景const scene = new THREE.Scene()// 创建一个摄像机const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000)// 实例化渲染器const renderer = new THREE.WebGLRenderer()// 设置渲染大小renderer.setSize(window.innerWidth, window.innerHeight)renderer.render(scene, camera)document.body.appendChild(renderer.domElement) 编写完上述代码后应该会出现一个黑色区域，这个就是threeJs创建的 canvas 画布 绘制元素绘制一个正方体 创建一个立方体 需要一个 BoxGeometry 对象，这个对象包含了立方体所有的定点(vertices)和面(faces) 然后对于这个立方体给一个材质，这里我们采用 MeshBasicMaterial 方法，并设置一个默认颜色 接下来需要一个网格（Mesh），这个网格包含了 几何体及其材质的对象，然后通过 Scene 中的 add 方法添加到页面上，如果与摄像机重叠，还需要移动摄像机的位置 最后通过 WebGLRenderer 的 render 方法渲染 如果想要动起来，这个时候需要我们更改摄像机或者立方体的位置,并通过定时器函数，重新渲染 123456789101112131415161718var geometry = new THREE.BoxGeometry()var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;)let cube = new THREE.Mesh(geometry, material)camera.position.z = 5// scene 为之前创建的 THREE.Scene() 实例scene.add(cube)// renderer.render(scene, camera)function render() &#123; requestAnimationFrame(render) // 立方体旋转 旋转速度 cube.rotation.x += 0.1 cube.rotation.y += 0.1 // 修改摄像机的位置 // camera.position.set(x, y, z) renderer.render(scene, camera)&#125;render() 绘制线条 对于绘制线条 我们可以选择的材质只有 LineBasicMaterial 和 LineDashedMaterial 定义好材质之后，我们需要一个带有定点的 Geometry 或者 BufferGeometry 然后通过 THREE.Vector3(x, y, z) 定义线条的顶点，线条是画在连续的顶点之间的 最后 通过 THREE.Line(geometry, material) 将材质和顶点联系起来 ~~~js // LineDashedMaterial 创建 虚线性的 线条 // LineBasicMaterial 创建 实线线条 const material = new THREE.LineDashedMaterial({color: 0x0000ff}) const points = [] // 创建 3d 线条的各个顶点 points.push(new THREE.Vector3(-10, 0, 20)) points.push(new THREE.Vector3(0, 10, 20)) points.push(new THREE.Vector3(10, 0, 20)) // 通过 setFromPoints 设置线条的顶点 const geometry = new THREE.BufferGeometry().setFromPoints(points) // 创建线条治理 const line = new THREE.Line(geometry, material) ~~·","pubDate":"Sun, 15 Aug 2021 01:38:18 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/08/15/threeJs-study-01/","category":"JavaScript,threeJs,webgl"},{"title":"JavaScript 设计模式联系  -  创建型设计模式","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/06/14/design-parttern-01/","description":"简单工厂模式 简单工厂模式(Simple Factory) 又叫静态工厂模式，由一个工厂对象决定创建摸一种产品对象类的实例 简单工厂模式的理念就是创建对象，提取多个类似需求中相同部分，针对不同的地方进行特殊处理 1234567891011121314151617181920function factory(object) &#123; const Factory = new Object() // 相同的部分 Factory.name = object.name Factory.age = object.name // 不同的部分 switch(object.type) &#123; case &#x27;type1&#x27;: // 特殊处理 break; case &#x27;type2&#x27;: // 特殊处理 break; default: break; &#125; return Factory&#125; 工厂方法模式 工厂方法模式(Factory Methods) 通过对产品类的抽象使其创建业务，主要负责用于创建多累产品的实例 工厂方法模式的本意是将时间创建对象工作推迟到了子类当中，这样核心类就成为了抽象类，在使用工厂方法模式时，需要使用安全策略来防止我们每次获取到的不是想要的对象 安全策略1234567function Factory() &#123; if(this instanceof Factory) &#123; return this &#125; else &#123; return new Factory() &#125;&#125; 通过以上代码在实例化对象的时候判断一下是否是创建对象实例，如果不是则返回一个新的实例，以便能获取到预期的对象 工厂方式模式代码1234567891011121314151617function Factory(type, content) &#123; if(this instanceof Factory) &#123; return this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype.Car = &#123;&#125;Factory.prototype.Pat = &#123; &#125;Factory.prototype.Clothes = &#123; &#125; 抽象工厂模式 抽象工厂模式(Abstract Factory) 通过对类的工厂抽象使其业务用于产品类簇的创建，而不是创建某一类产品的实例 抽象类工厂其实是实现子类继承父类的方法，我们需要通过传递子类以及要继承父类的名称，并且在抽象工厂方法中增加一次对抽象类存在性的判断，如果存在，子类继承父类的方法。子类继承了父类的所有的属性和方法，如果子类中没有方法或者属性覆盖父类方法，当调用的时候，会直接返回父类的属性和方法。 抽象类工厂的主要作用是，当子类调用了自己本身不存在且不需要的方法是，会给予提示 12345678910111213141516171819202122232425262728293031323334353637function Abstract(child, parent) &#123; if(typeof Abstract[parent] === &#x27;function&#x27;) &#123; // 定义一个空的父类 function F() &#123;&#125; F.prototype = new Abstract[parent]() child.constructor = child child.prototype = new F() &#125; else &#123; throw new Error(&#x27;未找到改抽象类&#x27;) &#125;&#125;Abstract.Car = function() &#123; this.type = &#x27;car&#x27;&#125;Abstract.Car.prototype = &#123; getName: function () &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;, getPrice: function() &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;&#125;function Aodis() &#123; this.name = &#x27;aodi&#x27; this.price = 12312&#125;Abstract(Aodis, &#x27;Car&#x27;)console.log(Aodis)Aodis.prototype.getName = function() &#123; console.log(this.name)&#125;const aodi = new Aodis()aodi.getName()aodi.getPrice() 抽象类 抽象类是一种声明了但是无法使用的类，当你调用抽象类的方法时就会报错，我们可以手动在类型的方法中进行错误提示 123456789function Abstract() &#123;&#125;Abstract.prototype = &#123; getName() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;, getPrice() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;&#125; 当我们通过继承或者直接使用的方式来调用抽象类中方法时，会直接抛出错误","pubDate":"Mon, 14 Jun 2021 10:25:20 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/06/14/design-parttern-01/","category":"JavaScript"},{"title":"window.postMessage跨域的使用方式","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/05/04/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","description":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","pubDate":"Tue, 04 May 2021 15:23:18 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/05/04/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","category":"JavaScript"},{"title":"记一次在面试过程中遇到的 promise 编程题","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/04/01/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","description":"当时面试的时候遇到了这两个函数编程题，但是该死的是完全没有思路(悲伤) 利用 Promise 完成一个队列，队列中的任务数满了的话，后续任务不执行，当队列中的任务有完成的状态，才会添加新的任务进入队列 利用 Promise 完成一个 retry 函数，传入一个执行函数和一个计数器，在一定次数范围内，如果函数执行失败的话会再次尝试执行该函数，直到执行成功 面试结束之后，我上网上搜索了一下类似的问题，接下来是我总结之后的思路，以及最后成功的代码 Promise 队列 这个问题有以下几个重点 队列： 存放未执行的任务队列 计数器： 存放当前正在执行的任务数量 任务执行最大数量 添加任务函数 执行任务函数 接下根据我们上述描述的重点来创建一个任务队列执行类 1234567891011121314class Scheduler &#123; // 初始化任务队列，以及根据传入的数量来限制最大执行数量 constructor(maxCount) &#123; this.maxCount = count this.list = [] this.count = 0 &#125; add() &#123; &#125; start() &#123; &#125;&#125; 接下我们就要来编写添加函数了，在写添加函数之前我们首先思考一下这个添加函数里面应该注意那些东西 首先，如果我们想要在任务执行完成之后对执行结果操作的话，这个 add 函数必须返回一个 promise 函数 12345add(task) &#123; return new Promise(resolve =&gt; &#123; resolve() &#125;)&#125; 添加一个任务的时候，我们需要把这个任务添加到未执行的任务队列的存放起来 1234567add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(task()) &#125;) &#125;)&#125; 这个时候就出现了一个问题，我们应该怎样监控这个任务是否已经执行完成，这个时候 promise 的作用就来了，我们在 then 中就可以判断到函数是否执行成功 123456789add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(Promise.resolve(task()).then()) // 如果 task 执行之后的返回值是一个promise对象则可以修改成以下形式 // this.list.push(task().then()) &#125;) &#125;)&#125; 添加函数先写到这里，然后我们来写执行函数，在start函数中我们需要做的就是判断一下正在执行任务数是否小于最大执行数，然后从待执行队列中取出一个任务并执行，然后将正在执行的任务数加上1 123456start() &#123; if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list.shift()() &#125;&#125; 接下来修改 add 函数 为当我们添加一个任务时，在最后执行一下执行函数，在执行任务完成之后，减少执行队列数，并触发执行函数，最后把任务的返回值 return 出来 123456789101112add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;)&#125; 接下来实例化任务队列，并创建一个异步执行方法和一个添加任务函数 123456789101112let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Scheduler &#123; constructor(count) &#123; this.list = [] this.maxCount = count this.count = 0 &#125; add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;) &#125; start() &#123; console.log(this.count) if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list[0]() this.list.shift() &#125; &#125;&#125;let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125;addTask(5000,&#x27;1&#x27;)addTask(1100,&#x27;2&#x27;)addTask(2200,&#x27;3&#x27;)addTask(3300,&#x27;4&#x27;)addTask(3300,&#x27;5&#x27;)addTask(3300,&#x27;6&#x27;)addTask(3300,&#x27;7&#x27;)addTask(2200,&#x27;8&#x27;) Promise retry 函数 function retry(fun, count) { if(count === 0) return let val = fun() if(val &gt; 3) { return val } else { return retry(fun, –count) }} function random() { return Math.random() * 5}console.log(retry(random, 5)) 这个问题现在看起来挺简单的，但是当时估计相差了，思路都理解错了，难受","pubDate":"Thu, 01 Apr 2021 08:25:13 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/04/01/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","category":"promise,面试"},{"title":"JavaScript - 手写一个 Promise 方法","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/03/18/js-promise/","description":"ES6新增了一个用于处理异步操作数据的一个原生API，能够解决回调地狱的产生 常用的方法 Promise.resolve() Promise.reject() Promise.then() Promise.catch() Promise.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() 接下来我们来使用代码来实现这些操作 实现Promise 首先我们在创建 Promise 实例，会传入两个函数用来表示成功的回调以及失败的回调，然后我们可以设计 Promise 类中的内容大概是这个样子的 12345678910111213141516171819202122232425262728293031const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125;,4) &#125; reject(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;) &#125;&#125; 这样就实现了一个简单的Promise方法，并且更改状态之后就不可以在修改状态了,并且用两个变量来接收resolve和reject两个方法传入的值 Promise.then 1234567891011121314151617181920Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; 调用 then 方法时判断一下传入的是否是函数，如果是函数就直接调用，并把成功的参数传入最后的 return this 则是为了实现链式结构 Promise.catch 12345678910111213141516171819Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; Promise.finally 1234Promise.prototype.finally = function(fn) &#123; fn() return this&#125; Promise.resolve 1234Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125; 这个稍微有些麻烦，我们需要判断传入的 value 是不是 Promise 类型的，如果是就可以直接返回，然后调用 .then 等方法，否则就需要我们创建一个 Promise 实例并返回 Promise.reject 1234Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125; 但是这里还有许多需要注意的地方，例如Promise.then中如果有 return 的话则需要以返回的状态和值为主，如果没有,就以上一次的状态和值为主同时还需要对代码使用 try...catch... 进行容错处理，使得在 catch 中能够拿到错误信息 代码修改如下12345678910111213141516171819Promise.prototype.then = function(resolve, reject) &#123; try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125;&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125; 实现Promise高级语法 Promise.all 12345678910111213141516171819202122232425262728Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; // 保证数组顺序返回正确 resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; Promise.race 1234567891011121314151617181920212223242526272829Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) break; &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; promise.allSettled 123456789101112131415161718192021222324252627282930313233343536373839404142Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; 这些代码中还是有很多的bug 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125; reject(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;&#125;Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125;Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125;Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.finally = function(fn) &#123; fn() return this&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125;","pubDate":"Thu, 18 Mar 2021 05:15:52 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/03/18/js-promise/","category":"JavaScript"},{"title":"浅浅的剖析一下 Vue 的执行顺序","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/08/vue-learn-api-with-%E6%BA%90%E7%A0%81-implement/","description":"定义 Vue 构造函数1234567891011121314151617181920212223import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue) lifecycleMixin(Vue)renderMixin(Vue)export default Vue 定义了 一个 Vue 构造函数，这个构造函数传入的参数是 options，使用的时候通过 new 关键字来创建实例，然后调用了 _init 方法 根据传入的 options 配置来初始化 Vue 实例 初始化 initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344var uid$3 = 0;Vue.prototype._init = function (options) &#123; var vm = this; vm._uid = uid$3++; var startTag, endTag; // 是否记录 性能 if (config.performance &amp;&amp; mark) &#123; startTag = &quot;vue-perf-start:&quot; + (vm._uid); endTag = &quot;vue-perf-end:&quot; + (vm._uid); mark(startTag); &#125; vm._isVue = true; if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; &#123; initProxy(vm); &#125; vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); if (config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false); mark(endTag); measure((&quot;vue &quot; + (vm._name) + &quot; init&quot;), startTag, endTag); &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 通过上述代码，我们可以看到 Vue 在初始化的时候主要做了以下几件事 创建 Vue 实例 唯一标识符 _uid 根据 config 配置判断是否开启 性能监控 performance 设置 Vue 标识符 _isVue 为 true 代表当前实例是 Vue 实例 通过 option 的 _isComponents 属性判断当前 Vue 实例是否是组件，如果是组件就调用 initInternalComponent 函数，不是组件就调用 mergeOptions 方法，并将返回的参数赋予 Vue 实例的 $options 属性 调用 initProxy 方法，判断 proxy 代理是否存在，如果存在，使用 proxy 对 Vue 实例进行响应式监控和代理 设置 Vue 的 _self 属性 为自身实例 调用 initLifecycle 函数 初始化生命周期 调用 initEvents 方法 初始化事件对象 调用 initRender 方法 初始化渲染使用的方法 slot, scopedSlots, createElement, _c方法，并对 $attrs,$listeners 方法进行进行数据响应式处理 调用 beforeCreate 生命周期，由于此时 还没有任何数据或者方法挂载到 Vue 实例上，所以 无法访问 调用 initInjections 方法 初始化 inject 属性 调用 initState 方法 初始化 data,props,methods,computed,watch 属性，设置数据响应式处理，及将属性挂载到 Vue 实例上 调用 initProvide 方法 初始化 provide 属性 调用 created 生命周期，此时可以访问到 inject,data,props,methods,computed上属性的值 调用 $mount 方法 获取 元素节点 el 判断是否传入 render 函数，没有就初始化一个空 DOM 节点 调用 beforeMount 生命周期 设置 组件变化的监听方法，监听组件是否更新 设置 Vue 实例挂载状态为 true 调用 mounted 生命周期 stateMixin该函数主要针对 实例 $data, $props 进行数据响应式处理，不允许更新并且初始化实例 $set, $delete, $watch(并返回一个 撤销监听的方法) eventMixin初始化事件方法 $once, $on, $off, $emit lifecycleMixin初始化 _update, forceUpdate, destory 当组件发生更新操作或者卸载的时候会触发这些生命周期beforeUpdate, updated, beforeDestory, destoryed renderMixin在这个函数中 首先通过 installRenderHelpers 方法在 Vue 实例上注册了 协助渲染的函数 12345678910111213141516171819function installRenderHelpers (target) &#123; target._o = markOnce; // 定义静态节点 只渲染一次, v-once 指令 target._n = toNumber; // 转化为整型 target._s = toString; // 字符串转化 target._l = renderList; // 渲染 v-for 循环 target._t = renderSlot; // 渲染 slot target._q = looseEqual; // 判断 对象是否相等 target._i = looseIndexOf; // 获取 元素 在 数组中的位置 target._m = renderStatic; // 定义静态节点 只渲染一次, v-once 指令 target._f = resolveFilter; // 调用 filter 方法 target._k = checkKeyCodes; // 检查键盘事件 target._b = bindObjectProps; // 读取 元素的 attr 属性绑定到 props 上面 target._v = createTextVNode; // 创建 文本node 节点 target._e = createEmptyVNode; // 创建空节点 target._u = resolveScopedSlots; // 渲染 ScopedSlot target._g = bindObjectListeners; // 绑定事件函数到 on 方法上去 target._d = bindDynamicKeys; // 渲染传入 变量 的 attrs 属性 target._p = prependModifier; // 设置前置修饰符&#125; 然后初始化 $nextTick _render 解析 dom 元素并渲染(patch)Vue 再渲染 DOM 的时候即 mountComponent 方法中 会调用 _update 方法，并将 Vue 的 _render 函数的返回值 (一个 VNode 对象) 作为参数传入,第二个参数 hydrating 为 undefined 然后在 _update 方法中 通过 __patch__ 即 patch/createPatchFunction 方法渲染页面 我们来看一下 patch 方法做了哪些东西 12// vm.$el, vnodevar patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;) 首先创造了 几个生命周期1var hooks = [&#x27;create&#x27;, &#x27;activate&#x27;, &#x27;update&#x27;, &#x27;remove&#x27;, &#x27;destroy&#x27;];","pubDate":"Mon, 08 Feb 2021 03:02:00 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/08/vue-learn-api-with-%E6%BA%90%E7%A0%81-implement/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (八) - 指令","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/01/vue-learn-api-with-%E6%BA%90%E7%A0%81-08/","description":"内置指令Vue 内置了以下几种指令 v-text v-html v-show v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre v-cloak v-once 在源码中分为以下几种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// v-html v-text v-modelvar directives$1 = &#123; model: model, text: text, html: html&#125;// v-on v-bind v-clockvar baseDirectives = &#123; on: on, bind: bind$1, cloak: noop&#125;;// v-if v-else v-else-iffunction processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// v-prefunction processPre (el) &#123; if (getAndRemoveAttr(el, &#x27;v-pre&#x27;) != null) &#123; el.pre = true; &#125;&#125;// v-for v-slotfunction processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// v-slotvar slotBinding = getAndRemoveAttrByRegex(el, slotRE);// v-oncefunction processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-showif (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) &#123; child.data.show = true;&#125; v-text / v-html123456789101112131415161718192021222324252627282930313233343536373839// dir 为 directive 中的 binding 属性/** arg: null end: 18 isDynamicArg: false modifiers: undefined name: &quot;text&quot; rawName: &quot;v-text&quot; start: 5 value: &quot;text&quot;*/function text (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;textContent&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;function html (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;innerHTML&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;// addProp (当前元素实例, &#x27;textContent&#x27;, &#x27;_s(dir.value)&#x27;, dir, null)function addProp (el, name, value, range, dynamic) &#123; (el.props || (el.props = [])).push(rangeSetItem(&#123; name: name, value: value, dynamic: dynamic &#125;, range)); el.plain = false;&#125;// rangeSetItemfunction rangeSetItem (item, range) &#123; if (range) &#123; if (range.start != null) &#123; item.start = range.start; &#125; if (range.end != null) &#123; item.end = range.end; &#125; &#125; return item&#125; v-text 指令在 processAttrs 函数中 通过 addDirective 方法 添加一个 directive 属性，然后 通过 updateDOMProps 方法中的 elm[key] = cur 为 元素的 textContent 或者 innerHTML 属性赋值 12&lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;&lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt; 注意：如果 v-text/v-html 指令所在的元素下的子元素，则不会被渲染 v-model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function model (el, dir, _warn) &#123; warn$1 = _warn; var value = dir.value; var modifiers = dir.modifiers; var tag = el.tag; var type = el.attrsMap.type; &#123; // inputs with type=&quot;file&quot; are read only and setting the input&#x27;s // value will throw an error. if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;file&#x27;) &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot; type=\\&quot;file\\&quot;&gt;:\\n&quot; + &quot;File inputs are read only. Use a v-on:change listener instead.&quot;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; &#125; if (el.component) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else if (tag === &#x27;select&#x27;) &#123; genSelect(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;checkbox&#x27;) &#123; genCheckboxModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;radio&#x27;) &#123; genRadioModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; || tag === &#x27;textarea&#x27;) &#123; genDefaultModel(el, value, modifiers); &#125; else if (!config.isReservedTag(tag)) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot;&gt;: &quot; + &quot;v-model is not supported on this element type. &quot; + &#x27;If you are working with contenteditable, it\\&#x27;s recommended to &#x27; + &#x27;wrap a library dedicated for that purpose inside a custom component.&#x27;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; // ensure runtime directive metadata return true&#125; v-model 指令主要针对于 input 输入框 及textarea 等需要输入或者状态变更的元素，v-model 相当于 v-bind:value + v-on:change 的组合体，在其他组件上不能使用 v-model v-show123456789101112131415161718192021222324// ref// def: &#123;bind: ƒ, update: ƒ, unbind: ƒ&#125;// expression: &quot;true&quot;// modifiers: &#123;&#125;// name: &quot;show&quot;// rawName: &quot;v-show&quot;// value: truebind: function bind (el, ref, vnode) &#123; var value = ref.value; vnode = locateNode(vnode); var transition$$1 = vnode.data &amp;&amp; vnode.data.transition; var originalDisplay = el.__vOriginalDisplay = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display; console.log(ref,value, transition$$1) if (value &amp;&amp; transition$$1) &#123; vnode.data.show = true; enter(vnode, function () &#123; el.style.display = originalDisplay; &#125;); &#125; else &#123; el.style.display = value ? originalDisplay : &#x27;none&#x27;; &#125;&#125;, 取 ref.value 如果 v-show=&quot;false&quot; 则 ref.value 为 false 将 元素的display 属性设置为 null v-if/v-else/v-else-if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 判断当前元素是否有 v-if，v-else， v-else-if 指令// 并将元素上的if,else,elseif 属性置为对应状态function processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// 通过 addIfCondition 方法将 v-if 所在的元素放入 ifConditions 数组中function addIfCondition (el, condition) &#123; if (!el.ifConditions) &#123; el.ifConditions = []; &#125; el.ifConditions.push(condition);&#125;// markStatic$1if (node.ifConditions) &#123; for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 &lt; l$1; i$1++) &#123; var block = node.ifConditions[i$1].block; markStatic$1(block); if (!block.static) &#123; node.static = false; &#125; &#125;&#125;// genIfConditions 转换 IfConditions 中的元素function genIfConditions ( conditions, state, altGen, altEmpty) &#123; if (!conditions.length) &#123; return altEmpty || &#x27;_e()&#x27; &#125; var condition = conditions.shift(); if (condition.exp) &#123; return (&quot;(&quot; + (condition.exp) + &quot;)?&quot; + (genTernaryExp(condition.block)) + &quot;:&quot; + (genIfConditions(conditions, state, altGen, altEmpty))) &#125; else &#123; return (&quot;&quot; + (genTernaryExp(condition.block))) &#125; // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) &#123; return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) &#125;&#125; v-for 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 判断是否含有 v-for 指令 然后通过 extend 方法将 parseFor 转出的参数扩展到 元素上function processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// 判断 for 循环function parseFor (exp) &#123; // 正则表达式匹配，循环数组是否正确 [exp, item, 10] var inMatch = exp.match(forAliasRE); if (!inMatch) &#123; return &#125; var res = &#123;&#125;; res.for = inMatch[2].trim(); // 针对 v-for=&quot;(item,index) in array&quot; 进行处理 去除 item / item,index var alias = inMatch[1].trim().replace(stripParensRE, &#x27;&#x27;); // 针对(item,index) in array 去除 , index var iteratorMatch = alias.match(forIteratorRE); if (iteratorMatch) &#123; res.alias = alias.replace(forIteratorRE, &#x27;&#x27;).trim(); res.iterator1 = iteratorMatch[1].trim(); if (iteratorMatch[2]) &#123; res.iterator2 = iteratorMatch[2].trim(); &#125; &#125; else &#123; res.alias = alias; &#125; // alias 对象别名 可以通过 alias 访问遍历数组的元素 // iterator1 遍历时第二个参数 return res&#125;// genFor 获取与 v-for 指令相关参数，调用 renderList 方法渲染数组function genFor ( el, state, altGen, altHelper) &#123; var exp = el.for; var alias = el.alias; var iterator1 = el.iterator1 ? (&quot;,&quot; + (el.iterator1)) : &#x27;&#x27;; var iterator2 = el.iterator2 ? (&quot;,&quot; + (el.iterator2)) : &#x27;&#x27;; if (state.maybeComponent(el) &amp;&amp; el.tag !== &#x27;slot&#x27; &amp;&amp; el.tag !== &#x27;template&#x27; &amp;&amp; !el.key ) &#123; state.warn( &quot;&lt;&quot; + (el.tag) + &quot; v-for=\\&quot;&quot; + alias + &quot; in &quot; + exp + &quot;\\&quot;&gt;: component lists rendered with &quot; + &quot;v-for should have explicit keys. &quot; + &quot;See https://vuejs.org/guide/list.html#key for more info.&quot;, el.rawAttrsMap[&#x27;v-for&#x27;], true /* tip */ ); &#125; el.forProcessed = true; // avoid recursion // 调用 renderList 方法 传入渲染函数 return (altHelper || &#x27;_l&#x27;) + &quot;((&quot; + exp + &quot;),&quot; + &quot;function(&quot; + alias + iterator1 + iterator2 + &quot;)&#123;&quot; + &quot;return &quot; + ((altGen || genElement)(el, state)) + &#x27;&#125;)&#x27;&#125;// rederListfunction renderList ( val, render) &#123; var ret, i, l, keys, key; if (Array.isArray(val) || typeof val === &#x27;string&#x27;) &#123; ret = new Array(val.length); for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i); &#125; &#125; else if (typeof val === &#x27;number&#x27;) &#123; ret = new Array(val); for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i); &#125; &#125; else if (isObject(val)) &#123; if (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123; ret = []; // 利用 Symbol.iterator 方法 循环 对象val var iterator = val[Symbol.iterator](); var result = iterator.next(); while (!result.done) &#123; ret.push(render(result.value, ret.length)); result = iterator.next(); &#125; &#125; else &#123; keys = Object.keys(val); ret = new Array(keys.length); for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i]; ret[i] = render(val[key], key, i); &#125; &#125; &#125; if (!isDef(ret)) &#123; ret = []; &#125; (ret)._isVList = true; return ret&#125; v-on 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980name = name.replace(onRE, &#x27;&#x27;);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);// addHandlerfunction addHandler (el,name,value,modifiers,important,warn,range,dynamic) &#123; modifiers = modifiers || emptyObject; // warn prevent and passive modifier /* istanbul ignore if */ if ( warn &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( &#x27;passive and prevent can\\&#x27;t be used together. &#x27; + &#x27;Passive handler can\\&#x27;t prevent default event.&#x27;, range ); &#125; // normalize click.right and click.middle since they don&#x27;t actually fire // this is technically browser-specific, but at least for now browsers are // the only target envs that have right/middle clicks. if (modifiers.right) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;contextmenu&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;contextmenu&#x27;; delete modifiers.right; &#125; &#125; else if (modifiers.middle) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;mouseup&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;mouseup&#x27;; &#125; &#125; // check capture modifier if (modifiers.capture) &#123; delete modifiers.capture; name = prependModifierMarker(&#x27;!&#x27;, name, dynamic); &#125; if (modifiers.once) &#123; delete modifiers.once; name = prependModifierMarker(&#x27;~&#x27;, name, dynamic); &#125; /* istanbul ignore if */ if (modifiers.passive) &#123; delete modifiers.passive; name = prependModifierMarker(&#x27;&amp;&#x27;, name, dynamic); &#125; var events; if (modifiers.native) &#123; delete modifiers.native; events = el.nativeEvents || (el.nativeEvents = &#123;&#125;); &#125; else &#123; events = el.events || (el.events = &#123;&#125;); &#125; var newHandler = rangeSetItem(&#123; value: value.trim(), dynamic: dynamic &#125;, range); if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers; &#125; var handlers = events[name]; /* istanbul ignore if */ if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler); &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler]; &#125; else &#123; events[name] = newHandler; &#125; el.plain = false;&#125; 修饰器 .stop 阻止默认事件 event.stopPropagation() .prevent 阻止默认事件 event.preventDefault() .capture 添加事件监听器使用 capture 模式 .self 只当事件从侦听器绑定的元素本身触发时才触发回调 .&#123;keyCode | keyAlias&#125; 只有特定键触发才会触发回调函数 .native 监听根元素的原生时间 .once 只触发一次回调 .left 点击鼠标左键触发 .right 点击鼠标右键触发 .middle 点击鼠标中键触发 .passive 以 &#123;passive: true&#125; 模式添加侦听器 v-bind 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name = name.replace(bindRE, &#x27;&#x27;);value = parseFilters(value);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;if ( value.trim().length === 0) &#123; warn$2( (&quot;The value for a v-bind expression cannot be empty. Found in \\&quot;v-bind:&quot; + name + &quot;\\&quot;&quot;) );&#125;if (modifiers) &#123; if (modifiers.prop &amp;&amp; !isDynamic) &#123; name = camelize(name); if (name === &#x27;innerHtml&#x27;) &#123; name = &#x27;innerHTML&#x27;; &#125; &#125; if (modifiers.camel &amp;&amp; !isDynamic) &#123; name = camelize(name); &#125; if (modifiers.sync) &#123; syncGen = genAssignmentCode(value, &quot;$event&quot;); if (!isDynamic) &#123; addHandler( el, (&quot;update:&quot; + (camelize(name))), syncGen, null, false, warn$2, list[i] ); if (hyphenate(name) !== camelize(name)) &#123; addHandler( el, (&quot;update:&quot; + (hyphenate(name))), syncGen, null, false, warn$2, list[i] ); &#125; &#125; else &#123; // handler w/ dynamic event name addHandler( el, (&quot;\\&quot;update:\\&quot;+(&quot; + name + &quot;)&quot;), syncGen, null, false, warn$2, list[i], true // dynamic ); &#125; &#125;&#125;if ((modifiers &amp;&amp; modifiers.prop) || ( !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name))) &#123; addProp(el, name, value, list[i], isDynamic);&#125; else &#123; addAttr(el, name, value, list[i], isDynamic);&#125; 修饰符 .prop 作为 DOM 的property绑定，而不是作为 attribute 绑定 。camel 将事件名转化为驼峰模式 .sync 会扩展一个更新父组件绑定值的 v-on 监听器 v-slot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118function processSlotContent (el) &#123; var slotScope; if (el.tag === &#x27;template&#x27;) &#123; slotScope = getAndRemoveAttr(el, &#x27;scope&#x27;); /* istanbul ignore if */ if (slotScope) &#123; warn$2( &quot;the \\&quot;scope\\&quot; attribute for scoped slots have been deprecated and &quot; + &quot;replaced by \\&quot;slot-scope\\&quot; since 2.5. The new \\&quot;slot-scope\\&quot; attribute &quot; + &quot;can also be used on plain elements in addition to &lt;template&gt; to &quot; + &quot;denote scoped slots.&quot;, el.rawAttrsMap[&#x27;scope&#x27;], true ); &#125; el.slotScope = slotScope || getAndRemoveAttr(el, &#x27;slot-scope&#x27;); &#125; else if ((slotScope = getAndRemoveAttr(el, &#x27;slot-scope&#x27;))) &#123; /* istanbul ignore if */ if (el.attrsMap[&#x27;v-for&#x27;]) &#123; warn$2( &quot;Ambiguous combined usage of slot-scope and v-for on &lt;&quot; + (el.tag) + &quot;&gt; &quot; + &quot;(v-for takes higher priority). Use a wrapper &lt;template&gt; for the &quot; + &quot;scoped slot to make it clearer.&quot;, el.rawAttrsMap[&#x27;slot-scope&#x27;], true ); &#125; el.slotScope = slotScope; &#125; // slot=&quot;xxx&quot; var slotTarget = getBindingAttr(el, &#x27;slot&#x27;); if (slotTarget) &#123; el.slotTarget = slotTarget === &#x27;&quot;&quot;&#x27; ? &#x27;&quot;default&quot;&#x27; : slotTarget; el.slotTargetDynamic = !!(el.attrsMap[&#x27;:slot&#x27;] || el.attrsMap[&#x27;v-bind:slot&#x27;]); // preserve slot as an attribute for native shadow DOM compat // only for non-scoped slots. if (el.tag !== &#x27;template&#x27; &amp;&amp; !el.slotScope) &#123; addAttr(el, &#x27;slot&#x27;, slotTarget, getRawBindingAttr(el, &#x27;slot&#x27;)); &#125; &#125; // 2.6 v-slot syntax &#123; if (el.tag === &#x27;template&#x27;) &#123; // v-slot on &lt;template&gt; var slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) &#123; &#123; if (el.slotTarget || el.slotScope) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.parent &amp;&amp; !maybeComponent(el.parent)) &#123; warn$2( &quot;&lt;template v-slot&gt; can only appear at the root level inside &quot; + &quot;the receiving component&quot;, el ); &#125; &#125; var ref = getSlotName(slotBinding); var name = ref.name; var dynamic = ref.dynamic; el.slotTarget = name; el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf &#125; &#125; else &#123; // v-slot on component, denotes default slot var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding$1) &#123; &#123; if (!maybeComponent(el)) &#123; warn$2( &quot;v-slot can only be used on components or &lt;template&gt;.&quot;, slotBinding$1 ); &#125; if (el.slotScope || el.slotTarget) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.scopedSlots) &#123; warn$2( &quot;To avoid scope ambiguity, the default slot should also use &quot; + &quot;&lt;template&gt; syntax when there are other named slots.&quot;, slotBinding$1 ); &#125; &#125; // add the component&#x27;s children to its default slot var slots = el.scopedSlots || (el.scopedSlots = &#123;&#125;); var ref$1 = getSlotName(slotBinding$1); var name$1 = ref$1.name; var dynamic$1 = ref$1.dynamic; var slotContainer = slots[name$1] = createASTElement(&#x27;template&#x27;, [], el); slotContainer.slotTarget = name$1; slotContainer.slotTargetDynamic = dynamic$1; slotContainer.children = el.children.filter(function (c) &#123; if (!c.slotScope) &#123; c.parent = slotContainer; return true &#125; &#125;); slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now el.children = []; // mark el non-plain so data gets generated el.plain = false; &#125; &#125; &#125;&#125; v-pre 跳过这个元素和子元素的编译过程，显示原始的标签 v-cloak 无表达式，绑定一个空函数，隐藏未编译的 标签直到实例准备完成 v-once 123456789101112131415161718192021222324252627282930313233// 判断是否含有 v-once 指令function processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-oncefunction genOnce (el, state) &#123; el.onceProcessed = true; if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.staticInFor) &#123; var key = &#x27;&#x27;; var parent = el.parent; while (parent) &#123; if (parent.for) &#123; key = parent.key; break &#125; parent = parent.parent; &#125; if (!key) &#123; state.warn( &quot;v-once can only be used inside v-for that is keyed. &quot;, el.rawAttrsMap[&#x27;v-once&#x27;] ); return genElement(el, state) &#125; return (&quot;_o(&quot; + (genElement(el, state)) + &quot;,&quot; + (state.onceId++) + &quot;,&quot; + key + &quot;)&quot;) &#125; else &#123; return genStatic(el, state) &#125;","pubDate":"Mon, 01 Feb 2021 09:29:54 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/01/vue-learn-api-with-%E6%BA%90%E7%A0%81-08/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (七) - 实例 property","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/01/vue-learn-api-with-%E6%BA%90%E7%A0%81-07/","description":"$on $emit监听 Vue.$emit 发送的事件，回调函数会接收所有传入参数的参数 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// $on 监听事件Vue.prototype.$on = function (event, fn) &#123; var vm = this; if (Array.isArray(event)) &#123; for (var i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn); &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true; &#125; &#125; return vm&#125;;// $emit 发送事件及参数Vue.prototype.$emit = function (event) &#123; var vm = this; &#123; var lowerCaseEvent = event.toLowerCase(); if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( &quot;Event \\&quot;&quot; + lowerCaseEvent + &quot;\\&quot; is emitted in component &quot; + (formatComponentName(vm)) + &quot; but the handler is registered for \\&quot;&quot; + event + &quot;\\&quot;. &quot; + &quot;Note that HTML attributes are case-insensitive and you cannot use &quot; + &quot;v-on to listen to camelCase events when using in-DOM templates. &quot; + &quot;You should probably use \\&quot;&quot; + (hyphenate(event)) + &quot;\\&quot; instead of \\&quot;&quot; + event + &quot;\\&quot;.&quot; ); &#125; &#125; var cbs = vm._events[event]; if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs; var args = toArray(arguments, 1); var info = &quot;event handler for \\&quot;&quot; + event + &quot;\\&quot;&quot;; for (var i = 0, l = cbs.length; i &lt; l; i++) &#123; // 调用 事件监听的回调函数 invokeWithErrorHandling(cbs[i], vm, args, vm, info); &#125; &#125; return vm&#125;;// invokeWithErrorHandlingfunction invokeWithErrorHandling ( handler, context, args, vm, info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 主要是用了 事件发布订阅模式 (vm._events[event] || (vm._events[event] = [])).push(fn) 通过这段代码 将 $on 监听的事件名称及方法 存储到 Vue 的私有属性 _event 中，当使用 $emit 发送事件的时候会在 _event 中找到对应的时间名，然后调用 res = args ? handler.apply(context, args) : handler.call(context) 调用 回调函数 使用1234567// 发送事件this.$emit(&#x27;sayHi&#x27;, &#x27;hi&#x27;)// 接收事件this.$on(&#x27;sayHi&#x27;, function(msg) &#123; console.log(&#x27;say &#x27; + msg) // say hi&#125;) $once 监听一个自定义时间，只触发一次，触发之后移除监听器 12345678910Vue.prototype.$once = function (event, fn) &#123; var vm = this; function on () &#123; vm.$off(event, on); fn.apply(vm, arguments); &#125; on.fn = fn; vm.$on(event, on); return vm&#125;; 在 $once 函数内部定义了一个回调函数，用于 触发事件之后调用 $off 方法销毁事件监听器$emit 触发 $once 监听事件 $off 移除事件监听器 1234567891011121314151617181920212223242526272829303132333435Vue.prototype.$off = function (event, fn) &#123; var vm = this; // all if (!arguments.length) &#123; vm._events = Object.create(null); return vm &#125; // array of events if (Array.isArray(event)) &#123; for (var i$1 = 0, l = event.length; i$1 &lt; l; i$1++) &#123; vm.$off(event[i$1], fn); &#125; return vm &#125; // specific event var cbs = vm._events[event]; if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null; return vm &#125; // specific handler var cb; var i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1); break &#125; &#125; return vm&#125;; 使用 $off 方法移除监听器的时候可以选择性的传两个参数 event, fn 如果不传参数 默认移除所有的监听器事件 如果只传了 event 事件，移除对应事件下所有的监听器事件 如果同时提供了 event 事件和 回调，移除对应事件下的这个回调的监听器 使用123this.$off() // 移除所有this.$off(&#x27;test&#x27;) // 移除 test 下的所有监视器函数this.$off(&#x27;test&#x27;, fn) // 移除 test 下的 fn 回调函数 fn 是一个变量，指向回调函数地址 $mount 传入 el 为 DOM 元素 源码参考地址 使用123new Vue(&#123; render: (h) =&gt; h()&#125;).$mount(&#x27;#app&#x27;) $forceUpdate强制更新页面，仅影响实例本身和插入插槽内容的子组件 123456Vue.prototype.$forceUpdate = function () &#123; var vm = this; if (vm._watcher) &#123; vm._watcher.update(); &#125;&#125;; 原理是调用 Watcher 的 update 方法更新 DOM 元素 $nextTick Vue.nextTick $destroy源码123456789101112131415161718192021222324252627282930313233343536373839404142Vue.prototype.$destroy = function () &#123; var vm = this; if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;); vm._isBeingDestroyed = true; // remove self from parent var parent = vm.$parent; if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm); &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown(); &#125; var i = vm._watchers.length; while (i--) &#123; vm._watchers[i].teardown(); &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount--; &#125; // call the last hook... vm._isDestroyed = true; // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null); // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;); // turn off all instance listeners. vm.$off(); // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null; &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null; &#125;&#125;; 在 $destroy 函数执行过程中，触发了 beforeDestroy 和 destroyed 生命周期函数 为防止多次调用，添加了是否正在销毁组件状态 同时移除所有的子组件，监听函数 销毁所有的事件监听函数，并置空 node 节点","pubDate":"Mon, 01 Feb 2021 07:25:46 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/02/01/vue-learn-api-with-%E6%BA%90%E7%A0%81-07/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (六) - 实例 property","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/29/vue-learn-api-with-%E6%BA%90%E7%A0%81-06/","description":"$data源码12dataDef.get = function () &#123; return this._data &#125;;Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $data 设置监听方法，访问 $data 属性的时候 直接返回 Vue 的 _data 数据 不推介使用 $data 来访问 Vue 中 data 中的数据，因为 Vue 在内部已经做了映射，直接把 data 中的属性 映射到 Vue 实例上 $props源码12propsDef.get = function () &#123; return this._props &#125;;Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $props 设置监听方法，访问 $props 属性的时候 直接返回 Vue 的 _props 数据 不推介使用 $props 来访问 Vue 中 props 中的数据，因为 Vue 在内部已经做了映射，直接把 props 中的属性 映射到 Vue 实例上 $el源码1234// $mount el = el &amp;&amp; inBrowser ? query(el) : undefined;// mountComponent vm.$el = el; 存储了 Vue 实例的根元素 $options源码12345678910111213141516171819202122// 初始化实例的时候传入 options 参数function Vue (options) &#123; if (!(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125;// _init 方法if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; 使用Vue 也支持我们自定义 property 特性，可以通过 optionMergeStrategies 配置自定义特性的合并规则 访问的时候通过 this.$options.property 来访问 $parnet 指向当前组件的 父实例，如果没有父组件实例，则为 null $children 指向组件的子组件 是一个数组 $root 指向 Vue 实例的根组件，如果没有父组件，即指向自身 123vm.$parent = parent;vm.$root = parent ? parent.$root : vm;vm.$children = []; $slots [name]: Array&lt;VNode&gt; 用来访问插槽 源码12345678910111213141516171819202122232425262728293031323334353637383940414243// initRendervm.$slots = resolveSlots(options._renderChildren, renderContext);// resolveSlotsfunction resolveSlots ( children, context) &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; var slots = &#123;&#125;; for (var i = 0, l = children.length; i &lt; l; i++) &#123; var child = children[i]; var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot; &#125; // named slots should only be respected if the vnode was rendered in the // same context. if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; var name = data.slot; var slot = (slots[name] || (slots[name] = [])); if (child.tag === &#x27;template&#x27;) &#123; slot.push.apply(slot, child.children || []); &#125; else &#123; slot.push(child); &#125; &#125; else &#123; (slots.default || (slots.default = [])).push(child); &#125; &#125; // ignore slots that contains only whitespace for (var name$1 in slots) &#123; if (slots[name$1].every(isWhitespace)) &#123; delete slots[name$1]; &#125; &#125; return slots&#125; 在初始化渲染的时候，解析 DOM 树，通过 resolveSlots 方法 提取出 slots 对象 resolveSlots 方法 判断 slot 属性是否为空，然后将同一个 slot 下的 node 节点 合并成一个 slot 数组,最后通过 delete 方法删除 slot 为空的数组 使用123456789101112131415161718192021222324252627&lt;blog-post&gt; &lt;template v-slot:header&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;Here&#x27;s some page content, which will be included in vm.$slots.default, because it&#x27;s not inside a named slot.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt; &lt;/template&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt;&lt;script&gt; Vue.component(&#x27;blog-post&#x27;, &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement(&#x27;div&#x27;, [ createElement(&#x27;header&#x27;, header), createElement(&#x27;main&#x27;, body), createElement(&#x27;footer&#x27;, footer) ]) &#125; &#125;)&lt;/script&gt; $scopedSlots &#123; [name: string]: props =&gt; Array&lt;VNode&gt; | undefined &#125; 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Vue.prototype._renderthis.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this。$slots);// 函数 normalizeScopedSlotsfunction normalizeScopedSlots ( slots, normalSlots, prevSlots) &#123; var res; var hasNormalSlots = Object.keys(normalSlots).length &gt; 0; var isStable = slots ? !!slots.$stable : !hasNormalSlots; var key = slots &amp;&amp; slots.$key; if (!slots) &#123; res = &#123;&#125;; &#125; else if (slots._normalized) &#123; // fast path 1: child component re-render only, parent did not change return slots._normalized &#125; else if ( isStable &amp;&amp; prevSlots &amp;&amp; prevSlots !== emptyObject &amp;&amp; key === prevSlots.$key &amp;&amp; !hasNormalSlots &amp;&amp; !prevSlots.$hasNormal ) &#123; // fast path 2: stable scoped slots w/ no normal slots to proxy, // only need to normalize once return prevSlots &#125; else &#123; res = &#123;&#125;; for (var key$1 in slots) &#123; if (slots[key$1] &amp;&amp; key$1[0] !== &#x27;$&#x27;) &#123; res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]); &#125; &#125; &#125; // expose normal slots on scopedSlots for (var key$2 in normalSlots) &#123; if (!(key$2 in res)) &#123; res[key$2] = proxyNormalSlot(normalSlots, key$2); &#125; &#125; // avoriaz seems to mock a non-extensible $scopedSlots object // and when that is passed down this would cause an error if (slots &amp;&amp; Object.isExtensible(slots)) &#123; (slots)._normalized = res; &#125; def(res, &#x27;$stable&#x27;, isStable); def(res, &#x27;$key&#x27;, key); def(res, &#x27;$hasNormal&#x27;, hasNormalSlots); return res&#125; $refs源码1234567891011121314151617181920212223242526272829303132333435363738394041var ref = &#123; create: function create (_, vnode) &#123; registerRef(vnode); &#125;, update: function update (oldVnode, vnode) &#123; if (oldVnode.data.ref !== vnode.data.ref) &#123; registerRef(oldVnode, true); registerRef(vnode); &#125; &#125;, destroy: function destroy (vnode) &#123; registerRef(vnode, true); &#125;&#125;;function registerRef (vnode, isRemoval) &#123; var key = vnode.data.ref; if (!isDef(key)) &#123; return &#125; var vm = vnode.context; var ref = vnode.componentInstance || vnode.elm; var refs = vm.$refs; if (isRemoval) &#123; if (Array.isArray(refs[key])) &#123; remove(refs[key], ref); &#125; else if (refs[key] === ref) &#123; refs[key] = undefined; &#125; &#125; else &#123; if (vnode.data.refInFor) &#123; if (!Array.isArray(refs[key])) &#123; refs[key] = [ref]; &#125; else if (refs[key].indexOf(ref) &lt; 0) &#123; // $flow-disable-line refs[key].push(ref); &#125; &#125; else &#123; refs[key] = ref; &#125; &#125;&#125; 通过 registerRef 方法 注册和移除旧的 VNode 使用12345678&lt;my-component ref=&quot;myComponent&quot;&gt;&lt;/my-component&gt;&lt;script&gt; export default &#123; mounted() &#123; console.log(this.$refs[&#x27;myComponent&#x27;]) &#125; &#125;&lt;/script&gt; $isServer12345678910111213var isServerRendering = function () &#123; if (_isServer === undefined) &#123; /* istanbul ignore if */ if (!inBrowser &amp;&amp; !inWeex &amp;&amp; typeof global !== &#x27;undefined&#x27;) &#123; // detect presence of vue-server-renderer and avoid // Webpack shimming the process _isServer = global[&#x27;process&#x27;] &amp;&amp; global[&#x27;process&#x27;].env.VUE_ENV === &#x27;server&#x27;; &#125; else &#123; _isServer = false; &#125; &#125; return _isServer&#125;; 判断 代码运行环境是否是服务端渲染,开启对应渲染和优化方法 $attrs 包含了父作用域中不作为 prop 被识别且获取的 attribute 绑定(除开 class 和 style)，当一个组件没有声明任何props时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件 12// function updateChildComponentvm.$attrs = parentVnode.data.attrs || emptyObject; $listeners 包含了父作用域中的 v-on(不包含 .natvie 修饰器) 事件监听器，可以通过 v-on=&quot;$listeners&quot; 传入内部组件 12vm.$listeners = listeners || emptyObject; $watch源码1234567891011121314151617181920212223Vue.prototype.$watch = function ( expOrFn, cb, options) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125;; options.user = true; var watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value); &#125; catch (error) &#123; handleError(error, vm, (&quot;callback for immediate watcher \\&quot;&quot; + (watcher.expression) + &quot;\\&quot;&quot;)); &#125; &#125; return function unwatchFn () &#123; watcher.teardown(); &#125;&#125;; 主要是通过 Watcher 构造函数及 createWatcher 方法对 Vue 实例的属性进行监控，然后返回一个取消观察的函数，用来停止触发回调 使用12345678910111213// 第一种使用this.$watch(&#x27;property&#x27;, cb)// 第二种使用this.$watch(&#x27;property&#x27;, cb, &#123; deep: true, immediate: true&#125;)// 第三种使用this.$watch(&#x27;property&#x27;, &#123; handler: cb, deep: true, immediate: true&#125;) $watch 方法会返回一个取消侦听函数，但是如果包含 immediate 选项时，不能在第一次回调时取消侦听给定的 property 12345678910111213141516// bad exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; unwatch()&#125;, &#123; deep: true, immediate: true&#125;)// good exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; if(unwatch) &#123; unwatch() &#125;&#125;, &#123; deep: true, immediate: true&#125;) $set 参考Vue.set $delete 参考Vue.delete","pubDate":"Fri, 29 Jan 2021 06:34:56 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/29/vue-learn-api-with-%E6%BA%90%E7%A0%81-06/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (五) - 选项 / 组合 & 其他","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/28/vue-learn-api-with-%E6%BA%90%E7%A0%81-05/","description":"parent主要用来存储 Vue 组件的父组件 mixins混入，主要用来开发 Vue组件中的可复用的功能 源码12345if (child.mixins) &#123; for (var i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm); &#125;&#125; Vue 在合并选项的时候 判断力 mixins 属性是否存在，如果存在，通过递归调用的方法合并到当前组件上 使用12345678910111213var mixin = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; mixins: [mixin]&#125; extends源码具体理解可以参考 Vue.extend123if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm);&#125; 使用12345678910111213var extend = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; extends: extend&#125; provide/inject provide Object | () =&gt; Object inject Array&lt;string&gt; | [key:string]: string | Symbol | Object 父组件通过 provide 提供依赖，子孙组件通过 inject 将依赖注入到当前组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 在 mergeOptionStract 配置中， provide 通过mergeData方法从父组件中绑定到子组件function initProvide (vm) &#123; var provide = vm.$options.provide; if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide; &#125;&#125;function initInjections (vm) &#123; var result = resolveInject(vm.$options.inject, vm); if (result) &#123; toggleObserving(false); Object.keys(result).forEach(function (key) &#123; /* istanbul ignore else */ &#123; defineReactive$$1(vm, key, result[key], function () &#123; warn( &quot;Avoid mutating an injected value directly since the changes will be &quot; + &quot;overwritten whenever the provided component re-renders. &quot; + &quot;injection being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125;); &#125; &#125;); toggleObserving(true); &#125;&#125;// 处理实例上的 inject 方法 返回处理之后的对象function resolveInject (inject, vm) &#123; if (inject) &#123; // inject is :any because flow is not smart enough to figure out cached var result = Object.create(null); var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject); for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; // #6574 in case the inject object is observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; var provideKey = inject[key].from; var source = vm; while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey]; break &#125; source = source.$parent; &#125; if (!source) &#123; if (&#x27;default&#x27; in inject[key]) &#123; var provideDefault = inject[key].default; result[key] = typeof provideDefault === &#x27;function&#x27; ? provideDefault.call(vm) : provideDefault; &#125; else &#123; warn((&quot;Injection \\&quot;&quot; + key + &quot;\\&quot; not found&quot;), vm); &#125; &#125; &#125; return result &#125;&#125; 使用12345678910111213141516// 父组件export default &#123; data() &#123; return &#123; bar: 342 &#125; &#125; provide: &#123; foo: &#x27;bar&#x27;, bar: this.bar &#125;&#125;// 子组件export default &#123; inject:[&#x27;foo&#x27;,&#x27;bar&#x27;]&#125; 高级使用技巧利用 Symbol 传递 12345678910111213const s = Symbol()const Provider = &#123; provide() &#123; return &#123; [s]: &#x27;foo&#x27; &#125; &#125;&#125;const Child = &#123; inject:&#123; s &#125;&#125; inject 的值作为 props 和 data 的初始值 1234567891011const child = &#123; inject: [&#x27;foo&#x27;], props: &#123; prop: &#123; default: this.foo &#125; &#125;, data() &#123; bar: this.foo &#125;&#125; name name 属性允许组件模板递归调用自身 delimiters 改变 纯文本插入分隔符 默认为[‘,‘] 源码12345678var defaultTagRE = /\\&#123;\\&#123;((?:.|\\r?\\n)+?)\\&#125;\\&#125;/g;var regexEscapeRE = /[-.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g;var buildRegex = cached(function (delimiters) &#123; var open = delimiters[0].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); var close = delimiters[1].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); return new RegExp(open + &#x27;((?:.|\\\\n)+?)&#x27; + close, &#x27;g&#x27;)&#125;); 使用123new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;,&#x27;&#125;&#x27;] // Vue 进行字符串切割替换的时候将会仿照 es6 的模板字符串&#125;) functional函数元组件 无状态(data)，无上下文(this)，没有响应式数据，相当于只是一个渲染组件，渲染之后就不会发生变化 1234567891011121314151617181920212223242526272829303132333435function createFunctionalComponent (Ctor,propsData,data,contextVm,children) &#123; var options = Ctor.options; var props = &#123;&#125;; var propOptions = options.props; if (isDef(propOptions)) &#123; for (var key in propOptions) &#123; props[key] = validateProp(key, propOptions, propsData || emptyObject); &#125; &#125; else &#123; if (isDef(data.attrs)) &#123; mergeProps(props, data.attrs); &#125; if (isDef(data.props)) &#123; mergeProps(props, data.props); &#125; &#125; var renderContext = new FunctionalRenderContext( data, props, children, contextVm, Ctor ); var vnode = options.render.call(null, renderContext._c, renderContext); if (vnode instanceof VNode) &#123; return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext) &#125; else if (Array.isArray(vnode)) &#123; var vnodes = normalizeChildren(vnode) || []; var res = new Array(vnodes.length); for (var i = 0; i &lt; vnodes.length; i++) &#123; res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext); &#125; return res &#125;&#125; 使用 context 参数 字段详解 props 提供所有 props 对象 children VNode 子节点的数组 slots 一个函数，返回了包含所有插槽的对象 scopedSlots 一个暴露传入的作用域插槽的对象，也已函数形式暴露普通插槽 data 传给组件的整个数据对象，作为 createElement 函数的第二个参数传入组件 parent 对父组件的引用 listeners 一个包含了所有父组件为当前组件注册的时间监听器对象，这是data.on的一个别名 injection 注入的 property 123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;function-component :list=&quot;list&quot; other=&quot;other&quot;&gt; this is a slot &#123;&#123;list.name&#125;&#125; &lt;div slot=&quot;default&quot;&gt; this is slot default &lt;/div&gt; &lt;/function-component&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; Vue.component(&#x27;function-component&#x27;, &#123; functional: true, props: &#123; list: &#123; type: Object, default: () =&gt; &#123; return &#123;&#125; &#125; &#125; &#125;, render: function (createElement, context) &#123; const header = context.scopedSlots.default() return createElement( &#x27;div&#x27;, [ createElement(&#x27;div&#x27;, [header[0]]), createElement(&#x27;div&#x27;, [header[1]]) ] ) &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 5, hide: true, list: &#123; name: &#x27;listName&#x27;, value: &#x27;listValue&#x27; &#125; &#125; &#125;, computed: &#123; test() &#123; return &#123; test1: 4 &#125; &#125; &#125;, &#125;)&lt;/script&gt; model prop(可选) String event(可选) String 允许一个自定义组件在使用 v-model 时定制定制 prop 和 event，默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，一些复杂的输入框可以使用 model 选项回避这些情况产生的冲突 源码12345678910111213141516171819function transformModel (options, data) &#123; var prop = (options.model &amp;&amp; options.model.prop) || &#x27;value&#x27;; var event = (options.model &amp;&amp; options.model.event) || &#x27;input&#x27; ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value; var on = data.on || (data.on = &#123;&#125;); var existing = on[event]; var callback = data.model.callback; if (isDef(existing)) &#123; if ( Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback ) &#123; on[event] = [callback].concat(existing); &#125; &#125; else &#123; on[event] = callback; &#125;&#125; 在设置值的时候通过一个 ||(或) 来判断 model 是否赋值，否则取默认设置的 value 及 input 使用123456789101112131415161718&lt;input v-model=&quot;inputValue&quot;&gt;&lt;!-- input 组件内部 --&gt;&lt;script&gt; export default &#123; model: &#123; prop: &#x27;text&#x27; event: &#x27;change&#x27; &#125;, props: &#123; text: String &#125;, methods: &#123; handleChange(value) &#123; this.$emit(&#x27;change&#x27;, value) &#125; &#125; &#125;&lt;/script&gt; inheritAttrs 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上 源码12345678910111213141516171819202122232425262728293031323334353637383940function updateAttrs (oldVnode, vnode) &#123; var opts = vnode.componentOptions; if (isDef(opts) &amp;&amp; opts.Ctor.options.inheritAttrs === false) &#123; return &#125; if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return &#125; var key, cur, old; var elm = vnode.elm; var oldAttrs = oldVnode.data.attrs || &#123;&#125;; var attrs = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] // #6666: IE/Edge forces progress value down to 1 before setting a max /* istanbul ignore if */ if ((isIE || isEdge) &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, &#x27;value&#x27;, attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125; 在更新的时候 判断一下 inheritAttrs 的值，如果为 false 直接返回 使用1234// 子组件export default &#123; inheritAttrs: false&#125; comments 主要作用是 是否保留渲染模板中的 HTML 注释","pubDate":"Thu, 28 Jan 2021 06:03:16 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/28/vue-learn-api-with-%E6%BA%90%E7%A0%81-05/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (四) - 选项 / DOM 及 生命周期函数、filters,directives,components","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/27/vue-learn-api-with-%E6%BA%90%E7%A0%81-04/","description":"el，template render源码el 指定的元素作为 Vue 实例的挂载目标 主要是通过 Vue 实例的 $mount 方法 $mount 方法 主要 通过 el 获取到 DOM 元素 然后调用 mountComponents 方法 绑定到 Vue 实例上，最后返回 Vue 实例1234567Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating)&#125;; mountComponent 方法 判断 是否有render函数，没有提示至少要有template或者render函数 (tempalte,el,render 不同同时使用) 调用 beforeMount 声明周期 判断是否开启性能优化检查 对 vm 的 updateComponet 函数进行 监听变化，如果发生变化，触发 beforeUpdate 生命周期函数 Vue 实例上挂载了 node 节点后更改 Vue 是否挂载状态 调用 mounted 生命周期 返回 挂载了 DOM 元素的 Vue 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function mountComponent (vm, el, hydrating) &#123; vm.$el = el; if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode; &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ); &#125; else &#123; warn( &#x27;Failed to mount component: template or render function not defined.&#x27;, vm ); &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent; /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; updateComponent = function () &#123; var name = vm._name; var id = vm._uid; var startTag = &quot;vue-perf-start:&quot; + id; var endTag = &quot;vue-perf-end:&quot; + id; mark(startTag); var vnode = vm._render(); mark(endTag); measure((&quot;vue &quot; + name + &quot; render&quot;), startTag, endTag); mark(startTag); vm._update(vnode, hydrating); mark(endTag); measure((&quot;vue &quot; + name + &quot; patch&quot;), startTag, endTag); &#125;; &#125; else &#123; updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); hydrating = false; // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 使用12345678910111213new Vue(&#123; el: &#x27;#app&#x27;, template: `&lt;div&gt;test&lt;/div&gt;`&#125;)new Vue(&#123; template: `&lt;div&gt;test&lt;/div&gt;`&#125;).$mount(&#x27;#app&#x27;)new Vue(&#123; el: &#x27;#app&#x27;, render: (h) =&gt; h()&#125;) 生命周期函数源码12345678910111213141516171819202122232425262728293031function callHook (vm, hook) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget(); var handlers = vm.$options[hook]; // 接收到的是一个数组 var info = hook + &quot; hook&quot;; if (handlers) &#123; for (var i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info); &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook); &#125; popTarget();&#125;function invokeWithErrorHandling (handler,context,args,vm,info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 在 callHook 方法中，主要是针对组件 生命周期进行处理，调用 invokeWithErrorHandling 方法 执行生命周期函数 在 invokeWithErrorHandling 方法中，通过 call 和 apply 执行生命周期函数及传参 使用生命周期函数 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed activated deactivated errorCaptured serverPrefetch 生命周期函数执行顺序 在 initMixin函数中，定义了 Vue 的 _init 函数，初始化 Vue 信息，合并 Vue 的 options 信息，初始化生命周期，初始化事件对象，初始化渲染方法 调用 beforeCreate 生命周期 不能访问到数据和dom元素，但是能够访问生命周期函数 初始化注册函数，初始化 data，props，methods，watch,provide 调用 created 生命周期 能获取到数据及方法，但是无法操作 dom 调用 $mount 方法挂载 DOM 元素 绑定 el 对应的 DOM 元素 调用 beforeMount 生命周期 调用 _update 挂载 DOM 元素, 使用 Watcher 构造函数 监听 updateComponent 方法，触发 beforeUpdate 生命周期 调用 mounted 生命周期 页面发生变化 时触发 updated 生命周期 页面销毁时时触发 $destroy 方法 调用 beforeDestroy 生命周期 清空 watcher，child，组件 及事件监听函数 调用 destroyed 生命周期 特殊的生命周期函数 activated/deactivated 只有被 keep-alive 组件包围的组件才有 这个生命周期函数 errorCaptured 全局报错信息的生命周期函数，报错捕获 directives源码请参照 Vue.directive 使用123456789export default &#123; directives: &#123; clip: &#123; insert: function() &#123;&#125;, bind: function() &#123;&#125; componentUpdate: function() &#123;&#125; &#125; &#125;&#125; filters源码请参照 Vue.filter 使用1234567export default &#123; filters: &#123; clip: function(value) &#123; return value &#125; &#125;&#125; components源码请参照 Vue.component 使用123456export default &#123; components: &#123; FirstComponent, SecondComponent &#125;&#125;","pubDate":"Wed, 27 Jan 2021 14:16:53 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/27/vue-learn-api-with-%E6%BA%90%E7%A0%81-04/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - Watcher 方法详解","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/27/vue-learn-api-with-%E6%BA%90%E7%A0%81-watcher/","description":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198var Watcher = function Watcher ( vm, // Vue 实例 expOrFn, // key值，watch 的属性 cb, // 回调函数 options, // 配置 &#123;lazy: true&#125; isRenderWatcher // 是否 在 Vue 实例上记载 Watcher ) &#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; // 深度监听 针对 对象 this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; // 判断 传入的 watch 函数 是否是函数，如果是函数，直接设置为 getter 函数 this.getter = expOrFn; &#125; else &#123; // 如果是对象，提取 函数 this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = noop; warn( &quot;Failed watching path: \\&quot;&quot; + expOrFn + &quot;\\&quot; &quot; + &#x27;Watcher only accepts simple dot-delimited paths. &#x27; + &#x27;For full control, use a function instead.&#x27;, vm ); &#125; &#125; this.value = this.lazy ? undefined : this.get();&#125;;/** * Evaluate the getter, and re-collect dependencies. */Watcher.prototype.get = function get () &#123; pushTarget(this); // 设置 Dep 构造函数的 target 为当前 Watcher 实例 var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); // 调用 getter 函数，并将 vue 实例作为参数传进去 &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (&quot;getter for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;;/** * Add a dependency to this directive. */// 此处 添加发布订阅模式，将 发布订阅模式 与 watcher 关联起来Watcher.prototype.addDep = function addDep (dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;;/** * Clean up for dependency collection. */Watcher.prototype.cleanupDeps = function cleanupDeps () &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;;/** * Subscriber interface. * Will be called when a dependency changes. */Watcher.prototype.update = function update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;;/** * Scheduler job interface. * Will be called by the scheduler. */Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError(e, this.vm, (&quot;callback for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;;/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */Watcher.prototype.evaluate = function evaluate () &#123; this.value = this.get(); this.dirty = false;&#125;;/** * Depend on all deps collected by this watcher. */Watcher.prototype.depend = function depend () &#123; var i = this.deps.length; while (i--) &#123; this.deps[i].depend(); &#125;&#125;;/** * Remove self from all dependencies&#x27; subscriber list. */Watcher.prototype.teardown = function teardown () &#123; if (this.active) &#123; // remove self from vm&#x27;s watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this); &#125; var i = this.deps.length; while (i--) &#123; this.deps[i].removeSub(this); &#125; this.active = false; &#125;&#125;;","pubDate":"Wed, 27 Jan 2021 13:45:28 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/27/vue-learn-api-with-%E6%BA%90%E7%A0%81-watcher/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - 选项 / 数据","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/24/vue-learn-api-with-%E6%BA%90%E7%A0%81-03/","description":"data在 data 中的数据 在 vue2 中会使用 Object.defineProperty 方法监听数据变化（vue3 采用 proxy）当数据发生变化的时候，会带动页面发生变化 在使用data的时候推介使用 返回一个初始对象的函数的方法，如果 data 是一个纯粹的对象，会造成 Vue 所有实例共享同一个引用数据对象 源码1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; if (!isPlainObject(data)) &#123; data = &#123;&#125;; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ); &#125; // proxy data on instance var keys = Object.keys(data); var props = vm.$options.props; var methods = vm.$options.methods; var i = keys.length; while (i--) &#123; var key = keys[i]; &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a data property.&quot;), vm ); &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( &quot;The data property \\&quot;&quot; + key + &quot;\\&quot; is already declared as a prop. &quot; + &quot;Use prop default value instead.&quot;, vm ); &#125; else if (!isReserved(key)) &#123; proxy(vm, &quot;_data&quot;, key); &#125; &#125; // observe data observe(data, true /* asRootData */);&#125; 上述源码 主要是判断一下 data 的 类型以及判断 data 定义的变量名是否在 props 及 methods 中是否也存在，之后调用 observe 方法给 data 对象添加数据监听 123456789101112function getData (data, vm) &#123; // #7573 disable dep collection when invoking data getters pushTarget(); try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, &quot;data()&quot;); return &#123;&#125; &#125; finally &#123; popTarget(); &#125;&#125; 数据映射，将 data 的数据映射到 Vue 实例上，这样我们通过 Vue.property 的方法也能访问到 data 上的数据 使用1234567export default &#123; data() &#123; return &#123; parameter: &#x27;parameter&#x27; &#125; &#125;&#125; props源码123456789101112131415161718192021222324252627282930313233function normalizeProps (options, vm) &#123; var props = options.props; if (!props) &#123; return &#125; var res = &#123;&#125;; var i, val, name; if (Array.isArray(props)) &#123; // 判断 props 类型 第一种是传递数组 [&#x27;props1&#x27;, &#x27;props2&#x27;] i = props.length; while (i--) &#123; val = props[i]; if (typeof val === &#x27;string&#x27;) &#123; name = camelize(val); res[name] = &#123; type: null &#125;; &#125; else &#123; warn(&#x27;props must be strings when using array syntax.&#x27;); &#125; &#125; &#125; else if (isPlainObject(props)) &#123; // 判断 props 类型 第二种是传递带有类型检查的对象 for (var key in props) &#123; val = props[key]; name = camelize(key); res[name] = isPlainObject(val) ? val : &#123; type: val &#125;; &#125; &#125; else &#123; warn( &quot;Invalid value for option \\&quot;props\\&quot;: expected an Array or an Object, &quot; + &quot;but got &quot; + (toRawType(props)) + &quot;.&quot;, vm ); &#125; options.props = res;&#125; 使用 props 有两种使用方式 数组方式 子组件用一个数组接收父组件传递的props props: [&#39;props1&#39;, &#39;props2&#39;]缺点就是无法做类型检查，无法控制接收到的 props 的数据类型及默认值 对象方式 子组件用一个对象接收父组件传入的props对象属性上有以下参数 type props 的数据类型，单个类型 直接判断 type: String ，多个类型 传递数组 type: [String, Array] default 默认值，如果父组件没有传递此 props，将会自动取默认值 require 是否必传 validator 自定义验证函数123456789101112export default &#123; // props: [&#x27;props1&#x27;, &#x27;props2&#x27;] props: &#123; props1: &#123; type: String, default: &#x27;&#x27;, require: true, validator: () =&gt; &#123;&#125; &#125;, props: Number &#125;&#125; propsData 使用 new 创建 Vue 实例的时候使用 源码 此源码也包含 props1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function initProps (vm, propsOptions) &#123; var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. var keys = vm.$options._propKeys = []; var isRoot = !vm.$parent; // root instance props should be converted if (!isRoot) &#123; toggleObserving(false); &#125; var loop = function ( key ) &#123; keys.push(key); var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( (&quot;\\&quot;&quot; + hyphenatedKey + &quot;\\&quot; is a reserved attribute and cannot be used as component prop.&quot;), vm ); &#125; defineReactive$$1(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( &quot;Avoid mutating a prop directly since the value will be &quot; + &quot;overwritten whenever the parent component re-renders. &quot; + &quot;Instead, use a data or computed property based on the prop&#x27;s &quot; + &quot;value. Prop being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125; &#125;); &#125; // static props are already proxied on the component&#x27;s prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, &quot;_props&quot;, key); &#125; &#125;; for (var key in propsOptions) loop( key ); toggleObserving(true);&#125;此方法主要是在初始化的时候 将propsData，props进行响应式处理 使用12345new Vue（&#123; propsData: &#123; msg: &#x27;123 &#125;&#125; computed源码123456789101112131415161718192021222324252627282930313233343536function initComputed (vm, computed) &#123; // 创建一个 watcher 对象 var watchers = vm._computedWatchers = Object.create(null); // 判断当前页面渲染类型 是否是服务端渲染 var isSSR = isServerRendering(); for (var key in computed) &#123; // 遍历 computed 对象 获取属性的返回值 var userDef = computed[key]; var getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get; if (getter == null) &#123; warn( (&quot;Getter is missing for computed property \\&quot;&quot; + key + &quot;\\&quot;.&quot;), vm ); &#125; // 如果 当前页面不是服务端渲染，调用 watcher 方法监听 computed 数值变化 if (!isSSR) &#123; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ); &#125; if (!(key in vm)) &#123; // 关键的一步，判断 computed 定义的变量在props及data中是否有值 defineComputed(vm, key, userDef); // 给 computed 的属性添加 get 方法 &#125; else &#123; if (key in vm.$data) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined in data.&quot;), vm); &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined as a prop.&quot;), vm); &#125; &#125; &#125;&#125; defineComputed 函数 主要作用是设置 映射到 Vue 实例上的 computed 属性的 get 和 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function defineComputed ( target, key, userDef) &#123; // 同样，首先判断一下是否是服务端渲染 var shouldCache = !isServerRendering(); if (typeof userDef === &#x27;function&#x27;) &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef); sharedPropertyDefinition.set = noop; &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop; sharedPropertyDefinition.set = userDef.set || noop; &#125; if (sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( (&quot;Computed property \\&quot;&quot; + key + &quot;\\&quot; was assigned to but it has no setter.&quot;), this ); &#125;; &#125; Object.defineProperty(target, key, sharedPropertyDefinition);&#125;function createComputedGetter (key) &#123; return function computedGetter () &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125; &#125;&#125;function createGetterInvoker(fn) &#123; return function computedGetter () &#123; return fn.call(this, this) &#125;&#125; 使用123456789101112131415export default &#123; computed: &#123; parameter1() &#123; return 1 &#125;, parameter2: &#123; get() &#123; return 2 &#125;, set() &#123; this.parameter1 = 4 &#125; &#125; &#125;&#125; methods源码123456789101112131415161718192021222324252627function initMethods (vm, methods) &#123; var props = vm.$options.props; for (var key in methods) &#123; &#123; if (typeof methods[key] !== &#x27;function&#x27;) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; has type \\&quot;&quot; + (typeof methods[key]) + &quot;\\&quot; in the component definition. &quot; + &quot;Did you reference the function correctly?&quot;, vm ); &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a prop.&quot;), vm ); &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; conflicts with an existing Vue instance method. &quot; + &quot;Avoid defining component methods that start with _ or $.&quot; ); &#125; &#125; vm[key] = typeof methods[key] !== &#x27;function&#x27; ? noop : bind(methods[key], vm); // 调用 函数的bind 方法，绑定 methods 方法的 this 到 Vue 实例上 &#125;&#125; 使用 不推介使用箭头函数来命名 methods 函数 此时 函数的 this 指向了 父级作用域上下文12345678910export default &#123; methods: &#123; fn1() &#123; // todo... &#125;, fn2() &#123; // todo... &#125; &#125;&#125; watchVue 中 watch 主要用于监听 data，props，computed 对象中的属性发生变化，一旦发生变化就会触发对应的函数，更新对应数据及页面结构 源码12345678910111213141516171819202122232425262728function initWatch (vm, watch) &#123; for (var key in watch) &#123; var handler = watch[key]; if (Array.isArray(handler)) &#123; for (var i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]); &#125; &#125; else &#123; createWatcher(vm, key, handler); &#125; &#125;&#125;function createWatcher ( vm, expOrFn, handler, options) &#123; if (isPlainObject(handler)) &#123; options = handler; handler = handler.handler; &#125; if (typeof handler === &#x27;string&#x27;) &#123; handler = vm[handler]; &#125; return vm.$watch(expOrFn, handler, options)&#125; 在 initWatch 的时候， 首先针对传入的 watch对象进行遍历watch 的属性如果是数组，数组内的函数会异议调用，其他情况会直接创建 watch vm Vue 实例 watch vue 组件上的 watch 对象 在 createWatcher 函数里面，因为传入的handler 可能是对象，所以做了兼容处理，之后要调用了 Vue 实例上的 $watch 方法来实现属性的监听, $watch 方法 我们会在接下进行讲解，现在先有个印象 vm Vue 实例 expOrFn 要进行数据监控的变量名 handler 回调函数，数据发生改变后执行此函数，吧改变后的值传递回来，也可以是对象，但是对象中必须要包含 handler 属性且是一个函数或者一个键，可以通过它在 vm 上找到对应函数 options 配置参数 针对对象进行特殊处理，防止无法监听到对象值的变化 使用在看了源码中的 initWatch 函数和 createWatcher 函数之后，根据对 watch 内部参数的处理我们可以猜到在使用 watch 的时候我们可以传递 数组、对象、函数、字符串 回调函数不推介使用 箭头函数，因为箭头函数的上下文已经绑定了，不会指向 Vue 实例 1234567891011121314151617181920export default &#123; watch: &#123; // Vue 在监控到 a 发生变化之后 会执行 methods 方法 即 vm[&#x27;methods&#x27;] a: &#x27;methods&#x27;, // Vue 在监控到 b 发生变化之后 会执行此回调函数 b: function() &#123;&#125;, // 针对对象属性监听，在 createWatcher 函数中 会对对象进行处理，取出回调函数 及 options 配置 // c 发生变化之后 会调用 对象中 handler 函数 c: &#123; handler: &#x27;methods&#x27;, deep: true &#125; // d 放生变化之后，数组中的每一个函数都会被执行，数组内部 watch 方法的执行和以上三种类似 d: [&#x27;methods&#x27;, function()&#123;&#125;, &#123; handler: function() &#123;&#125; &#125;], // 此种方法针对对象的某一个值进行监听，在 Vue 中会对 `key:&#x27;e-f&#x27; 进行处理，精准查找到 e 对象下的 f 属性 &#x27;e.f&#x27;: function() &#123;&#125; &#125;&#125;","pubDate":"Sun, 24 Jan 2021 14:38:26 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/24/vue-learn-api-with-%E6%BA%90%E7%A0%81-03/","category":"Vue源码"},{"title":"跟着 Vue源码学习 Vue api 系列 (二) - 全局 api","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/20/vue-learn-api-with-%E6%BA%90%E7%A0%81-02/","description":"Vue.extend({})源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function initExtend (Vue) &#123; /** * Each instance constructor, including Vue, has a unique * cid. This enables us to create wrapped &quot;child * constructors&quot; for prototypal inheritance and cache them. */ Vue.cid = 0; var cid = 1; /** * Class inheritance */ Vue.extend = function (extendOptions) &#123; extendOptions = extendOptions || &#123;&#125;; var Super = this; // 使用 super 继承Vue 实例 var SuperId = Super.cid; // 存储 Vue 实例的 cid var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] // 优化，如果多次使用同一个 Vue.extend 返回的是同一个 Vue.extend ,使用缓存，减少不必要的内存消耗 &#125; var name = extendOptions.name || Super.options.name; if (name) &#123; validateComponentName(name); // 检验 Vue extend 的name 属性是否合法 &#125; var Sub = function VueComponent (options) &#123; this._init(options); &#125;; /** 原型继承，将 vue 的原型 集成到子类 Sub 构造函数上，同时添加唯一标识符 */ Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; Sub.cid = cid++; /** 调用 mergeOptions 方法 将 extend的所有属性 合并到 Vue的 options 属性上 */ Sub.options = mergeOptions( Super.options, extendOptions ); Sub[&#x27;super&#x27;] = Super; // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. // 如果包含 props 属性，重新初始化 props if (Sub.options.props) &#123; initProps$1(Sub); &#125; // 如果包含 computed 属性，重新初始化 computed if (Sub.options.computed) &#123; initComputed$1(Sub); &#125; // allow further extension/mixin/plugin usage Sub.extend = Super.extend; Sub.mixin = Super.mixin; Sub.use = Super.use; // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type]; &#125;); // enable recursive self-lookup 启动递归查找 if (name) &#123; Sub.options.components[name] = Sub; &#125; // keep a reference to the super options at extension time. // later at instantiation we can check if Super&#x27;s options have // been updated. // 在分机处保留对超级选项的引用时间。稍后在实例化时，我们可以检查Super的选项是否已更新。 Sub.superOptions = Super.options; Sub.extendOptions = extendOptions; Sub.sealedOptions = extend(&#123;&#125;, Sub.options); // cache constructor cachedCtors[SuperId] = Sub; // 在此处赋值，缓存 当前 Vue extend return Sub &#125;;&#125; 通过以上源码，我们可以看出 Vue 在 extend 的时候主要做了以下几个事情 首先进行兼容处理，保证传入的对象不为空 创建一个变量 Super 用来存储 Vue 实例，并且存储 Vue 的 cid 判断当前 extend 是否已经被使用过，如果已经使用过，直接返回，以减少内存消耗 创建一个新的构造函数 Sub ，原型指向 Super 的原型，并创建一个唯一的 cid 接下来通过 mergeOptions 方法，将传入的 参数 与 Vue 实例的 options(data,lifeCycle,methods,props,methods 等) 合并，遵循 Vue 内部 config 中定义的optionMergeStrategies 配置 初始化 props 和 computed 属性 重新对 extend，mixin，use，filter，directive，component 属性进行赋值 最后 通过 _Ctor 缓存 当前创建的 Vue.extend 实例 返回 当前 Sub 构造函数，该构造函数 具有 Vue 所有属性及方法 使用 1234567891011121314151617181920212223var Profile = Vue.extend(&#123; data() &#123; return &#123; name: &#x27;lxx&#x27;, age: 24, &#125; &#125;, computed: &#123; time() &#123; return new Date.getTime() &#125; &#125;, mounted() &#123; this.getName() &#125; methods: &#123; getName() &#123; console.log(this.name) &#125; &#125;&#125;)new Profile().$mount(&#x27;#app&#x27;) 当我们 使用 Vue.extend 为 Vue 扩展一些信息的时候，会根据 Vue 的 optionMergeStrategies 配置的默认属性合并规则进行属性 合并，这样我们在任意组件都可以使用到这些属性和方法 Vue.nextTick([callback: Function,context: Object]) Vue 更新页面并不是同步更新的，而是采用异步更新的。 浏览器有一个更新循环 tick，这个 tick 时间间隔大概十几毫秒，Vue 在到浏览器执行下一个 tick 的时间段内搜集所有需要更新的 Dom 数据，在 下一个 tick 循环到来的时候同步更新到页面上。这时候就会造成一个问题，如果我们想在改变数据之后立刻获取页面的数据的话，这时候还没有触发浏览器的 tick 更新，页面没有变化，我们是获取不到更新后的 DOM 数据 使用 Vue.nextTick 可以使我们在页面更新完成之后获取 DOM 源码123456789101112131415161718192021222324function nextTick (cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve) &#123; _resolve = resolve; &#125;) &#125;&#125; 在 timerFunc() 函数 中 通过判断 Promise MutationObserver 及 setImmediate函数是否存在 如在就使用对应函数，不存在就使用setTimeout方法 使用123Vue.nextTick(() =&gt; &#123; // 获取更新后的 Dom&#125;) Vue.set(target: Object | Array, index: Number | string, value: any) 用于修改一些 Vue 响应式无法监听到的对象属性变更，同时触发视图更新 源码123456789101112131415161718192021222324252627282930function set (target, key, val) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val &#125; if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ); return val &#125; if (!ob) &#123; target[key] = val; return val &#125; defineReactive$$1(ob.value, key, val); ob.dep.notify(); return val&#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 key 是否属于 target 判断 传入 target 对象 是否是 Vue 实例 调用 defineReactive$$1 监听数据变化 调用 发布订阅模式 的 发布方法 使用1Vue.set(target, key, value) Vue.delete(target: Object | Array, index: Number | string) 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。 源码1234567891011121314151617181920212223242526function del (target, key) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot delete reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1); return &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid deleting properties on a Vue instance or its root $data &#x27; + &#x27;- just set it to null.&#x27; ); return &#125; if (!hasOwn(target, key)) &#123; return &#125; delete target[key]; if (!ob) &#123; return &#125; ob.dep.notify(); &#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 传入 target 对象 是否是 Vue 实例 删除 target[key] 调用 发布订阅模式 的 发布方法 使用1Vue.delete(target, key) Vue.directive( id: string, [definition]: Function | Object ) 此方法主要是为了给 Vue 设置自定义指令 及获取 Vue 指令 源码首先 定义了一个 platformDirectives 存储 directive 指令的属性，然后通过 extend 方法，将 platformDirectives 上的属性 复制到 Vue.options.directives 上123456var platformDirectives = &#123; model: directive, show: show&#125;;extend(Vue.options.directives, platformDirectives) directive 对象的属性 12345var directive = &#123; inserted: function() &#123;&#125;, componentUpdated: function()&#123;&#125;&#125; install12345678910111213141516171819202122232425262728inserted: function inserted (el, binding, vnode, oldVnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; // #6903 if (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123; mergeVNodeHook(vnode, &#x27;postpatch&#x27;, function () &#123; directive.componentUpdated(el, binding, vnode); &#125;); &#125; else &#123; setSelected(el, binding, vnode.context); &#125; el._vOptions = [].map.call(el.options, getValue); &#125; else if (vnode.tag === &#x27;textarea&#x27; || isTextInputType(el.type)) &#123; el._vModifiers = binding.modifiers; if (!binding.modifiers.lazy) &#123; el.addEventListener(&#x27;compositionstart&#x27;, onCompositionStart); el.addEventListener(&#x27;compositionend&#x27;, onCompositionEnd); // Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when // switching focus before confirming composition choice // this also fixes the issue where some browsers e.g. iOS Chrome // fires &quot;change&quot; instead of &quot;input&quot; on autocomplete. el.addEventListener(&#x27;change&#x27;, onCompositionEnd); /* istanbul ignore if */ if (isIE9) &#123; el.vmodel = true; &#125; &#125; &#125;&#125;, 我们可以看到在 inserted 函数中对 指令绑定的元素做了一个判断， 针对 select，textarea标签及 input 标签且属性是 是文本输入类型的元素做了特殊处理 componentUpdated 123456789101112131415161718192021componentUpdated: function componentUpdated (el, binding, vnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed, // it&#x27;s possible that the value is out-of-sync with the rendered options. // detect such cases and filter out values that no longer has a matching // option in the DOM. var prevOptions = el._vOptions; var curOptions = el._vOptions = [].map.call(el.options, getValue); if (curOptions.some(function (o, i) &#123; return !looseEqual(o, prevOptions[i]); &#125;)) &#123; // trigger change event if // no matching option found for at least one value var needReset = el.multiple ? binding.value.some(function (v) &#123; return hasNoMatchingOption(v, curOptions); &#125;) : binding.value !== binding.oldValue &amp;&amp; hasNoMatchingOption(binding.value, curOptions); if (needReset) &#123; trigger(el, &#x27;change&#x27;); &#125; &#125; &#125;&#125; 在 componentUpdated 方法中 对select 标签的元素做了特殊处理，渲染其子元素 option bind,update,unbind 针对元素的 display 进行处理 使用insert 函数传入参数有四个 el 当前指令挂载的元素节点 binding v-[name]:[arg].[modifies].[modifies]=&quot;[expression]&quot; name: 指令名 value: 指令的绑定值 oldValue: 指令绑定的前一个值，value参数改变之前的值 expression: 字符串形式的指令表达式 arg: 传递指令的参数 modifiers: 包含修饰符的对象 首先 如果 express 没有话 不会获取到 value, 如果想要获取 value，就要包含有 expression, 则该 expression 必须在 data 或者 computed 上必须要在第一层上 就算是 expression 用 ex1.ex2 或者 ex1[ex2],value 的值为 data[ex1] 或者 computed[ex1] 当 expression 为一个可以计算的表达式的时候 例如 1+1, ex1 + 1 等，value 的结果为 expression 计算之后的结果 vnode 虚拟node节点 oldVnode 上一个虚拟 DOM 节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;div v-test:test2.test1=&quot;test3&quot;&gt;&#123;&#123;test3&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.directive(&#x27;test&#x27;, &#123; bind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;4&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 4 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; */ &#125;, // 使用 componentUpdated 可以监控元素节点数据变化 展示的 更新之后的数据 componentUpdated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;9&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 9 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; // 此处存放的是 value 未被更改为4的时候的节点 */ &#125;, // 在元素bind的时候 可能updated方法就已经执行， // 此时 bind时候 的el对象是更新之后的对象,即 testChild 为 8 test3 为 9 // 但是 Vnode 及 oldVNode 还是元素未发生更改之前的元素节点 updated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;updated&#x27;) &#125;, // 指令解绑的时候触发 可以使用 v-if 控制元素隐藏和显示来触发 unbid unbind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;unbind&#x27;) &#125;, // 页面一渲染就会触发 insert: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;insert&#x27;) &#125;, &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 4 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.test3 = 9, this.testChild = 8 &#125;, 1000) &#125;, &#125;) &lt;/script&gt; Vue.filter(id:string, definition: Function)源码123456789101112131415161718192021222324252627282930var ASSET_TYPES = [ &#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;];ASSET_TYPES.forEach(function (type) &#123; Vue[type] = function ( id, definition ) &#123; if (!definition) &#123; return this.options[type + &#x27;s&#x27;][id] &#125; else &#123; /* istanbul ignore if */ if (type === &#x27;component&#x27;) &#123; validateComponentName(id); &#125; if (type === &#x27;component&#x27; &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id; definition = this.options._base.extend(definition); &#125; if (type === &#x27;directive&#x27; &amp;&amp; typeof definition === &#x27;function&#x27;) &#123; definition = &#123; bind: definition, update: definition &#125;; &#125; this.options[type + &#x27;s&#x27;][id] = definition; return definition &#125; &#125;; &#125;);&#125; 以上代码 是 ‘component’, ‘directive’, ‘filter’ 三个全局API 注册到 Vue 实例上的方法 如果是 component 则检查 组件名称是否是合格的组件名称 然后在判断 是否是 definition 参数是否是对象，如果是，则使用 Vue 实例的 extend 方法扩展全局的 extend 属性 如果是 directive 如果传入的 definition 是函数 则默认调用 bind 和 update 方法 使用123456&lt;div&gt;&#123;&#123; test | uppcase&#125;&#125;&lt;div&gt;&lt;script&gt;Vue.filter(&#x27;uppcase&#x27;, function(value) &#123; return value &amp;&amp; value.toUpperCase()&#125;&lt;/script&gt; Vue.component(id: string, definition: Function | Object)源码请查看 Vue.filter 的讲解 使用12345Vue.componet(&#x27;my-component&#x27;, &#123; data() &#123;return &#123;&#125;&#125; methods: &#123;&#125; computed: &#123;&#125;&#125;) definition 可以传递 Vue.extend({}),也可以直接传一个对象，Vue会自动调用 Vue.extend 方法 Vue.use(plugin)源码12345678910111213141516171819function initUse (Vue) &#123; Vue.use = function (plugin) &#123; var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) &#123; // 判断是否 安装过此插件 return this &#125; // additional parameters var args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &#x27;function&#x27;) &#123; plugin.install.apply(plugin, args); // 调用 plugin 的 install 函数 &#125; else if (typeof plugin === &#x27;function&#x27;) &#123; plugin.apply(null, args); // 直接执行 plugin 函数 &#125; installedPlugins.push(plugin); return this &#125;;&#125; 使用12// plugin必须是一个函数 或者包含 install 的对象 Vue.use(plugin) Vue.mixin(plugin)源码123456function initMixin$1 (Vue) &#123; Vue.mixin = function (mixin) &#123; this.options = mergeOptions(this.options, mixin); return this &#125;;&#125; 此方法 调用了 mergeOptions 方法将 传入的参数 与 Vue 的 options 属性合并 使用 这个方法会影响 所有创建的 Vue 组件，不推介使用，但是可以用于 optionMergeStrategies 自定义 选项12345678910111213Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: &#x27;hello!&#x27;&#125;)// =&gt; &quot;hello!&quot; Vue.compile将一个模板字符串编译成 render 函数 源码没看懂，有时间再来研究(2021-01-24)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function createCompileToFunctionFn (compile) &#123; var cache = Object.create(null); return function compileToFunctions ( template, options, vm ) &#123; options = extend(&#123;&#125;, options); var warn$$1 = options.warn || warn; delete options.warn; /* istanbul ignore if */ &#123; // detect possible CSP restriction try &#123; new Function(&#x27;return 1&#x27;); &#125; catch (e) &#123; if (e.toString().match(/unsafe-eval|CSP/)) &#123; warn$$1( &#x27;It seems you are using the standalone build of Vue.js in an &#x27; + &#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27; + &#x27;The template compiler cannot work in this environment. Consider &#x27; + &#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27; + &#x27;templates into render functions.&#x27; ); &#125; &#125; &#125; // check cache var key = options.delimiters ? String(options.delimiters) + template : template; if (cache[key]) &#123; return cache[key] &#125; // compile var compiled = compile(template, options); // check compilation errors/tips &#123; if (compiled.errors &amp;&amp; compiled.errors.length) &#123; if (options.outputSourceRange) &#123; compiled.errors.forEach(function (e) &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + (e.msg) + &quot;\\n\\n&quot; + generateCodeFrame(template, e.start, e.end), vm ); &#125;); &#125; else &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + template + &quot;\\n\\n&quot; + compiled.errors.map(function (e) &#123; return (&quot;- &quot; + e); &#125;).join(&#x27;\\n&#x27;) + &#x27;\\n&#x27;, vm ); &#125; &#125; if (compiled.tips &amp;&amp; compiled.tips.length) &#123; if (options.outputSourceRange) &#123; compiled.tips.forEach(function (e) &#123; return tip(e.msg, vm); &#125;); &#125; else &#123; compiled.tips.forEach(function (msg) &#123; return tip(msg, vm); &#125;); &#125; &#125; &#125; // turn code into functions var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors) &#125;); // check function generation errors. // this should only happen if there is a bug in the compiler itself. // mostly for codegen development use /* istanbul ignore if */ &#123; if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123; warn$$1( &quot;Failed to generate render function:\\n\\n&quot; + fnGenErrors.map(function (ref) &#123; var err = ref.err; var code = ref.code; return ((err.toString()) + &quot; in\\n\\n&quot; + code + &quot;\\n&quot;); &#125;).join(&#x27;\\n&#x27;), vm ); &#125; &#125; return (cache[key] = res) &#125;&#125; 使用123456789var res = Vue.compile(&#x27;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#x27;)new Vue(&#123; data: &#123; msg: &#x27;hello&#x27; &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) Vue.observable(object)让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象 源码123456789101112131415161718192021function observe (value, asRootData) &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++; &#125; return ob &#125; 调用了 通過 new Observer() 在 Observer 内部通过 walk 方法 调用 defineReactive$$1 进行对象响应式处理 使用12345678const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h(&#x27;button&#x27;, &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; Vue.version提供 Vue 的版本号 1Vue.version = &#x27;2.6.12&#x27;;","pubDate":"Wed, 20 Jan 2021 09:18:54 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/20/vue-learn-api-with-%E6%BA%90%E7%A0%81-02/","category":"Vue源码"},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（二）Vue3 生命周期","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/17/vue3-vite-typescript-02/","description":"Vue3 继承了 Vue2 的所有生命周期函数，所以 Vue2 的生命周期的应用方式同样适用于 Vue3。同时 Vue3 还新增了一些新的生命周期。 原有的生命周期函数我们这边不做过多的赘述，我们来讲解一下 Vue3 相对于 Vue2 变更了和新增了哪些生命周期函数 beforeUnmount unmounted 这两个生命周期替代了 Vue2 的 beforeDestory 和 destoryed生命周期，两者的作用是一致的，都是在组件卸载的时候调用的，在 Vue3 还可以使用 unmout API 来卸载应用 renderTracked 跟踪 虚拟DOM 渲染时候调用，接收 debugger event 作为参数组件第一次渲染的时候调用，数据发生改变不会调用 12345678910111213141516&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; &#125;&lt;/script&gt; renderTriggered 当虚拟 DOM 重新渲染为 triggered.Similarly 为renderTracked，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键触发属性值的变更的时候触发 12345678910111213141516171819&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对,值是修改之后的值 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; mounted() &#123; setTimeout(() =&gt; &#123;this.cart++&#125;, 10000) &#125; &#125;&lt;/script&gt; 123456// 创建应用const app = createApp(&#123;&#125;)app.mount(&quot;#app&quot;)// 卸载应用app.unmount(&quot;#app&quot;) setup -&gt; created 和 beforeCreate setup 在 创建组件之前执行，作为组合式 API 的入口点,return 的返回值可以渲染到页面上 传参 props 父组件传入的 props 对象，是响应式的，prop 发生变化时会同时发生更新 注意不能使用结构赋值，否则会失去响应式的特性，如果想要解构出 props 中的属性可以选择使用 toRefs 来完成此操作 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;!-- 记录 Vue3 生命周期的相关使用方法 --&gt; &lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt; &lt;/setup-hook&gt; &lt;div&gt;test text&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import components from &#x27;./components/index&#x27;export default &#123; components: &#123; ...components &#125;, data() &#123; return &#123; time: 1000 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.time += 1000 &#125;, 1000) &#125;, methods: &#123; handleSuccess() &#123; console.log(&#x27;success&#x27;) &#125; &#125;,&#125;&lt;/script&gt; 12345678910111213141516171819&lt;div&gt; &lt;div&gt;当前时间：&#123;&#123;time&#125;&#125;&lt;/div&gt; &lt;div&gt;截取props&#123;&#123;newTime&#125;&#125;&lt;/div&gt; &lt;div&gt;toRefs(props)&#123;&#123;refTime&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;toRefs&#125; from &#x27;vue&#x27;export default &#123; setup(props) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) return &#123; newTime, refTime &#125; &#125;&#125;&lt;/script&gt; 使用 toRefs 解构 props 的时候 如果想要直接访问 需要访问其 value 属性，下面是打印出来的解构出来的值,最后需要使用 return 抛出需要渲染和使用的变量及方法 context 暴露了三个组件的 property (attrs, slots, emit) attrs 为父组件在子组件上传递的属性(未被props接收)slots 为父组件在子组件中传入的插槽 默认有一个 default 插槽emit 这是一个执行函数，相当于 Vue.$emit() 可以用于发送事件 context 是一个普通的 JavaScript 非响应式对象，可以安全的使用 ES6 的解构赋值操作 1234567891011121314151617181920&lt;!-- 父组件 --&gt;&lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt;&lt;/setup-hook&gt;&lt;!-- 子组件 --&gt;&lt;script&gt; setup(props, &#123;attrs, emit, slots&#125;) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) console.log(attrs, slots) emit(&#x27;success&#x27;) return &#123; newTime, refTime &#125; &#125;,&lt;/script&gt; 因此在执行 setup 的时候组件实例还未被创建，只能访问 props, attrs, slots, emit实例，无法访问 data, computed, methods setup 在最后会有一个返回值，这个返回值是包含我们需要渲染或者在其他生命周期需要使用的变量的对象。 我们在使用 setup 需要注意以下几点： setup 中的 this 并不是 Vue 实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。 如果在 setup 中，我们定义了一个引用类型的变量，并针对这个变量进行了延时修改，这时修改之后的值并不会改变页面渲染，因为我们定义的并不是一个响应式类型的数据，如果想要创建一个响应式类型的数据，可以使用 reactive 来创建 1let obj = reactive(&#123;value: 1, label: &#x27;object&#x27;&#125;) 如果我们定义的是一个基础类型的变量，此时也想要他实现响应式的一个变化，这是可以使用 ref 来创建，访问对象的值可以通过访问变量的 value 属性 1234const count = ref(0)console.log(count.value) // 0// 此外还可以对 ref 内部进行类型指定const count = ref&lt;string | number&gt;(0) setup 的返回值可以在其他生命周期或者函数中直接通过 this 调用，并且已进行过响应式处理 在 setup 中还新增了一下几种 生命周期钩子，这些钩子函数只能在 setup 中使用 onBeforeMountonMountedonBeforeUpdateonUpdatedonBeforeUnmountonUnmountonErrorCapturedonRenderTrackedonRenderTriggered 具体使用方法与生命周期函数类似，但是注意以上这些只能在 setup 中使用 12345setup() &#123; onMounted(() =&gt; &#123; console.log(&#x27;mounted&#x27;) &#125;)&#125; Vue3 还提供了 provide 和 inject 方便在 setup 中进行 提供和注入 1234567setup() &#123; provide(&#x27;title&#x27;, &#x27;this is a title&#x27;)&#125;setup() &#123; const title = inject(&#x27;title&#x27;, &#x27;default value&#x27;)&#125;","pubDate":"Sun, 17 Jan 2021 14:24:46 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/17/vue3-vite-typescript-02/","category":"vue3 vite ts"},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（一）搭建项目","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/15/vue3-vite-typescript-01/","description":"Vue3 新版出来了这么久，虽然之前也有联系过搭建，但是并没有测试过多的东西，趁着闲暇时间，打算从头采坑，记录自己的 Vue 3.0 的爬坑历程 搭建项目 本次项目搭建采用尤雨溪大大开发的 Vite，这是尤大最近开发出的新的 Web 开发工具具有以下优点 快速的冷启动 即时的模块热更新 真正的按需编译 使用 vite 极大的提高了前端的开发性能及开发速度 全局安装 Vite 123456789// 全局安装 vite-appnpm i -g vite-app// 创建项目npm init vite-app &lt;project-name&gt;cd project-nameyarn || npm install 安装 必要第三方插件 安装 TypeScript 1npm install -D typescript 根目录(src)下新增 shim.vue.d.ts 文件 123456789101112declare module &#x27;*.vue&#x27; &#123; import &#123; Component &#125; from &#x27;vue&#x27; const component: Component export default component&#125;// 或者declare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27; // const component: defineComponent&lt;&#123;&#125;,&#123;&#125;,any&gt; export default Vue&#125; 修改 main.js 为 main.ts 并修改 index.html 文的引用 安装 vue-router vue3.0 最好安装最新的版的 vue-router，版本错误的话无法使用路由进行跳转 1npm install vue-router@4 然后在 src 目录下新建 router 目录，在目录下新建 index.ts 文件 从 vue-router 引入 createRouter 和 createWebHashHistory(或者createWebHistory) 1import &#123;createRouter, createWebHashHistory&#125; from &#x27;vue-router&#x27; 然后新建 一个 route对象，存放路由配置，使用 createRouter 方法 创建 router 对象，最后通过 export default 导出 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;../views/home/index.vue&#x27;), redirect: &#x27;/index&#x27;, children: [ &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;../views/login/index.vue&#x27;) &#125;, ] &#125;,]var router = createRouter(&#123; history: createWebHashHistory(), routes&#125;)export default router 在 mian.ts 对象中 通过 import 引入，并用 Vue 的 use 方法 注册到 Vue 实例上 12import router from &#x27;./router&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;) 使用 Vue 状态管理工具 Vuex 123456789101112131415161718192021222324// 安装npm install vuex@next// 使用// /src/store/index.tsimport Vuex from &#x27;vuex&#x27;const store = new Vuex.Store(&#123; // ... modules: &#123;&#125;, state: () =&gt; &#123; return &#123; name: &#x27;lxx&#x27; &#125; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;)export default store// 注册import store from &#x27;./store&#x27;createApp(App).use(router).use(store).mount(&#x27;#app&#x27;) 使用 sass 语法 12345// 安装 sassyarn add sass// 安装完成之后 将 sass 从 dependencies 移动到 devDependencies// 使用时 在 style 后加 lang=&quot;scss&quot; 如果想要对 Vite 构建的 Vue3.0应用进行新的配置，首先需要在根目录创建一个 vite.config.js 文件 配置路径别名1234567891011const path = require(&quot;path&quot;)function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.export = &#123; alias: &#123; &#x27;/@/&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 此时访问 src 目录下的文件就可以通过 /@/来进行访问 12// 访问 src 目录下的 component 目录下的 index 文件import Component from &#x27;/@/component&#x27; 为什么要使用 /@/ 而不是直接 @/ 呢，在这里 Vite 的官方配置给我们做了解释 当别名为文件系统路径的时候，请使用绝对路径，相对别名值将按原样使用，并不会解析为文件路径，所有要使用 /@/ 来代表绝对路径","pubDate":"Fri, 15 Jan 2021 14:56:10 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/15/vue3-vite-typescript-01/","category":"vue3 vite ts"},{"title":"JavaScript 原型链","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/14/js-prototype-chain/","description":"当我们定义了一个函数或者对象的时候，自带有属性中有一个属性 __proto__，这个属性又被称作原型链，指向构造当前函数的 prototype 1234567function Test() &#123; this.a = 1&#125;const test = new Test()console.log(test.__proto__) // &#123;constructor: f&#125;console.log(Test.prototype) // &#123;constructor: f&#125;console.log(test.__proto__ === Test.prototype) // true 当我们继续打印 Test.prototype.__proto__ 的时候会发现 Test 的构造函数是 Object，即 1console.log(Test.prototype.__proto__ === Object.prototype) // true 这个时候就会发现有些特殊的事情，当我们在 Test 的 prototype 属性上添加一些属性或者 Object 的 prototype 上添加一些属性，这时通过 new 构造出来的实例能不能访问到这些属性或者方法呢，接下来让我们尝试一下 12345678910111213141516171819202122 function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 console.log(test.a) // 1 console.log(test.b) // 3 console.log(test.c) // 4~~~~这个时候如果我们在 test 实例上新增一个属性 b 并赋值，这时侯打印出来的 test.b 的值是多少呢~~~js function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 test.b = 5 console.log(test.b) // b 这是因为 使用 new 构造函数的时候，会自动继承构造函数上的所有方法及属性，当我们在访问实例的某个属性的时候，会现在实例对象上查找是否包含有这个属性，如果包含就直接返回，不包含的话就会在实例的原型链 __proto__ 上继续查找，如果仍未找到，则会继续通过 __proto__一级一级的向上查找，直到找到 原型链的最后一级 Object,如果仍未找到就返回 undefined constructor 在实例的自身属性及 __proto__ 属性上有一个 contructor 属性，该属性指向 构造当前实例的 构造函数 1234567function Test() &#123; this.a = 1&#125;const test = new Test()// 这是因为 使用 new 构造函数的时候 把 Test 的所有属性都赋予了 testtest.__proto__.constructor // f Test() &#123;this.a = 1&#125;test.constructor // f Test() &#123;this.a = 1&#125; 判断是否包含属性 如何判断 实例的属性 是在实例自身身上还是在原型链上呢，这时候可以通过 Object.hasOwnProperty 123456789101112function Test() &#123; this.a = 1&#125;const test = new Test()Test.prototype.b = 3Object.prototype.c = 4console.log(test.hasOwnProperty(&#x27;a&#x27;)) // trueconsole.log(test.hasOwnProperty(&#x27;b&#x27;)) // falseconsole.log(test.hasOwnProperty(&#x27;c&#x27;)) // falseconsole.log(&#x27;a&#x27; in test) // trueconsole.log(&#x27;b&#x27; in test) // trueconsole.log(&#x27;v&#x27; in test) // true 属性 b 和 c 是挂载到 test 的原型链上的属性，并不属于 test 自身，所以通过 Object.hasOwnProperty 访问的时候返回为 false 特殊的原型 Object 和 Function 123Function.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // trueObject.__proto__ === Function.__proto__ // true","pubDate":"Thu, 14 Jan 2021 14:57:43 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/14/js-prototype-chain/","category":"JavaScript"},{"title":"JavaScript - this 指向问题","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/11/js-this-point/","description":"this 的指向问题一直是 JavaScript 中一个很重要的问题，我们在日常编程中，经常会遇到在函数中执行的时候，发现从 this 中取不到我们想要的东西，面试的过程中，this 也是经常会被面试官问到的一个问题。 接下来，我们将会在此篇文章中详细的讲解一个 JavaScript 中 this 的获取及指向问题 this 指向在 JavaScript 中一个特殊的关键字 this，通过 this 我们可以获取当前代码块执行环境的对象 我们可以通过 this.xxx 来获取到 this 所代表的对象的属性 this 取何值，取决于 this 所处代码块为谁调用的 总结一下 this 指向几种情况 普通函数调用的时候，this 指向 window 又称作默认绑定 来看下面这一段代码 123456var name = &#x27;zhangsan&#x27;function fn() &#123; var name = &#x27;lisi&#x27; console.log(this.name)&#125;fn() 猜一下上述代码 输出的 name 是什么？ 对的，输出的 zhangsan，也许你会问为什么 函数 fn 里面的 this 不是指向函数 fn，这是因为在全局中通过 var 创建的变量也会默认挂载在 window 对象中， 调用 fn() 函数的时候，直接调用相当于 window.fn()，此时 this 指向调用函数 fn 的对象 即 window，所以输出的是 zhangsan。 需要注意一点的是，这段代码在浏览器执行和在 node 环境在执行输出的结果是不一样，因为在 node 环境中 全局对象是 global，而不是 window。 通过对象方法调用的时候，函数的 this 指向这个对象 又称作隐式绑定 我们对以上代码再次进行改装 12345678910var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: function() &#123; console.log(this.name) &#125;&#125;var fn = obj.fnobj.fn()fn() 上述代码输出的是什么呢？可能有会说输出的都是 lisi，因为函数 fn 位于 obj 对象里，所以它的 this 指向 obj，但是我们想说这是一种错误的理解方式，因为 this 的指向不是由他位于哪个代码块中决定，而是由它所在的代码块由谁调用来决定。 我们知道函数在执行之前都会经过解析，然后在栈内存中存放解析后的键值对，当解析到 obj 的时候，因为 obj 的类型是 Object 所以会在栈内存中开辟一个新的栈内存，用来存储 obj 的键值对，然后将新建的栈内存通过引用赋予 obj，当解析到 obj 的 fn 函数的时候，同样会开辟一个新的栈内存 AAAFFF000，这个栈内存用来存放 fn 的函数字符串 当我们通过 obj 来调用的时候，可以理解为 AAAFFF000 这个栈内存 上下文对象是 obj， 此时通过 this 调用的时候，this 指的就是 obj 这个对象 而将 obj.fn 赋值于 fn 的时候，由于 obj.fn 是一个引用对象，所以将 obj.fn 的引用地址复制给了 fn，然后调用 fn 相当于在 window 的环境下执行 AAAFFF000 这个代码块，此时的 this 指向 window 所以输出的是 12// &#x27;lisi&#x27;// &#x27;zhangsan&#x27; 接下来我们对这段代码进行进一步改造，然后看一下它的执行结果 12345678910111213var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: (function() &#123; console.log(this.name) return function() &#123; console.log(this.name) &#125; &#125;)()&#125;var fn = obj.fnobj.fn()fn() 你猜到这段代码输出的结果了吗？ 这段代码输出的结果是 123// &#x27;zhangsan&#x27;// &#x27;lisi&#x27;// zhangsan 大家看 obj 对象中的 fn 函数，这个函数是一个自执行函数，会在解析的时候就执行，这个时候上下文对象是 window，所以输出的是 ‘zhangsan’ 然后返回一个函数，此时这个 obj.fn 就等于这个 return 回来的函数 后面的输出的数据执行方法和上一个例子是一样的，这里就不在多做赘述 特殊的例子: 回调函数模式 123456789function foo() &#123; function test() &#123; console.log(this) &#125; return test&#125;foo()() // window// 因为 foo() 执行的相当于返回了 test 再一次调用和调用 test() 方法相等// foo()() === test() 特殊情况：参数赋值的情况 首先上代码 123456789101112var a = 3function foo() &#123; console.log(this)&#125;function bar(fn) &#123; fn()&#125;var obj = &#123; a: 2, foo: foo&#125;bar(obj.foo) // window 在 bar 函数中， fn 为形参，在调用 bar 函数传入 obj.foo 实参的时候，实际上相当于隐形的将 obj.foo 赋值于 fn，fn进行调用的时候，正好符合 this 的默认绑定规则，此时 this 指向 window 总结起来就一句话 函数每次执行的都会有自己的 this 指向，函数单独调用的时候(包括自调用函数)，this 执行 window，以对象的方法调用时候，this 隐式绑定为 该对象 显示绑定 call，bind，apply bind,call,apply都可以改变函数的 this 指向 1234567891011var obj = &#123; a: 1&#125;var a = 2function test() &#123; console.log(this.a)&#125;test() // 2test.call(obj) // 1test.bind(obj) // 1test.apply(obj) // 1 其中 call 和 apply 在改变 this 指向的时候会自动调用函数，而 bind 只会改变 this 指向并不会执行函数 call 和 bind 是可以传入多个参数 call(this, arg1, arg2, …), apply 多个参数需要放到数组里面 apply(this, [arg1, arg2, arg3…]) 通过构造函数 new 关键字创建的，this 指向实例对象 在通过 new 关键字构造函数时，主要做了以下四件事 首先创建了一个空对象 然后连接到原型，将 obj 的 __proto__ 指向构造函数的 prototype123class A &#123;&#125;var a = new A()a.__proto__ === A.prototype 通过 .call(obj) 将 function 的 this 指向 obj 返回创建的这个对象 123456function Fn() &#123; console.log(this) this.a = 1&#125;var fn = new Fn() // Fn&#123;&#125;console.log(fn.a) // 1 如果 Fn 函数 中 return 了一个对象 obj，new 的时候 this 会指向这个 obj对象 1234567function Fn() &#123; console.log(this) this.a = 1 return &#123;&#125;&#125;var fn = new Fn() // &#123;&#125;console.log(fn.a) // undefined 通常来说，优先级的顺序大概是 new &gt; call/bind/apply &gt; 隐式绑定 &gt; 默认绑定 12345678910111213141516var a = &#x27;window&#x27;function test() &#123; console.log(this.a)&#125;var obj = &#123; a: &#x27;obj’, test: test&#125;var obj2 = &#123; a: &#x27;obj2&#x27;&#125;test() // windowtest.call(obj) // objobj.test.call(obj2) // obj2new obj.test() // undefined this 指向 test&#123;&#125; 特殊的 this 指向es6 的箭头函数 先来看一下普通函数的 this 指向 123456789function b() &#123; function a()&#123; console.log(this) &#125; let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()// &#123;a: fn(), c:fn()&#125; obj2.c()// window&#125;let obj = &#123;b&#125;obj.b()//使函数b内上下文this为obj 如果加上箭头函数 123456789function b() &#123; let a = () =&gt; console.log(this) let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()//&#123;b: fn()&#125; obj2.c()//&#123;b: fn()&#125;&#125;let obj = &#123;b&#125;obj.b()//&#123;b:fn()&#125; 从上面的例子可以看出，箭头函数在调用的时候，指向声明的时候所在的上下文 也可以说 箭头函数 是没有 this，他的 this 全由所处上下文对象的 this 指向决定，一旦this 指向确定，无法通过 new/call/bind/apply/隐式绑定/显示绑定等方法修改this指向","pubDate":"Mon, 11 Jan 2021 01:30:46 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/11/js-this-point/","category":"JavaScript"},{"title":"跟着 Vue源码学习 Vue api 系列 (一) - 全局配置","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/09/vue-learn-api-with-%E6%BA%90%E7%A0%81-01/","description":"此篇文章用来记录 Vue 中 Api 在 Vue源码中的具体实现方法，以便更好的理解 Vue 的各种 Api 的使用方法 全局配置Vue 的全局配置参数是存放在 config 里面的，我们可以通过修改 config 中的 properties 1234567891011121314151617181920212223Config = &#123; // user optionMergeStrategies: &#123; [key: string]: Function &#125;; silent: boolean; productionTip: boolean; performance: boolean; devtools: boolean; errorHandler: ?(err: Error, vm: Component, info: string) =&gt; void; warnHandler: ?(msg: string, vm: Component, trace: string) =&gt; void; ignoredElements: Array&lt;string | RegExp&gt;; keyCodes: &#123; [key: string]: number | Array&lt;number&gt; &#125;; // platform isReservedTag: (x?: string) =&gt; boolean; isReservedAttr: (x?: string) =&gt; boolean; parsePlatformTagName: (x: string) =&gt; string; isUnknownElement: (x?: string) =&gt; boolean; getTagNamespace: (x?: string) =&gt; string | void; mustUseProp: (tag: string, type: ?string, name: string) =&gt; boolean; // private async: boolean; // legacy _lifecycleHooks: Array&lt;string&gt;;&#125; 1. silent Boolean silent 配置 主要用于判断是否输出 Vue 所有的日志和警告 默认为 false 不取消日志和警告输出 设置为 true 取消日志和警告输出12345var hasConsole = typeof console !== &#x27;undefined&#x27;;// hasConsole 用于判断 window对象中 是否包含有 console 这个属性if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace));&#125; 2. optionMergeStrategies Object 自定义选项合并策略，覆盖已有值 主要用于 mixin 和 Vue.extend() 方法时对子组件和父组件 有相同属性时的合并策略 以下的 parentVal，parent 等父参数 只有 Vue.extend 或者 extends 传入对应类型数据时才有数据 Vue源码 自带的属性 el，propsData，provide 子组件和父组件如果有相同的方法，以子组件为主 el propsData12345678910111213141516var defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal&#125;;strats.el = strats.propsData = function (parent, child, vm, key) &#123; if (!vm) &#123; warn( &quot;option \\&quot;&quot; + key + &quot;\\&quot; can only be used during instance &quot; + &#x27;creation with the `new` keyword.&#x27; ); &#125; // 在这里进行了判断，如果 child 存在 就返回 child 否则返回 parent // 表明在合并的过程中 el 和 propsData 以子的为准 return defaultStrat(parent, child)&#125;; provide strats.provide = mergeDataOrFn; data123456789101112131415161718function (parentVal, childVal, vm ) &#123; // childVal 是 组件的 data 函数 if (!vm) &#123; // 判断 vue 的 data 对象是一个函数 保证各个组件之间的数据互不影响 if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &#x27;that returns a per-instance value in component &#x27; + &#x27;definitions.&#x27;, vm ); // 如果子的值不是函数 返回父的值 return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125;; margeDataOrFn 方法1234567891011121314151617181920212223242526272829303132333435363738// 合并数据function mergeDataOrFn (parentVal, childVal, vm) &#123; if (!vm) &#123; // in a Vue.extend merge, both should be functions if (!childVal) &#123; return parentVal &#125; if (!parentVal) &#123; return childVal &#125; // when parentVal &amp; childVal are both present, // we need to return a function that returns the // merged result of both functions... no need to // check if parentVal is a function here because // it has to be a function to pass previous merges. return function mergedDataFn () &#123; return mergeData( typeof childVal === &#x27;function&#x27; ? childVal.call(this, this) : childVal, typeof parentVal === &#x27;function&#x27; ? parentVal.call(this, this) : parentVal ) &#125; &#125; else &#123; return function mergedInstanceDataFn () &#123; // instance merge var instanceData = typeof childVal === &#x27;function&#x27; ? childVal.call(vm, vm) : childVal; var defaultData = typeof parentVal === &#x27;function&#x27; ? parentVal.call(vm, vm) : parentVal; if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125; &#125;&#125; margeData 方法set方法详解1234567891011121314151617181920212223242526272829function mergeData (to, from) &#123; if (!from) &#123; return to &#125; var key, toVal, fromVal; // 判断是否有 Symbol 数据类型，避免合并数据的时候遗漏 Symbol 类型属性 // Reflect.ownKeys(obj) 可以遍历出 Symbol 类型属性 // Object.keys,Object.values 无法遍历出 Symbol 类型属性 var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from); for (var i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; // in case the object is already observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; toVal = to[key]; fromVal = from[key]; if (!hasOwn(to, key)) &#123; set(to, key, fromVal); &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal); &#125; &#125; return to&#125; watch12345678910111213141516171819202122232425function (parentVal, childVal, vm, key) &#123; // work around Firefox&#x27;s Object.prototype.watch... if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125; if (childVal === nativeWatch) &#123; childVal = undefined; &#125; /* istanbul ignore if */ if (!childVal) &#123; return Object.create(parentVal || null) &#125; &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; // parent 存在 则和 child 合并，否则判断 child 是否是数组，返回 数组 ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret&#125;; hooks，watch 会把子组件和父组件相同的钩子函数合并到一个数组上，父组件的钩子函数先执行 声明周期函数(在此不一一列举了)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var LIFECYCLE_HOOKS = [ &#x27;beforeCreate&#x27;, &#x27;created&#x27;, &#x27;beforeMount&#x27;, &#x27;mounted&#x27;, &#x27;beforeUpdate&#x27;, &#x27;updated&#x27;, &#x27;beforeDestroy&#x27;, &#x27;destroyed&#x27;, &#x27;activated&#x27;, &#x27;deactivated&#x27;, &#x27;errorCaptured&#x27;, &#x27;serverPrefetch&#x27;];LIFECYCLE_HOOKS.forEach(function (hook) &#123; strats[hook] = mergeHook;&#125;);// 使用方法function mergeHook (parentVal, childVal) &#123; /** * 下面这个三目表达式可以拆分成下列样式 * var test1 = Array.isArray(childVal) ? childVal : [childVal] * var test2 = parentVal ? parentVal.concat(childVal) : test1 * var test3 = childVal ? test2 : parentVal * 如果 childVal 存在，就执行 test2 语句 不存在 则取 parentVal * test2 语句中 如果 parentVal 存在， 则与 childVal 连接成一个新数组 否则执行 test1 语句 * test1 语句中 如果 childVal 是数组 就取 childVal 否则就转成数组 */ var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal; // 对 获得的 res 进行去重 return res ? dedupeHooks(res) : res&#125;function dedupeHooks (hooks) &#123; var res = []; for (var i = 0; i &lt; hooks.length; i++) &#123; // 如果 res 数组中不存在 hooks[i],就插入 hooks[i] 否则略过 if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]); &#125; &#125; return res&#125; component directive filter123456789101112function mergeAssets (parentVal, childVal, vm, key) &#123; // 以 parentVal 为原型 创建对象 res.prototype === parentVal var res = Object.create(parentVal || null); if (childVal) &#123; //判断 childVal 的类型 assertObjectType(key, childVal, vm); // 通过 extend 方法将 childVal 的属性复制到 res 上 并覆盖相同属性的数据 return extend(res, childVal) &#125; else &#123; return res &#125;&#125; components，directives，filters 使用了原型继承，返回合并后的新对象 props methods inject computed 1234567891011function (parentVal, childVal, vm, key) &#123; if (childVal &amp;&amp; &quot;development&quot; !== &#x27;production&#x27;) &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = Object.create(null); // 合并 parentVal 和 childVal extend(ret, parentVal); if (childVal) &#123; extend(ret, childVal); &#125; return ret&#125;; props，methods，computed，inject 采用对象合并的方法，先合并父组件，在合并子组件，如果父组件和子组件有相同的属性，子组件会覆盖父组件的属性 简单的使用示例 1234567891011121314151617181920212223242526272829303132Vue.config.optionMergeStrategies._myOptions = (parntVal, childVal, vm) =&gt; &#123; console.log(parntVal, childVal, vm) return parntVal ? childVal ? childVal + parntVal : 0 : childVal &#125;const B = &#123; _myOptions: 3&#125;const C = &#123; _myOptions: 3&#125;Vue.component(&#x27;test&#x27;, &#123; mixins: [B,C], data() &#123; return &#123; test: 1 &#125; &#125;, _myOptions: 2, mounted() &#123; console.log(this.$options._myOptions) // 8 &#125;, template: `&lt;div&gt; children &lt;/div&gt;`&#125;)const app = new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; test &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `&#125;) devtools 12// detect devtoolsvar devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__; errorHandler 默认是 undefined 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 123Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, err, vm, info)&#125; 源码位置1234567891011121314function globalHandleError (err, vm, info) &#123; if (config.errorHandler) &#123; try &#123; return config.errorHandler.call(null, err, vm, info) &#125; catch (e) &#123; // if the user intentionally throws the original error in the handler, // do not log it twice if (e !== err) &#123; logError(e, null, &#x27;config.errorHandler&#x27;); &#125; &#125; &#125; logError(err, vm, info);&#125; warnHandler 默认值是 undefined，只会在开发环境下生效，生产环境下会被忽略 123Vue.config.warnHandler = (msg, vm, trace) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, msg, vm, trace)&#125; 源码12345678warn = function (msg, vm) &#123; var trace = vm ? generateComponentTrace(vm) : &#x27;&#x27;; if (config.warnHandler) &#123; config.warnHandler.call(null, msg, vm, trace); &#125; else if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace)); &#125;&#125;; ignoredElements Array 默认是一个空字符串，是一个由 字符串或者正则表达式组成的数组 作用是为了屏蔽 Vue 的组件验证的时候，自定义组件(Web Components API)报错提示功能，匹配到数组里面的组件名称的时候，会过滤掉提示 1234567Vue.config.ignoredElements = [ &#x27;my-custom-web-component&#x27;, &#x27;another-web-component&#x27;, // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 源码位置 123456789101112131415function isUnknownElement$$1 (vnode, inVPre) &#123; return ( !inVPre &amp;&amp; !vnode.ns &amp;&amp; !( config.ignoredElements.length &amp;&amp; config.ignoredElements.some(function (ignore) &#123; return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag &#125;) ) &amp;&amp; config.isUnknownElement(vnode.tag) )&#125; keyCodes {[key: string]: number | Array} 给 v-on 自定义键位别名123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 &quot;media-play-pause&quot;: 179, up: [38, 87]&#125; 123&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;&lt;input type=&quot;text&quot; @keyup.179=&quot;method&quot;&gt;&lt;!-- 以上两种方法等效 --&gt; performance boolean 默认为 false 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪 productionTip boolean 默认为 true， 设置为 false 阻止 vue 在启动时生成生产提示信息","pubDate":"Sat, 09 Jan 2021 14:17:53 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/09/vue-learn-api-with-%E6%BA%90%E7%A0%81-01/","category":"Vue源码"},{"title":"Vue 组件之间通讯的各种情况","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/07/vue-components-transfer-data/","description":"我们都知道 Vue 的两大核心是组件化和数据驱动，在 Vue 中，组件之间的值传递是一种十分常见的事情，那么你到底知道多少种组件的值传递的方法呢，接下来由我来带领大家了解一下 Vue 组件之间的关系Vue 的组件根据其在页面上的位置，我认为大致可以分为以下几种: 父子组件 什么是父子组件呢？ 假如现在页面中有一个根组件ParentComponent,现在我们需要在这个根组件中加入其他内容，例如一张图片，一段具有事件和样式的文字等，我们可以假设这个加入内容的组件名称为ChildrenComponent, 这个新加入的组件ChildrenComponent 相对与 ParentComponent就是子组件, ParentComponent 就是 ChildrenComponent 的父组件，如下所示 123&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 兄弟组件 什么是兄弟组件呢？以上面的父子组件为例，假如现在加入的不是一个组件，而是加入多个组件，加入的这些组件之间的关系就是兄弟组件的关系 12345&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 非父子，兄弟关系的组件 这种组件的关系是怎么形成的呢，可能就是位于不同父组件下的子组件之间的关系 1234&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt;&lt;other-component&gt;&lt;/other-component&gt; 比如这种，children-component 和 other-component 之间的关系都是即非父子，兄弟关系组件 当然以上说法都不是特别组件，因为 Vue 是一个单页面组件，都位于同一个根组件下面，所以 Vue 中的组件之间都或多或少都是有一些关系 Vue 组件之间的通讯上面介绍完了组件，我们现在介绍一下不同组件之间应该如何通讯 父子组件 Vue 组件上有个特殊的属性 Props 可以取到通过 v-bind指令或者直接通过 属性 传值 传递过来参数，通常用于父子组件传值 123&lt;parent-component&gt; &lt;children-component :type=&quot;type&quot; name=&quot;name&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 此时子组件可以通过 props 来获取父组件传递过来的参数 123456789101112131415161718// children-componentexport default &#123; // 第一种 (不推介，因为没有类型检测，不利于开发) props: [&#x27;type&#x27;, &#x27;name&#x27;], // 第二种 (推介，可以检查通过 props 传递过来值的类型，利于排错和开发) props: &#123; type: &#123; type: Array, // 如果需要兼容多重类型检查可以使用数组 [Array, Object, String] default: () =&gt; &#123; return [] &#125; &#125;, name: &#123; type: String, default: &#x27;&#x27; &#125; &#125;&#125; 子组件向父组件传值可以采用 $emit() 来发送事件，父组件采用 v-on 来监听事件发生 123456// 子组件export default &#123; mounted() &#123; this.$emit(&#x27;change&#x27;) &#125;&#125; 1234&lt;parent-component&gt; &lt;!-- v-on: 也可以简化成 @ --&gt; &lt;children-component v-on:change=&quot;handleChange&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 当然我们也可以采用 v-model 来传递参数，但是此时子组件必须要用 props 接收 一个名叫 value 的值，当事件触发时，把新的值通过自定义的 input 事件抛出 因为 v-model 等价 v-bind:value 和 v-on:input $parent 和 $children 也可以实现父子组件之间传值 但是 Vue 并不推介我们使用这种方法来进行父子组件传值通讯，只是作为访问组件的应急方法，更推介采用 props 和events($emit,$on) 父子组件之间也可以通过 $refs 方法来进行通讯 在子组件上添加属性 ref 值为 refValue, 父组件可以通过 this.$refs[refValue] 或者 this.$refs.refValue 来访问和调用子组件上面的方法和值 注意： 使用 $ref 获取子组件必须是子组件已经在页面中加载成功了，即在 除beforeCreate, created, destoryed 生命周期函数以外的其他声明周期调用，如果组件是手动控制显示和隐藏，即使用 v-if，此时可以采用 this.$nextTick(() =&gt; &#123;this.$refs[refValue]&#125;) 方法来访问子组件的方法 兄弟组件之间的传值 通过共有的父组件来进行传值 子组件通过 $emit 方法调用父组件的方法，然后通过父组件来调用其他的子组件来实现兄弟组件之间之间传值 通过 $parent 方法 同父子组件传值，可以使用，但是不推介 非父子，兄弟关系的组件 Vuex Vue 状态管理工具 可以使用 Vue 的状态管理工具来进行传值 123456789101112131415161718192021222324252627282930313233// store.js/** * state: 存储状态管理对象及数据 * mutations: 同步修改 state 的属性的值，同时只有 mutations 能够修改 state 的值 使用时通过 commit 来调用 * actions: 异步修改 state 的属性的值，通过调用 mutations 的方法来修改 通过 dispatch 方法调用 */ export default &#123; state: &#123; type：1 &#125;, mutations: &#123; setType(state, type) &#123; state.type = type &#125;, &#125;, actions: &#123; setType(&#123;commit&#125;, type) &#123; commit(&#x27;setType&#x27;, type) &#125; &#125;&#125;// a 组件export default &#123; mounted() &#123; this.$store.dispatch(&#x27;setType&#x27;, 1) &#125;&#125;// b 组件export default &#123; mounted() &#123; this.$store.state.type &#125;&#125; 关于 Vuex 的更多使用方法请百度查找官方使用文档 Vue bus 也叫中央事件总线 定义一个全局的 Vue，通过挂载到 window 对象或者 Vue 实例上面，此时可以通过 Vue bus 的 $emit 和 $on 方法来进行事件传递 123456789101112// 第一种var bus = new Vue()// 发送事件bus.$emit(&#x27;patch&#x27;)// 接收事件bus.$on(&#x27;patch)// 第二种 Vue.$bus = new Vue()// 发送事件Vue.$bus.$emit(&#x27;patch&#x27;)// 接收事件Vue.$bus.$on(&#x27;patch) 进阶方法以上都是一些比较简单的组件之间传值的方法，相信在座的各位基本上都用到过，接下来介绍一些比较高端的方法，这些方法我们可能没有用过，也可能没有听说过，接下来让我来带领大家去了解他们，使用他们 $attrs 和 $listeners 此方法适用于多层父子组件结构进行通讯，因为层级过多，此时使用 $emit 和 $on 方法来进行传值，你需要在需要通讯的两个祖孙组件之间的每个组件都要写上重复的 $emit 和 $on, 增加事件追踪难度，同时难以阅读 此时可以采用 $attrs 和 $listeners来进行传值 这种方法所采用的办法就是将祖父组件的 传给 父组件的 属性和监听事件传递给孙组件 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 函数我就不写了，只是做一个简略的展示 --&gt; &lt;!-- grandfather 组件 --&gt; &lt;grand-father&gt; &lt;a-parent :a=&quot;a = 4444&quot; :b=&quot;b = 5555&quot; @getData=&quot;handleGetData&quot; @passData=&quot;handlePassdata&quot;&gt;&lt;/a-parent&gt; &lt;/grand-father&gt; &lt;!-- parent 组件 --&gt; &lt;a-parent&gt; &lt;b-children v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/b-children&gt; &lt;/a-parent&gt; &lt;script&gt; ... // 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 props:[] // 注意如果在此处使用了props接收了参数， 则通过 v-bind 传递给子组件的 $attrs 中就会缺失对应参数 mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; ... &lt;/script&gt; &lt;!-- children 组件 --&gt; &lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt; &lt;script&gt; ... mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时 props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; // a 的值 也可以通过 $emit 方法传递给祖组件 console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; methods: &#123; passData(val) &#123; // 此处发送的事件名称需要与祖组件监听方法一致 即 @passData this.$emit(&#x27;passData&#x27;, val) &#125; &#125; ... &lt;/script&gt; provide 和 inject 父组件通过 provide 提供变量，子组件通过 inject 注入变量，不管子组件多深，只要调用了 inject 就可以注入 provide 中的数据，而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用 123456789101112131415161718192021222324&lt;!-- grandfather 组件 --&gt;&lt;grand-father&gt; &lt;a-parent&gt;&lt;/a-parent&gt;&lt;/grand-father&gt;&lt;script&gt; ... provide: &#123; test: &#x27;test&#x27; &#125; ...&lt;/script&gt;&lt;!-- parent 组件 --&gt;&lt;a-parent&gt; &lt;b-children&gt;&lt;/b-children&gt;&lt;/a-parent&gt;&lt;!-- children 组件 --&gt;&lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt;&lt;script&gt; ... inject:[&#x27;test&#x27;] ...&lt;/script&gt; boradcast 和 dispatch 这种方法我不太了解，贴上代码，大家自己体会 (＾－＾) vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和emit的封装，但在一些基础组件中却很实用。 123456789101112131415161718192021222324252627282930313233function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;","pubDate":"Thu, 07 Jan 2021 13:11:23 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/07/vue-components-transfer-data/","category":"Vue"},{"title":"面试题解析 - other people","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3-other-from-internat/","description":"在公众号看到了一位大佬分享的自己的多家大公司的面试经历，看了一遍面试问题，深感自己在各方面的不足，所以诞生了这篇文章，分析一下大佬的面试题以及答案 公众号原文转载地址 掘金原文地址 原生js怎么实现拖放 answer: 首先给要实现的拖拽的元素的 draggable 属性设置为true 使用时间监听 addEventListener 监听元素的 dragstart, dragend, dragover, dragleave, dragenter, drop 等事件 dragstart 被拖动的元素，开始拖放触发 dragend 拖放的对象元素，拖放操作结束 dragover 拖放过程中鼠标经过的元素，被拖放的元素正在本元素范围内移动(一直) dragleave 拖放过程中鼠标经过的元素，被拖放的元素离开本元素范围 dragenter 拖放过程中鼠标经过的元素，被拖放的元素“开始”进入其它元素范围内（刚进入） drag 被拖放的元素，拖放过程中 drop 拖放的目标元素，其他元素被拖放到本元素中参考示例优化： 卡顿的话可以添加 css 属性，来使元素移动更加流畅 transition: tranform, opacity 0.5s,0.5s ease,ease react-dnd拖放的核心API参考文章未完待续 如何实现路由监听（vue） 组件内可以使用 watch 监听 $route 对象 全局监听路由 beforeEach, afterEach 组件内部监听路由变化 beforeRouteEnter, beforeRouteLeave, beforeRouteUpdate 路由的独享钩子函数 beforeEnter相关书籍连接 红宝书第四版js灵魂之问(上)js灵魂之问(中)js灵魂之问(下)css世界flex小青蛙flex阮一峰博客卡颂的react技术揭秘若川的源码系列难凉热血的vue源码分析数据结构与算法之美政采云团队的博客–算法篇天天的前端算法总结ssh的前端算法进阶指南修言算法小册谢希仁的计算机网络神三元的http灵魂之问浏览器专栏nginx笔记linux笔记","pubDate":"Wed, 06 Jan 2021 02:44:55 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AF%A6%E8%A7%A3-other-from-internat/","category":"面试"},{"title":"new Object() 和 Object.create() 的区别","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/04/deferent-in-new-Object-object-create/","description":"今天我们来谈一谈通过 new Object() 和 Object.create() 创造的对象有什么区别 首先这两个方法都可以用来创建一个对象 12345var a = new Object()var a = Object.create()// 或者var a = new Object(obj)var a = Object.create(obj) 但是这两个方法创建的对象是有一些不同 new Object() 创建的对象是通过构造函数创建的对象，添加的属性是在自身实例下面Object.create() 创建的对象可以理解为继承一个对象，添加的属性是在 __proto__ 属性下面 123456var a = &#123;a: 1&#125;var b = new Object(a)console.log(b) // &#123;a: 1&#125;var c = Object.create(a)console.log(c) // &#123;&#125;console.log(c.__proto__) // &#123;a: 1&#125; new Object() 创建空对象的时候也是有 __proto__ 原型链的Object.create() 创建空对象是没有 __proto__ 原型链的 123456var b = new Object()console.log(b) // &#123;&#125;console.log(b.__proto__) // &#123;a: 1&#125;var c = Object.create(a) // 此时有数据，不多描述console.log(c) // &#123;&#125;console.log(c.__proto__) // undefined 使用 Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) 创建的对象访问时，p的值不可修改，不可枚举 1234var c = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) // 此时有数据，不多描述console.log(c) // &#123;p: 42&#125;c = Object.create(&#123;&#125;, &#123;p: 42&#125;) // 此时会报错 VM587:1 Uncaught TypeError: Property description must be an object: 42 要求我们 p 的值 42，要放在一个对象中Object.keys(c) // []","pubDate":"Mon, 04 Jan 2021 12:46:00 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/04/deferent-in-new-Object-object-create/","category":"JavaScript"},{"title":"Vue keep-alive 组件状态缓存","link":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/04/vue-keep-alive/","description":"这段时间做项目时，老板要求要缓存一些页面的表单数据，于是想到了 vue 的 keep-alive ，在使用时，自己也犯了一些错误，在此记录一下 首次使用 在阅读文档的时候，没有理解文档的内容，keep-alive 组件，vue官方文档给的解释是 匹配首先检查组件自身的name选项，如果name选项不可用，则匹配他的局部注册名称，但是不知怎的被我理解成为了 路由配置的name属性，结果闹了一个大乌龙 然后，自己怎么测试都发现不能缓存页面状态，最后使用面向百度编程找到了自己的错误 如何使用 为了方便我们不用新增一个组件，就把组件的name添加到 keep-alive 组件中，在这里我采用了一个取巧的方法 保证组件的 name 属性与对应路由的 name 属性保持一致 提取我们所需要的路由对象 这个方法根据我们传入的路由名称 动态提取出我们需要的路由对象，而不是获取所有的路由对象 12345678910function handleGetRoutes(routeName) &#123; let routeObj = Object.create(null) asyncRoutes.map((item) =&gt; &#123; if (item.name === routeName) &#123; routeObj = item &#125; return item &#125;) return routeObj&#125; 通过递归的方法获取到所有的 name 属性 1234567891011121314151617const routes = handleGetRoutes(&#x27;Classify&#x27;)let includes = []this.handleGetRouteName(routes, includes)handleGetRouteName(obj, arr) &#123; if ( obj.children &amp;&amp; obj.children instanceof Array &amp;&amp; obj.children.length &gt; 0 ) &#123; const length = obj.children.length for (let i = 0; i &lt; length; i++) &#123; this.handleGetRouteName(obj.children[i], arr) &#125; &#125; arr.push(obj.name) &#125;, 最后在 keep-alive 组件中使用 123&lt;keep-alive :include=&quot;includes&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 其他用法 生命周期函数 activated,deactivated include include 表示只有匹配到的组件才会被缓存 exclude exclude 表示只有匹配到的组件才不会被缓存include和exclude允许组件有条件的缓存，有三种表示方式 1234567891011121314&lt;!-- 字符串 --&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 正则表达式 --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 数组 --&gt; &lt;keep-alive :include=&quot;[&#x27;a&#x27;,&#x27;b&#x27;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; max max 表示 最大缓存组件个数，缓存组件达到最大个数后，添加新的缓存组件，最久未被访问的实例会被销毁掉","pubDate":"Mon, 04 Jan 2021 09:35:02 GMT","guid":"https://lxxstar987.gitee.io/lxx1997.github.io/2021/01/04/vue-keep-alive/","category":"Vue"}]}