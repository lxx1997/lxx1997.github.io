{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Thu, 04 Aug 2022 14:22:40 GMT","lastBuildDate":"Fri, 05 Aug 2022 13:59:34 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"leetcode 百天解题 - day 17 - 1403. 非递增顺序的最小子序列","link":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","description":"题目名称给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。 示例输入：nums = [4,3,10,9,8] 输出：[10,9] 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 题解这道题其实只是一个简单难度的题，最开始没有仔细读题，看到子序列数组，以为是连续的，所以就采用滑动窗口的思路去做，结果提交的时候发现和用例不对。 然后仔细读了一下题发现以下重点 不强调元素在原数组中的连续性 和 答案应当按 非递增顺序 排列 这个时候思路就十分清晰了，既然答案需要按非递增序列排序，我们就先把传进来的数组按照非递增顺序排序，然后计算数组的和，从头开始遍历数组，将数组的每一项加起来和数组剩余的数进行对比，如果满足要求，则代表这一部分数组是我们要的结果，而且也不需要再去对比不同子序列的长度和和的大小，因为数组开头的元素是最大的，得到的子序列是一定满足最后的结果的 答案12345678910111213var minSubsequence = function(nums) &#123; nums = nums.sort((a,b) =&gt; b - a) let total = nums.reduce((total, item) =&gt; total += item, 0) let index = 0, mix = 0 for(let i = 0; i &lt; nums.length; i++) &#123; mix += nums[i] if(mix &gt; total - mix) &#123; index = i break; &#125; &#125; return nums.splice(0, index + 1)&#125;;","pubDate":"Thu, 04 Aug 2022 14:22:40 GMT","guid":"https://lxx1997.github.io/2022/08/04/handredday/leetcode/day-17-1403/","category":"leetcode"},{"title":"leetcode 百天解题 - day 16 - 16. 最接近的三数之和","link":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","description":"题目名称给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 示例输入：nums = [-1,2,1,-4], target = 1 输出：2 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 题解这道题其实和 12天的三数之和类似，如果采用粗暴的三次遍历的方式的话，提交结果测试的时候肯定是会发生超时的，所以这里还是采用双指针的方式 首先先判断长度，如果数组长度等于3，那么可以肯定的是这三个数的和就是我们需要的值 如果长度大于三，这个时候我们先把数组按照从小到大的顺序排列，然后针对第一个数进行 for 循环，另外两个数采用指针的方式进行循环，计算三个数的和，是否与target 最小，如果不是，根据差的正负值来判断是移动左指针还是右指针，最后返回最接近的值 答案123456789101112131415161718192021var threeSumClosest = function(nums, target) &#123; nums = nums.sort((a, b) =&gt; a - b) if(nums.length === 3) return nums.reduce((total, item) =&gt; total += item, 0) let mixSum = target, smallest = Infinity for(let i = 0; i &lt; nums.length - 2; i++) &#123; let total = nums[i] let left = i + 1, right = nums.length - 1 while(left &lt; right) &#123; let sum = total + nums[left] + nums[right] let deffer = target - sum, absDeffer = Math.abs(deffer) if(absDeffer &gt; smallest) &#123; deffer &lt; 0 ? right-- : left++ &#125; else &#123; smallest = absDeffer mixSum = sum deffer &lt; 0 ? right-- : left++ &#125; &#125; &#125; return mixSum;&#125;;","pubDate":"Wed, 03 Aug 2022 14:57:28 GMT","guid":"https://lxx1997.github.io/2022/08/03/handredday/leetcode/day-16-16/","category":"leetcode"},{"title":"leetcode 百天解题 - day 15 - 622. 设计循环队列","link":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","description":"题目名称设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。 你的实现应该支持如下操作： MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 isEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。 示例MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3 circularQueue.enQueue(1); // 返回 true circularQueue.enQueue(2); // 返回 true circularQueue.enQueue(3); // 返回 true circularQueue.enQueue(4); // 返回 false，队列已满 circularQueue.Rear(); // 返回 3 circularQueue.isFull(); // 返回 true circularQueue.deQueue(); // 返回 true circularQueue.enQueue(4); // 返回 true circularQueue.Rear(); // 返回 4 题解这道题主要考察队列的实现，这里的队列采用的先进先出原则，我们在这里可以使用数组来模拟，当我们添加一个元素的时候使用 Array.push 方法向数组末尾添加一个元素，删除元素时，使用 Array.shift 删除数组开始的元素模拟出队列的先进先出原则 答案123456789101112131415161718192021222324252627282930313233343536373839404142434445var MyCircularQueue = function(k) &#123; this.queue = [] this.length = k this.index = 0&#125;;MyCircularQueue.prototype.enQueue = function(value) &#123; if(this.index &lt; this.length) &#123; this.queue.push(value) this.index++ return true &#125; return false&#125;;MyCircularQueue.prototype.deQueue = function() &#123; if(this.index &gt; 0) &#123; this.queue.shift() this.index-- return true &#125; return false&#125;;MyCircularQueue.prototype.Front = function() &#123; if(this.index &gt; 0) &#123; return this.queue[0] &#125; return -1&#125;;MyCircularQueue.prototype.Rear = function() &#123; if(this.index &gt; 0) &#123; return this.queue[this.index - 1] &#125; return -1&#125;;MyCircularQueue.prototype.isEmpty = function() &#123; return this.index === 0&#125;;MyCircularQueue.prototype.isFull = function() &#123; return this.index === this.length&#125;;","pubDate":"Tue, 02 Aug 2022 13:15:19 GMT","guid":"https://lxx1997.github.io/2022/08/02/handredday/leetcode/day-15-622/","category":"leetcode"},{"title":"leetcode 百天解题 - day 14 - 1374. 生成每种字符都是奇数个的字符串","link":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","description":"题目名称给你一个整数 n，请你返回一个含 n 个字符的字符串，其中每种字符在该字符串中都恰好出现 奇数次 。 返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可 示例输入：n = 4 输出：”pppz” 解释：”pppz” 是一个满足题目要求的字符串，因为 ‘p’ 出现 3 次，且 ‘z’ 出现 1 次。当然，还有很多其他字符串也满足题目要求，比如：”ohhh” 和 “love” 题解这道题没有什么难点，可以取巧，如果输入的数是奇数，就可以全部输出同一个单词，输入为偶数时，可以是两个字母 答案123var generateTheString = function(n) &#123; return n % 2 === 1 ? new Array(n).fill(&quot;a&quot;).join(&quot;&quot;) : (new Array(n-1).fill(&quot;a&quot;).join(&quot;&quot;) + &quot;b&quot;)&#125;;","pubDate":"Mon, 01 Aug 2022 13:21:36 GMT","guid":"https://lxx1997.github.io/2022/08/01/handredday/leetcode/day-14-1374/","category":"leetcode"},{"title":"leetcode 百天解题 - day 13 - 1161. 最大层内元素和","link":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","description":"题目名称给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。 请返回层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。 示例输入：root = [1,7,0,7,-8,null,null] 输出：2 解释： 第 1 层各元素之和为 1， 第 2 层各元素之和为 7 + 0 = 7， 第 3 层各元素之和为 7 + -8 = -1， 所以我们返回第 2 层的层号，它的层内元素之和最大。 题解这道题主要考察树的广度优先遍历，将数一层一级的分割开来，然后分别计算每层的和，比较大小 答案123456789101112131415161718192021222324252627282930313233var maxLevelSum = function(root) &#123; let rootArr = changeTreeToArray([[root]]) let max = -Infinity, floor = 1 for(let i = 0; i &lt; rootArr.length; i++) &#123; let sum = getSum(rootArr[i]) if(max &lt; sum) &#123; max = sum; floor = i + 1 &#125; &#125; return floor&#125;;function getSum(arr) &#123; let total = 0 arr.forEach(item =&gt; &#123; total += item.val &#125;); return total&#125;function changeTreeToArray(arr, index = 0) &#123; let newArr = [], root = arr[index] for(let i = 0; i &lt; root.length; i++) &#123; let r = root[i] r.left &amp;&amp; newArr.push(r.left); r.right &amp;&amp; newArr.push(r.right) &#125; if(newArr.length === 0) return arr arr.push(newArr); index++ return changeTreeToArray(arr, index)&#125;","pubDate":"Sun, 31 Jul 2022 10:15:26 GMT","guid":"https://lxx1997.github.io/2022/07/31/handredday/leetcode/day-13-1161/","category":"leetcode"},{"title":"leetcode 百天解题 - day 12 - 15. 三数之和","link":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","description":"题目名称给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 题解这道题有几个点需要注意一下 最后返回的数据是去重后的数组，也就是说按照从小到大排列后，没有包含同样序列的子元素，数组去重同样是一个难点 注意执行时间，如果强行去循环的话，因为复杂度是 O(n^3),所以最后一定是会超时的 数组去重的话可以采用 Set 来存储得到的数组，不过需要把数组排序之后，转成字符串存放 循环的采用双指针的方式 在最开始先把原数组按照从小到大排列，这样我们就不必再对得到的结果进行排序操作，而且再循环时还可以排除第一个元素大于0的循环， 接下来采用双指针的方式，从数组的两端进行和的对比，因为第一个数的大小已经固定，所以只需要确保剩余两个数加上第一个数的和为0就可以了，如果和小于0，说明负数过大，所以左指针右移,如果和大于0，说明正数过大，所以右指针左移 最后将得到的结果数组转化成能够识别的内容 答案123456789101112131415161718192021var threeSum = function(nums) &#123; let sum = [], hash = new Set(); if(nums.length &lt; 3) return sum nums = nums.sort((a, b) =&gt; a - b) for(let i = 0; i &lt; nums.length - 2; i++) &#123; let first = nums[i] if(first &gt; 0) break; let l = i + 1, r = nums.length - 1 while(l &lt; r) &#123; let second = nums[l], third = nums[r] let s = first + second + third if(s &lt; 0)&#123; l++; continue;&#125;// 和小于0，说明负数过大，所以左指针右移，减少 if(s &gt; 0)&#123; r--; continue;&#125;// 和大于0，说明正数过大，所以右指针左移，减少 hash.add(`$&#123;first&#125;,$&#123;second&#125;,$&#123;third&#125;`) l++; r--; &#125; &#125; return Array.from(hash).map(item =&gt; item.split(&quot;,&quot;).map(item =&gt; +item))&#125;;","pubDate":"Sat, 30 Jul 2022 09:55:44 GMT","guid":"https://lxx1997.github.io/2022/07/30/handredday/leetcode/day-12-15/","category":"leetcode"},{"title":"leetcode 百天解题 - day 11 - 593. 有效的正方形","link":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","description":"题目名称给定2D空间中四个点的坐标 p1, p2, p3 和 p4，如果这四个点构成一个正方形，则返回 true 。 点的坐标 pi 表示为 [xi, yi] 。输入 不是 按任何顺序给出的。 一个 有效的正方形 有四条等边和四个等角(90度角)。 示例输入: p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,1] 输出: True 输入：p1 = [0,0], p2 = [1,1], p3 = [1,0], p4 = [0,12] 输出：false 输入：p1 = [1,0], p2 = [-1,0], p3 = [0,1], p4 = [0,-1] 输出：true 题解第一种方法我们可以知道正方形都是等边的，且四个角都是直角，因此随机选三个点，然后判断这三个点组成的三角形是否是等腰直角三角形 判断三个点是否是等腰三角形，只需要判断三个点之间的距离是否其中两个点与另一个点的距离相等，且两个点之间的距离是到另一个点距离的根号2倍 答案12345678910111213141516171819202122var validSquare = function(p1, p2, p3, p4) &#123; return checkTrangle(p1,p2,p3) &amp;&amp; checkTrangle(p4,p2,p3) &amp;&amp; checkTrangle(p1,p2,p4) &amp;&amp; checkTrangle(p1,p3,p4)&#125;;function checkTrangle(p1, p2, p3) &#123; let a = Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2) let b = Math.pow(p3[0] - p1[0], 2) + Math.pow(p3[1] - p1[1], 2) let c = Math.pow(p2[0] - p3[0], 2) + Math.pow(p2[1] - p3[1], 2) if(a === 0 || b === 0 || c === 0) return false let max= Math.max(a,b,c) if(max === c) &#123; return a === b &amp;&amp; a + b === c &#125; if(max === b) &#123; return a === c &amp;&amp; a + c === b &#125; if(max === a) &#123; return c === b &amp;&amp; c + b === a &#125; return false&#125;","pubDate":"Fri, 29 Jul 2022 14:38:01 GMT","guid":"https://lxx1997.github.io/2022/07/29/handredday/leetcode/day-11-593/","category":"leetcode"},{"title":"leetcode 百天解题 - day 10 - 1331. 数组序号转换","link":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","description":"题目名称给你一个整数数组 arr ，请你将数组中的每个元素替换为它们排序后的序号。 序号代表了一个元素有多大。序号编号的规则如下： 序号从 1 开始编号。一个元素越大，那么序号越大。如果两个元素相等，那么它们的序号相同。每个数字的序号都应该尽可能地小。 示例输入：arr = [40,10,20,30] 输出：[4,1,2,3] 题解这个就相对来说较为简单了 首先针对原数组进行去重操作后，得到一个新的数组，然后在对这个不包含重复元素的数组进行从小到大排序 然后对原数组进行遍历操作，针对每一个原数组的元素，找到其在排序后的数组中的位置，替换原数组对应元素位置，最后的得到的新数组就是，原数组的数组序号转换 答案1234var arrayRankTransform = function(arr) &#123; let arrSort = Array.from(new Set(arr)).sort((a, b) =&gt; a - b) return arr.map(item =&gt; arrSort.indexOf(item) + 1)&#125;;","pubDate":"Thu, 28 Jul 2022 14:48:43 GMT","guid":"https://lxx1997.github.io/2022/07/28/handredday/leetcode/day-10-1331/","category":"leetcode"},{"title":"leetcode 百天解题 - day 09 - 592. 分数加减运算","link":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","description":"题目名称给定一个表示分数加减运算的字符串 expression ，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。 示例输入: expression = “-1/2+1/2”输出: “0/1” 输入: expression = “-1/2+1/2+1/3”输出: “1/3” 输入: expression = “1/3-1/2”输出: “-1/6” 题解死办法，把分子分母单独提取出来，进行数值运行，最后提取出公约数后，将分子分母简化到最简 分数的加减法则x1/y1 + x2/y2 = (x1y2+x2y1)/y1y2x1/y1 - x2/y2 = (x1y2-x2y1)/y1y2 最大公约数用a和b求余，如果余数为0，则最大公约数为b，否则用 b 与 a%b 的进行求余比较，最后当余数为0时，剩余的数则是这两个数的最大公约数 答案1234567891011121314151617181920212223242526272829303132333435363738394041424344454647var fractionAddition = function(expression) &#123; let denominator = 0, numerator = 1; // 分子，分母 let index = 0, n = expression.length; while (index &lt; n) &#123; // 读取分子 let denominator1 = 0, sign = 1; if (expression[index] === &#x27;-&#x27; || expression[index] === &#x27;+&#x27;) &#123; sign = expression[index] === &#x27;-&#x27; ? -1 : 1; index++; &#125; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; denominator1 = denominator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator1 = sign * denominator1; index++; // 读取分母 let numerator1 = 0; while (index &lt; n &amp;&amp; isDigit(expression[index])) &#123; numerator1 = numerator1 * 10 + expression[index].charCodeAt() - &#x27;0&#x27;.charCodeAt(); index++; &#125; denominator = denominator * numerator1 + denominator1 * numerator; numerator *= numerator1; &#125; if (denominator === 0) &#123; return &quot;0/1&quot;; &#125; const g = gcd(Math.abs(denominator), numerator); // 获取最大公约数 return Math.floor(denominator / g) + &quot;/&quot; + Math.floor(numerator / g);&#125;const gcd = (a, b) =&gt; &#123; let remainder = a % b; while (remainder !== 0) &#123; a = b; b = remainder; remainder = a % b; &#125; return b;&#125;;const isDigit = (ch) =&gt; &#123; return parseFloat(ch).toString() === &quot;NaN&quot; ? false : true;&#125;","pubDate":"Wed, 27 Jul 2022 14:21:01 GMT","guid":"https://lxx1997.github.io/2022/07/27/handredday/leetcode/day-09-592/","category":"leetcode"},{"title":"leetcode 百天解题 - day 08 - 14. 最长公共前缀","link":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","description":"题目名称编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 “”。 示例输入：strs = [“flower”,”flow”,”flight”] 输出：”fl” 输入：strs = [“dog”,”racecar”,”car”] 输出：”” 题解这道题没有什么难点，主要就是取一个参照值（例如数组的第一个元素）然后从第一个字符到最后一个字符和数组中元素对比，直到出现不完全相同的字符的时候，这个时候便是公共的前缀 答案1234567891011121314var longestCommonPrefix = function(strs) &#123; if(strs.length === 1) return strs[0] let suffix = &quot;&quot; const compareStr = strs[0] for(let i = 1;i &lt; compareStr.length; i++) &#123; let s = compareStr[i] if(strs.every(item =&gt; item[i] === s)) &#123; suffix += s &#125; else &#123; return suffix &#125; &#125; return suffix&#125;;","pubDate":"Tue, 26 Jul 2022 13:35:55 GMT","guid":"https://lxx1997.github.io/2022/07/26/handredday/leetcode/day-08-14/","category":"leetcode"},{"title":"leetcode 百天解题 - day 07 - 919. 完全二叉树插入器","link":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","description":"题目名称完全二叉树 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。 设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。 实现 CBTInserter 类: CBTInserter(TreeNode root) 使用头节点为 root 的给定树初始化该数据结构； CBTInserter.insert(int v) 向树中插入一个值为 Node.val == val的新节点 TreeNode。使树保持完全二叉树的状态，并返回插入节点 TreeNode 的父节点的值； CBTInserter.get_root() 将返回树的头节点。 示例输入[“CBTInserter”, “insert”, “insert”, “get_root”][[[1, 2]], [3], [4], []] 输出[null, 1, 2, [1, 2, 3, 4]] 题解这道题主要考察树的 广度优先遍历（bfs） 我们需要从树中取出非完全二叉树的节点，所以最重要的就是如何取出这个节点，这里采用的是 广度优先遍历的方法，首先将树根据节点顺序转化成为一个数组，然后在数组中找出第一个不完全二叉树节点 但是目前由于需要操作的步骤过多，性能较差，有待优化 答案12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var CBTInserter = function(root) &#123; this.root = root this.incompleteNode = getFirstIncompleteTree(root)&#125;;CBTInserter.prototype.insert = function(val) &#123; if(!this.incompleteNode.left) &#123; this.incompleteNode.left = &#123; val: val &#125; &#125; else if(!this.incompleteNode.right) &#123; this.incompleteNode.right = &#123; val: val &#125; &#125; let parent = this.incompleteNode if(this.incompleteNode.left &amp;&amp; this.incompleteNode.right) &#123; this.incompleteNode = getFirstIncompleteTree(this.root) &#125; return parent.val&#125;;function getFirstIncompleteTree(root) &#123; let nodeList = getTreeNodes([root]) for(let i = 0; i &lt; nodeList.length; i++) &#123; let node = checkIncompleteTree(nodeList[i]) if(node) return nodeList[i] &#125; return null&#125;function getTreeNodes(arr = [root]) &#123; let newArr = [...arr] for(let i = 0; i &lt; arr.length; i++) &#123; let root = arr[i] root.left &amp;&amp; newArr.push(root.left) root.right &amp;&amp; newArr.push(root.right) if(!root.left || !root.right) return newArr &#125; return getTreeNodes(newArr)&#125;function checkIncompleteTree(node) &#123; return !node.left || !node.right&#125;CBTInserter.prototype.get_root = function() &#123; return this.root&#125;;","pubDate":"Mon, 25 Jul 2022 14:44:26 GMT","guid":"https://lxx1997.github.io/2022/07/25/handredday/leetcode/day-07-919/","category":"leetcode"},{"title":"leetcode 百天解题 - day 06 - 1184. 公交站间的距离","link":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","description":"题目名称环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。 环线上的公交车都可以按顺时针和逆时针的方向行驶。 返回乘客从出发点 start 到目的地 destination 之间的最短距离。 示例输入：distance = [1,2,3,4], start = 0, destination = 1 输出：1 输入：distance = [1,2,3,4], start = 0, destination = 2 输出：3 题解这道题主要考察我们对于数组的操作，根据题目，我们可以得知 公交可以按照顺序针和逆时针运动，也就是说方向并不固定，其次就是没有规定 出发点一定在目的站的前面（这个是重点） 所以这个时候就有两种类型，一种是出发点在目的地前面，还有一种是出发点在目的地的后面 针对第一种，我们可以先计算出所有站的距离的和 total，然后在计算出两站之间顺时针的距离 dis，然后对比 dis 和 total - dis 的距离哪个最小 第二种同样，只不过是将出发点和目的地翻转一下 答案1234567891011121314151617var distanceBetweenBusStops = function(distance, start, destination) &#123; if(start === destination) return 0 let total = distance.reduce((total, item) =&gt; &#123; return total + item &#125;, 0) let dis = 0 if(destination &lt; start) &#123; dis = distance.slice(destination, start).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; else &#123; dis = distance.slice(start, destination).reduce((total, item) =&gt; &#123; return total + item &#125;, 0) &#125; return Math.min(dis, total - dis)&#125;;","pubDate":"Sun, 24 Jul 2022 11:34:47 GMT","guid":"https://lxx1997.github.io/2022/07/24/handredday/leetcode/day-06-1184/","category":"leetcode"},{"title":"leetcode 百天解题 - day 05 - 13. 罗马数字转整数","link":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","description":"题目名称罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 示例输入: s = “LVIII”输出: 58 输入: s = “MCMXCIV”输出: 1994 题解这道题主要考察我们对于字符串的处理方式；根据题目我们可以找到以下几种组合 &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 根据上面我们列出的组合，现针对字符串中的复杂字符进行替换，并且对应的数字进行加法操作 之所以返回 &quot; &quot; 是为了避免返回空字符串或者原字符，会对最后的结果造成影响 1234567function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s&#125; 最后将我们替换之后的，只剩下单个字符的组合，这时只需要将字符对应的数字进行加法操作，就得出最后的数了 答案1234567891011121314151617181920212223242526272829303132333435var romanToInt = function(s) &#123; let NumHash = &#123; &quot;I&quot;: 1, &quot;IV&quot;: 4, &quot;V&quot;: 5, &quot;IX&quot;: 9, &quot;X&quot;: 10, &quot;XL&quot;: 40, &quot;L&quot;: 50, &quot;XC&quot;: 90, &quot;C&quot;: 100, &quot;CD&quot;: 400, &quot;D&quot;: 500, &quot;CM&quot;: 900, &quot;M&quot;: 1000 &#125; let num = 0, arr = [&quot;IV&quot;, &quot;IX&quot;, &quot;XL&quot;, &quot;XC&quot;, &quot;CD&quot;, &quot;CM&quot;]; arr.map(item =&gt; &#123; s = repalceValue(s, item) &#125;); for(let i = 0; i &lt; s.length; i++) &#123; if(s[i] !== &quot; &quot;) &#123; num += NumHash[s[i]] &#125; &#125; function repalceValue(s, key) &#123; s = s.replace(new RegExp(key, &quot;g&quot;), () =&gt; &#123; num += NumHash[key] return &quot; &quot; &#125;) return s &#125; return num&#125;;","pubDate":"Sat, 23 Jul 2022 15:12:40 GMT","guid":"https://lxx1997.github.io/2022/07/23/handredday/leetcode/day-05-13/","category":"leetcode"},{"title":"leetcode 百天解题 - day 04 - 8 字符串转换整数 (atoi)","link":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","description":"题目名称请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，”123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−2^31, 2^31 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −2^31 的整数应该被固定为 −2^31 ，大于 2^31 − 1 的整数应该被固定为 2^31 − 1 。 返回整数作为最终结果。注意： 本题中的空白字符只包括空格字符 ‘ ‘ 。除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 示例输入：s = “42” 输出：42 解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 第 1 步：”42”（当前没有读入字符，因为没有前导空格） 第 2 步：”42”（当前没有读入字符，因为这里不存在 ‘-‘ 或者 ‘+’） 第 3 步：”42”（读入 “42”） 解析得到整数 42 。 由于 “42” 在范围 [-231, 231 - 1] 内，最终结果为 42 。 题解这道题其实并不麻烦，主要是考察我们的边界处理能力还有就是题目理解能力 首先看题目，题目最开始说去除多余的空格，去除空格的话我们可以采用for循环，也可以采用字符串的 trim 方法 然后就是判断去除空格后的第一个字符是否是 “+” 或者 “-“,如果是，则标记对应的正负符号 如果不是则判断这个字符是否是属于 0 - 9 的数字，如果是，则继续判断下一个字符，如果不是，返回0（我就是在这一步卡了，没有注意的第一个字符就必须是0-9及+- 中的一位） 继续判断下一个字符，直到出现 0 - 9 以外的字符或者直到字符串结尾 然后在拿得到的字符串转为数字后，在与 32位进行比较，得出区间内的数字 答案1234567891011121314151617181920212223242526272829303132var myAtoi = function(s) &#123; let symbol = true, numList = new Array(10).fill(0).map((item,index) =&gt; index + &quot;&quot;), all = [&quot;+&quot;, &quot;-&quot;].concat(numList) s = s.trim() for(let i = 0; i &lt; s.length; i++) &#123; if(all.includes(s[i])) &#123; if(s[i] === &quot;+&quot;) &#123; s = s.slice(i + 1) &#125; else if(s[i] === &quot;-&quot;) &#123; s = s.slice(i + 1) symbol = false &#125; else &#123; s = s.slice(i) &#125; break &#125; else &#123; return 0 &#125; &#125; if(!numList.includes(s[0])) return 0 let ns = &quot;&quot; for(let i = 0; i &lt; s.length; i++) &#123; if (numList.includes(s[i])) &#123; ns +=s[i] &#125; else &#123; if(s.length) &#123; break; &#125; &#125; &#125; if(symbol) return Math.min(+ns, Math.pow(2, 31) - 1) return Math.max(-Number(ns), -Math.pow(2, 31))&#125;;","pubDate":"Fri, 22 Jul 2022 15:23:47 GMT","guid":"https://lxx1997.github.io/2022/07/22/handredday/leetcode/day-04-8/","category":"leetcode"},{"title":"leetcode 百天解题 - day 03 - 814 二叉树剪枝","link":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","description":"题目名称给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。 返回移除了所有不包含 1 的子树的原二叉树。 节点 node 的子树为 node 本身加上所有 node 的后代。 示例 输入：root = [1,null,0,0,1]输出：[1,null,0,null,1] 题解暴力计算法本道题主要考察二叉树和递归的使用，针对二叉树的左右节点进行递归操作，一旦有一个节点符合 既没有子节点，且当前节点值为 0，则去除此节点，然后将空值传给父节点，父节点再进行相同判断，直到最后的结果中不包含不包含1的子节点 答案123456789101112var pruneTree = function(root) &#123; if(root.left) &#123; root.left = pruneTree(root.left) &#125; if(root.right) &#123; root.right = pruneTree(root.right) &#125; if(root.val === 0 &amp;&amp; !root.left &amp;&amp; !root.right) &#123; return undefined &#125; return root&#125;;","pubDate":"Thu, 21 Jul 2022 14:41:48 GMT","guid":"https://lxx1997.github.io/2022/07/21/handredday/leetcode/day-03-814/","category":"leetcode"},{"title":"leetcode 百天解题 - day 02 - 1260 二维网格迁移","link":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","description":"题目名称给你一个 m 行 n 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。 每次「迁移」操作将会引发下述活动： 位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。位于 grid[m - 1][n - 1] 的元素将会移动到 grid[0][0]。请你返回 k 次迁移操作后最终得到的 二维网格。 示例 输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1 输出：[[9,1,2],[3,4,5],[6,7,8]] 题解暴力计算法这道题相对来说较为简单，从示例可以看出，所谓的移动k个元素，其实就是二维网格内的所有元素同步的移动k个元素，然后和二维数组内元素的总长度求余，所得余数便是二维网格内元素的位置 所以首先最重要的就是将二维网格平铺成为一个一维数组，可以使用数组的 flat 方法，当前也可以使用递归的方式来遍历出二维数组中的所有元素。 将二维数组平铺之后，然后根据传入的k值得出需要平移的元素个数，然后将不需要移动的元素和移动之后的元素拼接成一个新的数组，最后在根据原二维数组的长度得出新的二维数组 答案12345678910 var shiftGrid = function(grid, k) &#123; let arr = grid.flat(Infinity) let index = arr.length - k % arr.length let newArr = arr.slice(index).concat(arr.slice(0, index)) let length = grid[0].length, ngrid = [] for(let i = 0; i &lt; newArr.length; i += length) &#123; ngrid.push(newArr.slice(i, i + length)) &#125; return ngrid&#125;;","pubDate":"Wed, 20 Jul 2022 13:50:13 GMT","guid":"https://lxx1997.github.io/2022/07/20/handredday/leetcode/day-02-1260/","category":"leetcode"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","category":"hexo"},{"title":"leetcode 百天解题 - day 01 - 731 我的日程安排表 II","link":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","description":"题目名称实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。 MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。 当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。 请按照以下步骤调用MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end) 示例 MyCalendar();MyCalendar.book(10, 20); // returns trueMyCalendar.book(50, 60); // returns trueMyCalendar.book(10, 40); // returns trueMyCalendar.book(5, 15); // returns falseMyCalendar.book(5, 10); // returns trueMyCalendar.book(25, 55); // returns true解释：前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订。 题解暴力计算法 算法思想解析 最简单的一种方法就是暴力计算法，直接遍历已有的日历时间，然后计算出时间中两次重叠的时间区间，每次添加新的日历时，查看时间区间是否包含在两次重叠的时间区间内，如果包含在里面，则会造成三重重叠，不可添加进日历，如果不包含，则可以添加到日历，此时需要重新计算双重重叠的区间 算法步骤解析 首先我们需要创建一个 MyCalendarTwo 函数，并且定义日历数组（calenderList）和双重重复区间数组（doubleList） 在函数实例上创建 添加日历方法（book） 方法内部首先会去遍历双重重复区间数组，然后对比时间区间是否在双重区间内，只有不在双重区间内才可通过，否则返回false 具体对比方法其实就像两条线段，如果想要两条线段有重叠，只需要满足一个条件即可 其中一条线段的最右边的点一定是大于另一条线段的最左边的点，且最左边的点一定是小于另一条线段最右边的点 接下来就是和日历中的时间进行比较，计算出所有双重重叠区间，然后将新添加的时间区间添加到日历数组中 答案1234567891011121314151617181920var MyCalendarTwo = function() &#123; this.calenderList = [] this.doubleList = []&#125;;MyCalendarTwo.prototype.book = function(start, end) &#123; for(let i = 0; i &lt; this.doubleList.length; i++) &#123; let l = this.doubleList[i][0], r = this.doubleList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; return false &#125; &#125; for(let i = 0; i &lt; this.calenderList.length; i++) &#123; let l = this.calenderList[i][0], r = this.calenderList[i][1] if (end &gt; l &amp;&amp; start &lt; r) &#123; this.doubleList.push([Math.max(l, start), Math.min(r, end)]) &#125; &#125; this.calenderList.push([start, end]) return false&#125;;","pubDate":"Tue, 19 Jul 2022 13:31:34 GMT","guid":"https://lxx1997.github.io/2022/07/19/handredday/leetcode/day-01-731/","category":"leetcode"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/relearn-vue2-02/","category":"vue"},{"title":"html-webpack-plugin 的使用与进阶","link":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","description":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","pubDate":"Wed, 13 Jul 2022 03:19:44 GMT","guid":"https://lxx1997.github.io/2022/07/13/html-webpack-plugin/","category":"webpack"},{"title":"常用的前端动画库","link":"https://lxx1997.github.io/2022/07/12/web-animation-package/","description":"Lottie 文档 都2022年了，一个还不知道Lottie动画的前端已经OUT啦！ svga SVGA在前端方面的使用","pubDate":"Tue, 12 Jul 2022 08:58:08 GMT","guid":"https://lxx1997.github.io/2022/07/12/web-animation-package/","category":""},{"title":"生成 github SSH key","link":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","description":"生成 SSH key打开 git bash 命令行工具 输入一下命令，自动生成 ssh key 地址 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 可以通过命令行直接复制 ssh key 的内容 1clip &lt; ~/.ssh/id_ed25519.pub 复制成功之后，可以将 ssh key 复制到 github 的ssh key 上 和 github 链接执行以下命令 1234ssh-add ~/.ssh/id_ed25519// 或者echo $SSH_AGENT_SOCK 如果执行不成功，可能是 ssh-add 未开启，可以通过命令行查看是否开启ssh-add 服务1ps -ef | grep ssh 开启 ssh-add 服务12cd ~/.ssheval $(ssh-agent) 执行完上述命令后就可以进行ssh 链接","pubDate":"Fri, 08 Jul 2022 06:19:07 GMT","guid":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","category":"git"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part1","link":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","description":"computed 属性默认是只有 getter 属性的，也就是说我们只能获取到computed 属性的值，但是无法修改它，但是我们可以手动的设置 setter 属性，这样就可以手动赋值了 1234567891011121314export default &#123; computed() &#123; fullName: &#123; set: function (val) &#123; let name = val.split(&quot; &quot;) this.firstName = name[0] this.secondName = name[1] &#125;, get: function () &#123; return this.firstName + &quot; &quot; + this.secondName &#125; &#125; &#125;&#125; v-for 和 v-if 为什么不推介一起使用 这个是因为 v-for 和 v-if 的优先级问题，vue 会先进行 v-for 循环渲染元素，最后在进行 v-if 控制是否显示元素，会造成无谓的资源浪费 可以采用 v-show 代替 v-if 或者使用计算属性来代替 v-if， 只渲染我们想渲染的元素 key attribute 用来表示这个元素是完全独立的，和其他元素不同，在日常操作中可以用来强制刷新元素内容，只需要修改元素的key，就会重新去渲染元素 我之前用过 v-if 和 $nextTick 来强制重新渲染元素内容，很明显使用上述方法是一种很方便的操作 v-for 可以使用 in 或者 of 来作为分隔符 v-for 遍历对象时 v-for=&quot;(value, name, index) in obj&quot; 三个值 分别为 值，键，和 索引 vue 中可以使用 template 标签，该标签类似 react 中的&lt;&gt;&lt;/&gt;和React.Fragment,在实际渲染中并不会被渲染出来 如果我们想要在点击事件中访问原始的 dom 时间，可以将特殊的变量 $event 传到方法中 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 事件捕获的时候触发，如果点击的是子元素，会先于子元素事件触发 .self 只有当 event.target 是元素自身时触发，点击子元素时不会触发 .once 只会触发一次 .passive 和 .prevent 相反，不会阻止默认事件触发 使用修饰符的时候，顺序很重要，代码会以同样的顺序产生，例如v-on:click.prevent.self 会阻止所有点击，而 v-on:click.slef.prevent 只会阻止元素对自身的点击 按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 支持按键码 可以通过全局的 config.keyCodes 自定义按键修饰符别名1Vue.config.keyCodes.f1 = 112 系统修饰键 (修饰键在和其他事件一起使用的时候，需要同时触发才行，否则并不会单独触发修饰键) .ctrl .alt .shift .meta .exact 精确修饰符，允许我们控制精确的系统修饰符组合触发的事件 &lt;input v-model=&quot;toggle&quot; type=&quot;checkbox&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; 此时 toggle 会取 对应的 true-value 和 false-value 的值 v-model.lazy 默认情况下，v-model 会在input 事件触发后将输入框的值与数据同步，添加lazy 修饰符后，从而转为在 change 事件之后触发 v-model.number 会自动将用户输入的值转为数值类型 v-model.trim 会自动去除用户输入内容两端的空格 自定义组件中的 data 必须是一个函数，是为了保证每次创建组件的时候都能拿到一个独立的数据，否则，重复创建组件时，组件内的数据由于有同一个引用地址，会互相干扰 v-model 在自定义组件中使用相当于 v-bind:value 和 v-on:change 的组合 可以通过组件的 model 属性改变 v-model 的默认属性和事件绑定 12345678910export default &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27; &#125;, mounted() &#123; console.log(this.checked) this.$emit(&quot;change&quot;, &quot;val&quot;) &#125;,&#125; &lt;component v-bind:is=&quot;CustomComponent&quot;&gt;&lt;/component&gt; 通过 v-bind:is 可以自定义组件，组件会跟随 CustomComponent 的值变化而变化 传入一个对象的所有 property, 组件内部可以直接通过 示例中 post 拿到对应的属性 1&lt;component v-bind=&quot;post&quot;&gt;&lt;/component&gt; props 验证 123456789101112export default &#123; props: &#123; propA: &#123; type: String, default: &quot;&quot;, require: false, validator() &#123; &#125; &#125; &#125;&#125; type props 参数类型 String, Number, Boolean, Array, Object, Date, Function, Symbol, 或者自定义的构造函数 default 默认值，引用类型数据 需要使用函数并且通过return 返回默认引用类型 require 是否必须传 默认为 false validator 自定义效验规则 禁用 Attribute 继承，可以设置 inheritAttrs false 来之根元素继承 Attribute 具体表现为 如果设置为 false 子组件不会渲染 attribute， true 会在子组件上渲染 attribute 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 slot 缩写 v-slot: -&gt; # 后备内容 如果我们没有向插槽内提供内容，此时将会显示后备内容 &lt;slot&gt;默认内容&lt;/slot&gt; 具名插槽 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot-component v-slot:header&gt;&lt;/slot-component&gt; 作用域插槽 插槽内部 123456&lt;template&gt; &lt;div&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 外部使用 1234567&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 如果有多个插槽 12345678910&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;slot v-slot:other=&quot;otherSlotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 子组件可以通过 $root 来访问和修改根组件的实例及方法 provide, inject provide 选项允许和指定提供给后代组件的数据和方法 123456provide: function() &#123; return &#123; a: function() &#123;&#125;, b: 0 &#125;&#125; inject 允许子元素接受 provide 提供的 provide 1inject: [&#x27;a&#x27;, &#x27;b&#x27;] 但是出于设计考虑， 这些数据不是响应式的，而且会对重构及代码复用有很大的影响 X-Template x-template 需要定义在 Vue 所属的 DOM 元素外。 123&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component(&#x27;hello-world&#x27;, &#123; template: &#x27;#hello-world-template&#x27;&#125;) transition 过渡动画 v-enter 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义动画类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 显性的过渡持续时间 &lt;transition :duration=&quot;1000&quot; /&gt; &lt;transition :duration=&quot;&#123;enter: 500, leave: 800&#125;&quot; /&gt; JavaScript 钩子 123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; mixins 混入选项合并 数组对象会在内部进行合并，例如 data,属性名发生冲突时，以组件内属性优先 钩子函数合并成数组，都会被调用，混入对象的钩子函数优先于组件内钩子函数调用 值为对象时,将会被合并成为一个对象，且组件对象的键值对优先级更高 Vue.config.optionMergeStrategies 可以通过次宣讲自定义逻辑合并逻辑 自定义指令 1234567directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus /&gt; 钩子函数 bind 绑定时调用，只调用一次 inserted 被绑定元素插入父节点时调用 update 所在组件更新时调用，可能发生在子组件更新之前 componentUpdated 所在组件和子组件全部更新后调用 unbind 指令与元素解绑时调用 钩子函数参数 el 绑定的元素，可以用来操作 DOM binding name 指令名 value 指令绑定的值 oldValue 制定绑定的前一个值 expression 字符串形式的指令表达式 =&quot;1 + 1&quot; arg 传给指令的参数 :foo modifiers 指令修饰符 .foo vnode 当前虚拟节点 oldVnode 上一个虚拟节点 functional 函数式组件函数式组件没有响应式数据，也没有实例（没有 this 上下文）相反会有一个 context 参数 包含如下字段 props children slots scopedSlots data parent listeners injections","pubDate":"Thu, 07 Jul 2022 07:56:07 GMT","guid":"https://lxx1997.github.io/2022/07/07/relearn-vue2-01/","category":"vue"},{"title":"好用的浏览器页面测试页面性能工具","link":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","description":"pagespeed地址： https://pagespeed.web.dev/ gtmetrix地址： https://gtmetrix.com/ web.dev地址： https://web.dev/measure/","pubDate":"Thu, 07 Jul 2022 03:29:14 GMT","guid":"https://lxx1997.github.io/2022/07/07/web-page-speed-testing-tools/","category":"performance"},{"title":"最全的页面性能优化","link":"https://lxx1997.github.io/2022/06/24/how-to-make-pagespeed-fast/","description":"为什么要进行性能优化我们会在什么时候对页面性能进行优化呢，在我的观点里大致有以下几个方面 页面加载时间较长，导致部分用户在页面还未加载完成之后便离开了页面，增加了用户的跳出率 因为 google 的搜索算法，对页面性能这一块有一定要求，如果页面性能较差，那么当用户搜索工具关键词时，页面的顺序就越靠下，这样针对用户自然搜索流量这一块会有很大影响 用户在使用工具时，可能会由于部分操作及代码实现的影响，导致用户使用时会比较卡顿，用户体验较差，降低用户留存 如果想要提高用户的留存率这一块的数据，那么增加用户流量及降低用户跳出率就比较重要了 怎么进行性能优化我认为可以从以下几个方面来进行性能优化 html 解析阶段 javascript 加载阶段 页面渲染阶段 用户操作过程中 下面来分别介绍一下在各个阶段要具体要怎么做 html 解析阶段当浏览器请求到页面 html 的时候，会对html 进行解析，如果中间遇到 link 标签 或者 script 标签时，会去请求对应资源，并进行解析，在解析 css 文件的过程中，并不会阻止浏览器解析 html 文件，但是要注意，javascript 文件会阻止 css 和 html 文件的解析，所以尽量要把 javascript 文件访问 body 标签的最后，不要阻止html 和 css 的解析 在这个阶段我们可以通过以下几种方法提高页面速度 prefetch &amp;&amp; preload使用 prefetch 和 preload 方式 预加载文件，但是要注意这两个方法加载文件的优先级程度不同， prefetch 的优先级最低，浏览器不会立即下载文件，而是会在空闲时间去下载文件， preload 的优先级最高，会立即去下载文件，但是这两个方式都不会去解析文件，只是下载文件后存放本地，如果我们需要使用时就不必再次下载 注意：由于浏览器对于同一个域名下请求的个数有限制，所以要谨慎使用prefetch 和preload 方法，如果一次性加载文件过多，反而会影响后续资源的获取，起到反优化的效果 12345&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt; DNS Prefetch，即DNS预获取当浏览器加载文件时，会对地址进行 DNS 解析,获取地址对用的IP地址，虽然浏览器内部对这一部分操作进行过优化，会在一定时间内缓存 DNS 解析结果，但是 DNS 解析的时间还是比较长的，大概需要 20ms - 120ms 左右的时间，我们可以针对会使用的域名开启 dns 预解析操作，在浏览器空闲的时候，去解析 DNS,当我们使用的时候，就可以减少 dns 解析的时间操作，提高接口请求时间 123&lt;!-- 开启 DNS 解析 content: off 关闭 on 打开 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.template.com&quot;&gt; 但是要注意不要滥用预解析，如果短时间不需要的域名，可以不需要 dns 预解析 script 标签位置浏览器在遇到script 标签时，会暂停解析 html 和 css 文件，转而去解析 js 内容，这样就阻止了页面的解析和渲染，所以尽量保证script 标签在 body 标签的末尾，减少 js 文件对html 文件解析的影响 骨架屏可以采用骨架屏的方式，防止用户因为看不到内容，从而离开页面 JavaScript 解析阶段在这个阶段，浏览器回去下载页面渲染所需要的 javascript 文件，解析，然后渲染到页面上，在这个阶段影响页面加载速度主要有以下几个方面： 单个 js 文件过大，请求及解析文件耗时过大 同一时间请求了过多的资源，导致网络被占用，进一步影响了页面加载 采用不同域名加载静态资源我们都知道浏览器对同一个域名下的请求个数有一定的限制，例如google 浏览器限制最大并发个数是6个，当同时发起的请求的个数超过6个时，只会有有6个发起请求，其他的处于 padding 状态，只有当请求完成时，才会有下一个请求开发发起请求。 因此我们可以采用通过不同域名来请求静态资源，例如 所有的 js 资源可以单独采用一个域名来进行，图片等媒体资源可以采用一个域名来访问，这个就不会因为同一时间内请求的资源过多，影响页面加载速度 CDN 缓存当浏览器下载资源，会先通过 DNS 解析解析出资源所在主机的ip地址，然后去拉取资源，如果服务器刚好在用户所在城市附近，那么资源的加载速度并不会有多大影响，但如果距离过远，例如你人在北京，想要访问在美国的一台服务器上的资源，这个时候由于网络传输的印象，回导致资源获取延迟比较大。 这个时候就需要使用 CDN 缓存了， 这就是CDN的由来，分布式缓存服务器，主要功能是在转发、传输、链路抖动等情况下，最小化资源的时延，并保证信息的连续性和速度。 当我们访问资源，会首先向距离我们最近的 DNS 服务器发出资源请求，如果 这个DNS 服务器缓存有我们想要的资源，如果没有，则会向原服务器请求资源，然后返回给我们，这样一般就降低了资源在请求链路传输的延迟问题。 但是使用 DNS 缓存也会有一些弊端，因为资源都是已经缓存到 DNS 服务器上了，如果在资源缓存未失效的请求，资源进行了变更，这个时候用户访问到的又可能还是旧版资源，这个时候我们可以手动请求 DNS 缓存，但是这个方法不太方便，所以我们可以通过打包的方式，对静态资源添加 hash 后缀，这样每次发版或者更换资源，都会把地址专项新的地址，这样 CDN 就会重新对资源进行缓存针对不能添加 hash 的文件，我们可以通过修改参数的方式来使 CDN 重新刷新缓存，例如123// package.version 为 package.json 的版本号let url = `http://www.example.com/useinfo?_v=$&#123;package.version&#125;`axios.get*(url) 这样当我们每次发版的时候，只需要修改一下版本号，就可以刷新 CDN 缓存了 减少 javascript 包的体积当 js 文件体积过大时，我们需要减少 javascript 包的大小，来减少js 加载时间和解析时间。 可以通过一下几种方式减少包的体积 分包 我们可以通过打包的方式，来将一些第三方资源包打包到一个文件，因为这部分资源我们通常并不会经常修改，这样当我们发版的时候，如果第三方资源并没有发生变化，那么这一块的资源并不会清空 CDN 缓存 1234567891011121314151617181920module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &quot;vendors&quot;, priority: -10 &#125;, utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 这样所有的 node_modules 下需要打包的资源都会打包到 vendors js 文件里面 如果是多页面应用还可以吧多次使用的资源的资源打包到同一个包里面，这样多个页面就可以共用这一个包 123456789101112131415module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 资源懒加载 这里主要以 vue 项目举例 假如我们的页面有多个路由，我们在访问其中一个路由的时候其实是不需要加载其他路由所需要的内容，这个时候可以使用懒加载的方式来减少首屏需要加载的资源 1234&#123; name: &quot;/home&quot;, component: () =&gt; import(&quot;./home.vue&quot;)&#125; 这个时候只有我们访问 /home 这个路由的时候才会加载 home 所需要的资源， 针对同一个路由中 也需要懒加载的组件的组件可以使用以下方式 1234567891011121314&lt;tempalte&gt; &lt;LazyLoad v-if=&quot;lazy&quot; /&gt;&lt;/tempalte&gt;&lt;script&gt;const LazyLoad = () =&gt; import(&quot;./LazyLoad.vue&quot;)export default &#123; data() &#123; return &#123; lazy: false &#125; &#125;&#125;&lt;/script&gt; vue 在内部做过处理，只有当 lazy = true， 需要渲染 LazyLoad 组件时，才会加载对应资源 通过以上操作，我们可以极大减少首屏加载所需要的资源大小，提高页面加载速度 Tree Shaking tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。 使用了 tree shaking后， 如果一段代码我们并没有通过 import 方式引入，这段代码在打包的时候就不会打包进去，但是这个时候也会出现其他问题，因为在迭代过程中，可能之前我们引入了一些资源，但这些资源在后期迭代的过程中不在使用了，但是并没有从代码中移除，这个时候，这些资源也会被打包到代码中，并且项目越大，这种问题出现的几率越大。 因此webpack 扩展了这个检测能力，主要通过 package.json 的 sideEffect 属性来标记 当我们把 sideEffect 设置为 false 时， 代表所有的代码都不包含副作用，告诉 webpack 可以安全的删除所有的未使用的 export 导出。 如果部分代码存在副作用，我们通过一个数组来过滤掉这部分存在副作用的代码。 123456789101112&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: false&#125;&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot; ]&#125; 我在对 vue 项目进行代码 treeshaking 的时候遇到过这样一个问题，打包没有问题，但是发到测试环境后看，页面样式发生了混乱，推测是 可能是由于 vue 文件进行 treeshaking 时，所以 就把 vue 文件标为 副作用文件，不进行treeshaking 12345678&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot;， &quot;*.vue&quot;, &quot;*.less&quot; ]&#125; gzip 压缩 资源在经过网关的时候可以开启 gzip 压缩，使用了 gzip 后，静态文件可以被压缩 3 - 10 倍左右 经过以上操作，可以极大减少用户请求页面加载资源大小，减少服务器带宽压力 页面渲染阶段在页面渲染阶段 主要是用户让用户能够更快的看到页面，以及可操作，所以这个阶段就需要我们根据需求调整 资源加载 及 js 执行时间长度 延迟加载资源 对于部分第三方组件，例如支付，广告这些全局共用的js，可以等到使用的时候再去加载 从产品设计方面 针对部分阻塞页面加载及用户操作的资源可以通过用户的主动操作触发，而非页面一加载就执行 用户操作过程再用户操作过程中，可能有些操作会需要大量计算，由于浏览器是单线程操作，长时间的计算将会阻止用户操作，造成页面出现卡顿的现状,我们可以通过采用分段计算和优化计算消毒，或者采用替代方法。 使用全局加载动画，告诉用户当前属于什么状态。 canvas.toDataURL 可以采用 canvas.toBlob 方法替代（如果有使用的话） setTimeout， setInterval， requestAnimationFrame 等方式实现异步操作","pubDate":"Fri, 24 Jun 2022 14:20:06 GMT","guid":"https://lxx1997.github.io/2022/06/24/how-to-make-pagespeed-fast/","category":"performance"}]}