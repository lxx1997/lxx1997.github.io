{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Mon, 05 Sep 2022 13:01:59 GMT","lastBuildDate":"Mon, 12 Sep 2022 10:01:34 GMT","generator":"hexo-generator-json-feed","webMaster":"lxx","items":[{"title":"page","link":"https://lxx1997.github.io/2022/09/05/handredday/leetcode/day-49-34/","description":"","pubDate":"Mon, 05 Sep 2022 13:01:59 GMT","guid":"https://lxx1997.github.io/2022/09/05/handredday/leetcode/day-49-34/","category":""},{"title":"博客快捷入口","link":"https://lxx1997.github.io/2022/08/26/blog-key-article-classify/","description":"框架VueVue3react 浏览器百日挑战leetcode 百日挑战 2022-07-19 - 至今","pubDate":"Fri, 26 Aug 2022 02:36:40 GMT","guid":"https://lxx1997.github.io/2022/08/26/blog-key-article-classify/","category":""},{"title":"vue3 状态管理工具 - pinia","link":"https://lxx1997.github.io/2022/08/11/vue-pinia-state-manager/","description":"Vue3 出来都有一年多了，生态系统相对来说都慢慢变得完善起来了，像针对 vue2 的 vue-router 路由组件，vuex 状态管理工具都开始适应 vue3 了 这里就介绍 针对 vue3 的状态管理工具 vuex5 又叫 pinia 与 vuex4 和 vuex3 对比 mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。 无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。 不再需要注入、导入函数、调用函数、享受自动完成功能！ 无需动态添加 Store，默认情况下它们都是动态的，您甚至都不会注意到。请注意，您仍然可以随时手动使用 Store 进行注册，但因为它是自动的，您无需担心。 不再有 modules 的嵌套结构。您仍然可以通过在另一个 Store 中导入和 使用 来隐式嵌套 Store，但 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 您甚至可以拥有 Store 的循环依赖关系。 没有 命名空间模块。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的。 使用安装 pinia123npm install piniayarn add pinia 在 Vue 中注册123import &#123; createPinia &#125; from &quot;pinia&quot;createApp(App).use(createPinia()).mount(&#x27;#app&#x27;) 创建一个storepinia 提供了一个方法 defineStore 来定义一个 Store defineStore 需要我们传入两个参数，第一个参数是 name, 这个值是唯一的，第二个参数是 Store 的值，包含 state, getters, actions 1234567891011121314151617181920import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;, getters: &#123; getCount(state) &#123; return state.count &#125; &#125;, actions: &#123; addCount() &#123; this.count++ &#125; &#125;&#125;) 组件内使用 setup components在 setup component 内可以直接使用 1234567&lt;script setup&gt; const countStore = useCountStore() console.log(countStore.count) // 1 console.log(countStore.getCount) // 1 countStore.addCount()&lt;/script&gt; 需要注意的是，不能对 store 进行解构赋值，因为这会破坏 store 的响应式 如果想要对 store 进行解构赋值，可以采用 storeToRefs,它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用12345&lt;script setup&gt; import &#123; storeToRefs &#125; from &quot;pinia&quot; const countStore = useCountStore() const &#123; count, getCount &#125; = storeToRefs(countStore)&lt;/script&gt; 属性statestate 用来定义应用程序状态开始，在 pinia 中状态是一个返回初始状态函数 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;&#125;) 如果想要重置 Store 的状态，可以调用 $reset 方法 1useCountStore.$reset() 不在 setup() 中使用 可以使用 mapState 将状态映射为只读属性 12345export default &#123; computed: &#123; ...mapState(useCountStore, options) &#125;&#125; options 有两种类型 数组类型 如果是数组类型的话，其内的元素是需要映射的属性名，例如我们想要映射 state 的 count 的值 ...mapState(useCountStore, [&quot;count&quot;]),组件内可以直接使用 this.count 访问 对象类型 对象类型的话，key 是组件内访问时的属性名，key 所对应的值是 Store state 里面的值 12345678export default &#123; computed: &#123; ...mapState(useCountStore, &#123; aliasCount: &quot;count&quot;, // 组件内访问时 this.aliasCount,相当于访问 store 的 count 属性 doubleCount: (state) =&gt; state.count * 2 // 类似于 Store 的 getters 属性 &#125;) &#125;&#125; 如果想要直接修改这些状态属性，类似 this.count++,可以使用 mapWritableState API gettersgetters 的使用 类似于 state，但是创建方式略有不同 getters 是一个有具体返回值的函数，这个函数可以是有 state的值或者其他 getters 中的值计算出来的结果 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; getters: &#123; doubleCount: (state) =&gt; state.count * 2, othercount(state) &#123; return this.doubleCount * state.count &#125; &#125;&#125;) 在 setup 函数中使用时，可以直接通过 store 访问 非 setup 函数可以通过 mapState 方法注册到 computed 属性中 actionsactions 中的方法适合用来定义业务逻辑，而且是可以进行异步操作 在非 setup 函数中使用的时候可以通过 mapActions 映射出来 1234567export default &#123; methods: &#123; ...mapActions(useCountStore, &#123; changeCount: &quot;count&quot;, &#125;) &#125;&#125; 第二个参数传递的类型可以参考 mapState 在 setup 函数中，可以直接在 setup 中使用，也可以在组件中通过 store 对象调用 1234567891011121314151617181920212223242526272829export default &#123; setup(props) &#123; let &#123; todoItem &#125; = toRefs(props) const todoList = useTodoListStore() const handleEdit = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; isEditing: true &#125;) &#125; const handleDelete = () =&gt; &#123; todoList.removeTodoList(todoItem.value.id) &#125; const handleConfirm = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; content: value.value &#125;) &#125; return &#123; value, handleEdit, handleDelete, handleConfirm &#125; &#125;&#125; 另外，针对 actions vuex 提供了一个 $onAction 方法来订阅action 及结果 当我们订阅一个 store 后，每触发一次 store 内部的 action 执行，都会触发一次回调函数，传递给它的回调在 action 之前执行。 after 处理 Promise 并允许您在 action 完成后执行函数。 以类似的方式，onError 允许您在处理中抛出错误。 123456789101112131415161718192021222324252627282930313233const unsubscribe = todoListStore.$onAction( (&#123; name, // action 的名字 store, // store 实例 args, // 调用这个 action 的参数 after, // 在这个 action 执行完毕之后，执行这个函数 onError, // 在这个 action 抛出异常的时候，执行这个函数 &#125;) =&gt; &#123; // 记录开始的时间变量 const startTime = Date.now() // 这将在 `store` 上的操作执行之前触发 console.log(`Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#x27;, &#x27;)&#125;].`) // 如果 action 成功并且完全运行后，after 将触发。 // 它将等待任何返回的 promise after((result) =&gt; &#123; console.log( `Finished &quot;$&#123;name&#125;&quot; after $&#123; Date.now() - startTime &#125;ms.\\nResult: $&#123;result&#125;.` ) &#125;) // 如果 action 抛出或返回 Promise.reject ，onError 将触发 onError((error) =&gt; &#123; console.warn( `Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.` ) &#125;) &#125;)unsubscribe()","pubDate":"Thu, 11 Aug 2022 07:19:53 GMT","guid":"https://lxx1997.github.io/2022/08/11/vue-pinia-state-manager/","category":"Vue3"},{"title":"React Hooks - 自定义hooks","link":"https://lxx1997.github.io/2022/08/09/react/react-custom-hooks/","description":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React react hooksuseEffectuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力 它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途 在使用时我们传递一个数组，useEffect 会在数组内的数据发生变化时重新执行 useEffect 函数需返回一个清除函数，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除 12345useEffect(() =&gt; &#123; return () =&gt; &#123; // 在此执行当前useEffect 的副作用清除，例如监听函数，定时器等操作 &#125;&#125;, [obj1, obj2]) // 仅在 obj1， obj2 改变的时候触发 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。 useStateuseState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。 更新函数操作是完全替换，而非合并操作 1234const [count, setCount] = useState(0) // 初始化 countsetCount(1) // 改变 count 值setCount(x =&gt; x + 1) // 改变 count 值 会基于原count 值的基础上 +1 useContext 上下文对象用来接收由React.createContext() 创建的 context对象，并返回context对象的当前值，父组件需要有 &lt;MyContext.Provider&gt; 包裹着，值由 value 确定 12345678910111213141516171819202122232425262728293031323334353637const themes = &#123; light: &#123; foreground: &quot;#000000&quot;, background: &quot;#eeeeee&quot; &#125;, dark: &#123; foreground: &quot;#ffffff&quot;, background: &quot;#222222&quot; &#125;&#125;;const ThemeContext = React.createContext(themes.light);function App() &#123; return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; const theme = useContext(ThemeContext); return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125; useReduceruseReducer 是 useState 的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 在上述例子中，当修改 state 里面的值的时候，会通过dispatch 传递一个比较复杂的值作为 reducer 方法中的 action，在reducer 内部通过 action 的值来进行代码运算，返回出新的值 useCallbackReact useCallbackHook 返回一個記憶化的回調函數。這使我們能夠隔離資源密集型功能，以便它們不會在每次渲染時自動運行。 使用useCallback鉤子來防止函數被重新創建，除非有必要。 123const addTodo = useCallback(() =&gt; &#123; setTodos((t) =&gt; [...t, &quot;New Todo&quot;]);&#125;, [todos]); 当组件内容发生变化重新渲染的时候，如果 todos 没有发生变化的话，addTodo 函数不会重新创建 useMemoReact useCallbackHook 返回一個記憶化的值，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作 123456789const Todo = (&#123; todos &#125;) =&gt; &#123; return &lt;div&gt;&#123; todos.map(item =&gt; &lt;div&gt; &#123;item.name&#125; &lt;/div&gt;) &#125;&lt;/div&gt;&#125;export default useMemo(Todo) 以上 Todo 组件仅会在 todos 参数发生变化时才会重新计算渲染，如果传入内容有函数，可以和 useCallback 接合，实现值的缓存 useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。 useRef 既可以用来存储 dom 对象，也可以用来存储单个的值 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。 1234const ref = useRef(1)console.log(ref.current)ref.current = 2console.log(ref.current) useImperativeHandle 和 forwardRefuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 父组件使用 forwardRef 来接收子组件暴露出的实例值 123456789101112131415161718function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;function App() &#123; FancyInput = forwardRef(FancyInput); function focus() &#123; inputRef.current.focus() &#125; return &lt;FancyInput ref=&#123;inputRef&#125; /&gt;&#125; useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;); return isOnline;&#125; useDeferredValueuseDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。 该 hook 与使用防抖和节流去延迟更新的用户空间 hooks 类似。使用 useDeferredValue 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，并且像 startTransition 一样，延迟值可以暂停，而不会触发现有内容的意外降级。 1234567891011121314151617181920function Typeahead() &#123; const query = useSearchQuery(&#x27;&#x27;); const deferredQuery = useDeferredValue(query); // Memoizing 告诉 React 仅当 deferredQuery 改变， // 而不是 query 改变的时候才重新渲染 const suggestions = useMemo(() =&gt; &lt;SearchSuggestions query=&#123;deferredQuery&#125; /&gt;, [deferredQuery] ); return ( &lt;&gt; &lt;SearchInput query=&#123;query&#125; /&gt; &lt;Suspense fallback=&quot;Loading results...&quot;&gt; &#123;suggestions&#125; &lt;/Suspense&gt; &lt;/&gt; );&#125; useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。 isPending 指示过渡任务何时活跃以显示一个等待状态：startTransition 用来启动过渡任务 1234567891011121314151617function App() &#123; const [isPending, startTransition] = useTransition(); const [count, setCount] = useState(0); function handleClick() &#123; startTransition(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;) &#125; return ( &lt;div&gt; &#123;isPending &amp;&amp; &lt;Spinner /&gt;&#125; &lt;button onClick=&#123;handleClick&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;/div&gt; );&#125; useIduseId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。 自定义 Hooks在知道上述 hooks 之后，react 也支持我们自定义 hooks 操作。 自定义 hooks 主要是用来 提取共享逻辑，优化代码结构。 1234567891011const useUserInfo = () =&gt; &#123; const [useInfo, setUseInfo] = useState(null) useEffect(() =&gt; &#123; // 这里做处理用户的个人信息 &#125;) return useInfo&#125;const useInfo = useUserInfo()","pubDate":"Tue, 09 Aug 2022 01:55:31 GMT","guid":"https://lxx1997.github.io/2022/08/09/react/react-custom-hooks/","category":"react,hooks"},{"title":"vue3 组合式Api setup","link":"https://lxx1997.github.io/2022/08/02/vue/vue3-composition-api-setup/","description":"什么是组合式API组合式API 主要是为了把相同的逻辑关注点收集在一起，使得逻辑处理更加清晰和方便。 针对 vue2 的组件选项来说，（data, computed, methods, watch）等组件存在，导致我们在修改同一个逻辑关注点的之后需要不停地跳转相关的代码块，代码碎片化，使得我们理解和维护复杂组件变得困难。 在 vue3组件中，这个位置称为 setup 这个是 Vue3 新增的一个选项 setup 选项会在组件被创建之前执行，一旦 props 解析完成，setup 就会被作为 组合式Api 的入口，也就是说 setup 执行的时机要比 vue2 的 beforeCreate 要早，此外 setup 中应避免使用 this 且因为调用发生在 data，computed，methods 之前，所以无法在 setup 中获取 既然 setup 中无法获取到 data，computed 中的内容，那么我们怎么创建和监控变量变化，且组件内能获取到呢？ setup 接收 props 和 context props 是父元素传递过来的 props context 是当前组件实例上下文 setup 函数 return 出一个对象，这个对象可以被组件直接获取到，相当于 data 和 methods 的集团体 怎么保证 setup 返回的变量是响应式的呢？ vue3 提供了一些 hooks，可以让我们创建响应式的变量 参数propssetup 接受两个参数，第一个参数是props，且是响应式的，传入新的props 时，会被一起更新 因为是响应式的，所以无法直接使用解构赋值，会失去响应式 12345678910111213141516171819202122232425262728293031323334353637383940// 父组件/** * 父组件向子组件传递一个 props title 属性，并且这个属性会在 3s 后发生变化 */export default &#123; setup() &#123; const title = ref(&quot;hhhhhh&quot;) setTimeout(() =&gt; &#123; title.value = &quot;this is new title&quot; &#125;, 3000); watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125; &#125;&#125;// 子组件/** * 子组件这里必须要在props 属性上添加需要接受的属性，否则setup 中的 props 无法接受到 * 当props 属性发生变化时，使用 watch 监听可以再次被触发，但是页面上内容不会发生变化，这是因为我们直接取的 props 里面的属性值，不具备响应式 */export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = props return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果我们想要对 props 进行解构操作，可以使用 toRefs 函数来完成此操作 下面代码我们会发现当 props 中的 title 属性发生变化后， 组件内 title 并不会跟随变化，而 computedTitle 则会跟随props 中的 title 属性发生变化 12345678910111213141516171819export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = toRefs(props) return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它 toRef 的作用相当于把 对象中的属性转化为 ref 类的属性，且与对象相关联，当对象中对应属性发生变化时, toRef 中的内容会同步发生改变 123456setup(props, context) &#123; let name = toRef(props, &quot;name&quot;) // name 会跟随 props 中的 name 属性变化而同步更新 return &#123; name: name &#125;&#125; contextcontext 是一个普通 JavaScript 对象，不是响应式的，因此可以使用 解构操作 暴露了其它可能在 setup 中有用的值： attrs 类似于 $attrs slots 类似于 $slots emit 类似于 $emit expose 公共property slots 和 attrs 是有状态的对象，跟随组件本身的更新而更新，避免使用解构赋值，如果想要根据 attrs 和 solts 更改应用富足用，应该在 onBeforeUpdate 钩子中执行操作 returnsetup return 出来的值可以在模板和组件中直接使用 如果父组件想要访问子组件 setup 中的 property，可以使用 expose 方法暴露出去 123456789101112export default &#123; setup(props, &#123; expose &#125;)&#123; let count = ref(0) const changeCount = () =&gt; ++count.value expose(&#123; changeCount &#125;) return &#123; count &#125; &#125;&#125; hookssetup 内部的钩子函数 onBeforeMount // 页面挂载钩子函数 onMounted onBeforeUpdate // 页面更新钩子函数 onUpdated onBeforeUnmount // 页面销毁钩子函数 onUnmounted onErrorCaptured // 页面错误事件钩子函数 onRenderTracked onRenderTriggered // 跟踪虚拟 DOM 重新渲染时调用 onActivated // keep-alive 缓存的组件激活时调用 onDeactivated // keep-alive 缓存的组件失活时调用 这些钩子函数的触发时机和在组件内部触发时机一致 这些钩子函数接受一个回调函数，当钩子函数被调用时，将会被执行 带 ref 的响应式变量在 Vue3 中，我们可以通过 ref hooks 创建一个响应式变量，ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值 之所以把值封装在对象中，主要是因为字符串和数字这些基本类型时通过值传递的，通过对象封装后，可以在整个对象安全的传递，不用担心失去响应式 1&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; 123456789101112131415setup(props, context) &#123; const title = ref(&quot;setup component&quot;) const changeTitle = function(val) &#123; title.value = val &#125; setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) return &#123; title, changeTitle &#125;&#125; 在上述实例中，我们可以发现，在3s 过后，页面上显示的内容发生变化，而且setup return 出来的属性和方法在组件的其他选项中都可以通过 this 来访问到 watch 响应式处理如果我们想要在 setup 选项中监听属性的变化，可以通过 watch hooks 方法监听属性变化 watch 接受三个参数，监听对象，回调函数，配置选项 配置选项同组件中的 watch 选项，同样包含 deep 和 immediate 属性，而且还额外接受一个 flush 选项 flush 选项有三个值 pre 默认值，指定回调在渲染前被调用 post 将回调推迟到渲染之后，这时候可以获取页面 dom 元素 sync 回调同步调用，不过会比较消耗性能 1watch(obj, (newValue, oldValue) =&gt; &#123;&#125;, &#123;deep?: true, immediate?: true, flush?: &quot;pre&quot; | &quot;post&quot; | &quot;sync&quot;&#125;) 下面这个例子，当 setTimeout 方法执行完成后，由于改变了 title 的值， 触发了 watch 函数，我们打开 console 就可以发现打印了title 改变之前的值和 修改之后的值 1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125;&#125; 如果我们想要监控多个数据源的变化，可以在watch 的时候 watch 监听对象传入一个数组，同理，当数组内的任意一个元素发生变化时，都会触发watch 函数，而且 watch 回调函数中传入的值也是以数组的形式存在的 123456789const firstName = ref(&#x27;&#x27;)const lastName = ref(&#x27;&#x27;)watch([firstName, lastName], (newValues, prevValues) =&gt; &#123; console.log(newValues, prevValues)&#125;)firstName.value = &#x27;John&#x27; // logs: [&quot;John&quot;, &quot;&quot;] [&quot;&quot;, &quot;&quot;]lastName.value = &#x27;Smith&#x27; // logs: [&quot;John&quot;, &quot;Smith&quot;] [&quot;John&quot;, &quot;&quot;] 如果在监控多个数据源变化时，针对多个数据源修改时是同步修改，并不涉及到 setTimeout 等异步操作时，watch 会把这些更改合并成一次操作，会将所有修改的值一起返回给回调函数 watch hooks 还可以通过回调函数的第三个参数来清除副作用，这个参数会在 watch hooks 被停止或者销毁时，或者副作用重新执行时触发 1234567891011121314151617setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o, onInvalidate) =&gt; &#123; console.log(n, o) onInvalidate(() =&gt; &#123; // 处理副作用方法 &#125;) &#125;) return &#123; title &#125;&#125; 类似的方式还有一个 watchEffect 方法 watchEffect在使用 watchEffect 的时候，会自动执行传入的函数，并且响应式的追踪依赖，并且在依赖发生变更操作时，重新运行传入的函数 1234567891011121314151617181920export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) watchEffect(() =&gt; &#123; console.log(title.value) &#125;) return &#123; title &#125; &#125;&#125; 上述代码执行完成后，我们会发现在控制台会首先输出 setup component， 然后 3s 过程会同时输出 setup component changed，这个是因为 watchEffect 会立即执行，但是因为依赖没有变更，所以就是初始值，3s 后，依赖发生了变更，这时 watch 和 watchEffect 同时触发 watchEffect 在执行完成后，会有一个返回值，我们可以通过这个返回值来停止监听,但是需要注意的是，watchEffect 还是会立即执行，只是当依赖方式变化时，不会再次触发 1234567891011121314151617export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) const stop = watchEffect(() =&gt; &#123; console.log(title.value) &#125;) stop() return &#123; title &#125; &#125;&#125; computed 计算属性1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) let computedTitle = computed(() =&gt; title.value + &quot;abcd&quot;) return &#123; title, computedTitle &#125;&#125; 访问 computed 值的时候和 访问响应式变量的值一样，都是通过 .value 来获取到 provide &amp;&amp; injectvue3 暴露出了两个方法 provide 和 inject 两个方法，这两个方法和 组件内的 provide和inject 方法等同 provide 传入两个参数，第一个参数是属性名，第二个参数是属性值1234setup(props, context) &#123; provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, 26)&#125; inject 传入两个参数，第一个参数是属性名，第二个参数是默认值1234setup(props, context) &#123; inject(&quot;name&quot;, &quot;lxx&quot;) inject(&quot;age&quot;)&#125; 但是通过上述创建的 provide 和 inject 之间不是响应式的，也就是说如果provide 的值改变并不会触发 inject 的值变化，provide 可以使用 ref 和 reactive 方法创建响应式的 provide 12345setup(props, context) &#123; const count = ref(0) provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, count)&#125; 模板引用(ref=””)12345678910111213141516171819202122&lt;template&gt; &lt;div :ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const root = ref(null) onMounted(() =&gt; &#123; // DOM 元素将在初始渲染后分配给 ref console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt; &#125;) return &#123; root &#125; &#125; &#125;&lt;/script&gt; 当页面加载完成后，会自动将 div 绑定给 root 如果需要使用 v-for 绑定多个标签，可以创建响应式数组或者响应式对象来实现","pubDate":"Tue, 02 Aug 2022 07:03:31 GMT","guid":"https://lxx1997.github.io/2022/08/02/vue/vue3-composition-api-setup/","category":"Vue3"},{"title":"创建默认的 hexo categories 首页","link":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","description":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","pubDate":"Wed, 20 Jul 2022 01:16:55 GMT","guid":"https://lxx1997.github.io/2022/07/20/hexo-create-categories-pages/","category":"hexo"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","link":"https://lxx1997.github.io/2022/07/19/vue/relearn-vue2-02/","description":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","pubDate":"Tue, 19 Jul 2022 07:04:48 GMT","guid":"https://lxx1997.github.io/2022/07/19/vue/relearn-vue2-02/","category":"Vue"},{"title":"html-webpack-plugin 的使用与进阶","link":"https://lxx1997.github.io/2022/07/13/web/html-webpack-plugin/","description":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","pubDate":"Wed, 13 Jul 2022 03:19:44 GMT","guid":"https://lxx1997.github.io/2022/07/13/web/html-webpack-plugin/","category":"webpack"},{"title":"常用的前端动画库","link":"https://lxx1997.github.io/2022/07/12/web/web-animation-package/","description":"Lottie 文档 都2022年了，一个还不知道Lottie动画的前端已经OUT啦！ svga SVGA在前端方面的使用","pubDate":"Tue, 12 Jul 2022 08:58:08 GMT","guid":"https://lxx1997.github.io/2022/07/12/web/web-animation-package/","category":""},{"title":"生成 github SSH key","link":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","description":"生成 SSH key打开 git bash 命令行工具 输入一下命令，自动生成 ssh key 地址 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 可以通过命令行直接复制 ssh key 的内容 1clip &lt; ~/.ssh/id_ed25519.pub 复制成功之后，可以将 ssh key 复制到 github 的ssh key 上 和 github 链接执行以下命令 1234ssh-add ~/.ssh/id_ed25519// 或者echo $SSH_AGENT_SOCK 如果执行不成功，可能是 ssh-add 未开启，可以通过命令行查看是否开启ssh-add 服务1ps -ef | grep ssh 开启 ssh-add 服务12cd ~/.ssheval $(ssh-agent) 执行完上述命令后就可以进行ssh 链接","pubDate":"Fri, 08 Jul 2022 06:19:07 GMT","guid":"https://lxx1997.github.io/2022/07/08/github-ssh-key-generate/","category":"git"},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part1","link":"https://lxx1997.github.io/2022/07/07/vue/relearn-vue2-01/","description":"computed 属性默认是只有 getter 属性的，也就是说我们只能获取到computed 属性的值，但是无法修改它，但是我们可以手动的设置 setter 属性，这样就可以手动赋值了 1234567891011121314export default &#123; computed() &#123; fullName: &#123; set: function (val) &#123; let name = val.split(&quot; &quot;) this.firstName = name[0] this.secondName = name[1] &#125;, get: function () &#123; return this.firstName + &quot; &quot; + this.secondName &#125; &#125; &#125;&#125; v-for 和 v-if 为什么不推介一起使用 这个是因为 v-for 和 v-if 的优先级问题，vue 会先进行 v-for 循环渲染元素，最后在进行 v-if 控制是否显示元素，会造成无谓的资源浪费 可以采用 v-show 代替 v-if 或者使用计算属性来代替 v-if， 只渲染我们想渲染的元素 key attribute 用来表示这个元素是完全独立的，和其他元素不同，在日常操作中可以用来强制刷新元素内容，只需要修改元素的key，就会重新去渲染元素 我之前用过 v-if 和 $nextTick 来强制重新渲染元素内容，很明显使用上述方法是一种很方便的操作 v-for 可以使用 in 或者 of 来作为分隔符 v-for 遍历对象时 v-for=&quot;(value, name, index) in obj&quot; 三个值 分别为 值，键，和 索引 vue 中可以使用 template 标签，该标签类似 react 中的&lt;&gt;&lt;/&gt;和React.Fragment,在实际渲染中并不会被渲染出来 如果我们想要在点击事件中访问原始的 dom 时间，可以将特殊的变量 $event 传到方法中 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 事件捕获的时候触发，如果点击的是子元素，会先于子元素事件触发 .self 只有当 event.target 是元素自身时触发，点击子元素时不会触发 .once 只会触发一次 .passive 和 .prevent 相反，不会阻止默认事件触发 使用修饰符的时候，顺序很重要，代码会以同样的顺序产生，例如v-on:click.prevent.self 会阻止所有点击，而 v-on:click.slef.prevent 只会阻止元素对自身的点击 按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 支持按键码 可以通过全局的 config.keyCodes 自定义按键修饰符别名1Vue.config.keyCodes.f1 = 112 系统修饰键 (修饰键在和其他事件一起使用的时候，需要同时触发才行，否则并不会单独触发修饰键) .ctrl .alt .shift .meta .exact 精确修饰符，允许我们控制精确的系统修饰符组合触发的事件 &lt;input v-model=&quot;toggle&quot; type=&quot;checkbox&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; 此时 toggle 会取 对应的 true-value 和 false-value 的值 v-model.lazy 默认情况下，v-model 会在input 事件触发后将输入框的值与数据同步，添加lazy 修饰符后，从而转为在 change 事件之后触发 v-model.number 会自动将用户输入的值转为数值类型 v-model.trim 会自动去除用户输入内容两端的空格 自定义组件中的 data 必须是一个函数，是为了保证每次创建组件的时候都能拿到一个独立的数据，否则，重复创建组件时，组件内的数据由于有同一个引用地址，会互相干扰 v-model 在自定义组件中使用相当于 v-bind:value 和 v-on:change 的组合 可以通过组件的 model 属性改变 v-model 的默认属性和事件绑定 12345678910export default &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27; &#125;, mounted() &#123; console.log(this.checked) this.$emit(&quot;change&quot;, &quot;val&quot;) &#125;,&#125; &lt;component v-bind:is=&quot;CustomComponent&quot;&gt;&lt;/component&gt; 通过 v-bind:is 可以自定义组件，组件会跟随 CustomComponent 的值变化而变化 传入一个对象的所有 property, 组件内部可以直接通过 示例中 post 拿到对应的属性 1&lt;component v-bind=&quot;post&quot;&gt;&lt;/component&gt; props 验证 123456789101112export default &#123; props: &#123; propA: &#123; type: String, default: &quot;&quot;, require: false, validator() &#123; &#125; &#125; &#125;&#125; type props 参数类型 String, Number, Boolean, Array, Object, Date, Function, Symbol, 或者自定义的构造函数 default 默认值，引用类型数据 需要使用函数并且通过return 返回默认引用类型 require 是否必须传 默认为 false validator 自定义效验规则 禁用 Attribute 继承，可以设置 inheritAttrs false 来之根元素继承 Attribute 具体表现为 如果设置为 false 子组件不会渲染 attribute， true 会在子组件上渲染 attribute 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 slot 缩写 v-slot: -&gt; # 后备内容 如果我们没有向插槽内提供内容，此时将会显示后备内容 &lt;slot&gt;默认内容&lt;/slot&gt; 具名插槽 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot-component v-slot:header&gt;&lt;/slot-component&gt; 作用域插槽 插槽内部 123456&lt;template&gt; &lt;div&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 外部使用 1234567&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 如果有多个插槽 12345678910&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;slot v-slot:other=&quot;otherSlotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 子组件可以通过 $root 来访问和修改根组件的实例及方法 provide, inject provide 选项允许和指定提供给后代组件的数据和方法 123456provide: function() &#123; return &#123; a: function() &#123;&#125;, b: 0 &#125;&#125; inject 允许子元素接受 provide 提供的 provide 1inject: [&#x27;a&#x27;, &#x27;b&#x27;] 但是出于设计考虑， 这些数据不是响应式的，而且会对重构及代码复用有很大的影响 X-Template x-template 需要定义在 Vue 所属的 DOM 元素外。 123&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component(&#x27;hello-world&#x27;, &#123; template: &#x27;#hello-world-template&#x27;&#125;) transition 过渡动画 v-enter 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义动画类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 显性的过渡持续时间 &lt;transition :duration=&quot;1000&quot; /&gt; &lt;transition :duration=&quot;&#123;enter: 500, leave: 800&#125;&quot; /&gt; JavaScript 钩子 123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; mixins 混入选项合并 数组对象会在内部进行合并，例如 data,属性名发生冲突时，以组件内属性优先 钩子函数合并成数组，都会被调用，混入对象的钩子函数优先于组件内钩子函数调用 值为对象时,将会被合并成为一个对象，且组件对象的键值对优先级更高 Vue.config.optionMergeStrategies 可以通过次宣讲自定义逻辑合并逻辑 自定义指令 1234567directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus /&gt; 钩子函数 bind 绑定时调用，只调用一次 inserted 被绑定元素插入父节点时调用 update 所在组件更新时调用，可能发生在子组件更新之前 componentUpdated 所在组件和子组件全部更新后调用 unbind 指令与元素解绑时调用 钩子函数参数 el 绑定的元素，可以用来操作 DOM binding name 指令名 value 指令绑定的值 oldValue 制定绑定的前一个值 expression 字符串形式的指令表达式 =&quot;1 + 1&quot; arg 传给指令的参数 :foo modifiers 指令修饰符 .foo vnode 当前虚拟节点 oldVnode 上一个虚拟节点 functional 函数式组件函数式组件没有响应式数据，也没有实例（没有 this 上下文）相反会有一个 context 参数 包含如下字段 props children slots scopedSlots data parent listeners injections","pubDate":"Thu, 07 Jul 2022 07:56:07 GMT","guid":"https://lxx1997.github.io/2022/07/07/vue/relearn-vue2-01/","category":"Vue"},{"title":"好用的浏览器页面测试页面性能工具","link":"https://lxx1997.github.io/2022/07/07/web/web-page-speed-testing-tools/","description":"pagespeed地址： https://pagespeed.web.dev/ gtmetrix地址： https://gtmetrix.com/ web.dev地址： https://web.dev/measure/","pubDate":"Thu, 07 Jul 2022 03:29:14 GMT","guid":"https://lxx1997.github.io/2022/07/07/web/web-page-speed-testing-tools/","category":"performance"},{"title":"最全的页面性能优化","link":"https://lxx1997.github.io/2022/06/24/web/how-to-make-pagespeed-fast/","description":"为什么要进行性能优化我们会在什么时候对页面性能进行优化呢，在我的观点里大致有以下几个方面 页面加载时间较长，导致部分用户在页面还未加载完成之后便离开了页面，增加了用户的跳出率 因为 google 的搜索算法，对页面性能这一块有一定要求，如果页面性能较差，那么当用户搜索工具关键词时，页面的顺序就越靠下，这样针对用户自然搜索流量这一块会有很大影响 用户在使用工具时，可能会由于部分操作及代码实现的影响，导致用户使用时会比较卡顿，用户体验较差，降低用户留存 如果想要提高用户的留存率这一块的数据，那么增加用户流量及降低用户跳出率就比较重要了 怎么进行性能优化我认为可以从以下几个方面来进行性能优化 html 解析阶段 javascript 加载阶段 页面渲染阶段 用户操作过程中 下面来分别介绍一下在各个阶段要具体要怎么做 html 解析阶段当浏览器请求到页面 html 的时候，会对html 进行解析，如果中间遇到 link 标签 或者 script 标签时，会去请求对应资源，并进行解析，在解析 css 文件的过程中，并不会阻止浏览器解析 html 文件，但是要注意，javascript 文件会阻止 css 和 html 文件的解析，所以尽量要把 javascript 文件访问 body 标签的最后，不要阻止html 和 css 的解析 在这个阶段我们可以通过以下几种方法提高页面速度 prefetch &amp;&amp; preload使用 prefetch 和 preload 方式 预加载文件，但是要注意这两个方法加载文件的优先级程度不同， prefetch 的优先级最低，浏览器不会立即下载文件，而是会在空闲时间去下载文件， preload 的优先级最高，会立即去下载文件，但是这两个方式都不会去解析文件，只是下载文件后存放本地，如果我们需要使用时就不必再次下载 注意：由于浏览器对于同一个域名下请求的个数有限制，所以要谨慎使用prefetch 和preload 方法，如果一次性加载文件过多，反而会影响后续资源的获取，起到反优化的效果 12345&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt; DNS Prefetch，即DNS预获取当浏览器加载文件时，会对地址进行 DNS 解析,获取地址对用的IP地址，虽然浏览器内部对这一部分操作进行过优化，会在一定时间内缓存 DNS 解析结果，但是 DNS 解析的时间还是比较长的，大概需要 20ms - 120ms 左右的时间，我们可以针对会使用的域名开启 dns 预解析操作，在浏览器空闲的时候，去解析 DNS,当我们使用的时候，就可以减少 dns 解析的时间操作，提高接口请求时间 123&lt;!-- 开启 DNS 解析 content: off 关闭 on 打开 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.template.com&quot;&gt; 但是要注意不要滥用预解析，如果短时间不需要的域名，可以不需要 dns 预解析 script 标签位置浏览器在遇到script 标签时，会暂停解析 html 和 css 文件，转而去解析 js 内容，这样就阻止了页面的解析和渲染，所以尽量保证script 标签在 body 标签的末尾，减少 js 文件对html 文件解析的影响 骨架屏可以采用骨架屏的方式，防止用户因为看不到内容，从而离开页面 JavaScript 解析阶段在这个阶段，浏览器回去下载页面渲染所需要的 javascript 文件，解析，然后渲染到页面上，在这个阶段影响页面加载速度主要有以下几个方面： 单个 js 文件过大，请求及解析文件耗时过大 同一时间请求了过多的资源，导致网络被占用，进一步影响了页面加载 采用不同域名加载静态资源我们都知道浏览器对同一个域名下的请求个数有一定的限制，例如google 浏览器限制最大并发个数是6个，当同时发起的请求的个数超过6个时，只会有有6个发起请求，其他的处于 padding 状态，只有当请求完成时，才会有下一个请求开发发起请求。 因此我们可以采用通过不同域名来请求静态资源，例如 所有的 js 资源可以单独采用一个域名来进行，图片等媒体资源可以采用一个域名来访问，这个就不会因为同一时间内请求的资源过多，影响页面加载速度 CDN 缓存当浏览器下载资源，会先通过 DNS 解析解析出资源所在主机的ip地址，然后去拉取资源，如果服务器刚好在用户所在城市附近，那么资源的加载速度并不会有多大影响，但如果距离过远，例如你人在北京，想要访问在美国的一台服务器上的资源，这个时候由于网络传输的印象，回导致资源获取延迟比较大。 这个时候就需要使用 CDN 缓存了， 这就是CDN的由来，分布式缓存服务器，主要功能是在转发、传输、链路抖动等情况下，最小化资源的时延，并保证信息的连续性和速度。 当我们访问资源，会首先向距离我们最近的 DNS 服务器发出资源请求，如果 这个DNS 服务器缓存有我们想要的资源，如果没有，则会向原服务器请求资源，然后返回给我们，这样一般就降低了资源在请求链路传输的延迟问题。 但是使用 DNS 缓存也会有一些弊端，因为资源都是已经缓存到 DNS 服务器上了，如果在资源缓存未失效的请求，资源进行了变更，这个时候用户访问到的又可能还是旧版资源，这个时候我们可以手动请求 DNS 缓存，但是这个方法不太方便，所以我们可以通过打包的方式，对静态资源添加 hash 后缀，这样每次发版或者更换资源，都会把地址专项新的地址，这样 CDN 就会重新对资源进行缓存针对不能添加 hash 的文件，我们可以通过修改参数的方式来使 CDN 重新刷新缓存，例如123// package.version 为 package.json 的版本号let url = `http://www.example.com/useinfo?_v=$&#123;package.version&#125;`axios.get*(url) 这样当我们每次发版的时候，只需要修改一下版本号，就可以刷新 CDN 缓存了 减少 javascript 包的体积当 js 文件体积过大时，我们需要减少 javascript 包的大小，来减少js 加载时间和解析时间。 可以通过一下几种方式减少包的体积 分包 我们可以通过打包的方式，来将一些第三方资源包打包到一个文件，因为这部分资源我们通常并不会经常修改，这样当我们发版的时候，如果第三方资源并没有发生变化，那么这一块的资源并不会清空 CDN 缓存 1234567891011121314151617181920module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &quot;vendors&quot;, priority: -10 &#125;, utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 这样所有的 node_modules 下需要打包的资源都会打包到 vendors js 文件里面 如果是多页面应用还可以吧多次使用的资源的资源打包到同一个包里面，这样多个页面就可以共用这一个包 123456789101112131415module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 资源懒加载 这里主要以 vue 项目举例 假如我们的页面有多个路由，我们在访问其中一个路由的时候其实是不需要加载其他路由所需要的内容，这个时候可以使用懒加载的方式来减少首屏需要加载的资源 1234&#123; name: &quot;/home&quot;, component: () =&gt; import(&quot;./home.vue&quot;)&#125; 这个时候只有我们访问 /home 这个路由的时候才会加载 home 所需要的资源， 针对同一个路由中 也需要懒加载的组件的组件可以使用以下方式 1234567891011121314&lt;tempalte&gt; &lt;LazyLoad v-if=&quot;lazy&quot; /&gt;&lt;/tempalte&gt;&lt;script&gt;const LazyLoad = () =&gt; import(&quot;./LazyLoad.vue&quot;)export default &#123; data() &#123; return &#123; lazy: false &#125; &#125;&#125;&lt;/script&gt; vue 在内部做过处理，只有当 lazy = true， 需要渲染 LazyLoad 组件时，才会加载对应资源 通过以上操作，我们可以极大减少首屏加载所需要的资源大小，提高页面加载速度 Tree Shaking tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。 使用了 tree shaking后， 如果一段代码我们并没有通过 import 方式引入，这段代码在打包的时候就不会打包进去，但是这个时候也会出现其他问题，因为在迭代过程中，可能之前我们引入了一些资源，但这些资源在后期迭代的过程中不在使用了，但是并没有从代码中移除，这个时候，这些资源也会被打包到代码中，并且项目越大，这种问题出现的几率越大。 因此webpack 扩展了这个检测能力，主要通过 package.json 的 sideEffect 属性来标记 当我们把 sideEffect 设置为 false 时， 代表所有的代码都不包含副作用，告诉 webpack 可以安全的删除所有的未使用的 export 导出。 如果部分代码存在副作用，我们通过一个数组来过滤掉这部分存在副作用的代码。 123456789101112&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: false&#125;&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot; ]&#125; 我在对 vue 项目进行代码 treeshaking 的时候遇到过这样一个问题，打包没有问题，但是发到测试环境后看，页面样式发生了混乱，推测是 可能是由于 vue 文件进行 treeshaking 时，所以 就把 vue 文件标为 副作用文件，不进行treeshaking 12345678&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot;， &quot;*.vue&quot;, &quot;*.less&quot; ]&#125; gzip 压缩 资源在经过网关的时候可以开启 gzip 压缩，使用了 gzip 后，静态文件可以被压缩 3 - 10 倍左右 经过以上操作，可以极大减少用户请求页面加载资源大小，减少服务器带宽压力 页面渲染阶段在页面渲染阶段 主要是用户让用户能够更快的看到页面，以及可操作，所以这个阶段就需要我们根据需求调整 资源加载 及 js 执行时间长度 延迟加载资源 对于部分第三方组件，例如支付，广告这些全局共用的js，可以等到使用的时候再去加载 从产品设计方面 针对部分阻塞页面加载及用户操作的资源可以通过用户的主动操作触发，而非页面一加载就执行 用户操作过程再用户操作过程中，可能有些操作会需要大量计算，由于浏览器是单线程操作，长时间的计算将会阻止用户操作，造成页面出现卡顿的现状,我们可以通过采用分段计算和优化计算消毒，或者采用替代方法。 使用全局加载动画，告诉用户当前属于什么状态。 canvas.toDataURL 可以采用 canvas.toBlob 方法替代（如果有使用的话） setTimeout， setInterval， requestAnimationFrame 等方式实现异步操作","pubDate":"Fri, 24 Jun 2022 14:20:06 GMT","guid":"https://lxx1997.github.io/2022/06/24/web/how-to-make-pagespeed-fast/","category":"performance"},{"title":"SPA-prerender","link":"https://lxx1997.github.io/2022/04/23/web/SPA-prerender/","description":"由于单页面应用只生成了一个HTML 文件，如果想要做 SEO 的话， H 标签，img 标签的 alt 这些并不会被爬虫抓取到，所以需要我们做预渲染，使得生成的html文件中包含需要 爬虫抓取的内容， react-snap 插件可以帮助实现这个操作 使用安装1yarn add --dev react-snap package.json123&quot;scripts&quot;: &#123;&quot;postbuild&quot;: &quot;react-snap&quot;&#125; 入口 (src/index.js)12345678import &#123; hydrate, render &#125; from &quot;react-dom&quot;;const rootElement = document.getElementById(&quot;root&quot;);if (rootElement.hasChildNodes()) &#123;hydrate(&lt;App /&gt;, rootElement);&#125; else &#123;render(&lt;App /&gt;, rootElement);&#125; 在使用 build 打包的时候，打包完成之后会执行我们添加的 postbuild 命令，然后将root下面的内容添加到 #root dom 里面，这样爬虫就可以从页面上抓取到关键词 问题 Q: 在日常发版过程中通常会采用自动化发版，我们公司采用的是 gitlab 的 CI/CD 环境进行发版，最后进行postbuild 操作的时候 发现无法预渲染，要怎么解决 A: 虚拟环境的话，可以采用 puppeteer 来模拟浏览器环境puppeteer 是 Node.js 的一个库可以用来模拟 chrome 环境1234// gitlab-ci.ymlapt-get install -yq gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget #install dependencies for puppeteer, which is a dependency for react-snapsh ./bash.sh #運行自定義腳本以更改 react-snap 上的選項以使其工作運行自定義腳本以更改 react-snap 上的選項以使其工作1234# bash.sh# modifies react-snap defaultOptions to add the --no-sandbox and --disable-setuid-sandbox flags so that puppeteer/chromium can run in the codebuild standard imagesed -i &quot;s/puppeteerArgs: \\[\\],/puppeteerArgs: \\[\\&quot;--no-sandbox\\&quot;, \\&quot;--disable-setuid-sandbox\\&quot;\\],/&quot; ./node_modules/react-snap/index.jsecho changed arguments in react-snap 123456789101112131415161718192021&quot;reactSnap&quot;: &#123; &quot;include&quot;: [ // 需要进行预渲染的页面 &quot;/prerender.html&quot;, ], &quot;puppeteerArgs&quot;: [ &quot;--no-sandbox&quot;, &quot;--disable-setuid-sandbox&quot;, &quot;--disable-web-security&quot; // 允许 接口跨域进行请求 ], &quot;viewport&quot;: &#123; // 预渲染的页面宽高，可以控制移动端适配和web端适配 &quot;width&quot;: 1400, &quot;height&quot;: 850 &#125;, &quot;userAgent&quot;: &quot;ReactSnap&quot;, // 环境，可以通过这个来区分是否是处于预渲染环境 &quot;crawl&quot;: false, &quot;concurrency&quot;: 1, &quot;inlineCss&quot;: false, &quot;removeStyleTags&quot;: true, &quot;skipThirdPartyRequests&quot;: false, &quot;puppeteerIgnoreHTTPSErrors&quot;: true&#125; Q: 页面存在国际化语言，页面再进行预渲染之后，在线上环境会出现文字先消失在出现的问题要怎么解决 A: 因为预渲染主要是把 页面渲染完成之后的内容重新写到html 里面，并不包含js文件，加载页面时，会去获取多语言文件，在多语言文件获取之前，通过key 去拿对应的文案时会获取不到，所以就变成了空白，文件加载完成之后，这个时候多语言文案就可以正常拿到了 可以采用先加载多语言文件再渲染页面的方式，或者再打包时就把对应多语言打包进去，放到window 对象上 12345678910111213loadLanguageJson(language).then(() =&gt; &#123; const rootElement:HTMLElement = document.getElementById(&quot;root&quot;)!; if (rootElement.hasChildNodes()) &#123; hydrate(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; else &#123; render(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; &#125;)","pubDate":"Sat, 23 Apr 2022 14:39:08 GMT","guid":"https://lxx1997.github.io/2022/04/23/web/SPA-prerender/","category":"SEO"},{"title":"window.IntersectionObserver","link":"https://lxx1997.github.io/2022/04/05/web/window-IntersectionObserver/","description":"window.IntersectionObserverIntersectionObserver 提供了一种异步观察观察目标元素与其祖先元素或者顶级文档交叉状态的方法，即目标元素元素出现或者隐藏的时候就会触发 使用1var observe = new IntersectionObserver(callback， options) callback 回调函数，当我们监听的元素触发到阈值的时候会触发回调函数，callback 会有两个参数 entries 和 observer， entries 是一个数组返回触发监听的目标元素 options root root 属性是目标元素的祖先元素，如果未传入值则默认使用顶级文档视窗 rootMarign 计算交叉时添加到root边界和的矩形偏移量，所有偏移量均可用像素或者百分比 主要作用是缩小或者扩大根元素的判定范围 thresholds 一个包含阈值的列表，按照升序排列，列表中每个阈值都是监听对象的交叉区域与边界区域的比率，当监听对象的任何阈值被越过时，都会生成一个通知，如果未传入值，则默认为0 例如 [0, 0.25, 0.5, 0.75, 1]表示当目标对应比例在目标元素可见时，触发回调函数 方法 disconnect 停止监听工作 observe 添加监听目标元素并进行监听 takeRecords 返回所有观察目标的 intersectionObserverEntry 对象数组 unobserve 停止监听特定目标元素 IntersectionObserverEntry12345678910111213141516171819&#123; time: 3893.92, // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target: element // 被观察的目标元素，是一个 DOM 节点对象 rootBounds: ClientRect &#123; // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // 目标元素的矩形区域的信息 // ... &#125;, intersectionRect: ClientRect &#123; // 目标元素与视口（或根元素）的交叉区域的信息 // ... &#125;, intersectionRatio: 0.54, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0&#125; 使用 IntersectionObserver1234567891011121314151617// 创建 IntersectionObserver 实例var observe = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;, &#123; root: document.getElementById(&quot;app&quot;), rootMargin: &quot;0px 0px 0px 0px&quot;, thresholds: [0, 0.25, 0.5, 0.75, 1]&#125;)// 添加目标对象observe.observe(element)// 停止监听observe.unobserve(element)// 断开链接observe.disconnect() 我们可以解决什么问题 图片或者资源懒加载问题，使用 IntersectionObserver 可以监听到图片元素是否滚动到页面上，从而可以实现预加载和懒加载 元素曝光统计，我们在实际需求中可能需要统计或者计算元素是否曝光在页面上，然后向后台发送统计事件，这样可以方便产品对页面内容进行调整 其他计算，比如我们可能需要判断某个元素是否出现在页面上，然后再进行特殊的计算，如果这些计算数量较少，我们可以不做任何关注，但是如果页面上存在大量的这样的计算，我们需要实现按需计算，这个时候就可以使用 IntersectionObserver 监听元素是否出现在页面，来进行计算，从而减少浏览器内存消耗，提高用户体验","pubDate":"Tue, 05 Apr 2022 12:51:06 GMT","guid":"https://lxx1997.github.io/2022/04/05/web/window-IntersectionObserver/","category":"JavaScript"},{"title":"高性能JavaScript","link":"https://lxx1997.github.io/2022/03/26/reading/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/","description":"最近读了一本关于如果写出性能更优的JavaScript的书，提取了一些相关的知识点 JavaScript 文件加载及执行我们都知道一个完整前端页面想要展示出来，需要包含 html， css，和JavaScript 文件，其中 html 是框架，css是样式，JavaScript负责交互。但是多数浏览器采用单一进程来处理用户界面ui和JavaScript脚本执行，同一时刻只能做一件事，所以JavaScript执行的时间越久浏览器等待的时间就会越久 浏览器页面在获取到页面时首先会先解析html元素，在解析的过程中，如果遇到css文件或者js文件的时候会去下载文件，下载完成之后然后再去解析文件，但是针对JavaScript文件来说，其实浏览器并不知道js有没有执行改变页面元素的操作，因此浏览器在下载和解析文件的时候，其实是一个暂停的操作，所以当 js 文件执行时间越久，页面空白的时间就越长 解决方式： 将script 脚本尽量放在页面的最下方，保证页面解析完成之后才回去解析JavaScript脚本 针对script 脚本的数量做限制，每遇到一个script标签，浏览器都会停止其他操作去解析script脚本,而script脚本越大，下载时间越长，数量越多，http链接的额外请求的消耗越大。 script 标签的async 属性和 defer 属性，async 属性可以让资源在下载过程中不阻塞浏览器的解析，当下载完成之后在解析脚本文件，defer 属性则是延迟加载 script 文件，当页面解析完成之后才会去加载脚本文件 动态加载脚本文件。对于首屏加载不需要的脚本文件，我们可以在使用的时候再去加载文件。我们可以动态创建script标签，当js文件加载完成之后，再把script标签 append 到html文档中 数据存储方式JavaScript中有四种基本数据存储位置 字面量 字面量代表自身，不存储在特定位置，JavaScript中的字面量有字符串、数字、布尔值、对象、数组、函数、正则表达式、null、undefined 本地变量 开发人员使用关键字 var，let const 定义的数据存储单元 数组元素 存储在JavaScript数组对象内部，以数字作为索引 对象成员 存储在JavaScript对象内部，以字符串作为索引 大多数情况下，从字面量和本地变量存取数据性能是微不足道的，访问数组元素和对象成员的代价则高一些 作用域作用域决定了那些数据能够被访问，作用域内的每个对象都被成为一个可变对象，每个对象以键值对的形式存在，当函数创建后，作用域链就会被创建此函数的作用域中科访问的数据对象所填充，在函数内部表现为 [[Scope]] 属性 函数在被执行的时候，就会创建一个执行环境，函数每次执行时对应的执行环境都是独一无二的，同时调用一个函数会创建多个执行环境，函数调用完成后，执行环境就会被销毁 函数的作用域链是以栈的形式存在的，当一个函数被创建时，会创建一个局部作用域放到栈的顶端，当函数执行完成后，作用域会从栈顶删除，当在函数中想要寻找一个变量时，执行环境会沿着作用域链向下寻找，最后到全局作用域，如果找到了变量，就返回变量所存储的内容，否则返回 undefined 因此如果我们查找的对象在作用域链中越深，查找就越耗费时间，因此我们可以在函数的局部作用域链中，创建一个新的变量来存储我们查找的对象 使用 with 和 try...catch... 方法可以修改函数的作用域链对象，但是实际并不推介这样做 闭包 闭包时 JavaScript 最强大的特性之一，它允许函数访问余部作用域链之外的数据，但是频繁的使用闭包有可能会造成问题。 平时我们使用函数时，会创建一个局部作用域，当函数执行完成后，这个局部作用域会被删除，但是由于引入了闭包，引用依然存在，导致这个局部作用域无法被销毁掉，造成了更多的内存开销，造成内存泄漏 对象 JavaScript的对象是基于原型，原型定义并实现了一个新创建的对象所必须包含的成员泪飙，原型对象为所有对象实例共享。 因此对象中有两种成员类型：实例成员和原型成员，可以用 hasOwnProperty 方法来判断对象是否包含特性的实例成员 当我们存取对象的属性或者方法时，会先查找对象的实例成员是否存在，如果不存在，则会沿着原型链进行查找，因此，对象在原型链存在的位置越深，查找起来越慢 因此我们要学会缓存对象成员的值，尽量避免在同一个函数中多次读取同一个实验对象 DOM对象DOM 是浏览器对象，是浏览器提供给JavaScript用于访问文档中的数据API,由于javascript和dom两个相互独立的功能只能通过接口彼此连接，因此会产生消耗。 我们每一次访问或者修改dom属性都会产生性能消耗，因此我们可以减少DOM的访问次数，把大部分的运算留在 ECMAScript 这一端 innerHTML 和 DOM方法 innerHTML相对来说要快一点，因为它在绝大部分浏览器中都运行的很快，但是对于大部分的日常操作而言，并没有太大区别，我们更应该根据可读性，稳定性，团队习惯和代码风格来综合决定使用哪种方式 HTML集合 document.getELementsByName() document.getELementsByClassName() document.getELementsByTagName() document.images document.links document.forms 这些集合的长度会随着页面元素的变动而变动，所以我们不能简单的使用集合的长度来作为判断，我们可以把集合拷贝一个普通数组，在普通数组上进行操作 在方位内集合属性可以采用局部变量的方式存储集合元素的部分属性，避免多次重复读取，浪费性能 重绘和重排 引起重绘的方法： 元素的颜色等非几何属性发生变化 引起重排的方法： 添加或者删除可见dom元素 元素的位置发生改变 元素的几何尺寸发生变化 内容发生改变 页面初始化 浏览器窗口改变以上这些改变都会造成浏览器需要重新计算页面元素的位置，而重绘则不需要重新计算页面元素位置，重排一定会引起重绘，但是重绘不一定会引起重排 我们在操作页面元素时，要尽量减少页面重绘及重排次数，每一次重排都需要大量的计算，消耗浏览器性能，可以将多次重绘重排整合成一次进行操作 将页面元素变为不可见元素，在修改元素的属性，此时只需要发生两次重排 使用 文档碎片在DOM外创建子树再拷贝回文档 拷贝元素，修改副本，在替换原始元素 浏览器尝试通过队列化修改和批量执行的方式最小化重排次数，当你查询布局信息时，比如偏移量，滚动位置，浏览器为了返回最新的值，会刷新队列并应用所有变更，因此我们可以设置局部变量用来存储布局信息，避免重复获取 使用事件委托 当页面存在大量需要一次或者多次绑定事件的元素，会占用更多的内存，我们可以事件委托，只需要在外层元素绑定一个处理器，就可以处理起子元素上的所有事件 算法及流程控制 减少迭代的工作量，对于常用且不便的数据进行缓存处理 减少迭代次数（达夫设备：循环展开技术，使得一次迭代中实际执行力多次迭代） 优化if...else...语句，最常用的判断放在最前面，这样可以减少对比次数 递归操作，根据情况缓存每一次递归操作的值 使用对象或者数组来缓存数据 快速响应的用户界面 任何javascript任务都不应当执行超过 100 ms 过长的运行时间会导致UI更新出现明显的延迟，从而对用户的体验造成负面影响 使用定时器来安排代码的延迟执行，把长时间运行脚本分解成一系列的小任务 使用web worker 开启新的 javascript线程","pubDate":"Sat, 26 Mar 2022 14:21:26 GMT","guid":"https://lxx1997.github.io/2022/03/26/reading/%E9%AB%98%E6%80%A7%E8%83%BDJavaScript/","category":"reading"},{"title":"服务端 渲染 - nextjs","link":"https://lxx1997.github.io/2021/09/14/web/ssr-nextjs-01/","description":"初始化项目123npx create-next-app# oryarn create next-app 如果想要添加特殊配置有以下选择 --ts，--typescript 使用TypeScript -e，--example [name][github-url]使用样例 --example-path --use-npm 应用页面路由 Routernextjs 路由匹配规则 /pages/example.js | /pages/example/index.js 匹配路由 /example /pages/example/[id].js 匹配路由 /example/1 /pages/example/[...args].js 匹配路由 /example/1/2.../n /pages/example/[[...args]].js 匹配路由 /example/.../n 12345678// /example/[id].js// 路由为 /example/1import &#123; useRouter &#125; from &quot;next/dist/client/router&quot;;const Index = (): JSX.Element =&gt; &#123; const router = useRouter() const query = router.query // &#123;id: 1&#125;&#125;","pubDate":"Tue, 14 Sep 2021 14:31:56 GMT","guid":"https://lxx1997.github.io/2021/09/14/web/ssr-nextjs-01/","category":"JavaScript,SSR,nextJs,React"},{"title":"threeJs 学习之路 - API 及 参数传递","link":"https://lxx1997.github.io/2021/08/15/web/threeJs-study-api/","description":"THREE.Scene() 创建场景对象方法 add 添加物体，会被添加到坐标为 (0, 0, 0)的位置上 THREE.PerspectiveCamera() 这个对象是 threeJs 中相机的其中一种 透视摄像机参数有四个 视野角度 表示在显示器上看到的场景的范围，值是一个角度（值会 mod 360） 长宽比 长宽比的值会影响我们渲染物体的是否是正常的还是拉伸的，压扁的 远剪切面 近剪切面 物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中，根据我们渲染的物体的z轴的值和摄像机的z轴位置来决定的 THREE.WebGLRenderer() 创建一个渲染器实例属性 domElement 渲染器生成的dom元素，通过 appendChild 方法插入到页面中 setSize(width, height, updateStyle) 第二个参数决定是否以较低的分辨率来渲染 render(scene, camera) 渲染场景和摄像机","pubDate":"Sun, 15 Aug 2021 01:53:24 GMT","guid":"https://lxx1997.github.io/2021/08/15/web/threeJs-study-api/","category":""},{"title":"threeJs 学习之路 - 创建画布及绘制图形","link":"https://lxx1997.github.io/2021/08/15/web/threeJs-study-01/","description":"因为threeJs 版本在不断更新，所以本文可能部分 api 被替换，如果出现问题，请百度或者查找官方文档对应api 初始化引入引入的话可以采用 npm 引入 或者直接通过 CDN 方式引入 npm 引入 123456npm install three// 引入const THREE = require(&quot;three&quot;)import THREE from &quot;three&quot; CDN 方式引入 CDN地址 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js&quot;&gt;&lt;/script&gt; 创建画布 12345678910// 创建场景const scene = new THREE.Scene()// 创建一个摄像机const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000)// 实例化渲染器const renderer = new THREE.WebGLRenderer()// 设置渲染大小renderer.setSize(window.innerWidth, window.innerHeight)renderer.render(scene, camera)document.body.appendChild(renderer.domElement) 编写完上述代码后应该会出现一个黑色区域，这个就是threeJs创建的 canvas 画布 绘制元素绘制一个正方体 创建一个立方体 需要一个 BoxGeometry 对象，这个对象包含了立方体所有的定点(vertices)和面(faces) 然后对于这个立方体给一个材质，这里我们采用 MeshBasicMaterial 方法，并设置一个默认颜色 接下来需要一个网格（Mesh），这个网格包含了 几何体及其材质的对象，然后通过 Scene 中的 add 方法添加到页面上，如果与摄像机重叠，还需要移动摄像机的位置 最后通过 WebGLRenderer 的 render 方法渲染 如果想要动起来，这个时候需要我们更改摄像机或者立方体的位置,并通过定时器函数，重新渲染 123456789101112131415161718var geometry = new THREE.BoxGeometry()var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;)let cube = new THREE.Mesh(geometry, material)camera.position.z = 5// scene 为之前创建的 THREE.Scene() 实例scene.add(cube)// renderer.render(scene, camera)function render() &#123; requestAnimationFrame(render) // 立方体旋转 旋转速度 cube.rotation.x += 0.1 cube.rotation.y += 0.1 // 修改摄像机的位置 // camera.position.set(x, y, z) renderer.render(scene, camera)&#125;render() 绘制线条 对于绘制线条 我们可以选择的材质只有 LineBasicMaterial 和 LineDashedMaterial 定义好材质之后，我们需要一个带有定点的 Geometry 或者 BufferGeometry 然后通过 THREE.Vector3(x, y, z) 定义线条的顶点，线条是画在连续的顶点之间的 最后 通过 THREE.Line(geometry, material) 将材质和顶点联系起来 123456789101112// LineDashedMaterial 创建 虚线性的 线条// LineBasicMaterial 创建 实线线条const material = new THREE.LineDashedMaterial(&#123;color: 0x0000ff&#125;)const points = []// 创建 3d 线条的各个顶点points.push(new THREE.Vector3(-10, 0, 20))points.push(new THREE.Vector3(0, 10, 20))points.push(new THREE.Vector3(10, 0, 20))// 通过 setFromPoints 设置线条的顶点const geometry = new THREE.BufferGeometry().setFromPoints(points)// 创建线条治理const line = new THREE.Line(geometry, material)","pubDate":"Sun, 15 Aug 2021 01:38:18 GMT","guid":"https://lxx1997.github.io/2021/08/15/web/threeJs-study-01/","category":"JavaScript,threeJs,webgl"},{"title":"JavaScript 设计模式联系  -  创建型设计模式","link":"https://lxx1997.github.io/2021/06/14/web/design-parttern-01/","description":"简单工厂模式 简单工厂模式(Simple Factory) 又叫静态工厂模式，由一个工厂对象决定创建摸一种产品对象类的实例 简单工厂模式的理念就是创建对象，提取多个类似需求中相同部分，针对不同的地方进行特殊处理 1234567891011121314151617181920function factory(object) &#123; const Factory = new Object() // 相同的部分 Factory.name = object.name Factory.age = object.name // 不同的部分 switch(object.type) &#123; case &#x27;type1&#x27;: // 特殊处理 break; case &#x27;type2&#x27;: // 特殊处理 break; default: break; &#125; return Factory&#125; 工厂方法模式 工厂方法模式(Factory Methods) 通过对产品类的抽象使其创建业务，主要负责用于创建多累产品的实例 工厂方法模式的本意是将时间创建对象工作推迟到了子类当中，这样核心类就成为了抽象类，在使用工厂方法模式时，需要使用安全策略来防止我们每次获取到的不是想要的对象 安全策略1234567function Factory() &#123; if(this instanceof Factory) &#123; return this &#125; else &#123; return new Factory() &#125;&#125; 通过以上代码在实例化对象的时候判断一下是否是创建对象实例，如果不是则返回一个新的实例，以便能获取到预期的对象 工厂方式模式代码1234567891011121314151617function Factory(type, content) &#123; if(this instanceof Factory) &#123; return this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype.Car = &#123;&#125;Factory.prototype.Pat = &#123; &#125;Factory.prototype.Clothes = &#123; &#125; 抽象工厂模式 抽象工厂模式(Abstract Factory) 通过对类的工厂抽象使其业务用于产品类簇的创建，而不是创建某一类产品的实例 抽象类工厂其实是实现子类继承父类的方法，我们需要通过传递子类以及要继承父类的名称，并且在抽象工厂方法中增加一次对抽象类存在性的判断，如果存在，子类继承父类的方法。子类继承了父类的所有的属性和方法，如果子类中没有方法或者属性覆盖父类方法，当调用的时候，会直接返回父类的属性和方法。 抽象类工厂的主要作用是，当子类调用了自己本身不存在且不需要的方法是，会给予提示 12345678910111213141516171819202122232425262728293031323334353637function Abstract(child, parent) &#123; if(typeof Abstract[parent] === &#x27;function&#x27;) &#123; // 定义一个空的父类 function F() &#123;&#125; F.prototype = new Abstract[parent]() child.constructor = child child.prototype = new F() &#125; else &#123; throw new Error(&#x27;未找到改抽象类&#x27;) &#125;&#125;Abstract.Car = function() &#123; this.type = &#x27;car&#x27;&#125;Abstract.Car.prototype = &#123; getName: function () &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;, getPrice: function() &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;&#125;function Aodis() &#123; this.name = &#x27;aodi&#x27; this.price = 12312&#125;Abstract(Aodis, &#x27;Car&#x27;)console.log(Aodis)Aodis.prototype.getName = function() &#123; console.log(this.name)&#125;const aodi = new Aodis()aodi.getName()aodi.getPrice() 抽象类 抽象类是一种声明了但是无法使用的类，当你调用抽象类的方法时就会报错，我们可以手动在类型的方法中进行错误提示 123456789function Abstract() &#123;&#125;Abstract.prototype = &#123; getName() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;, getPrice() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;&#125; 当我们通过继承或者直接使用的方式来调用抽象类中方法时，会直接抛出错误","pubDate":"Mon, 14 Jun 2021 10:25:20 GMT","guid":"https://lxx1997.github.io/2021/06/14/web/design-parttern-01/","category":"JavaScript"},{"title":"window.postMessage跨域的使用方式","link":"https://lxx1997.github.io/2021/05/04/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","description":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","pubDate":"Tue, 04 May 2021 15:23:18 GMT","guid":"https://lxx1997.github.io/2021/05/04/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","category":"JavaScript"},{"title":"记一次在面试过程中遇到的 promise 编程题","link":"https://lxx1997.github.io/2021/04/01/interview/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","description":"当时面试的时候遇到了这两个函数编程题，但是该死的是完全没有思路(悲伤) 利用 Promise 完成一个队列，队列中的任务数满了的话，后续任务不执行，当队列中的任务有完成的状态，才会添加新的任务进入队列 利用 Promise 完成一个 retry 函数，传入一个执行函数和一个计数器，在一定次数范围内，如果函数执行失败的话会再次尝试执行该函数，直到执行成功 面试结束之后，我上网上搜索了一下类似的问题，接下来是我总结之后的思路，以及最后成功的代码 Promise 队列 这个问题有以下几个重点 队列： 存放未执行的任务队列 计数器： 存放当前正在执行的任务数量 任务执行最大数量 添加任务函数 执行任务函数 接下根据我们上述描述的重点来创建一个任务队列执行类 1234567891011121314class Scheduler &#123; // 初始化任务队列，以及根据传入的数量来限制最大执行数量 constructor(maxCount) &#123; this.maxCount = count this.list = [] this.count = 0 &#125; add() &#123; &#125; start() &#123; &#125;&#125; 接下我们就要来编写添加函数了，在写添加函数之前我们首先思考一下这个添加函数里面应该注意那些东西 首先，如果我们想要在任务执行完成之后对执行结果操作的话，这个 add 函数必须返回一个 promise 函数 12345add(task) &#123; return new Promise(resolve =&gt; &#123; resolve() &#125;)&#125; 添加一个任务的时候，我们需要把这个任务添加到未执行的任务队列的存放起来 1234567add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(task()) &#125;) &#125;)&#125; 这个时候就出现了一个问题，我们应该怎样监控这个任务是否已经执行完成，这个时候 promise 的作用就来了，我们在 then 中就可以判断到函数是否执行成功 123456789add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(Promise.resolve(task()).then()) // 如果 task 执行之后的返回值是一个promise对象则可以修改成以下形式 // this.list.push(task().then()) &#125;) &#125;)&#125; 添加函数先写到这里，然后我们来写执行函数，在start函数中我们需要做的就是判断一下正在执行任务数是否小于最大执行数，然后从待执行队列中取出一个任务并执行，然后将正在执行的任务数加上1 123456start() &#123; if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list.shift()() &#125;&#125; 接下来修改 add 函数 为当我们添加一个任务时，在最后执行一下执行函数，在执行任务完成之后，减少执行队列数，并触发执行函数，最后把任务的返回值 return 出来 123456789101112add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;)&#125; 接下来实例化任务队列，并创建一个异步执行方法和一个添加任务函数 123456789101112let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Scheduler &#123; constructor(count) &#123; this.list = [] this.maxCount = count this.count = 0 &#125; add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;) &#125; start() &#123; console.log(this.count) if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list[0]() this.list.shift() &#125; &#125;&#125;let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125;addTask(5000,&#x27;1&#x27;)addTask(1100,&#x27;2&#x27;)addTask(2200,&#x27;3&#x27;)addTask(3300,&#x27;4&#x27;)addTask(3300,&#x27;5&#x27;)addTask(3300,&#x27;6&#x27;)addTask(3300,&#x27;7&#x27;)addTask(2200,&#x27;8&#x27;) Promise retry 函数 function retry(fun, count) { if(count === 0) return let val = fun() if(val &gt; 3) { return val } else { return retry(fun, –count) }} function random() { return Math.random() * 5}console.log(retry(random, 5)) 这个问题现在看起来挺简单的，但是当时估计相差了，思路都理解错了，难受","pubDate":"Thu, 01 Apr 2021 08:25:13 GMT","guid":"https://lxx1997.github.io/2021/04/01/interview/%E9%9D%A2%E8%AF%95-%E9%A2%98%E8%A7%A3/","category":"interview,promise"},{"title":"JavaScript - 手写一个 Promise 方法","link":"https://lxx1997.github.io/2021/03/18/web/js-promise/","description":"ES6新增了一个用于处理异步操作数据的一个原生API，能够解决回调地狱的产生 常用的方法 Promise.resolve() Promise.reject() Promise.then() Promise.catch() Promise.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() 接下来我们来使用代码来实现这些操作 实现Promise 首先我们在创建 Promise 实例，会传入两个函数用来表示成功的回调以及失败的回调，然后我们可以设计 Promise 类中的内容大概是这个样子的 12345678910111213141516171819202122232425262728293031const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125;,4) &#125; reject(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;) &#125;&#125; 这样就实现了一个简单的Promise方法，并且更改状态之后就不可以在修改状态了,并且用两个变量来接收resolve和reject两个方法传入的值 Promise.then 1234567891011121314151617181920Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; 调用 then 方法时判断一下传入的是否是函数，如果是函数就直接调用，并把成功的参数传入最后的 return this 则是为了实现链式结构 Promise.catch 12345678910111213141516171819Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; Promise.finally 1234Promise.prototype.finally = function(fn) &#123; fn() return this&#125; Promise.resolve 1234Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125; 这个稍微有些麻烦，我们需要判断传入的 value 是不是 Promise 类型的，如果是就可以直接返回，然后调用 .then 等方法，否则就需要我们创建一个 Promise 实例并返回 Promise.reject 1234Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125; 但是这里还有许多需要注意的地方，例如Promise.then中如果有 return 的话则需要以返回的状态和值为主，如果没有,就以上一次的状态和值为主同时还需要对代码使用 try...catch... 进行容错处理，使得在 catch 中能够拿到错误信息 代码修改如下12345678910111213141516171819Promise.prototype.then = function(resolve, reject) &#123; try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125;&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125; 实现Promise高级语法 Promise.all 12345678910111213141516171819202122232425262728Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; // 保证数组顺序返回正确 resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; Promise.race 1234567891011121314151617181920212223242526272829Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) break; &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; promise.allSettled 123456789101112131415161718192021222324252627282930313233343536373839404142Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; 这些代码中还是有很多的bug 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125; reject(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;&#125;Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125;Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125;Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.finally = function(fn) &#123; fn() return this&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125;","pubDate":"Thu, 18 Mar 2021 05:15:52 GMT","guid":"https://lxx1997.github.io/2021/03/18/web/js-promise/","category":"JavaScript"},{"title":"浅浅的剖析一下 Vue 的执行顺序","link":"https://lxx1997.github.io/2021/02/08/vue/vue-learn-api-with-%E6%BA%90%E7%A0%81-implement/","description":"定义 Vue 构造函数1234567891011121314151617181920212223import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue) lifecycleMixin(Vue)renderMixin(Vue)export default Vue 定义了 一个 Vue 构造函数，这个构造函数传入的参数是 options，使用的时候通过 new 关键字来创建实例，然后调用了 _init 方法 根据传入的 options 配置来初始化 Vue 实例 初始化 initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344var uid$3 = 0;Vue.prototype._init = function (options) &#123; var vm = this; vm._uid = uid$3++; var startTag, endTag; // 是否记录 性能 if (config.performance &amp;&amp; mark) &#123; startTag = &quot;vue-perf-start:&quot; + (vm._uid); endTag = &quot;vue-perf-end:&quot; + (vm._uid); mark(startTag); &#125; vm._isVue = true; if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; &#123; initProxy(vm); &#125; vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); if (config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false); mark(endTag); measure((&quot;vue &quot; + (vm._name) + &quot; init&quot;), startTag, endTag); &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 通过上述代码，我们可以看到 Vue 在初始化的时候主要做了以下几件事 创建 Vue 实例 唯一标识符 _uid 根据 config 配置判断是否开启 性能监控 performance 设置 Vue 标识符 _isVue 为 true 代表当前实例是 Vue 实例 通过 option 的 _isComponents 属性判断当前 Vue 实例是否是组件，如果是组件就调用 initInternalComponent 函数，不是组件就调用 mergeOptions 方法，并将返回的参数赋予 Vue 实例的 $options 属性 调用 initProxy 方法，判断 proxy 代理是否存在，如果存在，使用 proxy 对 Vue 实例进行响应式监控和代理 设置 Vue 的 _self 属性 为自身实例 调用 initLifecycle 函数 初始化生命周期 调用 initEvents 方法 初始化事件对象 调用 initRender 方法 初始化渲染使用的方法 slot, scopedSlots, createElement, _c方法，并对 $attrs,$listeners 方法进行进行数据响应式处理 调用 beforeCreate 生命周期，由于此时 还没有任何数据或者方法挂载到 Vue 实例上，所以 无法访问 调用 initInjections 方法 初始化 inject 属性 调用 initState 方法 初始化 data,props,methods,computed,watch 属性，设置数据响应式处理，及将属性挂载到 Vue 实例上 调用 initProvide 方法 初始化 provide 属性 调用 created 生命周期，此时可以访问到 inject,data,props,methods,computed上属性的值 调用 $mount 方法 获取 元素节点 el 判断是否传入 render 函数，没有就初始化一个空 DOM 节点 调用 beforeMount 生命周期 设置 组件变化的监听方法，监听组件是否更新 设置 Vue 实例挂载状态为 true 调用 mounted 生命周期 stateMixin该函数主要针对 实例 $data, $props 进行数据响应式处理，不允许更新并且初始化实例 $set, $delete, $watch(并返回一个 撤销监听的方法) eventMixin初始化事件方法 $once, $on, $off, $emit lifecycleMixin初始化 _update, forceUpdate, destory 当组件发生更新操作或者卸载的时候会触发这些生命周期beforeUpdate, updated, beforeDestory, destoryed renderMixin在这个函数中 首先通过 installRenderHelpers 方法在 Vue 实例上注册了 协助渲染的函数 12345678910111213141516171819function installRenderHelpers (target) &#123; target._o = markOnce; // 定义静态节点 只渲染一次, v-once 指令 target._n = toNumber; // 转化为整型 target._s = toString; // 字符串转化 target._l = renderList; // 渲染 v-for 循环 target._t = renderSlot; // 渲染 slot target._q = looseEqual; // 判断 对象是否相等 target._i = looseIndexOf; // 获取 元素 在 数组中的位置 target._m = renderStatic; // 定义静态节点 只渲染一次, v-once 指令 target._f = resolveFilter; // 调用 filter 方法 target._k = checkKeyCodes; // 检查键盘事件 target._b = bindObjectProps; // 读取 元素的 attr 属性绑定到 props 上面 target._v = createTextVNode; // 创建 文本node 节点 target._e = createEmptyVNode; // 创建空节点 target._u = resolveScopedSlots; // 渲染 ScopedSlot target._g = bindObjectListeners; // 绑定事件函数到 on 方法上去 target._d = bindDynamicKeys; // 渲染传入 变量 的 attrs 属性 target._p = prependModifier; // 设置前置修饰符&#125; 然后初始化 $nextTick _render 解析 dom 元素并渲染(patch)Vue 再渲染 DOM 的时候即 mountComponent 方法中 会调用 _update 方法，并将 Vue 的 _render 函数的返回值 (一个 VNode 对象) 作为参数传入,第二个参数 hydrating 为 undefined 然后在 _update 方法中 通过 __patch__ 即 patch/createPatchFunction 方法渲染页面 我们来看一下 patch 方法做了哪些东西 12// vm.$el, vnodevar patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;) 首先创造了 几个生命周期1var hooks = [&#x27;create&#x27;, &#x27;activate&#x27;, &#x27;update&#x27;, &#x27;remove&#x27;, &#x27;destroy&#x27;];","pubDate":"Mon, 08 Feb 2021 03:02:00 GMT","guid":"https://lxx1997.github.io/2021/02/08/vue/vue-learn-api-with-%E6%BA%90%E7%A0%81-implement/","category":"Vue,SourceCode"},{"title":"跟着 Vue源码学习 Vue api 系列 (八) - 指令","link":"https://lxx1997.github.io/2021/02/01/vue/vue-learn-api-with-%E6%BA%90%E7%A0%81-08/","description":"内置指令Vue 内置了以下几种指令 v-text v-html v-show v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre v-cloak v-once 在源码中分为以下几种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// v-html v-text v-modelvar directives$1 = &#123; model: model, text: text, html: html&#125;// v-on v-bind v-clockvar baseDirectives = &#123; on: on, bind: bind$1, cloak: noop&#125;;// v-if v-else v-else-iffunction processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// v-prefunction processPre (el) &#123; if (getAndRemoveAttr(el, &#x27;v-pre&#x27;) != null) &#123; el.pre = true; &#125;&#125;// v-for v-slotfunction processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// v-slotvar slotBinding = getAndRemoveAttrByRegex(el, slotRE);// v-oncefunction processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-showif (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) &#123; child.data.show = true;&#125; v-text / v-html123456789101112131415161718192021222324252627282930313233343536373839// dir 为 directive 中的 binding 属性/** arg: null end: 18 isDynamicArg: false modifiers: undefined name: &quot;text&quot; rawName: &quot;v-text&quot; start: 5 value: &quot;text&quot;*/function text (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;textContent&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;function html (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;innerHTML&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;// addProp (当前元素实例, &#x27;textContent&#x27;, &#x27;_s(dir.value)&#x27;, dir, null)function addProp (el, name, value, range, dynamic) &#123; (el.props || (el.props = [])).push(rangeSetItem(&#123; name: name, value: value, dynamic: dynamic &#125;, range)); el.plain = false;&#125;// rangeSetItemfunction rangeSetItem (item, range) &#123; if (range) &#123; if (range.start != null) &#123; item.start = range.start; &#125; if (range.end != null) &#123; item.end = range.end; &#125; &#125; return item&#125; v-text 指令在 processAttrs 函数中 通过 addDirective 方法 添加一个 directive 属性，然后 通过 updateDOMProps 方法中的 elm[key] = cur 为 元素的 textContent 或者 innerHTML 属性赋值 12&lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;&lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt; 注意：如果 v-text/v-html 指令所在的元素下的子元素，则不会被渲染 v-model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function model (el, dir, _warn) &#123; warn$1 = _warn; var value = dir.value; var modifiers = dir.modifiers; var tag = el.tag; var type = el.attrsMap.type; &#123; // inputs with type=&quot;file&quot; are read only and setting the input&#x27;s // value will throw an error. if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;file&#x27;) &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot; type=\\&quot;file\\&quot;&gt;:\\n&quot; + &quot;File inputs are read only. Use a v-on:change listener instead.&quot;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; &#125; if (el.component) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else if (tag === &#x27;select&#x27;) &#123; genSelect(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;checkbox&#x27;) &#123; genCheckboxModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;radio&#x27;) &#123; genRadioModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; || tag === &#x27;textarea&#x27;) &#123; genDefaultModel(el, value, modifiers); &#125; else if (!config.isReservedTag(tag)) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot;&gt;: &quot; + &quot;v-model is not supported on this element type. &quot; + &#x27;If you are working with contenteditable, it\\&#x27;s recommended to &#x27; + &#x27;wrap a library dedicated for that purpose inside a custom component.&#x27;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; // ensure runtime directive metadata return true&#125; v-model 指令主要针对于 input 输入框 及textarea 等需要输入或者状态变更的元素，v-model 相当于 v-bind:value + v-on:change 的组合体，在其他组件上不能使用 v-model v-show123456789101112131415161718192021222324// ref// def: &#123;bind: ƒ, update: ƒ, unbind: ƒ&#125;// expression: &quot;true&quot;// modifiers: &#123;&#125;// name: &quot;show&quot;// rawName: &quot;v-show&quot;// value: truebind: function bind (el, ref, vnode) &#123; var value = ref.value; vnode = locateNode(vnode); var transition$$1 = vnode.data &amp;&amp; vnode.data.transition; var originalDisplay = el.__vOriginalDisplay = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display; console.log(ref,value, transition$$1) if (value &amp;&amp; transition$$1) &#123; vnode.data.show = true; enter(vnode, function () &#123; el.style.display = originalDisplay; &#125;); &#125; else &#123; el.style.display = value ? originalDisplay : &#x27;none&#x27;; &#125;&#125;, 取 ref.value 如果 v-show=&quot;false&quot; 则 ref.value 为 false 将 元素的display 属性设置为 null v-if/v-else/v-else-if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 判断当前元素是否有 v-if，v-else， v-else-if 指令// 并将元素上的if,else,elseif 属性置为对应状态function processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// 通过 addIfCondition 方法将 v-if 所在的元素放入 ifConditions 数组中function addIfCondition (el, condition) &#123; if (!el.ifConditions) &#123; el.ifConditions = []; &#125; el.ifConditions.push(condition);&#125;// markStatic$1if (node.ifConditions) &#123; for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 &lt; l$1; i$1++) &#123; var block = node.ifConditions[i$1].block; markStatic$1(block); if (!block.static) &#123; node.static = false; &#125; &#125;&#125;// genIfConditions 转换 IfConditions 中的元素function genIfConditions ( conditions, state, altGen, altEmpty) &#123; if (!conditions.length) &#123; return altEmpty || &#x27;_e()&#x27; &#125; var condition = conditions.shift(); if (condition.exp) &#123; return (&quot;(&quot; + (condition.exp) + &quot;)?&quot; + (genTernaryExp(condition.block)) + &quot;:&quot; + (genIfConditions(conditions, state, altGen, altEmpty))) &#125; else &#123; return (&quot;&quot; + (genTernaryExp(condition.block))) &#125; // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) &#123; return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) &#125;&#125; v-for 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 判断是否含有 v-for 指令 然后通过 extend 方法将 parseFor 转出的参数扩展到 元素上function processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// 判断 for 循环function parseFor (exp) &#123; // 正则表达式匹配，循环数组是否正确 [exp, item, 10] var inMatch = exp.match(forAliasRE); if (!inMatch) &#123; return &#125; var res = &#123;&#125;; res.for = inMatch[2].trim(); // 针对 v-for=&quot;(item,index) in array&quot; 进行处理 去除 item / item,index var alias = inMatch[1].trim().replace(stripParensRE, &#x27;&#x27;); // 针对(item,index) in array 去除 , index var iteratorMatch = alias.match(forIteratorRE); if (iteratorMatch) &#123; res.alias = alias.replace(forIteratorRE, &#x27;&#x27;).trim(); res.iterator1 = iteratorMatch[1].trim(); if (iteratorMatch[2]) &#123; res.iterator2 = iteratorMatch[2].trim(); &#125; &#125; else &#123; res.alias = alias; &#125; // alias 对象别名 可以通过 alias 访问遍历数组的元素 // iterator1 遍历时第二个参数 return res&#125;// genFor 获取与 v-for 指令相关参数，调用 renderList 方法渲染数组function genFor ( el, state, altGen, altHelper) &#123; var exp = el.for; var alias = el.alias; var iterator1 = el.iterator1 ? (&quot;,&quot; + (el.iterator1)) : &#x27;&#x27;; var iterator2 = el.iterator2 ? (&quot;,&quot; + (el.iterator2)) : &#x27;&#x27;; if (state.maybeComponent(el) &amp;&amp; el.tag !== &#x27;slot&#x27; &amp;&amp; el.tag !== &#x27;template&#x27; &amp;&amp; !el.key ) &#123; state.warn( &quot;&lt;&quot; + (el.tag) + &quot; v-for=\\&quot;&quot; + alias + &quot; in &quot; + exp + &quot;\\&quot;&gt;: component lists rendered with &quot; + &quot;v-for should have explicit keys. &quot; + &quot;See https://vuejs.org/guide/list.html#key for more info.&quot;, el.rawAttrsMap[&#x27;v-for&#x27;], true /* tip */ ); &#125; el.forProcessed = true; // avoid recursion // 调用 renderList 方法 传入渲染函数 return (altHelper || &#x27;_l&#x27;) + &quot;((&quot; + exp + &quot;),&quot; + &quot;function(&quot; + alias + iterator1 + iterator2 + &quot;)&#123;&quot; + &quot;return &quot; + ((altGen || genElement)(el, state)) + &#x27;&#125;)&#x27;&#125;// rederListfunction renderList ( val, render) &#123; var ret, i, l, keys, key; if (Array.isArray(val) || typeof val === &#x27;string&#x27;) &#123; ret = new Array(val.length); for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i); &#125; &#125; else if (typeof val === &#x27;number&#x27;) &#123; ret = new Array(val); for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i); &#125; &#125; else if (isObject(val)) &#123; if (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123; ret = []; // 利用 Symbol.iterator 方法 循环 对象val var iterator = val[Symbol.iterator](); var result = iterator.next(); while (!result.done) &#123; ret.push(render(result.value, ret.length)); result = iterator.next(); &#125; &#125; else &#123; keys = Object.keys(val); ret = new Array(keys.length); for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i]; ret[i] = render(val[key], key, i); &#125; &#125; &#125; if (!isDef(ret)) &#123; ret = []; &#125; (ret)._isVList = true; return ret&#125; v-on 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980name = name.replace(onRE, &#x27;&#x27;);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);// addHandlerfunction addHandler (el,name,value,modifiers,important,warn,range,dynamic) &#123; modifiers = modifiers || emptyObject; // warn prevent and passive modifier /* istanbul ignore if */ if ( warn &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( &#x27;passive and prevent can\\&#x27;t be used together. &#x27; + &#x27;Passive handler can\\&#x27;t prevent default event.&#x27;, range ); &#125; // normalize click.right and click.middle since they don&#x27;t actually fire // this is technically browser-specific, but at least for now browsers are // the only target envs that have right/middle clicks. if (modifiers.right) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;contextmenu&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;contextmenu&#x27;; delete modifiers.right; &#125; &#125; else if (modifiers.middle) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;mouseup&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;mouseup&#x27;; &#125; &#125; // check capture modifier if (modifiers.capture) &#123; delete modifiers.capture; name = prependModifierMarker(&#x27;!&#x27;, name, dynamic); &#125; if (modifiers.once) &#123; delete modifiers.once; name = prependModifierMarker(&#x27;~&#x27;, name, dynamic); &#125; /* istanbul ignore if */ if (modifiers.passive) &#123; delete modifiers.passive; name = prependModifierMarker(&#x27;&amp;&#x27;, name, dynamic); &#125; var events; if (modifiers.native) &#123; delete modifiers.native; events = el.nativeEvents || (el.nativeEvents = &#123;&#125;); &#125; else &#123; events = el.events || (el.events = &#123;&#125;); &#125; var newHandler = rangeSetItem(&#123; value: value.trim(), dynamic: dynamic &#125;, range); if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers; &#125; var handlers = events[name]; /* istanbul ignore if */ if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler); &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler]; &#125; else &#123; events[name] = newHandler; &#125; el.plain = false;&#125; 修饰器 .stop 阻止默认事件 event.stopPropagation() .prevent 阻止默认事件 event.preventDefault() .capture 添加事件监听器使用 capture 模式 .self 只当事件从侦听器绑定的元素本身触发时才触发回调 .&#123;keyCode | keyAlias&#125; 只有特定键触发才会触发回调函数 .native 监听根元素的原生时间 .once 只触发一次回调 .left 点击鼠标左键触发 .right 点击鼠标右键触发 .middle 点击鼠标中键触发 .passive 以 &#123;passive: true&#125; 模式添加侦听器 v-bind 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name = name.replace(bindRE, &#x27;&#x27;);value = parseFilters(value);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;if ( value.trim().length === 0) &#123; warn$2( (&quot;The value for a v-bind expression cannot be empty. Found in \\&quot;v-bind:&quot; + name + &quot;\\&quot;&quot;) );&#125;if (modifiers) &#123; if (modifiers.prop &amp;&amp; !isDynamic) &#123; name = camelize(name); if (name === &#x27;innerHtml&#x27;) &#123; name = &#x27;innerHTML&#x27;; &#125; &#125; if (modifiers.camel &amp;&amp; !isDynamic) &#123; name = camelize(name); &#125; if (modifiers.sync) &#123; syncGen = genAssignmentCode(value, &quot;$event&quot;); if (!isDynamic) &#123; addHandler( el, (&quot;update:&quot; + (camelize(name))), syncGen, null, false, warn$2, list[i] ); if (hyphenate(name) !== camelize(name)) &#123; addHandler( el, (&quot;update:&quot; + (hyphenate(name))), syncGen, null, false, warn$2, list[i] ); &#125; &#125; else &#123; // handler w/ dynamic event name addHandler( el, (&quot;\\&quot;update:\\&quot;+(&quot; + name + &quot;)&quot;), syncGen, null, false, warn$2, list[i], true // dynamic ); &#125; &#125;&#125;if ((modifiers &amp;&amp; modifiers.prop) || ( !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name))) &#123; addProp(el, name, value, list[i], isDynamic);&#125; else &#123; addAttr(el, name, value, list[i], isDynamic);&#125; 修饰符 .prop 作为 DOM 的property绑定，而不是作为 attribute 绑定 。camel 将事件名转化为驼峰模式 .sync 会扩展一个更新父组件绑定值的 v-on 监听器 v-slot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118function processSlotContent (el) &#123; var slotScope; if (el.tag === &#x27;template&#x27;) &#123; slotScope = getAndRemoveAttr(el, &#x27;scope&#x27;); /* istanbul ignore if */ if (slotScope) &#123; warn$2( &quot;the \\&quot;scope\\&quot; attribute for scoped slots have been deprecated and &quot; + &quot;replaced by \\&quot;slot-scope\\&quot; since 2.5. The new \\&quot;slot-scope\\&quot; attribute &quot; + &quot;can also be used on plain elements in addition to &lt;template&gt; to &quot; + &quot;denote scoped slots.&quot;, el.rawAttrsMap[&#x27;scope&#x27;], true ); &#125; el.slotScope = slotScope || getAndRemoveAttr(el, &#x27;slot-scope&#x27;); &#125; else if ((slotScope = getAndRemoveAttr(el, &#x27;slot-scope&#x27;))) &#123; /* istanbul ignore if */ if (el.attrsMap[&#x27;v-for&#x27;]) &#123; warn$2( &quot;Ambiguous combined usage of slot-scope and v-for on &lt;&quot; + (el.tag) + &quot;&gt; &quot; + &quot;(v-for takes higher priority). Use a wrapper &lt;template&gt; for the &quot; + &quot;scoped slot to make it clearer.&quot;, el.rawAttrsMap[&#x27;slot-scope&#x27;], true ); &#125; el.slotScope = slotScope; &#125; // slot=&quot;xxx&quot; var slotTarget = getBindingAttr(el, &#x27;slot&#x27;); if (slotTarget) &#123; el.slotTarget = slotTarget === &#x27;&quot;&quot;&#x27; ? &#x27;&quot;default&quot;&#x27; : slotTarget; el.slotTargetDynamic = !!(el.attrsMap[&#x27;:slot&#x27;] || el.attrsMap[&#x27;v-bind:slot&#x27;]); // preserve slot as an attribute for native shadow DOM compat // only for non-scoped slots. if (el.tag !== &#x27;template&#x27; &amp;&amp; !el.slotScope) &#123; addAttr(el, &#x27;slot&#x27;, slotTarget, getRawBindingAttr(el, &#x27;slot&#x27;)); &#125; &#125; // 2.6 v-slot syntax &#123; if (el.tag === &#x27;template&#x27;) &#123; // v-slot on &lt;template&gt; var slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) &#123; &#123; if (el.slotTarget || el.slotScope) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.parent &amp;&amp; !maybeComponent(el.parent)) &#123; warn$2( &quot;&lt;template v-slot&gt; can only appear at the root level inside &quot; + &quot;the receiving component&quot;, el ); &#125; &#125; var ref = getSlotName(slotBinding); var name = ref.name; var dynamic = ref.dynamic; el.slotTarget = name; el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf &#125; &#125; else &#123; // v-slot on component, denotes default slot var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding$1) &#123; &#123; if (!maybeComponent(el)) &#123; warn$2( &quot;v-slot can only be used on components or &lt;template&gt;.&quot;, slotBinding$1 ); &#125; if (el.slotScope || el.slotTarget) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.scopedSlots) &#123; warn$2( &quot;To avoid scope ambiguity, the default slot should also use &quot; + &quot;&lt;template&gt; syntax when there are other named slots.&quot;, slotBinding$1 ); &#125; &#125; // add the component&#x27;s children to its default slot var slots = el.scopedSlots || (el.scopedSlots = &#123;&#125;); var ref$1 = getSlotName(slotBinding$1); var name$1 = ref$1.name; var dynamic$1 = ref$1.dynamic; var slotContainer = slots[name$1] = createASTElement(&#x27;template&#x27;, [], el); slotContainer.slotTarget = name$1; slotContainer.slotTargetDynamic = dynamic$1; slotContainer.children = el.children.filter(function (c) &#123; if (!c.slotScope) &#123; c.parent = slotContainer; return true &#125; &#125;); slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now el.children = []; // mark el non-plain so data gets generated el.plain = false; &#125; &#125; &#125;&#125; v-pre 跳过这个元素和子元素的编译过程，显示原始的标签 v-cloak 无表达式，绑定一个空函数，隐藏未编译的 标签直到实例准备完成 v-once 123456789101112131415161718192021222324252627282930313233// 判断是否含有 v-once 指令function processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-oncefunction genOnce (el, state) &#123; el.onceProcessed = true; if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.staticInFor) &#123; var key = &#x27;&#x27;; var parent = el.parent; while (parent) &#123; if (parent.for) &#123; key = parent.key; break &#125; parent = parent.parent; &#125; if (!key) &#123; state.warn( &quot;v-once can only be used inside v-for that is keyed. &quot;, el.rawAttrsMap[&#x27;v-once&#x27;] ); return genElement(el, state) &#125; return (&quot;_o(&quot; + (genElement(el, state)) + &quot;,&quot; + (state.onceId++) + &quot;,&quot; + key + &quot;)&quot;) &#125; else &#123; return genStatic(el, state) &#125;","pubDate":"Mon, 01 Feb 2021 09:29:54 GMT","guid":"https://lxx1997.github.io/2021/02/01/vue/vue-learn-api-with-%E6%BA%90%E7%A0%81-08/","category":"Vue,SourceCode"}]}