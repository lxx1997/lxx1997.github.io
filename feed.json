{"title":"SoulReader","description":"前端小菜鸟,努力深造","language":"en","link":"https://lxx1997.github.io","pubDate":"Fri, 12 May 2023 07:30:43 GMT","lastBuildDate":"Sun, 13 Aug 2023 12:04:47 GMT","generator":"hexo-generator-json-feed","webMaster":"SoulReader","items":[{"title":"Golang - 编程语言学习","link":"https://lxx1997.github.io/2023/05/12/frame/frame-golang-learn/","description":"","pubDate":"Fri, 12 May 2023 07:30:43 GMT","guid":"https://lxx1997.github.io/2023/05/12/frame/frame-golang-learn/","category":"frame,golang"},{"title":"Svelte - 前端框架学习","link":"https://lxx1997.github.io/2023/04/26/frame/svelte-web-learn/","description":"svelte 中文文档 什么是 SvelteSvelte 是一个构建 web 应用程序的工具。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建应用程序的编译阶段来处理。 需要注意，Svelte 是一款编译器。它可以将按照规定语法编写的代码打包成浏览器能运行的项目。和其他前端框架一样，同样也是使用 HTML 、CSS 和 JavaScript 进行开发。 使用创建项目1234npm create svelte@latest myapp // 在这一步,我们可以选择创建的项目类型，例如 是否默认使用 TypeScript，是否默认添加 eslint，pre-commit 等cd myappnpm installnpm run dev 创建一个 Svelte 组件Svelte 组件需要我们创建 .svelte 文件，类似于 Vue，一个 .svelte 文件 可以看做是一个单独的组件 .svelte 文件 包含三个部分 script 类似于 Vue 的 Script 标签，可以指定语言 lang=&quot;ts&quot;,主要用来定义变量和方法，可以在 当前文件内使用 style 样式文件，用来编写页面的css 样式 document 文本节点，和 Vue 不同的是，可以不用包裹在template 组件内，可以直接写 1234567891011&lt;div&gt;&#123;count&#125;&lt;/div&gt;&lt;script&gt; let count = 1&lt;/script&gt;&lt;style&gt; div &#123; color: red; &#125;&lt;/style&gt; 语法创建变量创建变量和 js 创建变量一至，再dom 节点只能给使用的时候 &#123;&#125; 包括起来，当发生变化的时候，会重新进行编译，对应dom会自动更新成最新的数据 123456789&lt;div class=&quot;pratice&quot;&gt; &#123; count &#125;&lt;/div&gt;&lt;script lang=&quot;ts&quot;&gt; let count = 1 setTimeout(() =&gt; &#123; count = 233 &#125;, 3000)&lt;/script&gt; 上述页面会在页面初始渲染后，三秒后从 1 变成 233 添加事件 点击事件 on:click 样式修改和正常样式编写一样 组件使用使用组件时，需要在 script 内引入 组件 使用的时候，直接使用即可，另外需要注意的是，组件内的标签样式和组件外的标签样式是互相隔离的 进阶操作向标签内加入 HTML在 SSvelte 中，可以使用 &#123;@html ...&#125;标签来插入html 但是 Svelte 不会对插入的html文本进行任何处理，也就是说我们需要自己进行转码，否则会遭到 XSS 攻击 1&lt;p&gt;&#123;@html html文本&#125;&lt;/p&gt; 反应式声明（类似于computed） $:使用 $: varible = 表达式，当表达式涉及到的变量发生改变时，变量会自动发生改变 123&lt;script&gt;$: add = count + 1&lt;/script&gt; 当count 的值发生变化时， add 的值也会自动发生变化 补充 也可以在 $:后面跟一个代码块，代码块内涉及到的变量的值发生变化时，会重新执行代码块内的内容，因此需要注意在代码块内尽量不要修改变量值，或者添加终结运行判断，以免造成无限循环 123456789101112&lt;script&gt;// type1$: console.log(count)// type2$: &#123; console.log(count)&#125;// type3$: if(count &gt;= 10) &#123; count--&#125;&lt;/script&gt; 数组和对象更新由于 Svelte 的反应性是由赋值语句触发的，因此直接修改对象属性或者使用数组中会修改原数组内容的方法时，不会触发应用的引用进行更新 12345678910111213141516171819202122&lt;script&gt;let num = [1]num.push(2) // 不会更新num = [...num, 2] // 会更新&lt;/script&gt;&lt;div&gt; &#123;obj.foo.bar&#125;&lt;/div&gt;&lt;script lang=&quot;ts&quot;&gt; let obj = &#123; foo: &#123; bar: &quot;bar&quot; &#125; &#125; let foo = obj.foo setTimeout(() =&gt; &#123; foo.bar = &quot;foo&quot; // 不会触发 object.foo.bar 的更新 obj.foo.bar = &quot;foo&quot; // 会触发 object.foo.bar 的更新 &#125;, 3000)&lt;/script&gt; 组件 props通过 export 关键字 来定义 props字段 123456789101112&lt;script&gt;export let count// 添加默认值export let count = 1&lt;/script&gt;// 组件传递值&lt;Counter count=&#123;1&#125; /&gt;// 批量传递值&lt;Counter &#123;...props&#125; /&gt; 语法判断 判断语法 判断语法需要使用 if 和 else 或者 else if 关键字，下面是具体使用示例 1234567891011121314151617181920// if 语句&#123;#if 判断语句 &#125; 执行代码&#123;/if&#125;// if else 语句&#123;#if 判断语句 &#125; 执行代码&#123;:else&#125; 执行代码&#123;/if&#125;// if else-if 语句&#123;#if 判断语句 &#125; 执行代码&#123;:else if 判断语句&#125; 执行代码&#123;:else&#125; 执行代码&#123;/if&#125; 上述代码会根据 判断语句的执行结果显示不同的内容 循环语法 Svelte 中循环语句使用 each ... as ... 的格式， each 后面跟的是循环对象，as 后面是循环中使用的变量 123&#123;#each list as item, index&#125; &lt;p&gt;&#123;item&#125; and &#123;index&#125;&lt;/p&gt;&#123;/each&#125; 如果需要类似于vue 和 react 添加 key 值,作用和vue react 中保持一致，告诉是什么地方需要改变 123&#123;#each list as item, index (item.name)&#125; &lt;p&gt;&#123;item.name&#125; and &#123;index&#125;&lt;/p&gt;&#123;/each&#125; 同步语法 Svellte 还实现了同步机制，可以直接在渲染时获取 Promise 的结果和报错，并且在结果未返回时，添加占位，类似于 React 的 Suspennse 组件 1234567&#123;#await promise&#125; promsie 结果未返回时占位组件&#123;:then res&#125; promsie 成功结果返回时占位组件&#123;:catch err&#125; promsie 失败结果返回时占位组件&#123;/await&#125; 也可以部分简写成一下格式 123&#123;#await promise then res&#125; promsie 成功结果返回时占位组件&#123;/await&#125; 事件绑定 注册事件 on:事件名 事件修饰符 preventDefault 阻止默认事件 stopPropagation 阻止冒泡 passive capture 事件触发机制（冒泡还是捕获） once 事件只触发一次 self 仅当点击元素本身才会触发1&lt;div on:click|preventDefault|capture=&#123;handleClick&#125;&gt;&lt;/div&gt; 组件内触发事件(emit) 12345678&lt;script&gt; import &#123; createEventDispather &#125; from &quot;svelte&quot; const dispatch = createEventDispather() // 调用该方法时，会自动发送事件，父级需要定义一个事件来接收参数 --&gt; function dispatchMessage(type, data) &#123; dispatch(type, data) &#125;&lt;/script&gt; 事件转发（子组件一步步向上传递）123// 正常情况下，父组件也需要像子组件一样，通过 dispatch 把事件向上传递，但是 Svelte 提供了一种更方便的方法&lt;Child on:message&gt;&lt;/Child&gt;// 父组件会自动把message 事件向上传递 svelte 绑定 (bind:属性) 属性绑定 bind:value input value绑定，类似于 vue v-model 数据双向绑定，任意一个变化都会导致另一个发生变化 bind:checked input 复选框选中状态 生命周期 onMount 在组件首次呈现到 DOM 后运行 onDestroy 组件被销毁时执行 beforeUpdate 组件渲染完成前执行 afterrUpdate 组件渲染完后前执行 tick Svelte 扩展Svelte 状态管理工具（store）创建一个Store 123import &#123; writable &#125; from &quot;svelte/store&quot;export const countStore = writable(0) 通过上述代码创建了一个 初始值为 0 的Store Svelte 为 Store 提供了三种方法。方便我们订阅和修改Store 的值 subscribe(fn: void) 添加订阅事件，会把store 的值当做fn 的参数传递过来，会返回一个函数，调用函数会自动取消当前订阅 update 更新，可以传递一个值或者一个函数 reset 初始化 另外可以直接使用 $count 来访问 count 的值 Svelte 提供了多种创建 Store 方法 writable 可读写，用户可以调用update 或者set 方法修改 readable 只读，不可以修改,支持两个参数，第一个参数是默认值，第二个参数为一个函数，主要用来随时修改 readable 的值，会返回一个函数，用来清除当前函数的副作用(闭包，垃圾清除) 12345678import &#123; readable &#125; from &quot;svelte/store&quot;export time = readable(new Date(), function start(set) &#123; let interval = setInterval(() =&gt; set(new Date()), 1000) return () =&gt; &#123; clearInterval(interval) &#125;&#125;) derived stores派生,可以用来定义一个依赖于其他 store 的 store，这样当依赖的store 发生变化的时候，自身也会发生变化 123456789101112import &#123; readable, derived &#125; from &quot;svelte/store&quot;export time = readable(new Date(), function start(set) &#123; let interval = setInterval(() =&gt; set(new Date()), 1000) return () =&gt; &#123; clearInterval(interval) &#125;&#125;)let now = new Date()export const elapsed = derived(time, $time =&gt; Math.round(($time - start) / 1000) 当然我们也可以利用store 的 订阅和更新方法，自定义一个带有各类事件的Store，这样代码会更加简洁，复用起来也更加方便 12345678910function createCount() &#123; const &#123; subscribe, set, update &#125; = writable(0); return &#123; subscribe, increment: () =&gt; update(n =&gt; n + 1), decrement: () =&gt; update(n =&gt; n - 1), reset: () =&gt; set(0) &#125;;&#125; 以上代码定义了一个初始账为 0 的Store，并且带有加和减操作函数 Svelte 标签 class 属性定义有以下几种方式 12345678&lt;!-- 第一种 --&gt;&lt;p class=&quot;pragraph&quot;&gt;&lt;/p&gt;&lt;!-- 第二种 --&gt;&lt;p class=&quot;&#123;active ? &#x27;active&#x27; : &quot;&quot;&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 第三种 --&gt;&lt;p class:active=&quot;&#123;active&#125;&quot;&gt;&lt;/p&gt;&lt;!-- 在第三种情况下，如果属性名和变量名相同，且无其他特殊判断时，可以简写成以下格式 --&gt;&lt;p class:active&gt;&lt;/p&gt; Svelte slot 组件Svelte 有以下几种slot组件 默认slot 组件 写在子组件标签内部，不符合其他slot 类型的都会默认写到 默认slot组件所在位置 123&lt;div class=&quot;box&quot;&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; 命名 slot 组件, 带有名称 Slot 组件，对应名称的slot 组件会自动添加到对应的位置 123456789101112&lt;!-- Box --&gt;&lt;div class=&quot;box&quot;&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;&lt;/div&gt;&lt;!-- Parent --&gt;&lt;div&gt; &lt;Box&gt; &lt;slot slot=&quot;header&quot;&gt; this is header &lt;/slot&gt; &lt;/Box&gt;&lt;/div&gt;","pubDate":"Wed, 26 Apr 2023 14:48:55 GMT","guid":"https://lxx1997.github.io/2023/04/26/frame/svelte-web-learn/","category":"web,frame,svelte"},{"title":"Graphql - 前端知识学习","link":"https://lxx1997.github.io/2023/04/26/frame/graphql-web-learn/","description":"个人的一些疑问前提：我一直没搞懂后端是如何根据传入的内容去查询的，后端数据库的表是如何设计的，如何根据传入的字段查找出对应的表中的数据，前端的参数传入还可以理解，后端的这一块是真的无法理解 补充说明 经过一段时间的仔细观看后发现，好像每个字段或者说字段所属的对象好像需要自己写查询方法，graphql提供了一些属性方便操作和查询(具体是否如此尚不清楚) 1234567Query: &#123; human(obj, args, context, info) &#123; return context.db.loadHumanByID(args.id).then( userData =&gt; new Human(userData) ) &#125;&#125; obj 上一级对象，如果字段属于根节点查询类型通常不会被使用。 args 可以提供在 GraphQL 查询中传入的参数。 context 会被提供给所有解析器，并且持有重要的上下文信息比如当前登入的用户或者数据库访问对象。 info 一个保存与当前查询相关的字段特定信息以及 schema 详细信息的值，更多详情请参考类型 GraphQLResolveInfo. Graphql 是什么GraphQL 是一个用于 API 的查询语言，是一个使用基于类型系统来执行查询的服务端运行时（类型系统由你的数据定义）。GraphQL 并没有和任何特定数据库或者存储引擎绑定，而是依靠你现有的代码和数据支撑。 官方文档 里面有非常细致的各种功能介绍 Graphql 怎么使用不同语言使用示例 Graphql 在框架中如何使用Vue Vue Apllo Apollo 是通过社区力量帮助你在应用中使用 GraphQL 的一套工具。它的 客户端和 服务端都非常有名。 通过这个，我们可以在 Vue 中直接使用 Graphql 进行数据查询","pubDate":"Wed, 26 Apr 2023 03:17:26 GMT","guid":"https://lxx1997.github.io/2023/04/26/frame/graphql-web-learn/","category":"web,frame"},{"title":"React TypeScript 项目中一些常用的类型定义","link":"https://lxx1997.github.io/2023/04/16/react/react-typescript-some-usual-types/","description":"一些常用的typescript 类型定义 文件名 [name].d.tssvg 文件123456declare module &#x27;*.svg&#x27; &#123; import React = require(&#x27;react&#x27;) export const ReactComponent: React.FC&lt;React.SVGProps&lt;SVGSVGElement&gt;&gt; const src: string export default src&#125; 这样定义完成后，svg 可以作为路径使用，也可以直接作为一个React Component 组件使用","pubDate":"Sun, 16 Apr 2023 10:01:33 GMT","guid":"https://lxx1997.github.io/2023/04/16/react/react-typescript-some-usual-types/","category":"react,TypeScript"},{"title":"常用的设计模式","link":"https://lxx1997.github.io/2023/04/10/web/javascript-design-parttern/","description":"工厂模式通过工厂模式，可以让我们使用同一个类时，根据不同传参，创建不同类型的实例以满足我们的需求 123456789101112class Factory &#123; constructor(type, data) &#123; switch(type) &#123; case &quot;type1&quot;: return new Type1(data) case &quot;type2&quot;: return new Type2(data) default: return new TypeDefault(data) &#125; &#125;&#125; 抽象工厂模式抽象模式主要在与对于类的一些结构进行抽象化处理，如果继承于该类的类直接调用，会抛出错误，需要继承类重新实现这个方法 主要用于对方法的处理，针对我们传入的类添加其他类的抽象方法，并且实现对象方法 123456789101112131415161718192021222324252627282930313233var VehicleFactory = function(subType, superType) &#123; if(typeof VehicleFactory[superType] === &quot;function&quot;) &#123; // 创建一个缓存类 function F() &#123;&#125; // 继承父类的属性和方法 F.prototype = new VehicleFactory[superType]() // 将子类的constructor 指向子类 subType.constructor = subType // 子类原型继承父类 subType.prototype = new F() &#125; else &#123; throw new Error(&quot;未创建&quot; + superType + &quot;抽象类&quot;) &#125;&#125;VehicleFactory.Car = function() &#123; this.type = &quot;car&quot;&#125;VehicleFactory.Car.prototype = &#123; getPrice: function() &#123; return new Error(&quot;抽象方法不能调用&quot;) &#125;&#125;var Car = function() &#123; this.price = 12312&#125;VehicleFactory(Car, &quot;Car&quot;)Car.prototype.getPrice = function() &#123; returrn this.price&#125;let car = new Car()car.getPrice() // 12312 单例模式单例模式主要保证我们每次 new 或者拿到的实例都是同一个实例，避免创建新的是类 1234567891011121314let instance = undefinedclass Factory &#123; constructor() &#123; &#125; getInstance() &#123; if(instance) &#123; return instance &#125; else &#123; instance = new Factory() return instance &#125; &#125;&#125; 观察者模式状态模式组合模式享元模式原型链模式桥接模式装饰器模式代理模式策略模式访问者模式委托模式数据访问对象模式节流模式参与者模式","pubDate":"Mon, 10 Apr 2023 14:30:43 GMT","guid":"https://lxx1997.github.io/2023/04/10/web/javascript-design-parttern/","category":"JavaScript,web"},{"title":"数组部分方法原理重写","link":"https://lxx1997.github.io/2023/04/08/web/array-methods-rewrite/","description":"map1234567891011Array.prototye.map = function (cb) &#123; if(typeof cb !== &quot;function&quot;) &#123; throw new Error(&quot;callback is not function&quot;) return &#125; let arr = [] for(let i = 0; i &lt; this.length; i++) &#123; arr.push(cb(this[i])) &#125; return arr&#125; filter1234567891011121314Array.prototye.filter = function (cb) &#123; if(typeof cb !== &quot;function&quot;) &#123; throw new Error(&quot;callback is not function&quot;) return &#125; let arr = [] for(let i = 0; i &lt; this.length; i++) &#123; let flag = cb(this[i]) if(flag) &#123; arr.push(this[i]) &#125; &#125; return arr&#125; reduce1234567891011Array.prototye. = function (cb, total) &#123; if(typeof cb !== &quot;function&quot;) &#123; throw new Error(&quot;callback is not function&quot;) return &#125; for(let i = 0; i &lt; this.length; i++) &#123; total = cb(total, this[i]) &#125; return total&#125; some12345678910111213Array.prototye.some = function (cb) &#123; if(typeof cb !== &quot;function&quot;) &#123; throw new Error(&quot;callback is not function&quot;) return &#125; for(let i = 0; i &lt; this.length; i++) &#123; let flag = cb(this[i]) if(flag) &#123; return flag &#125; &#125; return false&#125; every12345678910111213Array.prototye.every = function (cb) &#123; if(typeof cb !== &quot;function&quot;) &#123; throw new Error(&quot;callback is not function&quot;) return &#125; for(let i = 0; i &lt; this.length; i++) &#123; let flag = cb(this[i]) if(!flag) &#123; return flag &#125; &#125; return true&#125;","pubDate":"Sat, 08 Apr 2023 09:11:23 GMT","guid":"https://lxx1997.github.io/2023/04/08/web/array-methods-rewrite/","category":"JavaScript,web"},{"title":"个人整理的比较全的知识 - 方便自己回顾","link":"https://lxx1997.github.io/2023/04/04/interview/%E9%9D%A2%E8%AF%95%E9%A2%98-01/","description":"更全的面试题vue 生态面试题 HTML新增的 h5 属性 标签类 header,footer,aside,nav,article 媒体播放标签 audio,video canvas svg 等 存储属性 localStorage,sessionStorage input 标签新增type 属性 email,password,file,tel,date,url 等 CSSem/rem/px/vw/vh em 相对长度单位 是根据当前对象文本的字体尺寸，如果没有设置，则取默认尺寸 rem 相对单位，只根据 HTML 根元素的 font-size的值 px 指的是像素，为绝对单位，不会受到其他单位的影响 vw 屏幕宽度，最大为100，最小为0 vh 屏幕高度，最大为100，最小为0 BFC 块级格式化上下文是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 特性： 块级元素会在垂直方向一个接一个排列 避免子元素的margin 属性影响父元素 保证子元素的属性只在BFC盒内起作用，不会影响盒外的其他元素 触发方式： float: left/right position: absolute/fixed overflow: hidden/hidden-x/hidden-y display: inline-block/flex/gid 如何解决高度塌陷 :after { clear: both;} 或者在父元素内部最后新增一个元素设置 style clear: both; 设置 position: absolute overflow: hidden 元素水平垂直居中的方法 display: flex; align-items: center;justify-content: space-around; position:absolute; top:50%;left:50%;transform: translate(-50%, -50%) display: grid; align-items: center;justify-content: space-around; margin-top:50%;margin-left:50%;transform: translate(-50%, -50%) 定高的话可以使用 margin-left偏移自身一般宽度和高度 flex 布局有哪些属性 flex-direction 布局方向 row/row-reverse/column/column-reverse flex-wrap 是否换行 flex-flow flex-direction 和 flex-wrap 的简写模式 justify-content 主轴上的对齐方式 flex-start/flex-end/space-around/space-between/space-evenly/center align-items: 交叉轴 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch align-content 多根轴线对齐 flex-start/flex-end/space-around/space-between/space-evenly/center 子元素属性 order 定义项目排列顺序，数值越大越靠后 flex 设置 flex-grow/flex-shrik/flex-basic 的缩写 flex-grow 是否放大 默认为0 flex-shrink 是否缩小 默认为1 flex-basic 占据主轴空间 align-self 单独设置子元素的对齐方式,可以使部分子元素与其他子元素对齐方式不同 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch css 选择器优先级css 选择器有以下几种 ID 选择器 id=&quot;abc&quot; 类（class）选择器 class=&quot;abc&quot; 标签选择器 div 标签属性选择器 div[title=&quot;abc&quot;] 伪类和伪元素 after,before,selection,focus,hover,active, 父子选择器 div &gt; p 后代选择器 div p 其中 ID 选择器的权重最高，接着是类选择器，最后是标签选择器 !important 和 行内样式 的权重最高，权重高的的样式会覆盖掉权重低的样式 常用的 css 库 reset.css 是一个css文件，用来重置css样式的。 normalize.css 为了增强跨浏览器渲染的一致性，一个CSS 重置样式库。JavaScript数据类型 基础数据类型有 Number String Boolean Null Undefined Symbol Bigint (新增的，因为是为了兼容大数) 引用数据 Object 如何判断数据类型 typeof 需要注意的是 typeof null = object, typeof func() {} = function instanceof 原理是根据原型链来查找的 Object.prototype.toString.call() 会返回对应元素类型 [object Object/Array/RegExp/...] 数据类型转换 显示转换，比如使用 parseInt，Number，String，Boolean 方法强制进行转换 隐式转换，进行数据运算和 === 操作时，对象会调用 valueOf 方法进行转换，基础数据类型会根据内容进行隐式转换 123456789101112let a = &#123; valueOf: () =&gt; 4&#125;a + 1 // 5let b = &#123;&#125;b + 1 // &quot;[object Object]1&quot;let c = []c + 1 // &quot;1&quot;true + 1 // 2false + 1 // 1&quot;&quot; + 1 // &quot;1&quot; 你能写出多少种数组的方法1234567map filter reduce reduceRight someevery from of fill joinsplice slice find findIndex findLastindexOf lastIndexOf forEach concat findLastIndex includes contains values keys entriesat flat isArray sort poppush unshift shift toString toLocaleString 你能写出多少种字符串方法12345split substr substring match parseIntrepeat replace replaceAll concat parseFloatendsidth startsWidth padStart padEnd toLowerCasetoUpperCase toLocaleLowerCase toLocaleUpperCase codeAt charCodeAtvalueOf includes trim trimStart 多维数组转成一维数组的方法 flat 传参为 number，平铺层级 reduce + 递归 使用 reduce + 递归的方式 for + 递归 for 循环加递归 数组去重的方法 es6 Set 方法会自动去重 使用 hash，对象的键是具有唯一性的 简单的遍历，使用新的数组来承载去重后的数组，可以用 indexOf,includes 等方法判断元素是否存在 中心思想是如何去重，使用方法并不固定 闭包闭包是一个函数及其捆绑的周边环境状态的引用的组合，闭包可以使开发者从内部函数访问外部函数的作用域。 可以用来实现函数柯里化（将多个参数转变成单个参数传入func(a,b,c) =&gt; func(a)(b)(c)） 可以用来模拟私有方法，因为闭包内部的部分变量和方法，函数外部无法访问 闭包还可以用来解决变量提升的问题。 使用闭包需要注意内存泄露问题，因为这些作用域不会随着函数的执行而清除掉 原型链javascript对象上有一个属性，可以通过这个属性查找到她的原型，而且原型上也有这个属性，可以一级一级的向上查找 1234567891011let obj = new Object()obj.prototype === undefinedobj.__proto__ === Object.prototypeObject.prototype.__proto__ === nullfunction func () &#123;&#125;let f = new func()f.__proto__ === func.prototypefunc.prototype.__proto__ === Object.prototype 当我们在查找一个对象的属性的时候，如果当前对象不存在这个属性，则会沿着原型链一级一级的向上查找，直查找到最后一级，也就是 Object 对象上 需要注意的是在原型链上查找比较耗时和消耗性能，如果层级比较深的话，可以选择暂存下来 原型链上的属性和方法最好不要随意修改，否则可能会影响其他继承于该原型的函数 this 指向 直接执行 this 指向 window 1234567891011function func() &#123;&#125;func() // windowconst obj = &#123; func: function() &#123; &#125;&#125;let f1 = obj.funcf1() // window 挂载到对象上执行 this指向当前对象 123456const obj = &#123; func: function() &#123; &#125;&#125;obj.func() // obj new使用new 的时候会执行以下几个操作 创建一个新的空对象 将当前空对象的 prototype 指向当前函数的 prototype 将前端对象替换当前函数的执行上下文（this） 判断函数是否存在返回值，返回值如果是基础数据类型，则this 还是 创建的空对象，否则是return 的对象 call，bind，applycall 和 apply 会立即执行函数，同时将函数的this 指向传入的thisbind 不会立刻执行，而且参数可以不用一次性传入 call(this, …args) bind(this, …args) apply(this, args) 事件循环 (Event Loop) 宏任务（setTimeout，setInterval，script，ajax） 微任务（Promise.then, requestAnimationFrame， process.nextTic, Object.observer, MutationObserver(监察dom节点变化)） 同步任务 正常js解析，js代码执行等 函数的执行顺序是 如果存在同步任务，会先执行同步任务 同步任务执行完成后，先查找微任务队列中是否包含任务，如果包含需要执行的任务，会立即执行 微任务队列执行完成之后才会去判断宏任务中是否存在需要执行的任务，宏任务每次执行的时候都需要判断微任务队列中是否包含需要执行的任务 Promise Promise.resolve() 返回一个以给定值解析后的 Promise 对象 Promise.reject() 返回一个带有拒绝原因的 Promise 对象。 Promise.then() 返回一个 Promise 对象，有两个回调函数，一个成功的回调，一个失败情况的回调 Promise.catch() 返回一个 Promise 对象，只有一个失败情况的回调 Promise.finally() 无论成功和失败都会执行 Promise.all() 当所有的 Promise 成功后才回返回成功，结果按顺序返回，有一个失败就返回失败 Promise.race() 只要有一个 Promise 成功或者失败，就是返回一个成功或者失败的结果 Promise.allSettled() 当所有的 Promise 的结果都获取到才返回，不管成功还是失败 Promise.any() 只要有一个 Promise 成功就会返回成功的结果，全部失败才会返回失败的结果 手写一个 Promise 方法 Proxy/RflectProxy 对象用于创建一个对象的代理，实现对基本操作的拦截 类似于 Object.defineProperties,但是比她的功能更强大 123456789101112131415let obj = &#123; a: 1&#125;let o = new Proxy(obj, &#123; set: function(obj, key, value) &#123; console.log(obj, key, value) &#125;, get: function(obj, key, value) &#123; console.log(obj, key, value) return obj[key] &#125;,&#125;)obj.a = 20o.ao.a = 30 需要注意的是，只有通过代理后的对象修改和获取属性时，才会触发代理，原对象修改和删除并不会触发 handler 配置属性 get 属性读取操作 set 属性设置操作 has in操作符 deleteProperty delete 操作符 ownKeys Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。 apply 函数调用时触发 construct 使用 new 操作符触发 getPrototypeOf 获取原型对象扑捉器 Object.getPrototypeOf setPrototypeOf 设置原型对象扑捉器 Object.setPrototypeOf isExensible Object.isExtensible 方法的捕捉器 是否是可扩展的 preventExtensible Object.preventExtensions 方法的捕捉器。设置对象不可扩展 getOwnPropertyDescriptor 获取对象的属性描述（value,configurable,writable,get,set,enumerable） defineProperty Object.defineProperty 方法的捕捉器。 Reflect 方法同理，主要用来对 Proxy 对应属性的映射 能说一下 Set和 weakSet Map和 weakMap 有什么区别吗？主要区别在 weakMap 和 weakSet 存储的键值对是不会被垃圾清理进行标记和计数的，也就是说，在进行垃圾清理的时候，如果浏览器判断这个元素需要被清除掉，那么它就会从 weakMap 和 weakSet 中清除掉 还有一个比较重要的区别就是，weakSet和weakMap(key) 只能使用引用类型的值，而不像set和map可以使用任意类型的值 而map 和 set 并没有这种操作 方法都是一样的 Map有 set，has，get，keys，values，entries set有 add, has, get, size, keys, values, entries Symbol 的一些注意事项 使用 new Symbol 的时候，都会创建一个新的Symbol 无论传入的参数是否一样，也就是说 123let a = Symbol(&quot;123&quot;)let b = Symbol(&quot;123&quot;)b===a // false 如果想要获取到同一个 Symbol，可以采用 Symbol.for 方法创建 Symbol，它会去查找 是否已经创建了 Symbol，如果没有创建则会新建一个 Symbol，如果已创建，则会返回已创建的Symbol 123let a = Symbol.for(&quot;123&quot;)let b = Symbol.for(&quot;123&quot;)a === b // true 需要注意的是 Symbol 不能使用 new 关键字 ES6 新增了哪些内容ES6 现在统一作为 ECMA2015 以后的 javascript 版本的统称，主要新增了一下内容 新增let，const 命名变量(解决变量提升问题) 箭头函数（没有this，this的执行为定义的时候上下文，无法使用new，call，bind，apply 等操作更改this） 解构赋值（包含有 symbol.iterator 方法的对象都支持） class 语法糖（继承和封装） promise，async/await（将异步函数转成同步方法） map/set（将对象的键值对分别存储，允许使用对象作为键） 数组新增了 map，filter，reduce，some，every 等方法 for … of … class 语法糖 constructor 构造方法，new 的时候会执行 constructor 里面的代码 get set 方法 对某个属性设置存值函数和取值函数，拦截该属性的存取行为 static 静态方法 静态方法只能在类上直接调用，无法再实例上调用，并且可以被子类继承 私有属性和私有方法，只能在类内部访问的属性和方法，可以用 # 来标记，不可以在类的外面使用，可以通过this来访问 new.target 在类里面指向当前类 面对对象编程面对对象编程 面向过程编程：会将事情分为一个个函数和数据，按照一定的是顺序执行。 面向对象编程：将一个事情抽象成对象的概念，然后给对象赋予一些属性和方法，然后将每个对象执行自己的方法。因此易于维护，易复用，易扩展 面对对象编程 三大基本特性：封装，继承，多态 五大基本原则：单一职责，开放封闭，里式替换，依赖倒置，接口分离 函数式编程函数式变成属于结构化编程的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用 闭包和高阶函数 递归 惰性计算 有以下五个鲜明特点 函数是第一等公民 只用表达式，不用语句 没有副作用（函数只会返回一个新的值，不会修改外部变量的值，内容保持独立） 不修改状态（不会修改函数外变量或者属性的值） 引用透明性（同样的输入会返回同样的结果） 优点是： 代码简洁，开发快速 接近自然语言，便于理解 方便代码管理，调试起来更方便 支持并发操作（没有副作用） 修改方法内部时，不需要修改其他地方，升级方便 setTimeout和setInterval 那个用来计时最准确，为什么？setTimeout 要更准确一些。 原因如下： 如果setInterval 中函数执行时间超过等待事件，在函数执行完后后，由于任务已经被加入队列，所以，并不会等待一段时间后再执行，而是会立即执行 而setTimeout 则是等函数执行完成后，才会向异步任务队列添加回调，等待一段时间后，才会再次执行回调函数，代码执行间隔事件会比预期学校 但是具体哪个比较好，还是需要看具体需求的 AMD CommonJs，ES6 mdoule 之间的区别 AMD 异步模块加载，通过 define 定义模块，require 引用模块，模块加载完成后通过 回调函数执行代码 commonJs 通过 module.exports 导出模块，require 引入模块，模块内部变量只在内部起作用，不会污染全局，并且是同步加载的 ES6 module 通过 export 和 export default 导出模块，import 引入模块，加入了treeShaking，只会编译和打包被使用的模块。也支持动态加载 浏览器垃圾回收 引用计数 引用计数的原理当创建和引用对象时，都会给该对象的引用次数加1，当给变量重新赋值或者执行的上下文清除时，引用次数 -1，当引用次数为0的时候，会被清除的。 缺点是当出现循环引用的时候，由于引用计数一直不为0，所以无法被清除 标记清除 当变量进入执行环境时，会标记状态为进入，当弹出执行环境时，会标记状态为清除，标记状态为清除的会自动被js引擎清除 缺点是容易造成内存碎片化 标记整理法 同标记清除，会在清除后重新整理内存地址 垃圾回收优化 将内存分为 新生代和老生代，新生代缓存的是存活时间比较短的地址，老生代缓存的是存活时间久的地址 同时新生代又分为使用区和空闲区（双缓存），在进行清除时，会将使用区的变量的标记进行判断，如果被标记，则放到空闲区内，并且进行内存整理，最后将使用区的内存清空，并将使用区变成空闲区，空闲区变成使用区，并重复上述操作 内存泄露 循环引用 闭包 没有终止的 setInterval 性能优化最全的页面性能优化 输入一个链接地址到显示到页面上具体经过了那些步骤 浏览器首先会根据输入的网址，进行 DNS 域名解析找到对应服务器的ip地址 建立连接 （TCP/IP 协议）三次握手 客户端向服务端发送SYN 服务器恢复 SYN-ACK,最后客户端发送 ACK 报文 发送请求（请求头，请求体）到服务器，服务器会根据传入的地址，找到对应的文件返回到客户端 客户端下载文件后，会解析文件，将标签和样式通过对应的parse 转化为 dom 树和 CSSOM 树 如果在解析的过程中遇到 script 标签，如果script 标签没有引用外部文件，则会停止文件解析，等待 script 内部代码执行完成后才会继续解析，如果引入了外部文件，则会根据 defer 属性和 async 属性，来判断是否延迟加载 js文件。 将生成的 DOM 树和 CSSOM 树合并形成渲染树，进行布局计算，将计算结果会渲染屏幕上 渲染时涉及到图层的概念（position，translae3d，will-change, transform）,启动GPU加速，将所有图层最后组合到页面上正成最终结果 浏览器缓存 cache-control max-age 最大缓存时间 no-store 浏览器不会进行缓存，也不会进行协商缓存 no-cache 浏览器进行协商缓存通过 ETag/If-Match 和 last-modified public 可以被任何缓存例如共有缓存（CDN）和私有缓存（浏览器） private 仅可被私有缓存（浏览器）缓存 强缓存： 强缓存主要是向浏览器缓存区获取文件，并且根据文件是否失效（max-age/exproes）来判断是否需要重新重服务器拿取文件 协商缓存： 当强缓存失效时，会走协商缓存，协商缓存不会直接从浏览器缓存中拿取数据，而是直接向服务器发送请求，服务器根据 ETag 和 last-Modified 参数和服务器文件进行对比，如果发生变更，则代表文件已修改，返回给客户端最新的文件，如果没有变更再去读取本地缓存的文件 缓存类型 server-work （sw.js）走的是server-work 的缓存逻辑 memory cache 存在内存中，如果关闭tab页缓存会失效 disk cache 存在磁盘缓存中 重绘和重排(回流) 重绘 是指元素自身属性发生变化时，并不会影响其他元素位置和属性变化，例如：color，opciaty，backgound等 重排是指元素本身的物理尺寸发生变化时，引起页面重新排列，列如修改宽，高，外边距，内边距，边框，添加和删除元素，display: none等 如何避免频繁触发重绘和重排 如果涉及到频繁修改样式，可以采用统一修改的方式，例如，添加 class 或者 cssText 设置 position: absolute 脱离文档流 这是 transform 和 will-change 属性，启动 gpu加速 修改元素时批量修改 设置 display: none;修改完成后在显示出来 使用文档片段 （document.createDocumentFragment()） 创建一个熄灯节点，用来更新内容，更新换成后替换旧节点 获取以下属性和方法时，页面会被强制更新，因为这些属性需要根据页面上元素的最新状态进行更新offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect HTTP1/HTTP2 HTTP1.0 在 HTTP1.0 中，每发送一次请求，都要与服务器建立一次连接，请求完成后，连接会立即中断，再加上浏览器对于请求并发的限制，如果有一个请求一直处于padding 状态，则会影响后续接口的请求 HTTP1.1 则支持长连接，以及多个请求共用一次连接，然后返回结果根据请求顺序进行返回，虽然减少了连接次数，但是由于需要按照顺序返回，因此一旦有一个请求处于padding 状态，后面的接口即使结果已经拿到也不会返回给前端，而是等padding 结束后才返回给前端 HTTP2.0 支持多路复用以及二进制传输，首部压缩等操作， 多路复用 同一个tcp连接，可以同时发送多个请求和回应 二进制分帧 每一个请求和回应都生成一个独特的id，客户端和服务端根据id拿取数据，这样不会发生 堵塞影响后续接口数据传输 头部压缩 客户端和服务端同时维护一套 头部信息键值对，可以减少数据传输量 HTTP/HTTPS HTTP 超文本运输协议，是实现网络通信的一种规范,可以将信息从一个设备发送到另一个设备 HTTPS 在 HTTP 的基础上添加了加密协议（SSL/TLS）传输的信息是1进行加密过的，但是由于需要进行加密验证，所以性能方法消耗比较大 跨域出现的原因及解决方法出现原因：主要是同源策略，避免其他服务器的攻击，什么是同源策略呢？就是域名，端口号，还有协议必须要一样，如果有一个不一样，就不满足同源策略 解决方式： jsonp 主要利用script 标签不会被同源策略影响 postMessage cors 后端通过设置 Access-Control-Allow-Origin 参数，允许白名单域名进行访问 document.domain 事件流浏览器事件触发会经历三个阶段 事件捕获阶段（由最外层元素，向目标元素查找） 目前事件阶段（触发事件元素） 事件冒泡阶段（由目标元素向直至最外层元素） 事件类型又分为三种 原始事件 (on + 事件名) 相同事件只能存在一个，后面的会覆盖前面的 标准事件 (addEventListener) 相同事件可以绑定多个函数，这些函数都会触发 web 常见的攻击方式 XSS (跨站脚本攻击) CSRF 跨站请求伪造 SQL 注入 解决方式： 尽量不要使用 innerHTML,如需使用，需要对内容进行转码或者过滤等操作 对于发送给服务端数据，需要进行转码操作 针对 CSRF 进行同源检测，token验证等 针对SQL 注入，过滤和转义特殊字符串，检查输入内容，提前进行拦截 CDN 缓存CDN (全称 Content Delivery Network)，即内容分发网络，构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 当开启 CDN 缓存时，用户访问文件时，会首先访问 CDN 距离用户地区最近站点查找，如果查找到文件，会根据文件缓存时间是否过期等信息判断是返回缓存的文件还是向服务器重新拿取文件，如果没有找到则会向服务拉取最新文件进行缓存，并且发送给客户端 可以通过修改文件名称，修改路径地址，清空对应文件 CDN 缓存。 SEO 优化 title，meta标签（description，keywords,og:title…） image alt 和 src 属性 link conial a 标签的 href 属性 p 标签和 H1-6 标签 结构化数据（HowTo,Prodduct,Score…） 浏览器线程和进程之间的关系 进程是Cpu 最小的资源分配单位 线程是 CPU 最小的调度单位 一个进程可以同时存在多个线程，同一个进程下的所有线程共用一个存储空间 浏览器常用的进程大致分为以下几种 浏览器进程 GPU 进程 浏览器渲染进程 每个标签页都有一个单独的进程 浏览器的扩展插件也有自己的一个单独进程 相比于单进程浏览器，多进程有如下优点： 避免单个page crash影响整个浏览器 避免第三方插件crash影响整个浏览器 多进程充分利用多核优势 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性 浏览器内核有哪些线程 GUI 渲染进程 js 引擎（js内核） 事件触发线程 定时触发器线程 异步HTTP 请求 Vue2常用指令 v-if v-else v-else-if v-show v-for v-html v-text v-bind v-on v-model v-once v-slot 插件 常用修饰符 number .lazy v-model 监听change 而非 input keyup/keydown trim prevent/stop 阻止默认事件 once 只执行一次 right/left 鼠标左右键点击触发 camel 将属性转驼峰 生命周期 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestory destoryed errorCaptured 错误监听 activited keep-alive deactivited keep-alive 常用属性 name data props provide inject computed watch directives filters methods mixin 组件通讯 父子组件通讯 props provide/inject $emit $parent/$children $ref event bus 兄弟组件 通过父组件传值 $parent event bus 不相关组件 event bus Vuex Vue 组件之间通讯的各种情况 computed 和 watch computed 计算属性，计算后的结果值会被缓存下来，如果相关联的属性没有发生变化时，会取缓存后的结果 watch 监听属性，当属性发生变化时，会重新执行监听函数，针对对象可以使用 immediate 和 deep 来启动立即监听和深度监听 在日常使用中更推介使用computed 属性，因为会对得到的结果进行缓存，减少计算量 diff 算法 （双指针遍历）当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom 对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。 这样一直递归的遍历下去，直到整棵树完成对比。 请阐述vue的diff算法 Vue diff 算法双指针逻辑总结 新创建的 子节点数组 和 旧的子节点数组分别有一个 头节点指针和尾结点指针。 针对旧节点的两个指针，如果新节点的两个指针有匹配到的，则将该指针所对应的 Vnode 转移到对应的位置（头对头，尾队尾），对应头结点和尾结点的位置进行变化（头结点后移，尾结点前移） 知道头尾节点均不符合匹配时，这样就筛选出来两类节点，一种是旧子节点数组上需要删除的子节点，一种是新的子节点上需要新增的子节点。 这样做的目的是最大可能性的复用已有的真实dom节点，对于新增的，需要创建新的 dom节点。 MVVM 框架MVVM 是指双向数据流，即 View-Model 之间的双向通信，由 ViewModel 作桥接，当model 发生变化时，会通过 view-model 修改 view 视图，当 view 视图发生变化时，通过 view-model 修改 model，比较典型的就是 vue 的双向数据流绑定，通过 Object.defineProperty和 Proxy 对数据修改和获取进行拦截，收集依赖。进行绑定 Mvvm 前端数据流框架精讲 v-for 和 v-ifv-for 的优先级比v-if 的优先级要高，页面会首先根据 v-for 渲染列表，然后在根据 v-if 来判断列表元素是否显示和隐藏，因此会造成性能浪费 因此推荐使用 computed 属性，提前过滤需要隐藏后的数据后，在使用 v-for 进行渲染 v-show 和 v-ifv-show 会进行dom 树的构建，但是 display 属性为 none v-if 不会进行组件渲染，自然也不会构建 dom 树，对性能有优化 如果一个元素经常会触发显示和隐藏操作，可以使用 v-show，如果不会经常触发，推介使用v-if v-for 循环时 key的作用是什么进行diff 算法时，方便进行对比组件是否更新，以及组件复用 会首先对比key 是否一样，如果一样在判断标签或者 类型是否一致（input）这样可以节省一部分对比操作，提升性能 $nextTick 原理主要是利用了 javascript 引擎的事件循环机制，是的 $nextTick 传入的参数在同步事件之后触发，可以拿到 修改后的dom和 data 里面的值 使用 Promise.then,setImediate, setTimeout, mutationObserve 来实现 Vue 是如何监听属性变化的使用 Object.defineProperty 来监听属性的变化，重写get，set 方法，并且新增 Watcher 方法，当修改属性值时，触犯到 set 方法，在set 方法中会收集到当前这个属性所关联的依赖，并通知这些依赖进行更新. 每个组件被创建的时候（$mount,mountComponent,$watch）都会创建一个新的 Watcher 实例，并且赋值给 当前组件内进行数据监听时创建的 Dep 对象的 target,当我们初始化实例的时候，会调用 depend 方法，会将当前 Dep 添加到 Watcher 里面，会通过 Watcher 的 addDep 方法，把当前Watcher 添加到 Dep 的依赖（dep） 中,修改属性值的时候会调用 notify 方法，去执行该属性关联的 Watcher 的 update 方法，更新数据。 那几个方法会创建 new Watcher 纵观源码，有以下几个地方会创建 Watcher computed，在非 SSR 的情况下会给每个 监听的变量创构建一个 watcher $mount 方法 mountComponent 在挂载组件的时候也会创建一个 Watcher $watch 方法 12创建 Watcher使用 Object.defineProperty 对数据获取和更新进行拦截，get操作时添加依赖（watcher），set 时，notify 依赖执行 update 操作，更新数据和对应页面 data 为什么要用一个函数的模式是因为组件是可以重复使用的，如果data 不用一个函数模式的话，可以会造成数据污染，无法获取到想要的数据 Vuex 有几个模块 module 用来区分模块 state 用来存储值 mutations 用来修改state 的值 actions 用来异步操作，通过 mutations 修改值 getters 计算属性，会根据state最新的值来计算 Vuex 提供了 mapGetters，mapState，mapActions 等方法，方便我们快速获取Vuex 的值 Vuex 主要时通过Vue.use 注册到 Vue 实例上面的，其原理和 vue 的双向绑定原理类似，都是如果组件使用了Vuex 里面的属性，则会将该组件添加到属性的依赖上面，因此如果属性发生变化，就可以监控到那些组件需要执行更新操作 Vue-router 有几个模式设置 router 的 mode 属性，默认为 hash 模式，设置 history 后，为history模式 hash模式 在网址后面以 # 模式 history 模式 直接跟在网址后面 Vue-router 可以使用懒加载的方式 Vue 项目如何优化 路由懒加载 () =&gt; import(“”) 组件懒加载 () =&gt; import(“”) v-if 和 v-for 避免一起使用，可以用计算属性过滤部分数据 针对经常显示隐藏的页面结构，可以使用 v-show，否则应使用 v-if 等等 自定义指令 (directive)有以下几个周期，可以对dom 元素的各个状态进行监听 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestory destoryed Vue3Vue3 相对比 Vue2 新增了哪些东西？ composition APIref，reactive，watch，watchEffect，computed 等 setup setup 执行顺序在 beforeCreate 生命周期之前，因此也不能获取到 DOM,因此提供了 生命周期钩子函数 (on + 生命周期) ，通过 return 把参数和方法暴露出来 beforeDestory -&gt; beforeUnmount, Destoryed -&gt; unmount 数据监听方式由 Object.defineProperty 变更为 Proxy，这样的话一个是针对多层 object 对象不需要进行递归监听，其次是针对数组的新增和修改操作也能更加方便的监听 vue3 相比于 vue2 针对性能做了哪些优化 对组件类型进行区分，对静态节点进行了优化，会对静态节点保存下来，进行更新操作时，不需要重新创建节点 碰见连续静态节点的时候，会将这一段静态节点转成 html 字符串，直接使用 innerHTML 方法添加到元素内，减少了递归操作 缓存事件处理函数 对静态节点进行优化，虚拟dom对比时，直接跳过虚拟节点，减少对比和递归次数 React生命周期挂载阶段 constructor componentWillMount（新版 getDerivedtateFromProps） render componentDidMount 更新阶段 componentWillReceiveProps （getDerivedtateFromProps）） shouldComponentUpdate componentWillUpdate （null） render （getSnapshotBeforeUpdate） componentDidUpdate 卸载阶段 componentWillUnmount 为什么新版的react 的生命周期要加上 UNSAFE_ 前缀 这个是因为这个函数不安全，原因是因为 react 16 以后 react 支持 fiber 切片后，组件会根据执行优先级来进行编译和渲染，因此可能会出现一个组件正在执行更新或者创建操作时，有一个优先级更高的任务插进来，这个时候，当前任务会被暂停掉，更换优先级更高的任务执行操作，操作完成后，才会回到之前的操作，继续执行，这个时候，部分生命周期有可能会执行两次，造成数据混乱 虚拟dom（virtual DOM）virtual DOM 又称虚拟DOM， 是使用 JavaScript 对象来描述真实DOM节点，virtual DOM 内存储了真实DOM的各种信息，标签名，属性名包括子元素，virtual DOM 之间通过树形结构连接，与真实DOM一一对应，构成了最终的虚拟DOM树 virtual DOM 的修改不会触发页面的重绘和重排，可以有效避免真实DOM的频繁更新，通过对应的编译器可以实现一套代码，多端运行，但是由于 还需要渲染成真实DOM显示到页面上面，因此首次渲染时速度较慢 diff 算法React技术揭秘-卡颂 React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中n是树中元素的数量 React diff 算法做了以下优化 只进行同级比较，如果一个节点在更新前后层级不一样，则不会进行比较 不同类型的子元素是一个新的树，旧的树会被直接销毁，新的树会被创建 可以通过key 值来判断那些子元素保持稳定 react 在进行 diff 算法时，会首先针对 节点的 类型，key进行对比，如果都一样，在对比传入的 props，state 等属性是否有变化，有变化执行更新操作，没有变化就直接复用，不过不一样，则会创建一个新的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 之前abcd// 之后dabc===第一轮遍历开始===d（之后）vs a（之前） key改变，不能复用，跳出遍历===第一轮遍历结束======第二轮遍历开始===newChildren === dabc，没用完，不需要执行删除旧节点oldFiber === abcd，没用完，不需要执行插入新节点将剩余oldFiber（abcd）保存为map继续遍历剩余newChildren// 当前oldFiber：abcd// 当前newChildren dabckey === d 在 oldFiber中存在const oldIndex = d（之前）.index;此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3比较 oldIndex 与 lastPlacedIndex;oldIndex 3 &gt; lastPlacedIndex 0则 lastPlacedIndex = 3;d节点位置不变继续遍历剩余newChildren// 当前oldFiber：abc// 当前newChildren abckey === a 在 oldFiber中存在const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0此时 oldIndex === 0;比较 oldIndex 与 lastPlacedIndex;oldIndex 0 &lt; lastPlacedIndex 3则 a节点需要向右移动继续遍历剩余newChildren// 当前oldFiber：bc// 当前newChildren bckey === b 在 oldFiber中存在const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1此时 oldIndex === 1;比较 oldIndex 与 lastPlacedIndex;oldIndex 1 &lt; lastPlacedIndex 3则 b节点需要向右移动继续遍历剩余newChildren// 当前oldFiber：c// 当前newChildren ckey === c 在 oldFiber中存在const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2此时 oldIndex === 2;比较 oldIndex 与 lastPlacedIndex;oldIndex 2 &lt; lastPlacedIndex 3则 c节点需要向右移动===第二轮遍历结束=== 总结来说就是尽量复用已有的节点，将已有的节点按照新的节点数组进行排序，没有的节点再新增 总共进行了两次遍历，第一次遍历是为了找到相同的前缀子节点数组，第二次遍历是为了找到剩余子节点数组中可以复用的子节点。 fiber 分片React技术揭秘-卡颂 React Fiber可以理解为：React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。 总的来说，每一个 fiber 节点都对应着一个 react element，并且存储着当期节点的 属性，状态和值，fiber 与 fiber 之间通过 return，child，sibling 参数连接 在开始遍历的时候，会首先判断 child 是否有值，如果有值，会遍历child 的第一个值，然后逻辑同上。 如果child 没有值，会通过 sibling 查找当前节点的兄弟节点，兄弟节点查找完成后，会通过 return，回到父节点，然后继续执行操作（感觉像是深度优先遍历） 在进行 dom 挂载和更新的操作，fiber 采用的是双缓存。也就是说，react 在进行更新操作的时候，是存在两个fiber 树的，一个是当前页面渲染的旧的fiber 树（current Fiber），另一个是页面更新后需要渲染的 fiber 树（workInProcess Fiber），这两个 fiber 之间通过 alternate 参数连接 在更新过程中，会根据diff 算法判断是否需要复用原来的 fiber 节点（节省时间，提高效率） 页面更新完成后，workInProcess Fiber 将会变成 current Fiber，原来的 fiber 树将会被舍弃掉 常用 hooks useState useEffect useLayoutEffect 在 页面渲染时触发，应该是拿不到dom 对象 useRef 既可以用来存值，也可以用来获取dom对象 useMemo 缓存值 useCallback 缓存函数 useContext 上下文 useReducer useImperativeHandle/forwardRef 可以将子组件的方法暴露给父组件来使用 useImperativeHandle 可以将子组件中部分函数暴露给父组件的 ref使用 useMemo 和 useCallback 的区别useMemo 缓存的是值 useCallback 缓存的是具体函数 因为 React 函数式组件每次更新的时候，都会销毁上一次的上下文，然后重新创建新的上下文，也就是说在函数式组件内创建的函数，都会被重新创建 组件通讯 mobx/redux 等状态管理工具 props ref/useImperativeHandle 发布订阅模式 React.createContext/useContext(React.createContext/Provider/Consumer) React 如何监听数据变化主要是通过 setState，useState，forceUpdate，会生成一个 Update 对象，会和原属性的值进行对比，如果发生改变，则会触发更新操作，这个对比采用的是浅对比的方式。 Update 有一个更新队列，存放着这个组件本次需要执行的所有更新操作 Vue 和 React 有什么异同点？ 共同点如下： 都是javascript 的一个框架，定义了一套属于自己的方法来实现项目搭建 都采用了 虚拟DOM 的方式来对真实DOM 进行描述 都采用diff 算法来对组件更新时候的节点比较进行优化 都实现了自己的一套模板，vue(template),react(jsx) 不同点如下： vue 是采用 Object.defineProperty(Proxy) 来实现双向绑定原理的，，react 是单向数据流，修改值的话，只能通过 setState，useState,focusUpdate,render才会出现页面的更新操作 模板实现原理不一样，vue(template),react(jsx) diff 算法实现逻辑不一样，vue 采用的是双指针的方式，react 则采用单指针比较，同时检测出可复用的节点（两次循环） react 实现了 fiber，支持根据优先级进行渲染，优先级低的组件渲染可被中断，采用了双缓存的逻辑，方便进行一部分 fiber 的复用 Webpack多入口页面通过 entry 和 output 参数可以设置多入入口文件及打包后的文件名称和位置 接下来通过 html-webpack-plugin 插件指定文件渲染模板，此外还可以设置生成文件的 title meta 标签以及link 标签等内容，以满足部分 SEO 需求 loaders 的使用 常用loader具有那些loader 可以查看这里 style-loader css-loader sass-loader less-loader postcss-loader ts-loader babel-loader vue-loader webpack 打包流程 首先通过 entry 找到入口文件 通过各种loader(ts-loader,js-loader,style-loader,sass-loader) 等将需要打包的文件转成浏览器识别的语言 接下来通过 output 将转化成的代码生成js文件，如果有分包操作，将会被拆解成多个文件 然后通过 plugin 将 文件写入到html文档中，如果有html-webpack-plugin 则会根据对应的chunk 和模板文件写入 Vite深入理解Vite核心原理Other你在工作中觉得有没有什么比较难的事情我觉得这个其实挺蛇皮的，这种问题看起来没有一点可以问的价值，正常来说只要能完成，我觉得都没什么难的，以下列一下我在工作中认为比较难的事情 项目底层架构升级，需要对项目各个功能，参数，还有调用方式都有一个清晰的认知，否则在进行升级的过程中会出现各种各样的问题 多页面打包配置，基于 gitlab 实现多页面项目按需打包，避免发版影响页面过多 移动端样式适配，适配不同浏览器及移动端浏览器适配（样式，功能(下载)） 这种东西其实在做的时候感觉挺难的，其实会想之后感觉也就那样 设计模式用最简便的方法描述 工厂模式 抽象模式 单例模式 观察者模式 状态模式 组合模式 享元模式 原型链模式 桥接模式 装饰器模式 代理模式 策略模式 访问者模式 委托模式 数据访问对象模式 节流模式 参与者模式 npm，pnpm，yarn 之间的区别三者目前都是主流的包管理工具 一文看懂npm、yarn、pnpm之间的区别 npm 使用 npm 添加安装插件的时候，会在版本号前面有一个 ^ 符号，这个符号告诉npm 可以下载当前主版本号的任意一个版本，因此会出现 不同开发人员下载三方包的时候，下载下来的包不是同一个版本的包。 npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是npm安装速度慢的一个很重要的原因。 npm是有本地缓存的，它保存了已经下载的每个版本的压缩包。 pnpm pnpm采用了一种巧妙的方法，利用硬链接和符号链接来避免复制所有本地缓存源文件。 同时pnpm运行起来速度也是很快的 yarn 使用yarn 进行安装的时候，会对下载的插件版本号和package.json 中的版本号进行匹配，因此不会出现版本不同的情况 yarn 同样也提供了本地缓存的功能 cnpm cnpm 主要是 npm 的镜像，主要用于国内下载资源加速。 12// 安装cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org GIT正常提交流程1234git add .git commit -m &quot;message&quot;git pullgit push 合并分支1git merge branch-name 切换，创建，删除分支123git checkout &lt;branch-name&gt; // 切换分支git checkout -b &lt;branch-name&gt; // 创建本地新分支git checkout -d &lt;branch-name&gt; // 删除分支 拉取代码12git clone github.com/sample.git // 拉取代码git clone -b &lt;branch-name&gt; github.com/sample.git // 拉取指定分支代码 git 回滚12git revert -n [hash] // 在这个版本基础上重新生成一条记录git reset --hard [hash] // 本地强制回滚至上一次提交，并覆盖记录 设置用户12git config --global user.name [name]git config --global user.email [email] 其他用法123git log // 查看提交记录 q 退出查看git diff branch1 branch2 // 对比分支修改记录git cherry-pick [hash] // 合并末次commit 内容到当前分支 手写算法题数组方法重写 map reduce filter some every 后续持续更新，敬请期待","pubDate":"Tue, 04 Apr 2023 09:15:19 GMT","guid":"https://lxx1997.github.io/2023/04/04/interview/%E9%9D%A2%E8%AF%95%E9%A2%98-01/","category":"interview,promise"},{"title":"JavaScript - 手写一个 Promise 方法","link":"https://lxx1997.github.io/2023/03/13/web/hand-write-promise/","description":"手动实现 promise, 下面hi全部的代码,写了差不多有两个小时，并且附上示例 之前也有一版，不过我觉得这一版更好理解一些123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294// this code for create a new promiseconst PROMISE_PADDING = &quot;padding&quot;const PROMISE_FULLFILLED = &quot;fullfilled&quot;const PROMISE_REJECTED = &quot;rejected&quot;class newPromise &#123; constructor(func) &#123; this.status = PROMISE_PADDING this.value = undefined this.resolveCB = [] this.rejectCB = [] const resolve = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_FULLFILLED this.resolveCB &amp;&amp; this.resolveCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; const reject = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_REJECTED this.rejectCB &amp;&amp; this.rejectCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; try &#123; func(resolve, reject) &#125; catch (error) &#123; reject(error.message) &#125; &#125; then(res, rej) &#123; res = typeof res !== &quot;function&quot; ? (val) =&gt; val : res rej = typeof rej !== &quot;function&quot; ? (val) =&gt; val : rej return new newPromise((resolve, reject) =&gt; &#123; if(this.status === PROMISE_PADDING) &#123; // 这里之所以用 个函数包围住，主要是因为多次使用 .then 的时候，后面的 then 拿到的是前一个then 返回的实例，所以会出现，后面的then，无法执行 // 使用函数包裹之后，然后调用 resolve 和reject 保证后续 then 方法能够拿到正确的值 this.rejectCB.push(() =&gt; &#123; try &#123; let val = rej(this.value) reject(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) this.resolveCB.push(() =&gt; &#123; try &#123; let val = res(this.value) resolve(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; if(this.status === PROMISE_FULLFILLED) &#123; try &#123; this.value = res(this.value) resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; if(this.status === PROMISE_REJECTED) &#123; try &#123; this.value = rej(this.value) reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; &#125;) &#125; catch(rej) &#123; return this.then(undefined, rej) &#125; static resolve(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static reject(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static all(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; console.log(item instanceof newPromise) item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; reject(rej) &#125;) &#125; &#125;) &#125; static allSettled(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_REJECTED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;) &#125; &#125;) &#125; static race(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; rej(arr) &#125;) &#125; &#125;) &#125; static any(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; reject(arr) &#125; &#125;) &#125; &#125;) &#125;&#125;// new newPromise((resolve, reject) =&gt; &#123;// setTimeout(() =&gt; &#123;// resolve(1000)// &#125;, 2000);// &#125;).then((res =&gt; &#123;// console.log(res, &quot;res1&quot;)// &#125;)).then(res =&gt; &#123;// console.log(res, &quot;res4&quot;)// &#125;)// new newPromise((resolve, reject) =&gt; &#123;// // resolve(1000)// throw new Error(12345)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res2&quot;)// return res// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res3&quot;)// &#125;).catch(err =&gt; &#123;// console.log(err, &quot;err&quot;)// &#125;)// newPromise.resolve(() =&gt; &#123;// return 10000// &#125;).then(res =&gt; &#123;// console.log(res)// &#125;)// newPromise.all(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.allSettled(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.race(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)Promise.race([new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(3234), 500)&#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(1000), 1000)&#125;)]).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)newPromise.any(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// promise.then((res) =&gt; &#123;// console.log(res)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res&quot;)// throw new Error(&quot;1234&quot;)// &#125;).catch((err) =&gt; &#123;// console.log(err, &quot;1234&quot;)// &#125;)// Promise.resolve(100).then((res) =&gt; &#123;// console.log(res, &quot;promise&quot;)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;promise res&quot;)// &#125;)","pubDate":"Mon, 13 Mar 2023 08:22:04 GMT","guid":"https://lxx1997.github.io/2023/03/13/web/hand-write-promise/","category":"JavaScript"},{"title":"学习目标","link":"https://lxx1997.github.io/2023/03/03/learning-target-list/","description":"2023-03 项目 进度 单元测试 未开始 vue2 未开始 vue3 未开始 react 未开始","pubDate":"Fri, 03 Mar 2023 01:28:36 GMT","guid":"https://lxx1997.github.io/2023/03/03/learning-target-list/","category":"learning"},{"title":"React 多页面应用 - 实现多页面应用每个页面可以单独打包 及 gitlab CI/CD 发版配置","link":"https://lxx1997.github.io/2023/02/23/webpack/react-multiple-page-pack-separately/","description":"书接上回 React 多页面应用 - 路由配置 这次我们来实现一些不一样的需求，这是在日常工作中遇到的 首先我们来描述一下我们想要实现的需求 首先在这个项目中有多个项目（a,b,c,d…）,假如我只改了a项目的代码，按照我们之前的配置，发版的时候会把所有的项目都一起发上去，这样一个问题是会造成资源浪费（CDN 需要重新缓存），另一个问题是如果有修改到公共方法，会对未修改的项目造成影响，这个时候的需求是只发a项目相关的代码，其他项目的代码不会发上去。 接下来我们来看实现这个需求 实现项目单独打包在上一个项目的基础上，我们可以发现多页面打包的基础是在 打包的时候配置的多入口，那么只需要把原来的多入口变成单入口，就可以实现按需打包了 所以在上一个项目的基础上，把 config.entry 和 config.plugins 的内容单独抽离出来，然后在 overrideConfig 方法内动态传入需要打包的组件入口名称，然后根据传入的组件名称动态获取 entry 和 plugins 的内容。具体实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = (paths) =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig([&quot;page1&quot;, &quot;main&quot;])) 通过上述操作，我们可以实现根据传入的项目包的名称进行按需运行及按需打包 但是，这并不是最终的解决方案,我们不可能每次发版或者每次进行开发都要修改这个文件，这个操作太过繁琐，一旦忘了修改，就会发生比较严重的问题，这个时候需要对这个功能进行优化 项目单独打包优化在经过诸多讨论后，最后敲定的优化方案是 本地开发时，运行所有的项目，在进行发版的时候根据 tag 名进行各个项目发版 package.json 文件修改首先在 script 内新增一个命令 set:env，这个命令会在 发版的时候用到，和 tag 一起用来设置发版的项目 12345&#123; &quot;script&quot;: &#123; &quot;set:env&quot;: &quot;REACT_APP_PROJECT=&quot; &#125;&#125; 执行 set:env 时会向 process.env 新增变量 REACT_APP_PROJECT 可以用来判断当前发版项目，可以在项目全局进行访问，这里主要在config-overrides 文件里进行访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = () =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; let paths = [&quot;main&quot;, &quot;page1&quot;, &quot;page2&quot;] // 这里根据设置的变量来判断打包项目，如果没传则全量打包，主要针对本地开发使用 if(process.env.REACT_APP_PROJECT) &#123; paths = [process.env.REACT_APP_PROJECT, &quot;main&quot;] &#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig()) gitlab-ci.yml 文件修改首先需要修改 gitlab-ci 文件内容，使其由原先的通过判断分支来发版，更改为判断 tag 名称发版，tag 需要定一个规则，用于区分正式，测试环境，我这边定义的规则 V-[环境名称]-[version]-[project] 在 gitlab CI/CD 进行发版时，首先需要获取到 tag 名，gitlab-ci 提供了 $CI_COMMIT_REF_NAME 可以访问到 tag 名 123456789test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - echo $&#123;CI_COMMIT_REF_NAME##*-&#125; #获取最后一个 - 后面的内容 修改了上述代码后，当我们打好以 V-T-US- 开头的 tag 后，会自动触发gitlab 的发版流程，执行过程中，会输出 当前tag 名称以及 project 名称。 获取完成之后，就需要根据获取到的工程名称，编写 node 代码，修改 package.json 与发包相关的 代码 首先创建 updatePackage.sh 1234567# updatePackage.shPROJECT_NAME=defaultif [ &quot;$1&quot; ];then PROJECT_NAME=$1fi node ./update.js $PROJECT_NAME ./package.json 在执行 updatePackage.sh 文件的时候，如果传入的有参数，则会 自动复制 PROJECT_NAME 变量，然后通过 node 执行 node 文件，并将传入的内容以及需要修改的文件路径传过去 需要注意的是，这里的路径都是基于执行 updatePackage.sh 的位置来说的，而不是updatePackage.sh 文件的位置 然后创建 update.js 文件，用来读取和修改 package.json 12345678910// update.jsconst fs = require(&#x27;fs&#x27;); // 引入 fs 函数，用来读取文件const arg = process.argv.splice(2); // 获取node 执行文件时传入的参数const r = arg[arg.length - 1] // 获取 node 执行文件时传入的文件地址const c = fs.readFileSync(r);const json = JSON.parse(c);const set_env = json.scripts[&#x27;set:env&#x27;]const build_env = json.scripts[&#x27;build:test&#x27;]json.scripts[&quot;build:test&quot;] = set_env + arg[0] + &quot; &quot; + build_env // 修改 package.json 的打包命令fs.writeFileSync(r, JSON.stringify(json, null, 2)); 修改 gitlab-ci.yml 文件 执行 updatePackage.sh 文件 12345678910test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName 执行完上述命令后，gitlab 发版服务上拉取到的tag 代码，就会自动修改package.json 的内容，然后执行 打包命令的时候就会按照我们想要的发版的内容进行发版 扩展 如果有预渲染页面的，也可以同 updatePackage.sh 文件来动态的修改需要预渲染的页面，修改 gitlab-ci.yml 文件来更新对应文件 1234567891011test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName - aws s3 cp build/$&#123;projectName&#125;.html s3://bucket_path/$&#123;projectName&#125;.html # 上传对应文件到服务器 参考文章 在gitLab-CI-YML中獲取package.json的值 添加自定義環境變量 脚本实现版本号自动更新，不传参加1","pubDate":"Thu, 23 Feb 2023 07:30:48 GMT","guid":"https://lxx1997.github.io/2023/02/23/webpack/react-multiple-page-pack-separately/","category":"webpack,react,gitlab"},{"title":"React 多页面应用 - 路由配置","link":"https://lxx1997.github.io/2023/02/20/webpack/react-multiple-page-router/","description":"项目地址 创建项目1create-react-app react-multiple-page-router 打包环境配置1yarn add customize-cra react-app-rewired -D 修改 package.json 1234567891011121314151617// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;&#125;,// 更换为&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-app-rewired eject&quot;&#125;, 添加 config-overrides.js 12345const &#123; override &#125; = require(&quot;customize-cra&quot;);const overrideConfig = () =&gt; (config) =&gt; &#123; return config&#125;module.exports = override(overrideConfig()) 多页面配置在 src 目录下新建 pages 文件夹用来存放多页面入口 在 pages 目录下新建 pages1, pages2 目录，并创建入口文件 引入 HtmlWebpackPlugin 组件 1yarn add html-webpack-plugin -D 修改 config.overrides.js 配置多页面打包 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const overrideConfig = () =&gt; (config) =&gt; &#123; config.entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot; &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push( new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;) ) return config&#125;module.exports = override(overrideConfig()) 路由配置引入 react-router-dom 1yarn add react-router-dom -D 在 pages1,pages2 页面添加路由组件 123456789101112131415161718192021// page1/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718// page1/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import Test from &#x27;../../components/Test&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/test&quot;&#125;&gt;Test&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/test&quot; element=&#123;&lt;Test /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718192021// page2/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718192021// page2/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import About from &#x27;../../components/About&#x27;;import Home from &#x27;../../components/Home&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/home&quot;&#125;&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&#123;&quot;/about&quot;&#125;&gt;About&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 这样就可以切换路由了 存在问题 路由跳转后，刷新页面后，可能会无法定位到对应的路由","pubDate":"Mon, 20 Feb 2023 02:41:26 GMT","guid":"https://lxx1997.github.io/2023/02/20/webpack/react-multiple-page-router/","category":"webpack,react"},{"title":"window.postMessage跨域的使用方式","link":"https://lxx1997.github.io/2023/02/14/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","description":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","pubDate":"Tue, 14 Feb 2023 02:55:18 GMT","guid":"https://lxx1997.github.io/2023/02/14/web/window-postMessage%E8%B7%A8%E5%9F%9F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","category":"JavaScript"},{"title":"window.IntersectionObserver","link":"https://lxx1997.github.io/2023/02/14/web/window-IntersectionObserver/","description":"window.IntersectionObserverIntersectionObserver 提供了一种异步观察观察目标元素与其祖先元素或者顶级文档交叉状态的方法，即目标元素元素出现或者隐藏的时候就会触发 使用1var observe = new IntersectionObserver(callback， options) callback 回调函数，当我们监听的元素触发到阈值的时候会触发回调函数，callback 会有两个参数 entries 和 observer， entries 是一个数组返回触发监听的目标元素 options root root 属性是目标元素的祖先元素，如果未传入值则默认使用顶级文档视窗 rootMarign 计算交叉时添加到root边界和的矩形偏移量，所有偏移量均可用像素或者百分比 主要作用是缩小或者扩大根元素的判定范围 thresholds 一个包含阈值的列表，按照升序排列，列表中每个阈值都是监听对象的交叉区域与边界区域的比率，当监听对象的任何阈值被越过时，都会生成一个通知，如果未传入值，则默认为0 例如 [0, 0.25, 0.5, 0.75, 1]表示当目标对应比例在目标元素可见时，触发回调函数 方法 disconnect 停止监听工作 observe 添加监听目标元素并进行监听 takeRecords 返回所有观察目标的 intersectionObserverEntry 对象数组 unobserve 停止监听特定目标元素 IntersectionObserverEntry12345678910111213141516171819&#123; time: 3893.92, // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target: element // 被观察的目标元素，是一个 DOM 节点对象 rootBounds: ClientRect &#123; // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // 目标元素的矩形区域的信息 // ... &#125;, intersectionRect: ClientRect &#123; // 目标元素与视口（或根元素）的交叉区域的信息 // ... &#125;, intersectionRatio: 0.54, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0&#125; 使用 IntersectionObserver1234567891011121314151617// 创建 IntersectionObserver 实例var observe = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;, &#123; root: document.getElementById(&quot;app&quot;), rootMargin: &quot;0px 0px 0px 0px&quot;, thresholds: [0, 0.25, 0.5, 0.75, 1]&#125;)// 添加目标对象observe.observe(element)// 停止监听observe.unobserve(element)// 断开链接observe.disconnect() 我们可以解决什么问题 图片或者资源懒加载问题，使用 IntersectionObserver 可以监听到图片元素是否滚动到页面上，从而可以实现预加载和懒加载 元素曝光统计，我们在实际需求中可能需要统计或者计算元素是否曝光在页面上，然后向后台发送统计事件，这样可以方便产品对页面内容进行调整 其他计算，比如我们可能需要判断某个元素是否出现在页面上，然后再进行特殊的计算，如果这些计算数量较少，我们可以不做任何关注，但是如果页面上存在大量的这样的计算，我们需要实现按需计算，这个时候就可以使用 IntersectionObserver 监听元素是否出现在页面，来进行计算，从而减少浏览器内存消耗，提高用户体验","pubDate":"Tue, 14 Feb 2023 02:54:06 GMT","guid":"https://lxx1997.github.io/2023/02/14/web/window-IntersectionObserver/","category":"JavaScript"},{"title":"一些精品的前端学习网站","link":"https://lxx1997.github.io/2023/02/02/frontend-learning-website/","description":"网站名称 跳转链接 状态 web全栈体系 点击跳转 正在学习中 前端技能图谱 点击跳转 未学习 JavaScript MDN doc 点击跳转 正在学习中 卡颂 React React技术揭秘 点击跳转 正在学习中","pubDate":"Thu, 02 Feb 2023 01:32:37 GMT","guid":"https://lxx1997.github.io/2023/02/02/frontend-learning-website/","category":"web"},{"title":"杂谈 - 短视频对现实生活的影响","link":"https://lxx1997.github.io/2023/01/26/thinking/social/short-video-about-social/","description":"最近这一年左右经常在 b站 刷短视频，也看过多种多样的视频类型，例如分享个人生活，做饭，讲解历史等，也有男女对立，带货，以及虚假新闻等会对人的判断造成影响的短视频。最近突发感想，记录下来 短视频的崛起感兴趣的可以看一下这篇文章短视频行业是怎么火起来的？聊聊中美短视频行业的前世今生 我这边就不过多介绍了 短视频的优缺点这几年涌现出了许多家短视频平台，快手，抖音，西瓜，甚至于许多视频网站也开始向短视频平台进发，例如 b站，也开发出了短视频模式。 优点 短视频一般可能是十几秒到三四分钟不等，视频内容精炼，我们可以完全可以在空闲时间刷两到三个短视频，极大加快了我们获取新知识的速度 短视频更容易吸引人的注意力 缺点 容易沉迷，由于推送算法的影响，刷到的短视频经常都是自己喜欢看的，很容易长时间沉迷进去，从而占据人们大部分的娱乐时间 由于周围人都在刷短视频，人与人之间的交流逐渐减少，虽然之前也有类似的情况，但是短视频的更加显著一些 部分人群无法分辨高质量视频，容易被一些低质量视频或者三观不正的视频带偏，个人思想容易受到影响 为用户基数大，所以信息传递起来更快，这样就会被一部分不怀好意的人影响，传播虚假消息，挑拨社会问题，引发社会上的信任危机 视频比较短，部分内容可能无法完全展示，会造成断章取义的影响 反思 要学会分辨有用的知识和无用的知识 增强自控能力，避免沉迷","pubDate":"Thu, 26 Jan 2023 11:29:40 GMT","guid":"https://lxx1997.github.io/2023/01/26/thinking/social/short-video-about-social/","category":"thinking"},{"title":"Swiper - 一些常用的属性及方法","link":"https://lxx1997.github.io/2023/01/18/thirdPartPlugin/swiper-use-methods/","description":"介绍Swiper - is the free and most modern mobile touch slider with hardware accelerated transitions and amazing native behavior. It is intended to be used in mobile websites, mobile web apps, and mobile native/hybrid apps. Swiper - 是免費且最現代的移動觸摸滑塊，具有硬件加速轉換和驚人的本機行為。它旨在用於移動網站、移動網絡應用程序和移動原生/混合應用程序。 Swiper is not compatible with all platforms, it is a modern touch slider which is focused only on modern apps/platforms to bring the best experience and simplicity. Swiper 並非與所有平台兼容，它是一種現代觸摸滑塊，僅專注於現代應用程序/平台，以帶來最佳體驗和簡單性。 更多细节的使用可以查看官网，有 demo 且所有的api 使用Swiper 应该是最常用的滑块插件了，兼容了 Vue， react， Angular， solid， svelte 等三方框架，里面有很多属性和方法，里面有很多方法我们其实并不会遇到，有些方法很长用到，如果每次去查文档会浪费很多时间，在这里把一些常用的方法记录一下，方便下次查阅 属性 slidesPerView: number 在屏幕内显示多少个组件，组件宽度会平分当前屏幕宽度 slidesPerGroup: number 每次滚动滚动滑块个数 spaceBetween: number 组件之间的距离 initialSlide: number 当前选中 (活跃) 的组件 loop: boolean 是否循环 centeredSlides: boolean 是否居中显示，如果设置为 true 的 在滑动时最开始和最后的组件可以滑动到页面中央 isBeginning: boolean 可以用来判断是否是开头 isEnd: boolean 可以判断是否结尾123456const onSlideChange = (slider: any) =&gt; &#123; if(slider) &#123; setShowStart(!slider.isBeginning) setShowEnd(!slider.isEnd) &#125;&#125; breakpoints 不同屏幕尺寸下的适配，会替换掉原来的属性值 方法 slideTo 跳转到第几个滑块 onSwiper 可以获取 Swiper 实例（vue 和 react 中）","pubDate":"Wed, 18 Jan 2023 06:45:31 GMT","guid":"https://lxx1997.github.io/2023/01/18/thirdPartPlugin/swiper-use-methods/","category":"web,thirdPartPlugin"},{"title":"前端 - 文字换行","link":"https://lxx1997.github.io/2023/01/18/web/font-wrap/","description":"white-sapcewhite-sapce 可以通过 nowrap 或者 wrap 来控制一行文字在超出文本框长度时是否换行 normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 pre-wrap: 保留空白符序列，但是正常地进行换行。 pre-line: 合并空白符序列，但是保留换行符。 inherit: 规定应该从父元素继承 white-space 属性的值。 word-break 可以设置文字换行时是 自动换行还是 强制换行 normal: 只在允许的断字点换行(浏览器保持默认处理) break-word: 在长单词或URL地址内部进行换行 break-all: 强制换行，会打断英文单词 文本超出隐藏123white-space: nowrap;overflow: hidden;text-overflow: hidden; 文本超出显示省略号123white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 多行文本超出显示省略号12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 但是这种操作具有浏览器兼容性问题，在部分浏览器上并不适用，所以还有另一种解决方案，可以通过计算的方式来添加省略号这是代码 12345import clamp from &quot;clamp&quot; // 首先引入jsclamp(domEle, &#123; clamp: 2, splitOnChars: [&quot;。&quot;, &quot;.&quot;, &quot;-&quot;, &quot;–&quot;, &quot;—&quot;, &quot; &quot;]&#125;) 通过以上操作，会将domEle 里面的文本超出两行时会显示省略号，如果遇到一行无法完整显示的词，会根据splitOnChars 里面的参数判断是否需要将单词拆开换行 也可以通过修改 clamp 参数来控制显示行数","pubDate":"Wed, 18 Jan 2023 01:38:33 GMT","guid":"https://lxx1997.github.io/2023/01/18/web/font-wrap/","category":"web"},{"title":"杂谈 - 从一个前端的角度来看什么才是一个合格的产品","link":"https://lxx1997.github.io/2023/01/13/thinking/code/working-process-problems/","description":"产品经理（PM）也称产品企划，是指在公司中针对某一项或是某一类的产品进行规划和管理的人员，主要负责产品的研发、制造、营销、渠道等工作。产品经理是很难定义的一个角色，如果非要一句话定义，那么产品经理是为终端用户服务，负责产品整个生命周期的人。 但是事实上，部分产品并不专业，主要体现在以下几个方面 需求方面。产品主要负责编写需求文档以及原型图，方便UI,测试，开发等了解需求详细内容，但是实际上大部分产品并不会编写需求文档，可能只会有原型图，而且原型图并不完善，很多细节都没有标注，还有就是没有考虑到对程序其他功能之间的影响以及不同端之间的影响，而作为一个开发人员或者测试人员，本身无法从全局方面来分析需求，即使向产品提出遗漏的部分，但是也会有遗漏的地方，这些遗漏的地方，运气好的话可能会在开发以及测试阶段被查找出来，但是更多的时候则是会被用户发现。 任务排期。如果是一个做自营产品的公司，产品经理除了自己需要进行迭代的任务外，还需要收集市场部分，老板的需求，以及现场用户遇到的问题。然后根据任务的紧急度进行排期，而不是任务提出来了就要立即更改，打乱了原本正常的迭代流程。 但是实际上部分产品经理根本不会过滤需求，也不会根据需求的紧急度进行排期，经常是来了一个任务后，如果优先级比较高的话，可能会暂停当前迭代，开发新的需求，但是优先级不高的需求则会被插入当前迭代任务内，而且基本上不会给你增加时间，这就导致了开发和测试需要经常加班才能按时完成任务。 而且我还遇到更加蛇皮的操作，有了新需求后，直接和我说要加个什么需求，然后我加完之后，需要进行测试了，发现测试人员根本就不知道有这个需求；有时候也会遇到我都已经将所有需求都提测了，在测试阶段又给我提出了新的需求。 需求评审产品经理需要将当前迭代的内容以及详细的交互逻辑需要给UI，测试，前端，后端等相关人员讲解清楚，针对提出的疑问，要给出合理的解决办法，针对 UI 设计图，需要讲解一下页面的交互逻辑，以及交互动画，特效等，针对一些不合理的 UI 设计，需要进行修改。 但是在实际开发中，可能并不会有这一种流程，经常是产品提出需求，画出原型图后，开发就需要进行拆分任务和预估时间。然后基本上和 UI 同一时间进行开发。这也会造成开发在时间上的滞后。 每个人也不是生来就会的，不会的可以去学，可以从每次的失败中总结教训，下一次争取做的更好，但是有些产品来来回回做了那么多次迭代，流程上还是老样子，这样就不免得让人觉得十分心烦了","pubDate":"Fri, 13 Jan 2023 15:17:09 GMT","guid":"https://lxx1997.github.io/2023/01/13/thinking/code/working-process-problems/","category":"thinking"},{"title":"CANVAS 绘图小技巧 - 绘制一个带有圆角的矩形","link":"https://lxx1997.github.io/2023/01/11/web/canvas-draw-border-radius-rect/","description":"在工作中遇到了这样的一个问题，需要在下载的图片添加一些文字描述，这些文字有一个带有圆角的矩形背景。 主要实现方式是使用 Canvas 的 lineTo 方法和 arcTo 方法通过线条绘制出一个圆角矩形 moveTo(x, y)moveTo 主要是将一个新的子路径的起始点移动到 (x, y) 坐标的方法。 它代表我们绘制的线条的起点 lineTo(x, y)lineTo 主要是从当前绘制线条终点，连接到 (x, y) 坐标，绘制的是一条直线 arcTo(x1, y1, x2, y2, r)arcTo 则是用来绘制圆弧的，将会根据 (x1, y1), (x2, y2) 点的相对位置以点 (x1, y1) 偏移半径 R 的距离画一个圆弧，这个圆弧与 (x1, y1)，(x2, y2) 的连线相切，并从切点连线到(x2,y2), 接下来上代码，可以画出一个 左上角和右下角都是圆角的矩形 12345678910111213141516171819202122const drawRoundRect = (ctx, x, y, w, h, r, color) =&gt; &#123; var min_size = Math.min(w, h); if (r &gt; min_size / 2) r = min_size / 2; // 开始绘制 ctx.save() // 开始绘制 ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w, y) ctx.lineTo(x + w, y + h - r) ctx.arcTo(x + w, y + h, x + w - r, y + h, r) ctx.lineTo(x + w - r, y + h) ctx.lineTo(x, y + h) ctx.arcTo(x, y, x + w, y, r) ctx.closePath(); ctx.fillStyle = color ctx.fill() ctx.restore()&#125;let canvas = document.getElementById(&quot;canvas&quot;)let ctx = canvas.getContext(&quot;2d&quot;)drawRoundRect(ctx, 20, 20, 50, 50, 8, &quot;rgba(0,0,0,0.3)&quot;) 我们只需要传入canvas 的 context 属性以及起始点坐标，以及矩形宽高和圆角半径","pubDate":"Wed, 11 Jan 2023 09:59:18 GMT","guid":"https://lxx1997.github.io/2023/01/11/web/canvas-draw-border-radius-rect/","category":"web,canvas"},{"title":"移动端适配 - IOS 高版本无法下载之 navigator.share 使用","link":"https://lxx1997.github.io/2023/01/01/web/navigator-share-ios-chrome-download/","description":"在生产环境中，leader 发现了这样一个问题，在生产环境中，部分 IOS 用户在使用 chrome 时，无法正常下载，点击下载按钮时，没有反应，图片无法正常存储到用户手机上，经过排查后发现基本存在与 ios 15 版本以上 前因之前我们的网站一直主打的是pc端浏览器的使用，但是现在移动端访问网站的用户，也占有一定比例，为了使这一部分能够正常使用，所以针对移动端浏览器访问的时进行了一定的适配和功能调整，以保证用户正常使用，文件下载采用的 file-saver 的 saveAs 方法来下载文件。在线上环境也正常运行了一年的时间 现象针对 Android 用户基本上都能正常下载，但是针对 IOS 15 版本以上的用户，在使用 chrome 时无法正常下载，在针对竞品进行调研后发现他们使用的是 navigator.share 方法，调用浏览器的分享功能来保证能正常下载 使用 navigator.share在 MDN 上是这样介绍的 Navigator.share() 方法通过调用本机的共享机制作为 Web Share API 的一部分。但是由于这是一个实验性的功能，所以浏览器兼容版本比较高，并不是所有浏览都支持，所以需要做一下兼容，不支持 navigator.share, 就使用之前的下载方法 1const sharePromise = window.navigator.share(data); data 包含要共享的数据的对象。必须至少指定以下字段之一。可用选项包括： url: 要共享的 URL text: 要共享的文本 title: 要共享的标题（标题必传，否则无法正常使用） files: 要共享的文件(注意，这是一个数组) 分享文件之前，先使用 navigator.canShare() 判断这个文件能否被分享 在使用中还需要注意 IOS 版本，我在使用中发现， 15 版本一下的 navigator.canShare() 可以通过，但是 navigator.share 会报错，所以在使用之前还需要做一下判断 完整代码1234567891011121314151617181920212223let userAgent = navigator.userAgent.toLocaleLowerCase()let ios = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)let android = navigator.userAgent.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1let versionArray = userAgent.match(/version\\/([\\d.]+).*mobile/)// 获取当前ios 版本let version = Number(versionArray &amp;&amp; versionArray[1] &amp;&amp; versionArray[1].split(&quot;.&quot;)[0])let options = &#123; title: &quot;hello word&quot;, files: files&#125;if(navigator.canShare &amp;&amp; navigator.canShare(options) &amp;&amp; navigator.share &amp;&amp; (ios &amp;&amp; version &gt;= 15 || android)) &#123; try &#123; navigator.share(options).then(res =&gt; &#123; // 成功之后的其他操作 &#125;).catch(() =&gt; &#123; // 旧版本的下载 &#125;) &#125; catch(error) &#123; // 旧版本的下载 &#125;&#125; else &#123; // 旧版本的下载&#125; 补充一点：navigator.share在不刷新页面的时候只能调用一次，再次调用时 navigator.share 方法会拒绝此操作，所以需要做兼容","pubDate":"Sun, 01 Jan 2023 02:30:26 GMT","guid":"https://lxx1997.github.io/2023/01/01/web/navigator-share-ios-chrome-download/","category":"web,IOS,mobile,MobileAdaptation"},{"title":"基于 electron 实现一个记录用户粘贴历史记录应用程序 之 基础环境搭建","link":"https://lxx1997.github.io/2022/12/15/frame/electron-vue3-vite-ts-copyright/","description":"之前一直使用 utools 工具中的 剪贴板，感觉这个功能十分好用，不用在费劲的去寻找自己之前copy 的记录，十分的方便 但是由于几个月前收费了，本着能白嫖就付钱的心理，所以就没有继续使用了。 最近偶然想要做一下这个功能，也可以学习一个 electron 和 vue3 的新知识 环境搭建可以参考一下这个文章，这里有完整的搭建流程。 但是由于各个电脑的环境以及node， electron 等版本不一样的，所以还是会有一些不同，我只在这里简单的记录一下，并标注一下不同之处 环境 插件 版本 node v16.14.0 yarn v1.22.19 vue v3.2.45 @vitejs/plugin-vue 4.0.0 electron 22.0.0 electron-builder 23.6.0 electron-devtools-installer 3.2.0 rimraf 3.0.2 typescript 4.9.3 vite 4.0.0 vite-plugin-electron 0.10.4 vite-plugin-electron-renderer 0.11.3 vue-tsc 1.0.11 环境搭建初始化 vue3 + vite + ts 环境1yarn create vite todolist --template vue-ts 初始化 electron 环境1yarn add -D electron electron-builder rimraf vite-plugin-electron electron-devtools-installer 插件说明 electron-builder：打包工具 rimraf：快速删除文件或目录工具 vite-plugin-electron：vite 结合 electron 的库，关于这个插件可以参见 Vite 与 Electron 无缝衔接 electron-devtools-installer：electron 开发工具 vite-plugin-electron 插件是将 vite 和 electron 结合在一起的，可以让我们非常方便的结合 electron 和 vue，需要做一些指定的配置。 创建 electron 入口文件 electron.ts 和 预渲染 preload.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// electron.tsconst &#123; app, BrowserWindow, Menu, globalShortcut &#125; = require(&#x27;electron&#x27;);const path = require(&#x27;path&#x27;);const createWindow = () =&gt; &#123; // 隐藏顶部菜单 Menu.setApplicationMenu(null) const win = new BrowserWindow(&#123; webPreferences: &#123; contextIsolation: false, nodeIntegration: true, preload: path.join(__dirname, &#x27;./preload.ts&#x27;), &#125;, &#125;); if (app.isPackaged) &#123; win.loadFile(path.join(__dirname, &#x27;./index.html&#x27;)); &#125; else &#123; // Use [&#x27;ENV_NAME&#x27;] avoid vite:define plugin const url = `http://127.0.0.1:5173/`; win.loadURL(url); // 添加快捷键 globalShortcut.unregisterAll() globalShortcut.register(&#x27;ctrl+q&#x27;, function() &#123; app.quit() &#125;) globalShortcut.register(&#x27;ctrl+shift+i&#x27;, function() &#123; // 添加 devtools win.webContents.openDevTools() &#125;) &#125;&#125;;app.whenReady().then(() =&gt; &#123; createWindow(); app.on(&#x27;activate&#x27;, () =&gt; &#123; // On macOS it&#x27;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (BrowserWindow.getAllWindows().length === 0) createWindow(); &#125;);&#125;);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit(); &#125;&#125;); 1234// electron-preload/index.tsconst os = require(&#x27;os&#x27;);console.log(os.platform()); // 测试打印一下系统平台 配置 electron在 tsconfig.json 中监听 electron 相关文件和提示 这个没有发生变化1&quot;include&quot;: [..., &quot;electron-main/**/*.ts&quot;, &quot;electron-preload/**/*.ts&quot;],vite.config.ts 变化比较明显，首先 electronRenderer 引入插件变成了 vite-plugin-electron-renderer,其次是初始化的时候 electron 传入实例对象有变化123456789101112131415161718192021// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import * as path from &#x27;path&#x27;;import electron from &#x27;vite-plugin-electron&#x27;;import electronRenderer from &#x27;vite-plugin-electron-renderer&#x27;;export default defineConfig(&#123; plugins: [ vue(), electron(&#123; entry: &#123; main: &#x27;./electron.ts&#x27;, &#125;, &#125;), electronRenderer(), ], build: &#123; emptyOutDir: false, // 必须配置，否则electron相关文件将不会生成build后的文件 &#125;,&#125;); 配置打包命令1234// package.json&quot;script&quot;: &#123; &quot;build-electron&quot;: &quot;rimraf dist &amp;&amp; vite build &amp;&amp; electron-builder&quot;&#125; 其实在执行完上述内容后，基本上就可以正常运行和打包了","pubDate":"Thu, 15 Dec 2022 01:59:59 GMT","guid":"https://lxx1997.github.io/2022/12/15/frame/electron-vue3-vite-ts-copyright/","category":"vite,TypeScript,web,electron,vue3"},{"title":"TypeScript 高级类型","link":"https://lxx1997.github.io/2022/12/06/web/typescript-advanced-type/","description":"TypeScript 有许多高级类型，方便系统更好判断代码是否存在不合理的点，也更方便用户来排查错误和编写代码，下面介绍一些常用的高级类型，这些高级类型在日常开发中可能没有机会用到，但是了解一下对我们并没有任务坏处 交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性 相当于混入（mixin）,在新的类型中，可以拥有合并的所有类型中的成员 使用 &amp; 来表示交叉 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());var n = jim.name;jim.log(); 通过上述例子,我们利用泛型创建一个 extend 方法用来合并两个对象，通过交叉符号 &amp; 判断函数返回类型是传入类型的合并类型 这样我们在访问 extend 返回的对象时，如果获取到不存在的属性，就会贴心的为我们提示错误 联合类型联合类型与交叉类型很有关联，但是使用上却完全不同. 交叉类型 是将多个类型合并成一个新的类型 联合类型 是满足多个类型中的一个，这些类型可以是基础类型(string, number …) 也可以是用户定义的类或者接口","pubDate":"Tue, 06 Dec 2022 06:39:19 GMT","guid":"https://lxx1997.github.io/2022/12/06/web/typescript-advanced-type/","category":"TypeScript"},{"title":"css 选择器","link":"https://lxx1997.github.io/2022/12/02/web/css-selector/","description":"选择器 例子 例子描述 .class .intro 选择 class=”intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id=”firstname” 的元素。 * * 选择所有元素。 element p 选择所有 &lt;p&gt; 元素。 element.class p.intro 选择 class=”intro” 的所有 &lt;p&gt; 元素。 element,element div, p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。 element&gt;element div &gt; p 选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。 element+element div + p 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。 element1~element2 p ~ ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 [attribute] [target] 选择带有 target 属性的所有元素。 [attribute=value] [target=_blank] 选择带有 target=&quot;_blank&quot; 属性的所有元素。 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute =value] [lang =en] 选择 lang 属性值以 “en” 开头的所有元素。 [attribute^=value] a[href^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 [attribute$=value] a[href$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 [attribute=value] a[href=”w3schools”] 选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 &lt;p&gt; 的内容之后插入内容。 ::before p::before 在每个 &lt;p&gt; 的内容之前插入内容。 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :default input:default 选择默认的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个被禁用的 &lt;input&gt; 元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :focus input:focus 选择获得焦点的 input 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 input 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 input 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。","pubDate":"Fri, 02 Dec 2022 07:23:57 GMT","guid":"https://lxx1997.github.io/2022/12/02/web/css-selector/","category":"web"},{"title":"hexo 常用命令语句","link":"https://lxx1997.github.io/2022/12/02/extend/hexo-common-commands/","description":"创建一个博客到指定文件夹1hexo new page --path [folder-path]/[blog-name] create leetcode 练习（专用）1npx hexo new page --path handredday/leetcode/day-101-2283","pubDate":"Fri, 02 Dec 2022 02:46:41 GMT","guid":"https://lxx1997.github.io/2022/12/02/extend/hexo-common-commands/","category":"extends"},{"title":"web - H5 移动端适配问题","link":"https://lxx1997.github.io/2022/11/23/web/mobile-web-adaptation-problems/","description":"IOS 移动端适配唤起键盘输入时，页面底部的输入框无法浮动到键盘上方参考文章 这个出现的原因主要是 IOS 和 Andriod 的 适配不同 Andriod 的情况比较好理解。软键盘弹出后，实际webview被挤压了，变短了，相当于浏览器变小了，变成 原本高度 - 软键盘高 IOS 发布了 8.2 版本之后，与androids的不同，软键盘弹出，并不是挤压webview，webview的高度不会发生变化，而软键盘更像是一个悬浮在weview上的东西，并不会影响webview的实际高度，是“盖”上去的。这样就造成了我们目前所看到的情况，输入框被键盘遮挡，无法看到用户输入的内容 所以可以看到，我们在IOS上聚焦某个输入框，是会自动让页面发生滚动，以展示聚焦的输入框，此时页面的滚动，实际上是webview自身发生了移动。 这里可以采用的方法有两种 第一种是用户聚焦于输入框的时候，设置window 或者页面区域主动向上方滚动一定距离（例如软键盘高度），当用户失去焦点时，在滚动回原来的位置 第二种是改变 输入框所在元素的高度，使得输入框能够正常显示出来，当用户失去焦点时，在还原回原来的高度 12345678910111213141516171819const handleBlur = (e: any) =&gt; &#123; // 获取浏览器类型 let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123; element.style.height = &quot;100%&quot; &#125;, 100) &#125;&#125;const handleFocus = (e: any) =&gt; &#123; let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123;//设置一个计时器，时间设置与软键盘弹出所需时间相近 element.style.height = (window.innerHeight - 330) + &quot;px&quot; &#125;, 100) &#125;i IOS Safari 浏览器 canvas 写入图片过大，会造成页面重复刷新 参考文章 您的網頁在桌面上表現良好並不能保證它在 iOS 上也能表現良好。請記住，iOS 使用 EDGE（低帶寬、高延遲）、3G（高帶寬、高延遲）和 Wi-Fi（高帶寬、低延遲）連接到互聯網。因此，您需要最小化網頁的大小。在您的網頁中包含未使用或不必要的圖像、CSS 和 JavaScript 會對您的網站在 iOS 上的性能產生不利影響。 由於 iOS 上的可用內存，它可以處理的資源數量有限制： 解碼後的 GIF、PNG 和 TIFF 圖像的最大尺寸對於內存小於 256 MB 的設備是 3 兆像素，對於內存大於或等於 256 MB 的設備是 5 兆像素。也就是說，確保 width * height ≤ 3 * 1024 * 1024 適用於 RAM 小於 256 MB 的設備。請注意，解碼後的尺寸遠大於圖像的編碼尺寸。 使用子採樣時，JPEG 的最大解碼圖像大小為 32 兆像素。由於二次採樣，JPEG 圖像可以高達 32 兆像素，這允許 JPEG 圖像解碼為像素數的十六分之一的大小。大於 2 兆像素的 JPEG 圖像被二次採樣，即解碼為縮小的尺寸。JPEG 子採樣允許用戶查看來自最新數碼相機的圖像。 對於內存小於 256 MB 的設備，畫布元素的最大尺寸為 3 兆像素，對於內存大於或等於 256 MB 的設備，畫布元素的最大尺寸為 5 兆像素。如果未指定，畫布對象的高度和寬度為 150 x 300 像素。 每個頂級入口點的 JavaScript 執行時間限制為 10 秒。如果您的腳本執行時間超過 10 秒，iOS 上的 Safari 會在您代碼中的隨機位置停止執行腳本，因此可能會導致意外後果。施加此限制是因為 JavaScript 執行可能會導致主線程阻塞，因此當腳本運行時，用戶無法與網頁進行交互。閱讀“在 iOS 上調試 Web 內容”了解如何在 iOS 上調試 JavaScript。 一次可以打開的最大文檔數在iPhone 上是八個，在iPad 上是九個。 Andriod 移动端适配共用的适配方式在滚动的元素内部 有 pisition: fixed; 元素，点击到改元素，无法进行滑动在 IOS 可以采用在 pisition: fixed; 元素外包一层 pisition: sticky; div，可以实现 其他的话要触发浏览器默认的滚动（window，document.body）而非 元素的 overflow 属性才可以滑动","pubDate":"Wed, 23 Nov 2022 08:09:03 GMT","guid":"https://lxx1997.github.io/2022/11/23/web/mobile-web-adaptation-problems/","category":"web,IOS,mobile,MobileAdaptation"}]}