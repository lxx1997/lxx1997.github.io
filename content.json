{"meta":{"title":"SoulReader","subtitle":"勤劳刻苦","description":"前端小菜鸟,努力深造","author":"lxx","url":"https://lxx1997.github.io"},"posts":[{"title":"个人整理的比较全的知识 - 方便自己回顾","path":"2023/04/04/interview/面试题-01/","text":"HTML新增的 h5 属性 标签类 header,footer,aside,nav,article 媒体播放标签 audio,video canvas svg 等 存储属性 localStorage,sessionStorage input 标签新增type 属性 email,password,file,tel,date,url 等 CSSBFC 块级格式化上下文是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 特性： 块级元素会在垂直方向一个接一个排列 避免子元素的margin 属性影响父元素 保证子元素的属性只在BFC盒内起作用，不会影响盒外的其他元素 如果子元素有 float 或者 触发方式： float: left/right position: absolute/fixed overflow: hidden/hidden-x/hidden-y display: inline-block/flex/gid 如何解决高度塌陷 :after { clear: both;} 或者在父元素内部最后新增一个元素设置 style clear: both; 设置 position: absolute overflow: hidden 元素水平垂直居中的方法 display: flex; align-items: center;justify-content: space-around; position:absolute; top:50%;left:50%;transform: translate(-50%, -50%) display: grid; align-items: center;justify-content: space-around; margin-top:50%;margin-left:50%;transform: translate(-50%, -50%) 定高的话可以使用 margin-left偏移自身一般宽度和高度 flex 布局有哪些属性 flex-direction 布局方向 row/row-reverse/column/column-reverse flex-wrap 是否换行 flex-flow flex-direction 和 flex-wrap 的简写模式 justify-content 主轴上的对齐方式 flex-start/flex-end/space-around/space-between/space-evenly/center align-items: 交叉轴 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch align-content 多根轴线对齐 flex-start/flex-end/space-around/space-between/space-evenly/center 子元素属性 order 定义项目排列顺序，数值越大越靠后 flex 设置 flex-grow/flex-shrik/flex-basic 的缩写 flex-grow 是否放大 默认为0 flex-shrink 是否缩小 默认为1 flex-basic 占据主轴空间 align-self 单独设置子元素的对齐方式,可以使部分子元素与其他子元素对齐方式不同 flex-start/flex-end/center/base-line(以第一行文字基线对齐)/stretch css 选择器优先级css 选择器有以下几种 ID 选择器 id=&quot;abc&quot; 类（class）选择器 class=&quot;abc&quot; 标签选择器 div 标签属性选择器 div[title=&quot;abc&quot;] 伪类和伪元素 after,before,selection,focus,hover,active, 父子选择器 div &gt; p 其中 ID 选择器的权重最高，接着是类选择器，最后是标签选择器 JavaScript数据类型基础数据类型有 Number String Boolean Null Undefined Symbol Bigint (新增的，因为是为了兼容大数) 引用数据 Object 如何判断数据类型 typeof 需要注意的是 typeof null = object, typeof func() {} = function instanceof 原理是根据原型链来查找的 Object.prototype.toString.call() 会返回对应元素类型 [object Object/Array/RegExp/...] 闭包闭包是一个函数及其捆绑的周边环境状态的引用的组合，闭包可以使开发者从内部函数访问外部函数的作用域。 可以用来实现函数柯里化（将多个参数转变成单个参数传入func(a,b,c) =&gt; func(a)(b)(c)） 可以用来模拟私有方法，因为闭包内部的部分变量和方法，函数外部无法访问 闭包还可以用来解决变量提升的问题。 使用闭包需要注意内存泄露问题，因为这些作用域不会随着函数的执行而清除掉 原型链javascript对象上有一个属性，可以通过这个属性查找到她的原型，而且原型上也有这个属性，可以一级一级的向上查找 1234567891011let obj = new Object()obj.prototype === undefinedobj.__proto__ === Object.prototypeObject.prototype.__proto__ === nullfunction func () &#123;&#125;let f = new func()f.__proto__ === func.prototypefunc.prototype.__proto__ === Object.prototype 当我们在查找一个对象的属性的时候，如果当前对象不存在这个属性，则会沿着原型链一级一级的向上查找，直查找到最后一级，也就是 Object 对象上 需要注意的是在原型链上查找比较耗时和消耗性能，如果层级比较深的话，可以选择暂存下来 原型链上的属性和方法最好不要随意修改，否则可能会影响其他继承于该原型的函数 this 指向 直接执行 this 指向 window 1234567891011function func() &#123;&#125;func() // windowconst obj = &#123; func: function() &#123; &#125;&#125;let f1 = obj.funcf1() // window 挂载到对象上执行 this指向当前对象 123456const obj = &#123; func: function() &#123; &#125;&#125;obj.func() // obj new使用new 的时候会执行以下几个操作 创建一个新的空对象 将当前空对象的 prototype 指向当前函数的 prototype 将前端对象替换当前函数的执行上下文（this） 判断函数是否存在返回值，返回值如果是基础数据类型，则this 还是 创建的空对象，否则是return 的对象 call，bind，applycall 和 apply 会立即执行函数，同时将函数的this 指向传入的thisbind 不会立刻执行，而且参数可以不用一次性传入 call(this, …args) bind(this, …args) apply(this, args) 事件循环 (Event Loop) 宏任务（setTimeout，setInterval，script，ajax） 微任务（Promise.then, requestAnimationFrame， process.nextTic, Object.observer, MutationObserver(监察dom节点变化)） 同步任务 正常js解析，js代码执行等 函数的执行顺序是 如果存在同步任务，会先执行同步任务 同步任务执行完成后，先查找微任务队列中是否包含任务，如果包含需要执行的任务，会立即执行 微任务队列执行完成之后才会去判断宏任务中是否存在需要执行的任务，宏任务每次执行的时候都需要判断微任务队列中是否包含需要执行的任务 Promise Promise.resolve() 返回一个以给定值解析后的 Promise 对象 Promise.reject() 返回一个带有拒绝原因的 Promise 对象。 Promise.then() 返回一个 Promise 对象，有两个回调函数，一个成功的回调，一个失败情况的回调 Promise.catch() 返回一个 Promise 对象，只有一个失败情况的回调 Promise.finally() 无论成功和失败都会执行 Promise.all() 当所有的 Promise 成功后才回返回成功，结果按顺序返回，有一个失败就返回失败 Promise.race() 只要有一个 Promise 成功或者失败，就是返回一个成功或者失败的结果 Promise.allSettled() 当所有的 Promise 的结果都获取到才返回，不管成功还是失败 Promise.any() 只要有一个 Promise 成功就会返回成功的结果，全部失败才会返回失败的结果 手写一个 Promise 方法 Proxy/RflectProxy 对象用于创建一个对象的代理，实现对基本操作的拦截 类似于 Object.defineProperties,但是比她的功能更强大 123456789101112131415let obj = &#123; a: 1&#125;let o = new Proxy(obj, &#123; set: function(obj, key, value) &#123; console.log(obj, key, value) &#125;, get: function(obj, key, value) &#123; console.log(obj, key, value) return obj[key] &#125;,&#125;)obj.a = 20o.ao.a = 30 需要注意的是，只有通过代理后的对象修改和获取属性时，才会触发代理，原对象修改和删除并不会触发 handler 配置属性 get 属性读取操作 set 属性设置操作 has in操作符 deleteProperty delete 操作符 ownKeys Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。 apply 函数调用时触发 construct 使用 new 操作符触发 getPrototypeOf 获取原型对象扑捉器 Object.getPrototypeOf setPrototypeOf 设置原型对象扑捉器 Object.setPrototypeOf isExensible Object.isExtensible 方法的捕捉器 是否是可扩展的 preventExtensible Object.preventExtensions 方法的捕捉器。设置对象不可扩展 getOwnPropertyDescriptor 获取对象的属性描述（value,configurable,writable,get,set,enumerable） defineProperty Object.defineProperty 方法的捕捉器。 Reflect 方法同理，主要用来对 Proxy 对应属性的映射 浏览器垃圾回收 引用计数引用计数的原理当创建和引用对象时，都会给该对象的引用次数加1，当给变量重新赋值或者执行的上下文清除时，引用次数 -1，当引用次数为0的时候，会被清除的。 缺点是当出现循环引用的时候，由于引用计数一直不为0，所以无法被清除 标记清除当变量进入执行环境时，会标记状态为进入，当弹出执行环境时，会标记状态为清除，标记状态为清除的会自动被js引擎清除 缺点是容易造成内存碎片化 标记整理法同标记清除，会在清除后重新整理内存地址 垃圾回收优化将内存分为 新生代和老生代，新生代缓存的是存活时间比较短的地址，老生代缓存的是存活时间久的地址 同时新生代又分为使用区和空闲区（双缓存），在进行清除时，会将使用区的变量的标记进行判断，如果被标记，则放到空闲区内，并且进行内存整理，最后将使用区的内存清空，并将使用区变成空闲区，空闲区变成使用区，并重复上述操作 内存泄露 循环引用 闭包 没有终止的 setInterval 性能优化最全的页面性能优化 输入一个链接地址到显示到页面上具体经过了那些步骤 浏览器首先会根据输入的网址，进行 DNS 域名解析找到对应服务器的ip地址 建立连接 （TCP/IP 协议）三次握手 客户端向服务端发送SYN 服务器恢复 SYN-ACK,最后客户端发送 ACK 报文 发送请求（请求头，请求体）到服务器，服务器会根据传入的地址，找到对应的文件返回到客户端 客户端下载文件后，会解析文件，将标签和样式通过对应的parse 转化为 dom 树和 CSSOM 树 如果在解析的过程中遇到 script 标签，如果script 标签没有引用外部文件，则会停止文件解析，等待 script 内部代码执行完成后才会继续解析，如果引入了外部文件，则会根据 defer 属性和 async 属性，来判断是否延迟加载 js文件。 将生成的 DOM 树和 CSSOM 树合并形成渲染树，进行布局计算，将计算结果会渲染屏幕上 渲染时涉及到图层的概念（position，translae3d，will-change, transform）,启动GPU加速，将所有图层最后组合到页面上正成最终结果 浏览器缓存 cache-control max-age 最大缓存时间 no-store 浏览器不会进行缓存，也不会进行协商缓存 no-cache 浏览器进行协商缓存通过 ETag/If-Match 和 last-modified public 可以被任何缓存例如共有缓存（CDN）和私有缓存（浏览器） private 仅可被私有缓存（浏览器）缓存 强缓存：强缓存主要是向浏览器缓存区获取文件，并且根据文件是否失效（max-age/exproes）来判断是否需要重新重服务器拿取文件 协商缓存：当强缓存失效时，会走协商缓存，协商缓存不会直接从浏览器缓存中拿取数据，而是直接向服务器发送请求，服务器根据 ETag 和 last-Modified 参数和服务器文件进行对比，如果发生变更，则代表文件已修改，返回给客户端最新的文件，如果没有变更再去读取本地缓存的文件 缓存类型 server-work （sw.js）走的是server-work 的缓存逻辑 memory cache 存在内存中，如果关闭tab页缓存会失效 disk cache 存在磁盘缓存中 重绘和重排(回流) 重绘 是指元素自身属性发生变化时，并不会影响其他元素位置和属性变化，例如：color，opciaty，backgound等 重排是指元素本身的物理尺寸发生变化时，引起页面重新排列，列如修改宽，高，外边距，内边距，边框，添加和删除元素，display: none等 如何避免频繁触发重绘和重排 如果涉及到频繁修改样式，可以采用统一修改的方式，例如，添加 class 或者 cssText 设置 position: absolute 脱离文档流 这是 transform 和 will-change 属性，启动 gpu加速 修改元素时批量修改 设置 display: none;修改完成后在显示出来 使用文档片段 （document.createDocumentFragment()） 创建一个熄灯节点，用来更新内容，更新换成后替换旧节点 获取以下属性和方法时，页面会被强制更新，因为这些属性需要根据页面上元素的最新状态进行更新offsetTop、offsetLeft、offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightgetComputedStyle()getBoundingClientRect HTTP1/HTTP2Vue2常用指令 v-if v-else v-else-if v-show v-for v-html v-text v-bind v-on v-model v-once v-slot 插件 常用修饰符 number .lazy v-model 监听change 而非 input keyup/keydown trim prevent/stop 阻止默认事件 once 只执行一次 right/left 鼠标左右键点击触发 camel 将属性转驼峰 生命周期beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestorydestoryederrorCaptured 错误监听activited keep-alivedeactivited keep-alive 组件通讯 父子组件通讯 props provide/inject $emit $parent/$children $ref event bus 兄弟组件 通过父组件传值 $parent event bus 不相关组件 event bus Vuex Vue 组件之间通讯的各种情况 computed 和 watch computed 计算属性，计算后的结果值会被缓存下来，如果相关联的属性没有发生变化时，会取缓存后的结果 watch 监听属性，当属性发生变化时，会重新执行监听函数，针对对象可以使用 immediate 和 deep 来启动立即监听和深度监听 在日常使用中更推介使用computed 属性，因为会对得到的结果进行缓存，减少计算量 diff 算法当组件创建和更新时，vue会执行内部的update函数，该函数使用render函数生成的虚拟dom树，将新旧两树进行对比，找到差异点，最终更新到真实dom 对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程 在对比时，vue采用深度优先、同级比较的方式进行比对。同级比较就是说它不会跨越结构进行比较 在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的 具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组；如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。 在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置。 这样一直递归的遍历下去，直到整棵树完成对比。 请阐述vue的diff算法 Vue diff 算法双指针逻辑总结 新创建的 子节点数组 和 旧的子节点数组分别有一个 头节点指针和尾结点指针。 针对旧节点的两个指针，如果新节点的两个指针有匹配到的，则将该指针所对应的 Vnode 转移到对应的位置（头对头，尾队尾），对应头结点和尾结点的位置进行变化（头结点后移，尾结点前移） 知道头尾节点均不符合匹配时，这样就筛选出来两类节点，一种是旧子节点数组上需要删除的子节点，一种是新的子节点上需要新增的子节点。 这样做的目的是最大可能性的复用已有的真实dom节点，对于新增的，需要创建新的 dom节点。 MVVM 框架MVVM 是指双向数据流，即 View-Model 之间的双向通信，由 ViewModel 作桥接 Mvvm 前端数据流框架精讲 v-for 和 v-ifv-for 的优先级比v-if 的优先级要高，页面会首先根据 v-for 渲染列表，然后在根据 v-if 来判断列表元素是否显示和隐藏，因此会造成性能浪费 因此推荐使用 computed 属性，提前过滤需要隐藏后的数据后，在使用 v-for 进行渲染 v-show 和 v-ifv-show 会进行dom 树的构建，但是 display 属性为 none v-if 不会进行组件渲染，自然也不会构建 dom 树，对性能有优化 v-for 循环时 key的作用是什么进行diff 算法时，方便进行对比组件是否更新，以及组件复用 $nextTick 原理主要是利用了 javascript 引擎的时间循环机制，是的 $nextTick 传入的参数在同步事件之后触发，可以拿到 修改后的dom和 data 里面的值 使用 Promise.then,setImediate, setTimeout, mutationObserve 来实现 Vue 是如何监听属性变化的使用 Object.defineProperty 来监听属性的变化，重写get，set 方法，当 data 为什么要用一个函数的模式是因为组件是可以重复使用的，如果data 不用一个函数模式的话，可以会造成数据混乱，无法获取到想要的数据 Vuex 有几个模块 module state mutations actions getters Vuex 提供了 mapGetters，mapState，mapActions 等方法，方便我们快速获取Vuex 的值 Vue-router 有几个模式设置 router 的 mode 属性，默认为 hash 模式，设置 history 后，为history模式 hash模式在网址后面以 # 模式 history 模式直接跟在网址后面 Vue 项目如何优化 路由懒加载 () =&gt; import(“”) 组件懒加载 () =&gt; import(“”) v-if 和 v-for 避免一起使用，可以用计算属性过滤部分数据 针对经常显示隐藏的页面结构，可以使用 v-show，否则应使用 v-if 等等 Vue3React生命周期挂载阶段 constructor componentWillMount（新版 getDerivedtateFromProps） render componentDidMount 更新阶段 componentWillReceiveProps （getDerivedtateFromProps）） shouldComponentUpdate componentWillUpdate （null） render （getSnapshotBeforeUpdate） componentDidUpdate 卸载阶段 componentWillUnmount 为什么新版的react 的生命周期要加上 UNSAFE_ 前缀 这个是因为这个函数不安全，原因是因为 react 16 以后 react 支持 fiber 切片后，组件会根据执行优先级来进行编译和渲染，因此可能会出现一个组件正在执行更新或者创建操作时，有一个优先级更高的任务插进来，这个时候，当前任务会被暂停掉，更换优先级更高的任务执行操作，操作完成后，才会回到之前的操作，继续执行，这个时候，部分生命周期有可能会执行两次，造成数据混乱 diff 算法React技术揭秘-卡颂React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中n是树中元素的数量 React diff 算法做了以下优化 只进行同级比较，如果一个节点在更新前后层级不一样，则不会进行比较 不同类型的子元素是一个新的树，旧的树会被直接销毁，新的树会被创建 可以通过key 值来判断那些子元素保持稳定 react 在进行 diff 算法时，会首先针对 节点的 类型，key进行对比，如果都一样，在对比传入的 props，state 等属性是否有变化，有变化执行更新操作，没有变化就直接复用，不过不一样，则会创建一个新的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 之前abcd// 之后dabc===第一轮遍历开始===d（之后）vs a（之前） key改变，不能复用，跳出遍历===第一轮遍历结束======第二轮遍历开始===newChildren === dabc，没用完，不需要执行删除旧节点oldFiber === abcd，没用完，不需要执行插入新节点将剩余oldFiber（abcd）保存为map继续遍历剩余newChildren// 当前oldFiber：abcd// 当前newChildren dabckey === d 在 oldFiber中存在const oldIndex = d（之前）.index;此时 oldIndex === 3; // 之前节点为 abcd，所以d.index === 3比较 oldIndex 与 lastPlacedIndex;oldIndex 3 &gt; lastPlacedIndex 0则 lastPlacedIndex = 3;d节点位置不变继续遍历剩余newChildren// 当前oldFiber：abc// 当前newChildren abckey === a 在 oldFiber中存在const oldIndex = a（之前）.index; // 之前节点为 abcd，所以a.index === 0此时 oldIndex === 0;比较 oldIndex 与 lastPlacedIndex;oldIndex 0 &lt; lastPlacedIndex 3则 a节点需要向右移动继续遍历剩余newChildren// 当前oldFiber：bc// 当前newChildren bckey === b 在 oldFiber中存在const oldIndex = b（之前）.index; // 之前节点为 abcd，所以b.index === 1此时 oldIndex === 1;比较 oldIndex 与 lastPlacedIndex;oldIndex 1 &lt; lastPlacedIndex 3则 b节点需要向右移动继续遍历剩余newChildren// 当前oldFiber：c// 当前newChildren ckey === c 在 oldFiber中存在const oldIndex = c（之前）.index; // 之前节点为 abcd，所以c.index === 2此时 oldIndex === 2;比较 oldIndex 与 lastPlacedIndex;oldIndex 2 &lt; lastPlacedIndex 3则 c节点需要向右移动===第二轮遍历结束=== fiber 分片常用 hooks useState useEffect useLayoutEffect useRef useMemo 缓存 useCallback 缓存 useContext useReducer useImperativeHandle/forwardRef useImperativeHandle 可以将子组件中部分函数暴露给父组件的 ref使用 组件通讯 mobx/redux 等状态管理工具 props ref/useImperativeHandle 发布订阅模式 React 如何监听数据变化主要是通过 setState，useState，forceUpdate，会生成一个 Update 对象，会和原属性的值进行对比，如果发生改变，则会触发更新 WebpackOther","updated":"2023-04-04T09:15:19.000Z","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://lxx1997.github.io/tags/interview/"},{"name":"promise","slug":"promise","permalink":"https://lxx1997.github.io/tags/promise/"}]},{"title":"JavaScript - 手写一个 Promise 方法","path":"2023/03/13/web/hand-write-promise/","text":"手动实现 promise, 下面hi全部的代码,写了差不多有两个小时，并且附上示例 之前也有一版，不过我觉得这一版更好理解一些123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294// this code for create a new promiseconst PROMISE_PADDING = &quot;padding&quot;const PROMISE_FULLFILLED = &quot;fullfilled&quot;const PROMISE_REJECTED = &quot;rejected&quot;class newPromise &#123; constructor(func) &#123; this.status = PROMISE_PADDING this.value = undefined this.resolveCB = [] this.rejectCB = [] const resolve = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_FULLFILLED this.resolveCB &amp;&amp; this.resolveCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; const reject = (val) =&gt; &#123; if(this.status !== PROMISE_PADDING) &#123; return &#125; this.value = val this.status = PROMISE_REJECTED this.rejectCB &amp;&amp; this.rejectCB.map(fn =&gt; &#123; this.value = fn(this.value) &#125;) &#125; try &#123; func(resolve, reject) &#125; catch (error) &#123; reject(error.message) &#125; &#125; then(res, rej) &#123; res = typeof res !== &quot;function&quot; ? (val) =&gt; val : res rej = typeof rej !== &quot;function&quot; ? (val) =&gt; val : rej return new newPromise((resolve, reject) =&gt; &#123; if(this.status === PROMISE_PADDING) &#123; // 这里之所以用 个函数包围住，主要是因为多次使用 .then 的时候，后面的 then 拿到的是前一个then 返回的实例，所以会出现，后面的then，无法执行 // 使用函数包裹之后，然后调用 resolve 和reject 保证后续 then 方法能够拿到正确的值 this.rejectCB.push(() =&gt; &#123; try &#123; let val = rej(this.value) reject(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) this.resolveCB.push(() =&gt; &#123; try &#123; let val = res(this.value) resolve(val) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; if(this.status === PROMISE_FULLFILLED) &#123; try &#123; this.value = res(this.value) resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; if(this.status === PROMISE_REJECTED) &#123; try &#123; this.value = rej(this.value) reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125; &#125;) &#125; catch(rej) &#123; return this.then(undefined, rej) &#125; static resolve(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() resolve(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static reject(fn) &#123; fn = typeof fn !== &quot;function&quot; ? (val) =&gt; val : fn if(fn instanceof newPromise) &#123; return fn &#125; return new newPromise((resolve, reject) =&gt; &#123; try &#123; this.value = fn() reject(this.value) &#125; catch (error) &#123; reject(error.message) &#125; &#125;) &#125; static all(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; console.log(item instanceof newPromise) item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; reject(rej) &#125;) &#125; &#125;) &#125; static allSettled(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: res &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_REJECTED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; resolve(arr) &#125; &#125;) &#125; &#125;) &#125; static race(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; rej(arr) &#125;) &#125; &#125;) &#125; static any(...args) &#123; return new newPromise((resolve, reject) =&gt; &#123; let arr = [] if(args.length === 0) &#123; resolve([]) return &#125; for(let i = 0; i &lt; args.length; i++) &#123; let item = args[i] if(!(item instanceof newPromise)) &#123; item = newPromise.resolve(item) &#125; item.then(res =&gt; &#123; resolve(res) &#125;, rej =&gt; &#123; arr[i] = &#123; status: PROMISE_FULLFILLED, value: rej &#125; if(arr.every(item =&gt; item) &amp;&amp; arr.length === args.length) &#123; reject(arr) &#125; &#125;) &#125; &#125;) &#125;&#125;// new newPromise((resolve, reject) =&gt; &#123;// setTimeout(() =&gt; &#123;// resolve(1000)// &#125;, 2000);// &#125;).then((res =&gt; &#123;// console.log(res, &quot;res1&quot;)// &#125;)).then(res =&gt; &#123;// console.log(res, &quot;res4&quot;)// &#125;)// new newPromise((resolve, reject) =&gt; &#123;// // resolve(1000)// throw new Error(12345)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res2&quot;)// return res// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res3&quot;)// &#125;).catch(err =&gt; &#123;// console.log(err, &quot;err&quot;)// &#125;)// newPromise.resolve(() =&gt; &#123;// return 10000// &#125;).then(res =&gt; &#123;// console.log(res)// &#125;)// newPromise.all(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.allSettled(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)// newPromise.race(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123;// console.log(res)// &#125;, err =&gt; &#123;// console.log(err)// &#125;)Promise.race([new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; reject(3234), 500)&#125;), new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; resolve(1000), 1000)&#125;)]).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)newPromise.any(() =&gt; &#123;throw new Error(123)&#125;,() =&gt; 234, new newPromise((resolve) =&gt; setTimeout(() =&gt; resolve(1000), 1000))).then(res =&gt; &#123; console.log(res)&#125;, err =&gt; &#123; console.log(err)&#125;)// promise.then((res) =&gt; &#123;// console.log(res)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;res&quot;)// throw new Error(&quot;1234&quot;)// &#125;).catch((err) =&gt; &#123;// console.log(err, &quot;1234&quot;)// &#125;)// Promise.resolve(100).then((res) =&gt; &#123;// console.log(res, &quot;promise&quot;)// &#125;).then(res =&gt; &#123;// console.log(res, &quot;promise res&quot;)// &#125;)","updated":"2023-03-13T08:22:04.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"学习目标","path":"2023/03/03/learning-target-list/","text":"2023-03 项目 进度 单元测试 未开始 vue2 未开始 vue3 未开始 react 未开始","updated":"2023-03-03T01:28:36.000Z","categories":[{"name":"learning","slug":"learning","permalink":"https://lxx1997.github.io/categories/learning/"}],"tags":[{"name":"learning","slug":"learning","permalink":"https://lxx1997.github.io/tags/learning/"}]},{"title":"React 多页面应用 - 实现多页面应用每个页面可以单独打包 及 gitlab CI/CD 发版配置","path":"2023/02/23/webpack/react-multiple-page-pack-separately/","text":"书接上回 React 多页面应用 - 路由配置 这次我们来实现一些不一样的需求，这是在日常工作中遇到的 首先我们来描述一下我们想要实现的需求 首先在这个项目中有多个项目（a,b,c,d…）,假如我只改了a项目的代码，按照我们之前的配置，发版的时候会把所有的项目都一起发上去，这样一个问题是会造成资源浪费（CDN 需要重新缓存），另一个问题是如果有修改到公共方法，会对未修改的项目造成影响，这个时候的需求是只发a项目相关的代码，其他项目的代码不会发上去。 接下来我们来看实现这个需求 实现项目单独打包在上一个项目的基础上，我们可以发现多页面打包的基础是在 打包的时候配置的多入口，那么只需要把原来的多入口变成单入口，就可以实现按需打包了 所以在上一个项目的基础上，把 config.entry 和 config.plugins 的内容单独抽离出来，然后在 overrideConfig 方法内动态传入需要打包的组件入口名称，然后根据传入的组件名称动态获取 entry 和 plugins 的内容。具体实现代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = (paths) =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig([&quot;page1&quot;, &quot;main&quot;])) 通过上述操作，我们可以实现根据传入的项目包的名称进行按需运行及按需打包 但是，这并不是最终的解决方案,我们不可能每次发版或者每次进行开发都要修改这个文件，这个操作太过繁琐，一旦忘了修改，就会发生比较严重的问题，这个时候需要对这个功能进行优化 项目单独打包优化在经过诸多讨论后，最后敲定的优化方案是 本地开发时，运行所有的项目，在进行发版的时候根据 tag 名进行各个项目发版 package.json 文件修改首先在 script 内新增一个命令 set:env，这个命令会在 发版的时候用到，和 tag 一起用来设置发版的项目 12345&#123; &quot;script&quot;: &#123; &quot;set:env&quot;: &quot;REACT_APP_PROJECT=&quot; &#125;&#125; 执行 set:env 时会向 process.env 新增变量 REACT_APP_PROJECT 可以用来判断当前发版项目，可以在项目全局进行访问，这里主要在config-overrides 文件里进行访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869// config-overrides.jsconst &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot;&#125;const computedPluginList = (types) =&gt; &#123; let pluginList = [] for(let i = 0; i &lt; types.length; i++) &#123; switch (types[i]) &#123; case &quot;main&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;)) break; case &quot;page1&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;)) break; case &quot;page2&quot;: pluginList.push(new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;)) break; default: break; &#125; &#125; return pluginList&#125;const overrideConfig = () =&gt; (config) =&gt; &#123; const innerEntry = &#123;&#125; let paths = [&quot;main&quot;, &quot;page1&quot;, &quot;page2&quot;] // 这里根据设置的变量来判断打包项目，如果没传则全量打包，主要针对本地开发使用 if(process.env.REACT_APP_PROJECT) &#123; paths = [process.env.REACT_APP_PROJECT, &quot;main&quot;] &#125; if(paths) &#123; for(let i = 0; i &lt; paths.length; i++) &#123; innerEntry[paths[i]] = entry[paths[i]] &#125; &#125; else &#123; innerEntry.entry = entry &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push(...computedPluginList(paths)) return config&#125;module.exports = override(overrideConfig()) gitlab-ci.yml 文件修改首先需要修改 gitlab-ci 文件内容，使其由原先的通过判断分支来发版，更改为判断 tag 名称发版，tag 需要定一个规则，用于区分正式，测试环境，我这边定义的规则 V-[环境名称]-[version]-[project] 在 gitlab CI/CD 进行发版时，首先需要获取到 tag 名，gitlab-ci 提供了 $CI_COMMIT_REF_NAME 可以访问到 tag 名 123456789test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - echo $&#123;CI_COMMIT_REF_NAME##*-&#125; #获取最后一个 - 后面的内容 修改了上述代码后，当我们打好以 V-T-US- 开头的 tag 后，会自动触发gitlab 的发版流程，执行过程中，会输出 当前tag 名称以及 project 名称。 获取完成之后，就需要根据获取到的工程名称，编写 node 代码，修改 package.json 与发包相关的 代码 首先创建 updatePackage.sh 1234567# updatePackage.shPROJECT_NAME=defaultif [ &quot;$1&quot; ];then PROJECT_NAME=$1fi node ./update.js $PROJECT_NAME ./package.json 在执行 updatePackage.sh 文件的时候，如果传入的有参数，则会 自动复制 PROJECT_NAME 变量，然后通过 node 执行 node 文件，并将传入的内容以及需要修改的文件路径传过去 需要注意的是，这里的路径都是基于执行 updatePackage.sh 的位置来说的，而不是updatePackage.sh 文件的位置 然后创建 update.js 文件，用来读取和修改 package.json 12345678910// update.jsconst fs = require(&#x27;fs&#x27;); // 引入 fs 函数，用来读取文件const arg = process.argv.splice(2); // 获取node 执行文件时传入的参数const r = arg[arg.length - 1] // 获取 node 执行文件时传入的文件地址const c = fs.readFileSync(r);const json = JSON.parse(c);const set_env = json.scripts[&#x27;set:env&#x27;]const build_env = json.scripts[&#x27;build:test&#x27;]json.scripts[&quot;build:test&quot;] = set_env + arg[0] + &quot; &quot; + build_env // 修改 package.json 的打包命令fs.writeFileSync(r, JSON.stringify(json, null, 2)); 修改 gitlab-ci.yml 文件 执行 updatePackage.sh 文件 12345678910test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName 执行完上述命令后，gitlab 发版服务上拉取到的tag 代码，就会自动修改package.json 的内容，然后执行 打包命令的时候就会按照我们想要的发版的内容进行发版 扩展 如果有预渲染页面的，也可以同 updatePackage.sh 文件来动态的修改需要预渲染的页面，修改 gitlab-ci.yml 文件来更新对应文件 1234567891011test:sync-to-s3: only: # tags # 测试环境 - /V-T-US-.*/ script: # build - echo $&#123;CI_COMMIT_REF_NAME&#125; - projectName=$&#123;CI_COMMIT_REF_NAME##*-&#125; #设置变量 projectName - sh ./script/updatePackage.sh $projectName - aws s3 cp build/$&#123;projectName&#125;.html s3://bucket_path/$&#123;projectName&#125;.html # 上传对应文件到服务器 参考文章 在gitLab-CI-YML中獲取package.json的值 添加自定義環境變量 脚本实现版本号自动更新，不传参加1","updated":"2023-02-23T07:30:48.000Z","categories":[{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/categories/webpack/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/categories/react/"},{"name":"gitlab","slug":"gitlab","permalink":"https://lxx1997.github.io/categories/gitlab/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/tags/webpack/"},{"name":"gitlab","slug":"gitlab","permalink":"https://lxx1997.github.io/tags/gitlab/"}]},{"title":"React 多页面应用 - 路由配置","path":"2023/02/20/webpack/react-multiple-page-router/","text":"项目地址 创建项目1create-react-app react-multiple-page-router 打包环境配置1yarn add customize-cra react-app-rewired -D 修改 package.json 1234567891011121314151617// package.json&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;&#125;,// 更换为&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-app-rewired eject&quot;&#125;, 添加 config.overrides.js 12345const &#123; override &#125; = require(&quot;customize-cra&quot;);const overrideConfig = () =&gt; (config) =&gt; &#123; return config&#125;module.exports = override(overrideConfig()) 多页面配置在 src 目录下新建 pages 文件夹用来存放多页面入口 在 pages 目录下新建 pages1, pages2 目录，并创建入口文件 引入 HtmlWebpackPlugin 组件 1yarn add html-webpack-plugin -D 修改 config.overrides.js 配置多页面打包 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; override &#125; = require(&quot;customize-cra&quot;);const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)const overrideConfig = () =&gt; (config) =&gt; &#123; config.entry = &#123; main: &quot;./src/index.js&quot;, page1: &quot;./src/pages/page1/index.js&quot;, page2: &quot;./src/pages/page2/index.js&quot; &#125; config.output = &#123; filename: &quot;[name].[fullhash].js&quot;, path: __dirname + &#x27;/dist&#x27;, &#125; config.plugins.push( new htmlWebpackPlugin(&#123; title: &quot;main&quot;, template: &quot;./public/index.html&quot;, filename: &quot;main.html&quot;, chunks: [&quot;main&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page1&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page1.html&quot;, chunks: [&quot;page1&quot;] &#125;), new htmlWebpackPlugin(&#123; title: &quot;Page2&quot;, template: &quot;./public/index.html&quot;, filename: &quot;page2.html&quot;, chunks: [&quot;page2&quot;] &#125;) ) return config&#125;module.exports = override(overrideConfig()) 路由配置引入 react-router-dom 1yarn add react-router-dom -D 在 pages1,pages2 页面添加路由组件 123456789101112131415161718192021// page1/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718// page1/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import Test from &#x27;../../components/Test&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/test&quot;&#125;&gt;Test&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/test&quot; element=&#123;&lt;Test /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 123456789101112131415161718192021// page2/index.jsximport React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom/client&#x27;;import &#123; BrowserRouter &#125; from &#x27;react-router-dom&#x27;;import &#x27;./index.css&#x27;;import App from &#x27;./App&#x27;;import reportWebVitals from &#x27;../../reportWebVitals&#x27;;const root = ReactDOM.createRoot(document.getElementById(&#x27;root&#x27;));root.render( &lt;React.StrictMode&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/React.StrictMode&gt;);// If you want to start measuring performance in your app, pass a function// to log results (for example: reportWebVitals(console.log))// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitalsreportWebVitals(); 123456789101112131415161718192021// page2/App.jsximport &#x27;./App.css&#x27;;import &#123; Routes, Route, NavLink &#125; from &quot;react-router-dom&quot;import About from &#x27;../../components/About&#x27;;import Home from &#x27;../../components/Home&#x27;;function App() &#123; return ( &lt;div className=&quot;App&quot;&gt; &lt;h1&gt;Page2&lt;/h1&gt; &lt;NavLink to=&#123;&quot;/home&quot;&#125;&gt;Home&lt;/NavLink&gt; &lt;NavLink to=&#123;&quot;/about&quot;&#125;&gt;About&lt;/NavLink&gt; &lt;Routes&gt; &lt;Route path=&quot;/home&quot; element=&#123;&lt;Home /&gt;&#125; /&gt; &lt;Route path=&quot;/about&quot; element=&#123;&lt;About /&gt;&#125; /&gt; &lt;/Routes&gt; &lt;/div&gt; );&#125;export default App; 这样就可以切换路由了 存在问题 路由跳转后，刷新页面后，可能会无法定位到对应的路由","updated":"2023-02-21T02:41:26.000Z","categories":[{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/categories/webpack/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/categories/react/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/tags/webpack/"}]},{"title":"window.postMessage跨域的使用方式","path":"2023/02/14/web/window-postMessage跨域的使用方式/","text":"最近忙着工作的事情，好久没有更新博客了，正好最近要做的一个功能，最后决定使用 postMessage 进行解决 具体的使用场景是我这边打开新的窗口的时候需要向新的窗口传递一些数据 首先从网上摘取一些针对 postMessage 介绍 window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机 (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。 父窗口如何传递参数打开窗口的方式有一下几种 iframe的contentWindow属性、执行window.open返回的窗口对象、或者是命名过或数值索引的window.frames,此处暂时先介绍 window.open() 父窗口获取打开新窗口对象 1const open = window.open(&#x27;http://www.baidu.com&#x27;, &quot;_blank&quot;) postMessage 有三个参数1open.postMessage(message, targetOrigin, [transfer]); message 是传递的数据 一般来说是一个对象用来传递当前postMessage类型，以及要传递的数据，因为可以通过 postMessage 多次传递，但是调用的事件监听方法都是同一个，所以最好要加一个状态进行区分 targetOrigin 代表接受域名， 可以是 &quot;*&quot; 代表所有域名都可以，也可以是一个url，代表特定域名可以接受 transfer 是一串和message 同时传递的 Transferable 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 postMessage 在使用的时候需要在需要接收数据的窗口中定义一个事件监听函数 message, 注意这个方法需要挂载到 ·indow 上面, 我最开始给挂载到 document, 结果怎么都触发不了，尴尬 postMessage 传递的 message 数据在 回调函数参数的 data上 123window.addEventListener(&#x27;message&#x27;, (res) =&gt; &#123; console.log(res)&#125;) 子窗口获取父窗口 window.opener 方法 message 回到函数参数的 resource 属性，返回父窗口的引用 问题 使用window.open 打开新窗口会被拦截？ 12const open = window.open(&#x27;about:blank&#x27;)open.location.href = &quot;http://www.baidu.com&quot;","updated":"2023-02-14T02:55:18.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"window.IntersectionObserver","path":"2023/02/14/web/window-IntersectionObserver/","text":"window.IntersectionObserverIntersectionObserver 提供了一种异步观察观察目标元素与其祖先元素或者顶级文档交叉状态的方法，即目标元素元素出现或者隐藏的时候就会触发 使用1var observe = new IntersectionObserver(callback， options) callback 回调函数，当我们监听的元素触发到阈值的时候会触发回调函数，callback 会有两个参数 entries 和 observer， entries 是一个数组返回触发监听的目标元素 options root root 属性是目标元素的祖先元素，如果未传入值则默认使用顶级文档视窗 rootMarign 计算交叉时添加到root边界和的矩形偏移量，所有偏移量均可用像素或者百分比 主要作用是缩小或者扩大根元素的判定范围 thresholds 一个包含阈值的列表，按照升序排列，列表中每个阈值都是监听对象的交叉区域与边界区域的比率，当监听对象的任何阈值被越过时，都会生成一个通知，如果未传入值，则默认为0 例如 [0, 0.25, 0.5, 0.75, 1]表示当目标对应比例在目标元素可见时，触发回调函数 方法 disconnect 停止监听工作 observe 添加监听目标元素并进行监听 takeRecords 返回所有观察目标的 intersectionObserverEntry 对象数组 unobserve 停止监听特定目标元素 IntersectionObserverEntry12345678910111213141516171819&#123; time: 3893.92, // 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒 target: element // 被观察的目标元素，是一个 DOM 节点对象 rootBounds: ClientRect &#123; // 根元素的矩形区域的信息，getBoundingClientRect()方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回null bottom: 920, height: 1024, left: 0, right: 1024, top: 0, width: 920 &#125;, boundingClientRect: ClientRect &#123; // 目标元素的矩形区域的信息 // ... &#125;, intersectionRect: ClientRect &#123; // 目标元素与视口（或根元素）的交叉区域的信息 // ... &#125;, intersectionRatio: 0.54, // 目标元素的可见比例，即intersectionRect占boundingClientRect的比例，完全可见时为1，完全不可见时小于等于0&#125; 使用 IntersectionObserver1234567891011121314151617// 创建 IntersectionObserver 实例var observe = new IntersectionObserver((entries) =&gt; &#123; console.log(entries)&#125;, &#123; root: document.getElementById(&quot;app&quot;), rootMargin: &quot;0px 0px 0px 0px&quot;, thresholds: [0, 0.25, 0.5, 0.75, 1]&#125;)// 添加目标对象observe.observe(element)// 停止监听observe.unobserve(element)// 断开链接observe.disconnect() 我们可以解决什么问题 图片或者资源懒加载问题，使用 IntersectionObserver 可以监听到图片元素是否滚动到页面上，从而可以实现预加载和懒加载 元素曝光统计，我们在实际需求中可能需要统计或者计算元素是否曝光在页面上，然后向后台发送统计事件，这样可以方便产品对页面内容进行调整 其他计算，比如我们可能需要判断某个元素是否出现在页面上，然后再进行特殊的计算，如果这些计算数量较少，我们可以不做任何关注，但是如果页面上存在大量的这样的计算，我们需要实现按需计算，这个时候就可以使用 IntersectionObserver 监听元素是否出现在页面，来进行计算，从而减少浏览器内存消耗，提高用户体验","updated":"2023-02-14T02:55:18.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"一些精品的前端学习网站","path":"2023/02/02/frontend-learning-website/","text":"网站名称 跳转链接 状态 web全栈体系 点击跳转 正在学习中 前端技能图谱 点击跳转 未学习 JavaScript MDN doc 点击跳转 正在学习中 卡颂 React React技术揭秘 点击跳转 正在学习中","updated":"2023-02-02T01:32:37.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"nextJs","slug":"nextJs","permalink":"https://lxx1997.github.io/tags/nextJs/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"杂谈 - 短视频对现实生活的影响","path":"2023/01/26/thinking/social/short-video-about-social/","text":"最近这一年左右经常在 b站 刷短视频，也看过多种多样的视频类型，例如分享个人生活，做饭，讲解历史等，也有男女对立，带货，以及虚假新闻等会对人的判断造成影响的短视频。最近突发感想，记录下来 短视频的崛起感兴趣的可以看一下这篇文章短视频行业是怎么火起来的？聊聊中美短视频行业的前世今生 我这边就不过多介绍了 短视频的优缺点这几年涌现出了许多家短视频平台，快手，抖音，西瓜，甚至于许多视频网站也开始向短视频平台进发，例如 b站，也开发出了短视频模式。 优点 短视频一般可能是十几秒到三四分钟不等，视频内容精炼，我们可以完全可以在空闲时间刷两到三个短视频，极大加快了我们获取新知识的速度 短视频更容易吸引人的注意力 缺点 容易沉迷，由于推送算法的影响，刷到的短视频经常都是自己喜欢看的，很容易长时间沉迷进去，从而占据人们大部分的娱乐时间 由于周围人都在刷短视频，人与人之间的交流逐渐减少，虽然之前也有类似的情况，但是短视频的更加显著一些 部分人群无法分辨高质量视频，容易被一些低质量视频或者三观不正的视频带偏，个人思想容易受到影响 为用户基数大，所以信息传递起来更快，这样就会被一部分不怀好意的人影响，传播虚假消息，挑拨社会问题，引发社会上的信任危机 视频比较短，部分内容可能无法完全展示，会造成断章取义的影响 反思 要学会分辨有用的知识和无用的知识 增强自控能力，避免沉迷","updated":"2023-01-26T11:29:40.000Z","categories":[{"name":"thinking","slug":"thinking","permalink":"https://lxx1997.github.io/categories/thinking/"}],"tags":[{"name":"thinking","slug":"thinking","permalink":"https://lxx1997.github.io/tags/thinking/"}]},{"title":"Swiper - 一些常用的属性及方法","path":"2023/01/18/thirdPartPlugin/swiper-use-methods/","text":"介绍Swiper - is the free and most modern mobile touch slider with hardware accelerated transitions and amazing native behavior. It is intended to be used in mobile websites, mobile web apps, and mobile native/hybrid apps. Swiper - 是免費且最現代的移動觸摸滑塊，具有硬件加速轉換和驚人的本機行為。它旨在用於移動網站、移動網絡應用程序和移動原生/混合應用程序。 Swiper is not compatible with all platforms, it is a modern touch slider which is focused only on modern apps/platforms to bring the best experience and simplicity. Swiper 並非與所有平台兼容，它是一種現代觸摸滑塊，僅專注於現代應用程序/平台，以帶來最佳體驗和簡單性。 更多细节的使用可以查看官网，有 demo 且所有的api 使用Swiper 应该是最常用的滑块插件了，兼容了 Vue， react， Angular， solid， svelte 等三方框架，里面有很多属性和方法，里面有很多方法我们其实并不会遇到，有些方法很长用到，如果每次去查文档会浪费很多时间，在这里把一些常用的方法记录一下，方便下次查阅 属性 slidesPerView: number 在屏幕内显示多少个组件，组件宽度会平分当前屏幕宽度 slidesPerGroup: number 每次滚动滚动滑块个数 spaceBetween: number 组件之间的距离 initialSlide: number 当前选中 (活跃) 的组件 loop: boolean 是否循环 centeredSlides: boolean 是否居中显示，如果设置为 true 的 在滑动时最开始和最后的组件可以滑动到页面中央 isBeginning: boolean 可以用来判断是否是开头 isEnd: boolean 可以判断是否结尾123456const onSlideChange = (slider: any) =&gt; &#123; if(slider) &#123; setShowStart(!slider.isBeginning) setShowEnd(!slider.isEnd) &#125;&#125; breakpoints 不同屏幕尺寸下的适配，会替换掉原来的属性值 方法 slideTo 跳转到第几个滑块 onSwiper 可以获取 Swiper 实例（vue 和 react 中）","updated":"2023-02-01T09:45:31.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"},{"name":"thirdPartPlugin","slug":"thirdPartPlugin","permalink":"https://lxx1997.github.io/categories/thirdPartPlugin/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"},{"name":"thirdPartPlugin","slug":"thirdPartPlugin","permalink":"https://lxx1997.github.io/tags/thirdPartPlugin/"}]},{"title":"前端 - 文字换行","path":"2023/01/18/web/font-wrap/","text":"white-sapcewhite-sapce 可以通过 nowrap 或者 wrap 来控制一行文字在超出文本框长度时是否换行 normal: 默认。空白会被浏览器忽略。 pre: 空白会被浏览器保留。其行为方式类似 HTML 中的 pre 标签。 nowrap: 文本不会换行，文本会在在同一行上继续，直到遇到 br 标签为止。 pre-wrap: 保留空白符序列，但是正常地进行换行。 pre-line: 合并空白符序列，但是保留换行符。 inherit: 规定应该从父元素继承 white-space 属性的值。 word-break 可以设置文字换行时是 自动换行还是 强制换行 normal: 只在允许的断字点换行(浏览器保持默认处理) break-word: 在长单词或URL地址内部进行换行 break-all: 强制换行，会打断英文单词 文本超出隐藏123white-space: nowrap;overflow: hidden;text-overflow: hidden; 文本超出显示省略号123white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 多行文本超出显示省略号12345overflow : hidden;text-overflow: ellipsis;display: -webkit-box;-webkit-line-clamp: 2;-webkit-box-orient: vertical; 但是这种操作具有浏览器兼容性问题，在部分浏览器上并不适用，所以还有另一种解决方案，可以通过计算的方式来添加省略号这是代码 12345import clamp from &quot;clamp&quot; // 首先引入jsclamp(domEle, &#123; clamp: 2, splitOnChars: [&quot;。&quot;, &quot;.&quot;, &quot;-&quot;, &quot;–&quot;, &quot;—&quot;, &quot; &quot;]&#125;) 通过以上操作，会将domEle 里面的文本超出两行时会显示省略号，如果遇到一行无法完整显示的词，会根据splitOnChars 里面的参数判断是否需要将单词拆开换行 也可以通过修改 clamp 参数来控制显示行数","updated":"2023-01-18T01:38:33.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"https://lxx1997.github.io/tags/css/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"杂谈 - 从一个前端的角度来看什么才是一个合格的产品","path":"2023/01/13/thinking/code/working-process-problems/","text":"产品经理（PM）也称产品企划，是指在公司中针对某一项或是某一类的产品进行规划和管理的人员，主要负责产品的研发、制造、营销、渠道等工作。产品经理是很难定义的一个角色，如果非要一句话定义，那么产品经理是为终端用户服务，负责产品整个生命周期的人。 但是事实上，部分产品并不专业，主要体现在以下几个方面 需求方面。产品主要负责编写需求文档以及原型图，方便UI,测试，开发等了解需求详细内容，但是实际上大部分产品并不会编写需求文档，可能只会有原型图，而且原型图并不完善，很多细节都没有标注，还有就是没有考虑到对程序其他功能之间的影响以及不同端之间的影响，而作为一个开发人员或者测试人员，本身无法从全局方面来分析需求，即使向产品提出遗漏的部分，但是也会有遗漏的地方，这些遗漏的地方，运气好的话可能会在开发以及测试阶段被查找出来，但是更多的时候则是会被用户发现。 任务排期。如果是一个做自营产品的公司，产品经理除了自己需要进行迭代的任务外，还需要收集市场部分，老板的需求，以及现场用户遇到的问题。然后根据任务的紧急度进行排期，而不是任务提出来了就要立即更改，打乱了原本正常的迭代流程。 但是实际上部分产品经理根本不会过滤需求，也不会根据需求的紧急度进行排期，经常是来了一个任务后，如果优先级比较高的话，可能会暂停当前迭代，开发新的需求，但是优先级不高的需求则会被插入当前迭代任务内，而且基本上不会给你增加时间，这就导致了开发和测试需要经常加班才能按时完成任务。 而且我还遇到更加蛇皮的操作，有了新需求后，直接和我说要加个什么需求，然后我加完之后，需要进行测试了，发现测试人员根本就不知道有这个需求；有时候也会遇到我都已经将所有需求都提测了，在测试阶段又给我提出了新的需求。 需求评审产品经理需要将当前迭代的内容以及详细的交互逻辑需要给UI，测试，前端，后端等相关人员讲解清楚，针对提出的疑问，要给出合理的解决办法，针对 UI 设计图，需要讲解一下页面的交互逻辑，以及交互动画，特效等，针对一些不合理的 UI 设计，需要进行修改。 但是在实际开发中，可能并不会有这一种流程，经常是产品提出需求，画出原型图后，开发就需要进行拆分任务和预估时间。然后基本上和 UI 同一时间进行开发。这也会造成开发在时间上的滞后。 每个人也不是生来就会的，不会的可以去学，可以从每次的失败中总结教训，下一次争取做的更好，但是有些产品来来回回做了那么多次迭代，流程上还是老样子，这样就不免得让人觉得十分心烦了","updated":"2023-01-14T15:17:09.000Z","categories":[{"name":"thinking","slug":"thinking","permalink":"https://lxx1997.github.io/categories/thinking/"}],"tags":[{"name":"thinking","slug":"thinking","permalink":"https://lxx1997.github.io/tags/thinking/"}]},{"title":"CANVAS 绘图小技巧 - 绘制一个带有圆角的矩形","path":"2023/01/11/web/canvas-draw-border-radius-rect/","text":"在工作中遇到了这样的一个问题，需要在下载的图片添加一些文字描述，这些文字有一个带有圆角的矩形背景。 主要实现方式是使用 Canvas 的 lineTo 方法和 arcTo 方法通过线条绘制出一个圆角矩形 moveTo(x, y)moveTo 主要是将一个新的子路径的起始点移动到 (x, y) 坐标的方法。 它代表我们绘制的线条的起点 lineTo(x, y)lineTo 主要是从当前绘制线条终点，连接到 (x, y) 坐标，绘制的是一条直线 arcTo(x1, y1, x2, y2, r)arcTo 则是用来绘制圆弧的，将会根据 (x1, y1), (x2, y2) 点的相对位置以点 (x1, y1) 偏移半径 R 的距离画一个圆弧，这个圆弧与 (x1, y1)，(x2, y2) 的连线相切，并从切点连线到(x2,y2), 接下来上代码，可以画出一个 左上角和右下角都是圆角的矩形 12345678910111213141516171819202122const drawRoundRect = (ctx, x, y, w, h, r, color) =&gt; &#123; var min_size = Math.min(w, h); if (r &gt; min_size / 2) r = min_size / 2; // 开始绘制 ctx.save() // 开始绘制 ctx.beginPath(); ctx.moveTo(x + r, y); ctx.lineTo(x + w, y) ctx.lineTo(x + w, y + h - r) ctx.arcTo(x + w, y + h, x + w - r, y + h, r) ctx.lineTo(x + w - r, y + h) ctx.lineTo(x, y + h) ctx.arcTo(x, y, x + w, y, r) ctx.closePath(); ctx.fillStyle = color ctx.fill() ctx.restore()&#125;let canvas = document.getElementById(&quot;canvas&quot;)let ctx = canvas.getContext(&quot;2d&quot;)drawRoundRect(ctx, 20, 20, 50, 50, 8, &quot;rgba(0,0,0,0.3)&quot;) 我们只需要传入canvas 的 context 属性以及起始点坐标，以及矩形宽高和圆角半径","updated":"2023-01-11T09:59:18.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"},{"name":"canvas","slug":"canvas","permalink":"https://lxx1997.github.io/categories/canvas/"}],"tags":[{"name":"canvas","slug":"canvas","permalink":"https://lxx1997.github.io/tags/canvas/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"移动端适配 - IOS 高版本无法下载之 navigator.share 使用","path":"2023/01/01/web/navigator-share-ios-chrome-download/","text":"在生产环境中，leader 发现了这样一个问题，在生产环境中，部分 IOS 用户在使用 chrome 时，无法正常下载，点击下载按钮时，没有反应，图片无法正常存储到用户手机上，经过排查后发现基本存在与 ios 15 版本以上 前因之前我们的网站一直主打的是pc端浏览器的使用，但是现在移动端访问网站的用户，也占有一定比例，为了使这一部分能够正常使用，所以针对移动端浏览器访问的时进行了一定的适配和功能调整，以保证用户正常使用，文件下载采用的 file-saver 的 saveAs 方法来下载文件。在线上环境也正常运行了一年的时间 现象针对 Android 用户基本上都能正常下载，但是针对 IOS 15 版本以上的用户，在使用 chrome 时无法正常下载，在针对竞品进行调研后发现他们使用的是 navigator.share 方法，调用浏览器的分享功能来保证能正常下载 使用 navigator.share在 MDN 上是这样介绍的 Navigator.share() 方法通过调用本机的共享机制作为 Web Share API 的一部分。但是由于这是一个实验性的功能，所以浏览器兼容版本比较高，并不是所有浏览都支持，所以需要做一下兼容，不支持 navigator.share, 就使用之前的下载方法 1const sharePromise = window.navigator.share(data); data 包含要共享的数据的对象。必须至少指定以下字段之一。可用选项包括： url: 要共享的 URL text: 要共享的文本 title: 要共享的标题（标题必传，否则无法正常使用） files: 要共享的文件(注意，这是一个数组) 分享文件之前，先使用 navigator.canShare() 判断这个文件能否被分享 在使用中还需要注意 IOS 版本，我在使用中发现， 15 版本一下的 navigator.canShare() 可以通过，但是 navigator.share 会报错，所以在使用之前还需要做一下判断 完整代码1234567891011121314151617181920212223let userAgent = navigator.userAgent.toLocaleLowerCase()let ios = !!navigator.userAgent.match(/\\(i[^;]+;( U;)? CPU.+Mac OS X/)let android = navigator.userAgent.indexOf(&quot;Android&quot;) &gt; -1 || u.indexOf(&quot;Linux&quot;) &gt; -1let versionArray = userAgent.match(/version\\/([\\d.]+).*mobile/)// 获取当前ios 版本let version = Number(versionArray &amp;&amp; versionArray[1] &amp;&amp; versionArray[1].split(&quot;.&quot;)[0])let options = &#123; title: &quot;hello word&quot;, files: files&#125;if(navigator.canShare &amp;&amp; navigator.canShare(options) &amp;&amp; navigator.share &amp;&amp; (ios &amp;&amp; version &gt;= 15 || android)) &#123; try &#123; navigator.share(options).then(res =&gt; &#123; // 成功之后的其他操作 &#125;).catch(() =&gt; &#123; // 旧版本的下载 &#125;) &#125; catch(error) &#123; // 旧版本的下载 &#125;&#125; else &#123; // 旧版本的下载&#125; 补充一点：navigator.share在不刷新页面的时候只能调用一次，再次调用时 navigator.share 方法会拒绝此操作，所以需要做兼容","updated":"2023-01-01T02:30:26.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"},{"name":"IOS","slug":"IOS","permalink":"https://lxx1997.github.io/categories/IOS/"},{"name":"mobile","slug":"mobile","permalink":"https://lxx1997.github.io/categories/mobile/"},{"name":"MobileAdaptation","slug":"MobileAdaptation","permalink":"https://lxx1997.github.io/categories/MobileAdaptation/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"},{"name":"IOS","slug":"IOS","permalink":"https://lxx1997.github.io/tags/IOS/"},{"name":"mobile","slug":"mobile","permalink":"https://lxx1997.github.io/tags/mobile/"},{"name":"MobileAdaptation","slug":"MobileAdaptation","permalink":"https://lxx1997.github.io/tags/MobileAdaptation/"}]},{"title":"基于 electron 实现一个记录用户粘贴历史记录应用程序 之 基础环境搭建","path":"2022/12/15/frame/electron-vue3-vite-ts-copyright/","text":"之前一直使用 utools 工具中的 剪贴板，感觉这个功能十分好用，不用在费劲的去寻找自己之前copy 的记录，十分的方便 但是由于几个月前收费了，本着能白嫖就付钱的心理，所以就没有继续使用了。 最近偶然想要做一下这个功能，也可以学习一个 electron 和 vue3 的新知识 环境搭建可以参考一下这个文章，这里有完整的搭建流程。 但是由于各个电脑的环境以及node， electron 等版本不一样的，所以还是会有一些不同，我只在这里简单的记录一下，并标注一下不同之处 环境 插件 版本 node v16.14.0 yarn v1.22.19 vue v3.2.45 @vitejs/plugin-vue 4.0.0 electron 22.0.0 electron-builder 23.6.0 electron-devtools-installer 3.2.0 rimraf 3.0.2 typescript 4.9.3 vite 4.0.0 vite-plugin-electron 0.10.4 vite-plugin-electron-renderer 0.11.3 vue-tsc 1.0.11 环境搭建初始化 vue3 + vite + ts 环境1yarn create vite todolist --template vue-ts 初始化 electron 环境1yarn add -D electron electron-builder rimraf vite-plugin-electron electron-devtools-installer 插件说明 electron-builder：打包工具 rimraf：快速删除文件或目录工具 vite-plugin-electron：vite 结合 electron 的库，关于这个插件可以参见 Vite 与 Electron 无缝衔接 electron-devtools-installer：electron 开发工具 vite-plugin-electron 插件是将 vite 和 electron 结合在一起的，可以让我们非常方便的结合 electron 和 vue，需要做一些指定的配置。 创建 electron 入口文件 electron.ts 和 预渲染 preload.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// electron.tsconst &#123; app, BrowserWindow, Menu, globalShortcut &#125; = require(&#x27;electron&#x27;);const path = require(&#x27;path&#x27;);const createWindow = () =&gt; &#123; // 隐藏顶部菜单 Menu.setApplicationMenu(null) const win = new BrowserWindow(&#123; webPreferences: &#123; contextIsolation: false, nodeIntegration: true, preload: path.join(__dirname, &#x27;./preload.ts&#x27;), &#125;, &#125;); if (app.isPackaged) &#123; win.loadFile(path.join(__dirname, &#x27;./index.html&#x27;)); &#125; else &#123; // Use [&#x27;ENV_NAME&#x27;] avoid vite:define plugin const url = `http://127.0.0.1:5173/`; win.loadURL(url); // 添加快捷键 globalShortcut.unregisterAll() globalShortcut.register(&#x27;ctrl+q&#x27;, function() &#123; app.quit() &#125;) globalShortcut.register(&#x27;ctrl+shift+i&#x27;, function() &#123; // 添加 devtools win.webContents.openDevTools() &#125;) &#125;&#125;;app.whenReady().then(() =&gt; &#123; createWindow(); app.on(&#x27;activate&#x27;, () =&gt; &#123; // On macOS it&#x27;s common to re-create a window in the app when the // dock icon is clicked and there are no other windows open. if (BrowserWindow.getAllWindows().length === 0) createWindow(); &#125;);&#125;);app.on(&#x27;window-all-closed&#x27;, () =&gt; &#123; if (process.platform !== &#x27;darwin&#x27;) &#123; app.quit(); &#125;&#125;); 1234// electron-preload/index.tsconst os = require(&#x27;os&#x27;);console.log(os.platform()); // 测试打印一下系统平台 配置 electron在 tsconfig.json 中监听 electron 相关文件和提示 这个没有发生变化1&quot;include&quot;: [..., &quot;electron-main/**/*.ts&quot;, &quot;electron-preload/**/*.ts&quot;],vite.config.ts 变化比较明显，首先 electronRenderer 引入插件变成了 vite-plugin-electron-renderer,其次是初始化的时候 electron 传入实例对象有变化123456789101112131415161718192021// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;;import vue from &#x27;@vitejs/plugin-vue&#x27;;import * as path from &#x27;path&#x27;;import electron from &#x27;vite-plugin-electron&#x27;;import electronRenderer from &#x27;vite-plugin-electron-renderer&#x27;;export default defineConfig(&#123; plugins: [ vue(), electron(&#123; entry: &#123; main: &#x27;./electron.ts&#x27;, &#125;, &#125;), electronRenderer(), ], build: &#123; emptyOutDir: false, // 必须配置，否则electron相关文件将不会生成build后的文件 &#125;,&#125;); 配置打包命令1234// package.json&quot;script&quot;: &#123; &quot;build-electron&quot;: &quot;rimraf dist &amp;&amp; vite build &amp;&amp; electron-builder&quot;&#125; 其实在执行完上述内容后，基本上就可以正常运行和打包了","updated":"2022-12-15T01:59:59.000Z","categories":[{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/categories/vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"},{"name":"electron","slug":"electron","permalink":"https://lxx1997.github.io/categories/electron/"},{"name":"vue3","slug":"vue3","permalink":"https://lxx1997.github.io/categories/vue3/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"},{"name":"electron","slug":"electron","permalink":"https://lxx1997.github.io/tags/electron/"},{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/tags/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/tags/vite/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"TypeScript 高级类型","path":"2022/12/06/web/typescript-advanced-type/","text":"TypeScript 有许多高级类型，方便系统更好判断代码是否存在不合理的点，也更方便用户来排查错误和编写代码，下面介绍一些常用的高级类型，这些高级类型在日常开发中可能没有机会用到，但是了解一下对我们并没有任务坏处 交叉类型交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性 相当于混入（mixin）,在新的类型中，可以拥有合并的所有类型中的成员 使用 &amp; 来表示交叉 123456789101112131415161718192021222324252627function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; let result = &lt;T &amp; U&gt;&#123;&#125;; for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; return result;&#125;class Person &#123; constructor(public name: string) &#123; &#125;&#125;interface Loggable &#123; log(): void;&#125;class ConsoleLogger implements Loggable &#123; log() &#123; // ... &#125;&#125;var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());var n = jim.name;jim.log(); 通过上述例子,我们利用泛型创建一个 extend 方法用来合并两个对象，通过交叉符号 &amp; 判断函数返回类型是传入类型的合并类型 这样我们在访问 extend 返回的对象时，如果获取到不存在的属性，就会贴心的为我们提示错误 联合类型联合类型与交叉类型很有关联，但是使用上却完全不同. 交叉类型 是将多个类型合并成一个新的类型 联合类型 是满足多个类型中的一个，这些类型可以是基础类型(string, number …) 也可以是用户定义的类或者接口","updated":"2022-12-06T06:39:19.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"css 选择器","path":"2022/12/02/web/css-selector/","text":"选择器 例子 例子描述 .class .intro 选择 class=”intro” 的所有元素。 .class1.class2 .name1.name2 选择 class 属性中同时有 name1 和 name2 的所有元素。 .class1 .class2 .name1 .name2 选择作为类名 name1 元素后代的所有类名 name2 元素。 #id #firstname 选择 id=”firstname” 的元素。 * * 选择所有元素。 element p 选择所有 &lt;p&gt; 元素。 element.class p.intro 选择 class=”intro” 的所有 &lt;p&gt; 元素。 element,element div, p 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素。 element element div p 选择 &lt;div&gt; 元素内的所有 &lt;p&gt; 元素。 element&gt;element div &gt; p 选择父元素是 &lt;div&gt; 的所有 &lt;p&gt; 元素。 element+element div + p 选择紧跟 &lt;div&gt; 元素的首个 &lt;p&gt; 元素。 element1~element2 p ~ ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。 [attribute] [target] 选择带有 target 属性的所有元素。 [attribute=value] [target=_blank] 选择带有 target=&quot;_blank&quot; 属性的所有元素。 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 [attribute =value] [lang =en] 选择 lang 属性值以 “en” 开头的所有元素。 [attribute^=value] a[href^=”https”] 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素。 [attribute$=value] a[href$=”.pdf”] 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素。 [attribute=value] a[href=”w3schools”] 选择其 href 属性值中包含 “abc” 子串的每个 &lt;a&gt; 元素。 :active a:active 选择活动链接。 ::after p::after 在每个 &lt;p&gt; 的内容之后插入内容。 ::before p::before 在每个 &lt;p&gt; 的内容之前插入内容。 :checked input:checked 选择每个被选中的 &lt;input&gt; 元素。 :default input:default 选择默认的 &lt;input&gt; 元素。 :disabled input:disabled 选择每个被禁用的 &lt;input&gt; 元素。 :empty p:empty 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点）。 :enabled input:enabled 选择每个启用的 &lt;input&gt; 元素。 :first-child p:first-child 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素。 ::first-letter p::first-letter 选择每个 &lt;p&gt; 元素的首字母。 ::first-line p::first-line 选择每个 &lt;p&gt; 元素的首行。 :first-of-type p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :focus input:focus 选择获得焦点的 input 元素。 :fullscreen :fullscreen 选择处于全屏模式的元素。 :hover a:hover 选择鼠标指针位于其上的链接。 :in-range input:in-range 选择其值在指定范围内的 input 元素。 :indeterminate input:indeterminate 选择处于不确定状态的 input 元素。 :invalid input:invalid 选择具有无效值的所有 input 元素。 :lang(language) p:lang(it) 选择 lang 属性等于 “it”（意大利）的每个 &lt;p&gt; 元素。 :last-child p:last-child 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素。 :last-of-type p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :link a:link 选择所有未访问过的链接。 :not(selector) :not(p) 选择非 &lt;p&gt; 元素的每个元素。 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 :only-of-type p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 :only-child p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 :optional input:optional 选择不带 “required” 属性的 input 元素。 :out-of-range input:out-of-range 选择值超出指定范围的 input 元素。 ::placeholder input::placeholder 选择已规定 “placeholder” 属性的 input 元素。 :read-only input:read-only 选择已规定 “readonly” 属性的 input 元素。 :read-write input:read-write 选择未规定 “readonly” 属性的 input 元素。 :required input:required 选择已规定 “required” 属性的 input 元素。 :root :root 选择文档的根元素。 ::selection ::selection 选择用户已选取的元素部分。 :target #news:target 选择当前活动的 #news 元素。 :valid input:valid 选择带有有效值的所有 input 元素。 :visited a:visited 选择所有已访问的链接。","updated":"2022-12-02T07:23:57.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"}],"tags":[{"name":"css","slug":"css","permalink":"https://lxx1997.github.io/tags/css/"},{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"hexo 常用命令语句","path":"2022/12/02/extend/hexo-common-commands/","text":"创建一个博客到指定文件夹1hexo new page --path [folder-path]/[blog-name] create leetcode 练习（专用）1npx hexo new page --path handredday/leetcode/day-101-2283","updated":"2022-12-02T02:46:41.000Z","categories":[{"name":"extends","slug":"extends","permalink":"https://lxx1997.github.io/categories/extends/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lxx1997.github.io/tags/hexo/"},{"name":"extends","slug":"extends","permalink":"https://lxx1997.github.io/tags/extends/"}]},{"title":"web - H5 移动端适配问题","path":"2022/11/23/web/mobile-web-adaptation-problems/","text":"IOS 移动端适配唤起键盘输入时，页面底部的输入框无法浮动到键盘上方参考文章 这个出现的原因主要是 IOS 和 Andriod 的 适配不同 Andriod 的情况比较好理解。软键盘弹出后，实际webview被挤压了，变短了，相当于浏览器变小了，变成 原本高度 - 软键盘高 IOS 发布了 8.2 版本之后，与androids的不同，软键盘弹出，并不是挤压webview，webview的高度不会发生变化，而软键盘更像是一个悬浮在weview上的东西，并不会影响webview的实际高度，是“盖”上去的。这样就造成了我们目前所看到的情况，输入框被键盘遮挡，无法看到用户输入的内容 所以可以看到，我们在IOS上聚焦某个输入框，是会自动让页面发生滚动，以展示聚焦的输入框，此时页面的滚动，实际上是webview自身发生了移动。 这里可以采用的方法有两种 第一种是用户聚焦于输入框的时候，设置window 或者页面区域主动向上方滚动一定距离（例如软键盘高度），当用户失去焦点时，在滚动回原来的位置 第二种是改变 输入框所在元素的高度，使得输入框能够正常显示出来，当用户失去焦点时，在还原回原来的高度 12345678910111213141516171819const handleBlur = (e: any) =&gt; &#123; // 获取浏览器类型 let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123; element.style.height = &quot;100%&quot; &#125;, 100) &#125;&#125;const handleFocus = (e: any) =&gt; &#123; let &#123; ios &#125; = utils.myBrowserOS() if(ios) &#123; setTimeout(function()&#123;//设置一个计时器，时间设置与软键盘弹出所需时间相近 element.style.height = (window.innerHeight - 330) + &quot;px&quot; &#125;, 100) &#125;i IOS Safari 浏览器 canvas 写入图片过大，会造成页面重复刷新 参考文章 您的網頁在桌面上表現良好並不能保證它在 iOS 上也能表現良好。請記住，iOS 使用 EDGE（低帶寬、高延遲）、3G（高帶寬、高延遲）和 Wi-Fi（高帶寬、低延遲）連接到互聯網。因此，您需要最小化網頁的大小。在您的網頁中包含未使用或不必要的圖像、CSS 和 JavaScript 會對您的網站在 iOS 上的性能產生不利影響。 由於 iOS 上的可用內存，它可以處理的資源數量有限制： 解碼後的 GIF、PNG 和 TIFF 圖像的最大尺寸對於內存小於 256 MB 的設備是 3 兆像素，對於內存大於或等於 256 MB 的設備是 5 兆像素。也就是說，確保 width * height ≤ 3 * 1024 * 1024 適用於 RAM 小於 256 MB 的設備。請注意，解碼後的尺寸遠大於圖像的編碼尺寸。 使用子採樣時，JPEG 的最大解碼圖像大小為 32 兆像素。由於二次採樣，JPEG 圖像可以高達 32 兆像素，這允許 JPEG 圖像解碼為像素數的十六分之一的大小。大於 2 兆像素的 JPEG 圖像被二次採樣，即解碼為縮小的尺寸。JPEG 子採樣允許用戶查看來自最新數碼相機的圖像。 對於內存小於 256 MB 的設備，畫布元素的最大尺寸為 3 兆像素，對於內存大於或等於 256 MB 的設備，畫布元素的最大尺寸為 5 兆像素。如果未指定，畫布對象的高度和寬度為 150 x 300 像素。 每個頂級入口點的 JavaScript 執行時間限制為 10 秒。如果您的腳本執行時間超過 10 秒，iOS 上的 Safari 會在您代碼中的隨機位置停止執行腳本，因此可能會導致意外後果。施加此限制是因為 JavaScript 執行可能會導致主線程阻塞，因此當腳本運行時，用戶無法與網頁進行交互。閱讀“在 iOS 上調試 Web 內容”了解如何在 iOS 上調試 JavaScript。 一次可以打開的最大文檔數在iPhone 上是八個，在iPad 上是九個。 Andriod 移动端适配共用的适配方式在滚动的元素内部 有 pisition: fixed; 元素，点击到改元素，无法进行滑动在 IOS 可以采用在 pisition: fixed; 元素外包一层 pisition: sticky; div，可以实现 其他的话要触发浏览器默认的滚动（window，document.body）而非 元素的 overflow 属性才可以滑动","updated":"2022-11-23T08:09:03.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"},{"name":"IOS","slug":"IOS","permalink":"https://lxx1997.github.io/categories/IOS/"},{"name":"mobile","slug":"mobile","permalink":"https://lxx1997.github.io/categories/mobile/"},{"name":"MobileAdaptation","slug":"MobileAdaptation","permalink":"https://lxx1997.github.io/categories/MobileAdaptation/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"},{"name":"IOS","slug":"IOS","permalink":"https://lxx1997.github.io/tags/IOS/"},{"name":"mobile","slug":"mobile","permalink":"https://lxx1997.github.io/tags/mobile/"},{"name":"MobileAdaptation","slug":"MobileAdaptation","permalink":"https://lxx1997.github.io/tags/MobileAdaptation/"}]},{"title":"一些不常用的事件监听方法","path":"2022/10/27/web/document-eventListener-uncommon-use/","text":"documentselectionchange可以获取到点击的文字所在元素对象及点击或者选中文字起始位置和结束位置 应该是只针对 文字，我点击图片没有触发时间，点击文字时间正常触发12345678910111213141516171819202122// addEventListener versiondocument.addEventListener(&#x27;selectionchange&#x27;, () =&gt; &#123; console.log(document.getSelection()); /** * anchorNode: text * anchorOffset: 4 * baseNode: text * baseOffset: 4 选中起始位置 * extentNode: text 选中起始元素 * extentOffset: 4 选中结束位置 * focusNode: text 选中结束元素 * focusOffset: 4 * isCollapsed: true * rangeCount: 1 * type: &quot;Caret&quot; */&#125;);// onselectionchange versiondocument.onselectionchange = () =&gt; &#123; console.log(document.getSelection());&#125;; 通过下方代码操作可以改变选中位置12345678let selection = document.getSelection()!const range = document.createRange();selection.removeAllRanges();range.selectNodeContents(node);range.setStart(textNode,start)range.setEnd(textNode,start)range.collapse(false);selection.addRange(range); compositionStart可以监控到用户使用中文输入法输入 CompositionEnd可以监控到用户结束中文输入法输入 input元素添加了 contenteditable 属性后，可以监控到用户输入nativeEvent 上的 inputType 可以判断用户当前输入状态 deleteContentBackward 删除鼠标选中的字符或后方字符 deleteContentForward 删除鼠标选中的字符或前方字符 insertText 添加文字","updated":"2022-10-27T03:22:40.000Z","categories":[{"name":"web document","slug":"web-document","permalink":"https://lxx1997.github.io/categories/web-document/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"},{"name":"document","slug":"document","permalink":"https://lxx1997.github.io/tags/document/"},{"name":"eventListener","slug":"eventListener","permalink":"https://lxx1997.github.io/tags/eventListener/"}]},{"title":"vue3 状态管理工具 - pinia","path":"2022/08/11/vue/vue-pinia-state-manager/","text":"Vue3 出来都有一年多了，生态系统相对来说都慢慢变得完善起来了，像针对 vue2 的 vue-router 路由组件，vuex 状态管理工具都开始适应 vue3 了 这里就介绍 针对 vue3 的状态管理工具 vuex5 又叫 pinia 与 vuex4 和 vuex3 对比 mutations 不再存在。他们经常被认为是 非常 冗长。他们最初带来了 devtools 集成，但这不再是问题。 无需创建自定义复杂包装器来支持 TypeScript，所有内容都是类型化的，并且 API 的设计方式尽可能利用 TS 类型推断。 不再需要注入、导入函数、调用函数、享受自动完成功能！ 无需动态添加 Store，默认情况下它们都是动态的，您甚至都不会注意到。请注意，您仍然可以随时手动使用 Store 进行注册，但因为它是自动的，您无需担心。 不再有 modules 的嵌套结构。您仍然可以通过在另一个 Store 中导入和 使用 来隐式嵌套 Store，但 Pinia 通过设计提供平面结构，同时仍然支持 Store 之间的交叉组合方式。 您甚至可以拥有 Store 的循环依赖关系。 没有 命名空间模块。鉴于 Store 的扁平架构，“命名空间” Store 是其定义方式所固有的，您可以说所有 Store 都是命名空间的。 使用安装 pinia123npm install piniayarn add pinia 在 Vue 中注册123import &#123; createPinia &#125; from &quot;pinia&quot;createApp(App).use(createPinia()).mount(&#x27;#app&#x27;) 创建一个storepinia 提供了一个方法 defineStore 来定义一个 Store defineStore 需要我们传入两个参数，第一个参数是 name, 这个值是唯一的，第二个参数是 Store 的值，包含 state, getters, actions 1234567891011121314151617181920import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;, getters: &#123; getCount(state) &#123; return state.count &#125; &#125;, actions: &#123; addCount() &#123; this.count++ &#125; &#125;&#125;) 组件内使用 setup components在 setup component 内可以直接使用 1234567&lt;script setup&gt; const countStore = useCountStore() console.log(countStore.count) // 1 console.log(countStore.getCount) // 1 countStore.addCount()&lt;/script&gt; 需要注意的是，不能对 store 进行解构赋值，因为这会破坏 store 的响应式 如果想要对 store 进行解构赋值，可以采用 storeToRefs,它将为任何响应式属性创建 refs。 当您仅使用 store 中的状态但不调用任何操作时，这很有用12345&lt;script setup&gt; import &#123; storeToRefs &#125; from &quot;pinia&quot; const countStore = useCountStore() const &#123; count, getCount &#125; = storeToRefs(countStore)&lt;/script&gt; 属性statestate 用来定义应用程序状态开始，在 pinia 中状态是一个返回初始状态函数 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; state: () =&gt; &#123; return &#123; // state 值 count: 1 &#125; &#125;&#125;) 如果想要重置 Store 的状态，可以调用 $reset 方法 1useCountStore.$reset() 不在 setup() 中使用 可以使用 mapState 将状态映射为只读属性 12345export default &#123; computed: &#123; ...mapState(useCountStore, options) &#125;&#125; options 有两种类型 数组类型 如果是数组类型的话，其内的元素是需要映射的属性名，例如我们想要映射 state 的 count 的值 ...mapState(useCountStore, [&quot;count&quot;]),组件内可以直接使用 this.count 访问 对象类型 对象类型的话，key 是组件内访问时的属性名，key 所对应的值是 Store state 里面的值 12345678export default &#123; computed: &#123; ...mapState(useCountStore, &#123; aliasCount: &quot;count&quot;, // 组件内访问时 this.aliasCount,相当于访问 store 的 count 属性 doubleCount: (state) =&gt; state.count * 2 // 类似于 Store 的 getters 属性 &#125;) &#125;&#125; 如果想要直接修改这些状态属性，类似 this.count++,可以使用 mapWritableState API gettersgetters 的使用 类似于 state，但是创建方式略有不同 getters 是一个有具体返回值的函数，这个函数可以是有 state的值或者其他 getters 中的值计算出来的结果 12345678910import &#123; defineStore &#125; from &quot;pinia&quot;const useCountStore = defineStore(&quot;name&quot;, &#123; getters: &#123; doubleCount: (state) =&gt; state.count * 2, othercount(state) &#123; return this.doubleCount * state.count &#125; &#125;&#125;) 在 setup 函数中使用时，可以直接通过 store 访问 非 setup 函数可以通过 mapState 方法注册到 computed 属性中 actionsactions 中的方法适合用来定义业务逻辑，而且是可以进行异步操作 在非 setup 函数中使用的时候可以通过 mapActions 映射出来 1234567export default &#123; methods: &#123; ...mapActions(useCountStore, &#123; changeCount: &quot;count&quot;, &#125;) &#125;&#125; 第二个参数传递的类型可以参考 mapState 在 setup 函数中，可以直接在 setup 中使用，也可以在组件中通过 store 对象调用 1234567891011121314151617181920212223242526272829export default &#123; setup(props) &#123; let &#123; todoItem &#125; = toRefs(props) const todoList = useTodoListStore() const handleEdit = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; isEditing: true &#125;) &#125; const handleDelete = () =&gt; &#123; todoList.removeTodoList(todoItem.value.id) &#125; const handleConfirm = () =&gt; &#123; todoList.updatedTodoList(todoItem.value.id, &#123; content: value.value &#125;) &#125; return &#123; value, handleEdit, handleDelete, handleConfirm &#125; &#125;&#125; 另外，针对 actions vuex 提供了一个 $onAction 方法来订阅action 及结果 当我们订阅一个 store 后，每触发一次 store 内部的 action 执行，都会触发一次回调函数，传递给它的回调在 action 之前执行。 after 处理 Promise 并允许您在 action 完成后执行函数。 以类似的方式，onError 允许您在处理中抛出错误。 123456789101112131415161718192021222324252627282930313233const unsubscribe = todoListStore.$onAction( (&#123; name, // action 的名字 store, // store 实例 args, // 调用这个 action 的参数 after, // 在这个 action 执行完毕之后，执行这个函数 onError, // 在这个 action 抛出异常的时候，执行这个函数 &#125;) =&gt; &#123; // 记录开始的时间变量 const startTime = Date.now() // 这将在 `store` 上的操作执行之前触发 console.log(`Start &quot;$&#123;name&#125;&quot; with params [$&#123;args.join(&#x27;, &#x27;)&#125;].`) // 如果 action 成功并且完全运行后，after 将触发。 // 它将等待任何返回的 promise after((result) =&gt; &#123; console.log( `Finished &quot;$&#123;name&#125;&quot; after $&#123; Date.now() - startTime &#125;ms.\\nResult: $&#123;result&#125;.` ) &#125;) // 如果 action 抛出或返回 Promise.reject ，onError 将触发 onError((error) =&gt; &#123; console.warn( `Failed &quot;$&#123;name&#125;&quot; after $&#123;Date.now() - startTime&#125;ms.\\nError: $&#123;error&#125;.` ) &#125;) &#125;)unsubscribe()","updated":"2022-08-11T07:19:53.000Z","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/categories/Vue3/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/tags/Vue3/"}]},{"title":"React Hooks - 自定义hooks","path":"2022/08/09/react/react-custom-hooks/","text":"Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性 Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React react hooksuseEffectuseEffect 就是一个 Effect Hook，给函数组件增加了操作副作用的能力 它跟 class 组件中的 componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途 在使用时我们传递一个数组，useEffect 会在数组内的数据发生变化时重新执行 useEffect 函数需返回一个清除函数，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除 12345useEffect(() =&gt; &#123; return () =&gt; &#123; // 在此执行当前useEffect 的副作用清除，例如监听函数，定时器等操作 &#125;&#125;, [obj1, obj2]) // 仅在 obj1， obj2 改变的时候触发 如果想执行只运行一次的 effect（仅在组件挂载和卸载时执行），可以传递一个空数组（[]）作为第二个参数。 useStateuseState 会返回一对值：当前状态和一个让你更新它的函数，你可以在事件处理函数中或其他一些地方调用这个函数。 更新函数操作是完全替换，而非合并操作 1234const [count, setCount] = useState(0) // 初始化 countsetCount(1) // 改变 count 值setCount(x =&gt; x + 1) // 改变 count 值 会基于原count 值的基础上 +1 useContext 上下文对象用来接收由React.createContext() 创建的 context对象，并返回context对象的当前值，父组件需要有 &lt;MyContext.Provider&gt; 包裹着，值由 value 确定 12345678910111213141516171819202122232425262728293031323334353637const themes = &#123; light: &#123; foreground: &quot;#000000&quot;, background: &quot;#eeeeee&quot; &#125;, dark: &#123; foreground: &quot;#ffffff&quot;, background: &quot;#222222&quot; &#125;&#125;;const ThemeContext = React.createContext(themes.light);function App() &#123; return ( &lt;ThemeContext.Provider value=&#123;themes.dark&#125;&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; );&#125;function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton() &#123; const theme = useContext(ThemeContext); return ( &lt;button style=&#123;&#123; background: theme.background, color: theme.foreground &#125;&#125;&gt; I am styled by theme context! &lt;/button&gt; );&#125; useReduceruseReducer 是 useState 的替代方案，它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法 1234567891011121314151617181920212223const initialState = &#123;count: 0&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case &#x27;increment&#x27;: return &#123;count: state.count + 1&#125;; case &#x27;decrement&#x27;: return &#123;count: state.count - 1&#125;; default: throw new Error(); &#125;&#125;function Counter() &#123; const [state, dispatch] = useReducer(reducer, initialState); return ( &lt;&gt; Count: &#123;state.count&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+&lt;/button&gt; &lt;/&gt; );&#125; 在上述例子中，当修改 state 里面的值的时候，会通过dispatch 传递一个比较复杂的值作为 reducer 方法中的 action，在reducer 内部通过 action 的值来进行代码运算，返回出新的值 useCallbackReact useCallbackHook 返回一個記憶化的回調函數。這使我們能夠隔離資源密集型功能，以便它們不會在每次渲染時自動運行。 使用useCallback鉤子來防止函數被重新創建，除非有必要。 123const addTodo = useCallback(() =&gt; &#123; setTodos((t) =&gt; [...t, &quot;New Todo&quot;]);&#125;, [todos]); 当组件内容发生变化重新渲染的时候，如果 todos 没有发生变化的话，addTodo 函数不会重新创建 useMemoReact useCallbackHook 返回一個記憶化的值，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算 传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行不应该在渲染期间内执行的操作 123456789const Todo = (&#123; todos &#125;) =&gt; &#123; return &lt;div&gt;&#123; todos.map(item =&gt; &lt;div&gt; &#123;item.name&#125; &lt;/div&gt;) &#125;&lt;/div&gt;&#125;export default useMemo(Todo) 以上 Todo 组件仅会在 todos 参数发生变化时才会重新计算渲染，如果传入内容有函数，可以和 useCallback 接合，实现值的缓存 useRefuseRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内持续存在。 useRef 既可以用来存储 dom 对象，也可以用来存储单个的值 当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。 1234const ref = useRef(1)console.log(ref.current)ref.current = 2console.log(ref.current) useImperativeHandle 和 forwardRefuseImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。 父组件使用 forwardRef 来接收子组件暴露出的实例值 123456789101112131415161718function FancyInput(props, ref) &#123; const inputRef = useRef(); useImperativeHandle(ref, () =&gt; (&#123; focus: () =&gt; &#123; inputRef.current.focus(); &#125; &#125;)); return &lt;input ref=&#123;inputRef&#125; ... /&gt;;&#125;function App() &#123; FancyInput = forwardRef(FancyInput); function focus() &#123; inputRef.current.focus() &#125; return &lt;FancyInput ref=&#123;inputRef&#125; /&gt;&#125; useLayoutEffect其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。 useDebugValueuseDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。 1234567891011function useFriendStatus(friendID) &#123; const [isOnline, setIsOnline] = useState(null); // ... // 在开发者工具中的这个 Hook 旁边显示标签 // e.g. &quot;FriendStatus: Online&quot; useDebugValue(isOnline ? &#x27;Online&#x27; : &#x27;Offline&#x27;); return isOnline;&#125; useDeferredValueuseDeferredValue 接受一个值，并返回该值的新副本，该副本将推迟到更紧急地更新之后。如果当前渲染是一个紧急更新的结果，比如用户输入，React 将返回之前的值，然后在紧急渲染完成后渲染新的值。 该 hook 与使用防抖和节流去延迟更新的用户空间 hooks 类似。使用 useDeferredValue 的好处是，React 将在其他工作完成（而不是等待任意时间）后立即进行更新，并且像 startTransition 一样，延迟值可以暂停，而不会触发现有内容的意外降级。 1234567891011121314151617181920function Typeahead() &#123; const query = useSearchQuery(&#x27;&#x27;); const deferredQuery = useDeferredValue(query); // Memoizing 告诉 React 仅当 deferredQuery 改变， // 而不是 query 改变的时候才重新渲染 const suggestions = useMemo(() =&gt; &lt;SearchSuggestions query=&#123;deferredQuery&#125; /&gt;, [deferredQuery] ); return ( &lt;&gt; &lt;SearchInput query=&#123;query&#125; /&gt; &lt;Suspense fallback=&quot;Loading results...&quot;&gt; &#123;suggestions&#125; &lt;/Suspense&gt; &lt;/&gt; );&#125; useTransition返回一个状态值表示过渡任务的等待状态，以及一个启动该过渡任务的函数。 isPending 指示过渡任务何时活跃以显示一个等待状态：startTransition 用来启动过渡任务 1234567891011121314151617function App() &#123; const [isPending, startTransition] = useTransition(); const [count, setCount] = useState(0); function handleClick() &#123; startTransition(() =&gt; &#123; setCount(c =&gt; c + 1); &#125;) &#125; return ( &lt;div&gt; &#123;isPending &amp;&amp; &lt;Spinner /&gt;&#125; &lt;button onClick=&#123;handleClick&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;/div&gt; );&#125; useIduseId 是一个用于生成横跨服务端和客户端的稳定的唯一 ID 的同时避免 hydration 不匹配的 hook。 自定义 Hooks在知道上述 hooks 之后，react 也支持我们自定义 hooks 操作。 自定义 hooks 主要是用来 提取共享逻辑，优化代码结构。 1234567891011const useUserInfo = () =&gt; &#123; const [useInfo, setUseInfo] = useState(null) useEffect(() =&gt; &#123; // 这里做处理用户的个人信息 &#125;) return useInfo&#125;const useInfo = useUserInfo()","updated":"2022-08-09T01:55:31.000Z","categories":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/categories/react/"},{"name":"hooks","slug":"hooks","permalink":"https://lxx1997.github.io/categories/hooks/"}],"tags":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"hooks","slug":"hooks","permalink":"https://lxx1997.github.io/tags/hooks/"}]},{"title":"vue3 组合式Api setup","path":"2022/08/02/vue/vue3-composition-api-setup/","text":"什么是组合式API组合式API 主要是为了把相同的逻辑关注点收集在一起，使得逻辑处理更加清晰和方便。 针对 vue2 的组件选项来说，（data, computed, methods, watch）等组件存在，导致我们在修改同一个逻辑关注点的之后需要不停地跳转相关的代码块，代码碎片化，使得我们理解和维护复杂组件变得困难。 在 vue3组件中，这个位置称为 setup 这个是 Vue3 新增的一个选项 setup 选项会在组件被创建之前执行，一旦 props 解析完成，setup 就会被作为 组合式Api 的入口，也就是说 setup 执行的时机要比 vue2 的 beforeCreate 要早，此外 setup 中应避免使用 this 且因为调用发生在 data，computed，methods 之前，所以无法在 setup 中获取 既然 setup 中无法获取到 data，computed 中的内容，那么我们怎么创建和监控变量变化，且组件内能获取到呢？ setup 接收 props 和 context props 是父元素传递过来的 props context 是当前组件实例上下文 setup 函数 return 出一个对象，这个对象可以被组件直接获取到，相当于 data 和 methods 的集团体 怎么保证 setup 返回的变量是响应式的呢？ vue3 提供了一些 hooks，可以让我们创建响应式的变量 参数propssetup 接受两个参数，第一个参数是props，且是响应式的，传入新的props 时，会被一起更新 因为是响应式的，所以无法直接使用解构赋值，会失去响应式 12345678910111213141516171819202122232425262728293031323334353637383940// 父组件/** * 父组件向子组件传递一个 props title 属性，并且这个属性会在 3s 后发生变化 */export default &#123; setup() &#123; const title = ref(&quot;hhhhhh&quot;) setTimeout(() =&gt; &#123; title.value = &quot;this is new title&quot; &#125;, 3000); watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125; &#125;&#125;// 子组件/** * 子组件这里必须要在props 属性上添加需要接受的属性，否则setup 中的 props 无法接受到 * 当props 属性发生变化时，使用 watch 监听可以再次被触发，但是页面上内容不会发生变化，这是因为我们直接取的 props 里面的属性值，不具备响应式 */export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = props return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果我们想要对 props 进行解构操作，可以使用 toRefs 函数来完成此操作 下面代码我们会发现当 props 中的 title 属性发生变化后， 组件内 title 并不会跟随变化，而 computedTitle 则会跟随props 中的 title 属性发生变化 12345678910111213141516171819export default &#123; props: &#123; title: &#123; type: String, default: &quot;&quot; &#125; &#125;, setup(props, context) &#123; console.log(props.title) watch(props, (n, o) =&gt; &#123; console.log(props.title) &#125;) let &#123; title &#125; = toRefs(props) return &#123; title: props.title, computedTitle: title &#125; &#125;&#125; 如果 title 是可选的 prop，则传入的 props 中可能没有 title 。在这种情况下，toRefs 将不会为 title 创建一个 ref 。你需要使用 toRef 替代它 toRef 的作用相当于把 对象中的属性转化为 ref 类的属性，且与对象相关联，当对象中对应属性发生变化时, toRef 中的内容会同步发生改变 123456setup(props, context) &#123; let name = toRef(props, &quot;name&quot;) // name 会跟随 props 中的 name 属性变化而同步更新 return &#123; name: name &#125;&#125; contextcontext 是一个普通 JavaScript 对象，不是响应式的，因此可以使用 解构操作 暴露了其它可能在 setup 中有用的值： attrs 类似于 $attrs slots 类似于 $slots emit 类似于 $emit expose 公共property slots 和 attrs 是有状态的对象，跟随组件本身的更新而更新，避免使用解构赋值，如果想要根据 attrs 和 solts 更改应用富足用，应该在 onBeforeUpdate 钩子中执行操作 returnsetup return 出来的值可以在模板和组件中直接使用 如果父组件想要访问子组件 setup 中的 property，可以使用 expose 方法暴露出去 123456789101112export default &#123; setup(props, &#123; expose &#125;)&#123; let count = ref(0) const changeCount = () =&gt; ++count.value expose(&#123; changeCount &#125;) return &#123; count &#125; &#125;&#125; hookssetup 内部的钩子函数 onBeforeMount // 页面挂载钩子函数 onMounted onBeforeUpdate // 页面更新钩子函数 onUpdated onBeforeUnmount // 页面销毁钩子函数 onUnmounted onErrorCaptured // 页面错误事件钩子函数 onRenderTracked onRenderTriggered // 跟踪虚拟 DOM 重新渲染时调用 onActivated // keep-alive 缓存的组件激活时调用 onDeactivated // keep-alive 缓存的组件失活时调用 这些钩子函数的触发时机和在组件内部触发时机一致 这些钩子函数接受一个回调函数，当钩子函数被调用时，将会被执行 带 ref 的响应式变量在 Vue3 中，我们可以通过 ref hooks 创建一个响应式变量，ref 接收参数并将其包裹在一个带有 value property 的对象中返回，然后可以使用该 property 访问或更改响应式变量的值 之所以把值封装在对象中，主要是因为字符串和数字这些基本类型时通过值传递的，通过对象封装后，可以在整个对象安全的传递，不用担心失去响应式 1&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt; 123456789101112131415setup(props, context) &#123; const title = ref(&quot;setup component&quot;) const changeTitle = function(val) &#123; title.value = val &#125; setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) return &#123; title, changeTitle &#125;&#125; 在上述实例中，我们可以发现，在3s 过后，页面上显示的内容发生变化，而且setup return 出来的属性和方法在组件的其他选项中都可以通过 this 来访问到 watch 响应式处理如果我们想要在 setup 选项中监听属性的变化，可以通过 watch hooks 方法监听属性变化 watch 接受三个参数，监听对象，回调函数，配置选项 配置选项同组件中的 watch 选项，同样包含 deep 和 immediate 属性，而且还额外接受一个 flush 选项 flush 选项有三个值 pre 默认值，指定回调在渲染前被调用 post 将回调推迟到渲染之后，这时候可以获取页面 dom 元素 sync 回调同步调用，不过会比较消耗性能 1watch(obj, (newValue, oldValue) =&gt; &#123;&#125;, &#123;deep?: true, immediate?: true, flush?: &quot;pre&quot; | &quot;post&quot; | &quot;sync&quot;&#125;) 下面这个例子，当 setTimeout 方法执行完成后，由于改变了 title 的值， 触发了 watch 函数，我们打开 console 就可以发现打印了title 改变之前的值和 修改之后的值 1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) return &#123; title &#125;&#125; 如果我们想要监控多个数据源的变化，可以在watch 的时候 watch 监听对象传入一个数组，同理，当数组内的任意一个元素发生变化时，都会触发watch 函数，而且 watch 回调函数中传入的值也是以数组的形式存在的 123456789const firstName = ref(&#x27;&#x27;)const lastName = ref(&#x27;&#x27;)watch([firstName, lastName], (newValues, prevValues) =&gt; &#123; console.log(newValues, prevValues)&#125;)firstName.value = &#x27;John&#x27; // logs: [&quot;John&quot;, &quot;&quot;] [&quot;&quot;, &quot;&quot;]lastName.value = &#x27;Smith&#x27; // logs: [&quot;John&quot;, &quot;Smith&quot;] [&quot;John&quot;, &quot;&quot;] 如果在监控多个数据源变化时，针对多个数据源修改时是同步修改，并不涉及到 setTimeout 等异步操作时，watch 会把这些更改合并成一次操作，会将所有修改的值一起返回给回调函数 watch hooks 还可以通过回调函数的第三个参数来清除副作用，这个参数会在 watch hooks 被停止或者销毁时，或者副作用重新执行时触发 1234567891011121314151617setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o, onInvalidate) =&gt; &#123; console.log(n, o) onInvalidate(() =&gt; &#123; // 处理副作用方法 &#125;) &#125;) return &#123; title &#125;&#125; 类似的方式还有一个 watchEffect 方法 watchEffect在使用 watchEffect 的时候，会自动执行传入的函数，并且响应式的追踪依赖，并且在依赖发生变更操作时，重新运行传入的函数 1234567891011121314151617181920export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) watch(title, (n, o) =&gt; &#123; console.log(n, o) &#125;) watchEffect(() =&gt; &#123; console.log(title.value) &#125;) return &#123; title &#125; &#125;&#125; 上述代码执行完成后，我们会发现在控制台会首先输出 setup component， 然后 3s 过程会同时输出 setup component changed，这个是因为 watchEffect 会立即执行，但是因为依赖没有变更，所以就是初始值，3s 后，依赖发生了变更，这时 watch 和 watchEffect 同时触发 watchEffect 在执行完成后，会有一个返回值，我们可以通过这个返回值来停止监听,但是需要注意的是，watchEffect 还是会立即执行，只是当依赖方式变化时，不会再次触发 1234567891011121314151617export default &#123; setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) const stop = watchEffect(() =&gt; &#123; console.log(title.value) &#125;) stop() return &#123; title &#125; &#125;&#125; computed 计算属性1234567891011121314setup(props, context) &#123; const title = ref(&quot;setup component&quot;) setTimeout(() =&gt; &#123; title.value = &quot;setup component changed&quot; &#125;, 3000) let computedTitle = computed(() =&gt; title.value + &quot;abcd&quot;) return &#123; title, computedTitle &#125;&#125; 访问 computed 值的时候和 访问响应式变量的值一样，都是通过 .value 来获取到 provide &amp;&amp; injectvue3 暴露出了两个方法 provide 和 inject 两个方法，这两个方法和 组件内的 provide和inject 方法等同 provide 传入两个参数，第一个参数是属性名，第二个参数是属性值1234setup(props, context) &#123; provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, 26)&#125; inject 传入两个参数，第一个参数是属性名，第二个参数是默认值1234setup(props, context) &#123; inject(&quot;name&quot;, &quot;lxx&quot;) inject(&quot;age&quot;)&#125; 但是通过上述创建的 provide 和 inject 之间不是响应式的，也就是说如果provide 的值改变并不会触发 inject 的值变化，provide 可以使用 ref 和 reactive 方法创建响应式的 provide 12345setup(props, context) &#123; const count = ref(0) provide(&quot;name&quot;, &quot;lxx&quot;) provide(&quot;age&quot;, count)&#125; 模板引用(ref=””)12345678910111213141516171819202122&lt;template&gt; &lt;div :ref=&quot;root&quot;&gt;This is a root element&lt;/div&gt;&lt;/template&gt;&lt;script&gt; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; export default &#123; setup() &#123; const root = ref(null) onMounted(() =&gt; &#123; // DOM 元素将在初始渲染后分配给 ref console.log(root.value) // &lt;div&gt;This is a root element&lt;/div&gt; &#125;) return &#123; root &#125; &#125; &#125;&lt;/script&gt; 当页面加载完成后，会自动将 div 绑定给 root 如果需要使用 v-for 绑定多个标签，可以创建响应式数组或者响应式对象来实现","updated":"2022-08-08T07:03:31.000Z","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/categories/Vue3/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/tags/Vue3/"}]},{"title":"创建默认的 hexo categories 首页","path":"2022/07/20/extend/hexo-create-categories-pages/","text":"正常我们创建一个新的 hexo 博客时 直接访问 categories 默认页面时是无法访问到的，如果我们想要访问到可以通过以下操作创建一个默认的 categories 默认页面，在生成页面时，categories 相关内容会自动写进去 1hexo new page categories categories 默认 md 文档中添加 type: &quot;categories&quot; 12345---title: categoriesdate: 2022-07-20 09:13:01type: &quot;categories&quot;--- 创建 tags 默认页面类似，只需要把 type: &quot;categories&quot; 改为 type: &quot;tags&quot;","updated":"2022-07-20T01:16:55.000Z","categories":[{"name":"hexo","slug":"hexo","permalink":"https://lxx1997.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://lxx1997.github.io/tags/hexo/"}]},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part2","path":"2022/07/19/vue/relearn-vue2-02/","text":"filter(过滤器) 12&lt;p&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/p&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; 12345filter: &#123; capitalize: function(val) &#123; return val &#125;&#125; 过滤器可以串联，值从左向右传递","updated":"2022-07-19T07:04:48.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"relearn","slug":"relearn","permalink":"https://lxx1997.github.io/tags/relearn/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"html-webpack-plugin 的使用与进阶","path":"2022/07/13/webpack/html-webpack-plugin/","text":"在日常工作中遇到了需要打包成多页面的需求，由于每个页面的标题，描述以及一些seo和推广上的不一样，采用了 html-webpack-plugin 这个插件，在这里记录一下踩过的坑，以便后续查看和翻阅 简单的使用安装插件1yarn add html-webpack-plugin -D 使用123456789101112// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;] // 打包文件，与 entry 入口名相同 &#125;) ]&#125; 进阶操作自定义 meta 标签在日常开发过程中，我们可能会遇到一些与seo 相关或者需要在页面头部添加 meta 标签，我们就可以采用 html-webpack-plugin 来动态的向同一个模板插入不同的meta标签 12345678910111213141516// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125; &#125;) ]&#125; 以上代码会自动在打包之后的页面中添加 meta 标签 123456&lt;html&gt; &lt;head&gt; &lt;meta name=&quot;description&quot; content=&quot;description&quot; /&gt; &lt;meta name=&quot;keyword&quot; content=&quot;keyword&quot; /&gt; &lt;/head&gt;&lt;/html&gt; 自定义 link 标签123456789101112131415161718192021222324252627// package.jsonconst HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)module.exports = &#123; plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;/public/index.html&quot;, // 模板 filename: &quot;template.html&quot;, // 输出文件名称 chunks[&quot;template&quot;], // 打包文件，与 entry 入口名相同 meta: &#123; description: &quot;description&quot;, keyword: &quot;keyword&quot; &#125;， links: [ &#123; href: &quot;http://template.com/assets/abc.css&quot;, type: &quot;text/css&quot; &#125;, &#123; href: &quot;http://template.com/assets/abc.css&quot;, ref: &quot;alternate&quot;, hrefLang: &quot;en&quot;, &#125; ] &#125;) ]&#125; 然后在模板页面可以解析 links 的内容在打包时动态生成我们所需要的的 link 标签 1234567&lt;html&gt; &lt;head&gt; &lt;% for (var key1 in htmlWebpackPlugin.options.links) &#123; %&gt; &lt;link &lt;% for (key in htmlWebpackPlugin.options.links[key1]) &#123; %&gt; &lt;%= key %&gt;=&quot;&lt;%= htmlWebpackPlugin.options.links[key1][key] %&gt;&quot;&lt;% &#125; %&gt; /&gt; &lt;% &#125; %&gt; &lt;/head&gt;&lt;/html&gt; 在上述代码中，打包时首先会去拿取 htmlWebpackPlugin.options.links 中的内容进行遍历，然后根据 links 中元素的属性来动态生成link标签的 href,type,ref 等属性 未完待续","updated":"2022-07-13T03:19:44.000Z","categories":[{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/categories/webpack/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"html","slug":"html","permalink":"https://lxx1997.github.io/tags/html/"},{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/tags/webpack/"}]},{"title":"常用的前端动画库","path":"2022/07/12/web/web-animation-package/","text":"Lottie 文档 都2022年了，一个还不知道Lottie动画的前端已经OUT啦！ svga SVGA在前端方面的使用","updated":"2022-07-12T08:58:08.000Z","categories":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://lxx1997.github.io/tags/web/"}]},{"title":"生成 github SSH key","path":"2022/07/08/github-ssh-key-generate/","text":"生成 SSH key打开 git bash 命令行工具 输入一下命令，自动生成 ssh key 地址 1ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot; 可以通过命令行直接复制 ssh key 的内容 1clip &lt; ~/.ssh/id_ed25519.pub 复制成功之后，可以将 ssh key 复制到 github 的ssh key 上 和 github 链接执行以下命令 1234ssh-add ~/.ssh/id_ed25519// 或者echo $SSH_AGENT_SOCK 如果执行不成功，可能是 ssh-add 未开启，可以通过命令行查看是否开启ssh-add 服务1ps -ef | grep ssh 开启 ssh-add 服务12cd ~/.ssheval $(ssh-agent) 执行完上述命令后就可以进行ssh 链接","updated":"2022-07-08T06:19:07.000Z","categories":[{"name":"git","slug":"git","permalink":"https://lxx1997.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://lxx1997.github.io/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://lxx1997.github.io/tags/linux/"}]},{"title":"重新学习vue2 - 发现隐藏其中的细节 - part1","path":"2022/07/07/vue/relearn-vue2-01/","text":"computed 属性默认是只有 getter 属性的，也就是说我们只能获取到computed 属性的值，但是无法修改它，但是我们可以手动的设置 setter 属性，这样就可以手动赋值了 1234567891011121314export default &#123; computed() &#123; fullName: &#123; set: function (val) &#123; let name = val.split(&quot; &quot;) this.firstName = name[0] this.secondName = name[1] &#125;, get: function () &#123; return this.firstName + &quot; &quot; + this.secondName &#125; &#125; &#125;&#125; v-for 和 v-if 为什么不推介一起使用 这个是因为 v-for 和 v-if 的优先级问题，vue 会先进行 v-for 循环渲染元素，最后在进行 v-if 控制是否显示元素，会造成无谓的资源浪费 可以采用 v-show 代替 v-if 或者使用计算属性来代替 v-if， 只渲染我们想渲染的元素 key attribute 用来表示这个元素是完全独立的，和其他元素不同，在日常操作中可以用来强制刷新元素内容，只需要修改元素的key，就会重新去渲染元素 我之前用过 v-if 和 $nextTick 来强制重新渲染元素内容，很明显使用上述方法是一种很方便的操作 v-for 可以使用 in 或者 of 来作为分隔符 v-for 遍历对象时 v-for=&quot;(value, name, index) in obj&quot; 三个值 分别为 值，键，和 索引 vue 中可以使用 template 标签，该标签类似 react 中的&lt;&gt;&lt;/&gt;和React.Fragment,在实际渲染中并不会被渲染出来 如果我们想要在点击事件中访问原始的 dom 时间，可以将特殊的变量 $event 传到方法中 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止默认事件 .capture 事件捕获的时候触发，如果点击的是子元素，会先于子元素事件触发 .self 只有当 event.target 是元素自身时触发，点击子元素时不会触发 .once 只会触发一次 .passive 和 .prevent 相反，不会阻止默认事件触发 使用修饰符的时候，顺序很重要，代码会以同样的顺序产生，例如v-on:click.prevent.self 会阻止所有点击，而 v-on:click.slef.prevent 只会阻止元素对自身的点击 按键修饰符 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 支持按键码 可以通过全局的 config.keyCodes 自定义按键修饰符别名1Vue.config.keyCodes.f1 = 112 系统修饰键 (修饰键在和其他事件一起使用的时候，需要同时触发才行，否则并不会单独触发修饰键) .ctrl .alt .shift .meta .exact 精确修饰符，允许我们控制精确的系统修饰符组合触发的事件 &lt;input v-model=&quot;toggle&quot; type=&quot;checkbox&quot; true-value=&quot;yes&quot; false-value=&quot;no&quot; /&gt; 此时 toggle 会取 对应的 true-value 和 false-value 的值 v-model.lazy 默认情况下，v-model 会在input 事件触发后将输入框的值与数据同步，添加lazy 修饰符后，从而转为在 change 事件之后触发 v-model.number 会自动将用户输入的值转为数值类型 v-model.trim 会自动去除用户输入内容两端的空格 自定义组件中的 data 必须是一个函数，是为了保证每次创建组件的时候都能拿到一个独立的数据，否则，重复创建组件时，组件内的数据由于有同一个引用地址，会互相干扰 v-model 在自定义组件中使用相当于 v-bind:value 和 v-on:change 的组合 可以通过组件的 model 属性改变 v-model 的默认属性和事件绑定 12345678910export default &#123; model: &#123; prop: &#x27;checked&#x27;, event: &#x27;change&#x27; &#125;, mounted() &#123; console.log(this.checked) this.$emit(&quot;change&quot;, &quot;val&quot;) &#125;,&#125; &lt;component v-bind:is=&quot;CustomComponent&quot;&gt;&lt;/component&gt; 通过 v-bind:is 可以自定义组件，组件会跟随 CustomComponent 的值变化而变化 传入一个对象的所有 property, 组件内部可以直接通过 示例中 post 拿到对应的属性 1&lt;component v-bind=&quot;post&quot;&gt;&lt;/component&gt; props 验证 123456789101112export default &#123; props: &#123; propA: &#123; type: String, default: &quot;&quot;, require: false, validator() &#123; &#125; &#125; &#125;&#125; type props 参数类型 String, Number, Boolean, Array, Object, Date, Function, Symbol, 或者自定义的构造函数 default 默认值，引用类型数据 需要使用函数并且通过return 返回默认引用类型 require 是否必须传 默认为 false validator 自定义效验规则 禁用 Attribute 继承，可以设置 inheritAttrs false 来之根元素继承 Attribute 具体表现为 如果设置为 false 子组件不会渲染 attribute， true 会在子组件上渲染 attribute 父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。 slot 缩写 v-slot: -&gt; # 后备内容 如果我们没有向插槽内提供内容，此时将会显示后备内容 &lt;slot&gt;默认内容&lt;/slot&gt; 具名插槽 &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;slot-component v-slot:header&gt;&lt;/slot-component&gt; 作用域插槽 插槽内部 123456&lt;template&gt; &lt;div&gt; &lt;slot v-bind:user=&quot;user&quot;&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 外部使用 1234567&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 如果有多个插槽 12345678910&lt;template&gt; &lt;div&gt; &lt;slot v-slot:default=&quot;slotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;slot v-slot:other=&quot;otherSlotProps&quot;&gt; &#123;&#123; slotProps.user.firstName &#125;&#125; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 子组件可以通过 $root 来访问和修改根组件的实例及方法 provide, inject provide 选项允许和指定提供给后代组件的数据和方法 123456provide: function() &#123; return &#123; a: function() &#123;&#125;, b: 0 &#125;&#125; inject 允许子元素接受 provide 提供的 provide 1inject: [&#x27;a&#x27;, &#x27;b&#x27;] 但是出于设计考虑， 这些数据不是响应式的，而且会对重构及代码复用有很大的影响 X-Template x-template 需要定义在 Vue 所属的 DOM 元素外。 123&lt;script type=&quot;text/x-template&quot; id=&quot;hello-world-template&quot;&gt; &lt;p&gt;Hello hello hello&lt;/p&gt;&lt;/script&gt; 123Vue.component(&#x27;hello-world&#x27;, &#123; template: &#x27;#hello-world-template&#x27;&#125;) transition 过渡动画 v-enter 定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除 v-enter-active 定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active 定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 自定义动画类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 显性的过渡持续时间 &lt;transition :duration=&quot;1000&quot; /&gt; &lt;transition :duration=&quot;&#123;enter: 500, leave: 800&#125;&quot; /&gt; JavaScript 钩子 123456789101112&lt;transition v-on:before-enter=&quot;beforeEnter&quot; v-on:enter=&quot;enter&quot; v-on:after-enter=&quot;afterEnter&quot; v-on:enter-cancelled=&quot;enterCancelled&quot; v-on:before-leave=&quot;beforeLeave&quot; v-on:leave=&quot;leave&quot; v-on:after-leave=&quot;afterLeave&quot; v-on:leave-cancelled=&quot;leaveCancelled&quot;&gt;&lt;/transition&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 当与 CSS 结合使用时 // 回调函数 done 是可选的 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; mixins 混入选项合并 数组对象会在内部进行合并，例如 data,属性名发生冲突时，以组件内属性优先 钩子函数合并成数组，都会被调用，混入对象的钩子函数优先于组件内钩子函数调用 值为对象时,将会被合并成为一个对象，且组件对象的键值对优先级更高 Vue.config.optionMergeStrategies 可以通过次宣讲自定义逻辑合并逻辑 自定义指令 1234567directives: &#123; focus: &#123; inserted: function(el) &#123; el.focus() &#125; &#125;&#125; 1&lt;input v-focus /&gt; 钩子函数 bind 绑定时调用，只调用一次 inserted 被绑定元素插入父节点时调用 update 所在组件更新时调用，可能发生在子组件更新之前 componentUpdated 所在组件和子组件全部更新后调用 unbind 指令与元素解绑时调用 钩子函数参数 el 绑定的元素，可以用来操作 DOM binding name 指令名 value 指令绑定的值 oldValue 制定绑定的前一个值 expression 字符串形式的指令表达式 =&quot;1 + 1&quot; arg 传给指令的参数 :foo modifiers 指令修饰符 .foo vnode 当前虚拟节点 oldVnode 上一个虚拟节点 functional 函数式组件函数式组件没有响应式数据，也没有实例（没有 this 上下文）相反会有一个 context 参数 包含如下字段 props children slots scopedSlots data parent listeners injections","updated":"2022-07-07T07:56:07.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"relearn","slug":"relearn","permalink":"https://lxx1997.github.io/tags/relearn/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"好用的浏览器页面测试页面性能工具","path":"2022/07/07/web/web-page-speed-testing-tools/","text":"pagespeed地址： https://pagespeed.web.dev/ gtmetrix地址： https://gtmetrix.com/ web.dev地址： https://web.dev/measure/","updated":"2022-07-07T03:29:14.000Z","categories":[{"name":"performance","slug":"performance","permalink":"https://lxx1997.github.io/categories/performance/"}],"tags":[{"name":"performance","slug":"performance","permalink":"https://lxx1997.github.io/tags/performance/"}]},{"title":"最全的页面性能优化","path":"2022/06/24/web/how-to-make-pagespeed-fast/","text":"为什么要进行性能优化我们会在什么时候对页面性能进行优化呢，在我的观点里大致有以下几个方面 页面加载时间较长，导致部分用户在页面还未加载完成之后便离开了页面，增加了用户的跳出率 因为 google 的搜索算法，对页面性能这一块有一定要求，如果页面性能较差，那么当用户搜索工具关键词时，页面的顺序就越靠下，这样针对用户自然搜索流量这一块会有很大影响 用户在使用工具时，可能会由于部分操作及代码实现的影响，导致用户使用时会比较卡顿，用户体验较差，降低用户留存 如果想要提高用户的留存率这一块的数据，那么增加用户流量及降低用户跳出率就比较重要了 怎么进行性能优化我认为可以从以下几个方面来进行性能优化 html 解析阶段 javascript 加载阶段 页面渲染阶段 用户操作过程中 下面来分别介绍一下在各个阶段要具体要怎么做 html 解析阶段当浏览器请求到页面 html 的时候，会对html 进行解析，如果中间遇到 link 标签 或者 script 标签时，会去请求对应资源，并进行解析，在解析 css 文件的过程中，并不会阻止浏览器解析 html 文件，但是要注意，javascript 文件会阻止 css 和 html 文件的解析，所以尽量要把 javascript 文件访问 body 标签的最后，不要阻止html 和 css 的解析 在这个阶段我们可以通过以下几种方法提高页面速度 prefetch &amp;&amp; preload使用 prefetch 和 preload 方式 预加载文件，但是要注意这两个方法加载文件的优先级程度不同， prefetch 的优先级最低，浏览器不会立即下载文件，而是会在空闲时间去下载文件， preload 的优先级最高，会立即去下载文件，但是这两个方式都不会去解析文件，只是下载文件后存放本地，如果我们需要使用时就不必再次下载 注意：由于浏览器对于同一个域名下请求的个数有限制，所以要谨慎使用prefetch 和preload 方法，如果一次性加载文件过多，反而会影响后续资源的获取，起到反优化的效果 12345&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;prefetch&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.js&quot; as=&quot;type/javascript&quot; /&gt;&lt;link rel=&quot;preload&quot; href=&quot;https://www.template.com/assets/js/tempalte.css&quot; as=&quot;type/style&quot; /&gt; DNS Prefetch，即DNS预获取当浏览器加载文件时，会对地址进行 DNS 解析,获取地址对用的IP地址，虽然浏览器内部对这一部分操作进行过优化，会在一定时间内缓存 DNS 解析结果，但是 DNS 解析的时间还是比较长的，大概需要 20ms - 120ms 左右的时间，我们可以针对会使用的域名开启 dns 预解析操作，在浏览器空闲的时候，去解析 DNS,当我们使用的时候，就可以减少 dns 解析的时间操作，提高接口请求时间 123&lt;!-- 开启 DNS 解析 content: off 关闭 on 打开 --&gt;&lt;meta http-equiv=&quot;x-dns-prefetch-control&quot; content=&quot;on&quot;&gt;&lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.template.com&quot;&gt; 但是要注意不要滥用预解析，如果短时间不需要的域名，可以不需要 dns 预解析 script 标签位置浏览器在遇到script 标签时，会暂停解析 html 和 css 文件，转而去解析 js 内容，这样就阻止了页面的解析和渲染，所以尽量保证script 标签在 body 标签的末尾，减少 js 文件对html 文件解析的影响 骨架屏可以采用骨架屏的方式，防止用户因为看不到内容，从而离开页面 JavaScript 解析阶段在这个阶段，浏览器回去下载页面渲染所需要的 javascript 文件，解析，然后渲染到页面上，在这个阶段影响页面加载速度主要有以下几个方面： 单个 js 文件过大，请求及解析文件耗时过大 同一时间请求了过多的资源，导致网络被占用，进一步影响了页面加载 采用不同域名加载静态资源我们都知道浏览器对同一个域名下的请求个数有一定的限制，例如google 浏览器限制最大并发个数是6个，当同时发起的请求的个数超过6个时，只会有有6个发起请求，其他的处于 padding 状态，只有当请求完成时，才会有下一个请求开发发起请求。 因此我们可以采用通过不同域名来请求静态资源，例如 所有的 js 资源可以单独采用一个域名来进行，图片等媒体资源可以采用一个域名来访问，这个就不会因为同一时间内请求的资源过多，影响页面加载速度 CDN 缓存当浏览器下载资源，会先通过 DNS 解析解析出资源所在主机的ip地址，然后去拉取资源，如果服务器刚好在用户所在城市附近，那么资源的加载速度并不会有多大影响，但如果距离过远，例如你人在北京，想要访问在美国的一台服务器上的资源，这个时候由于网络传输的印象，回导致资源获取延迟比较大。 这个时候就需要使用 CDN 缓存了， 这就是CDN的由来，分布式缓存服务器，主要功能是在转发、传输、链路抖动等情况下，最小化资源的时延，并保证信息的连续性和速度。 当我们访问资源，会首先向距离我们最近的 DNS 服务器发出资源请求，如果 这个DNS 服务器缓存有我们想要的资源，如果没有，则会向原服务器请求资源，然后返回给我们，这样一般就降低了资源在请求链路传输的延迟问题。 但是使用 DNS 缓存也会有一些弊端，因为资源都是已经缓存到 DNS 服务器上了，如果在资源缓存未失效的请求，资源进行了变更，这个时候用户访问到的又可能还是旧版资源，这个时候我们可以手动请求 DNS 缓存，但是这个方法不太方便，所以我们可以通过打包的方式，对静态资源添加 hash 后缀，这样每次发版或者更换资源，都会把地址专项新的地址，这样 CDN 就会重新对资源进行缓存针对不能添加 hash 的文件，我们可以通过修改参数的方式来使 CDN 重新刷新缓存，例如123// package.version 为 package.json 的版本号let url = `http://www.example.com/useinfo?_v=$&#123;package.version&#125;`axios.get*(url) 这样当我们每次发版的时候，只需要修改一下版本号，就可以刷新 CDN 缓存了 减少 javascript 包的体积当 js 文件体积过大时，我们需要减少 javascript 包的大小，来减少js 加载时间和解析时间。 可以通过一下几种方式减少包的体积 分包 我们可以通过打包的方式，来将一些第三方资源包打包到一个文件，因为这部分资源我们通常并不会经常修改，这样当我们发版的时候，如果第三方资源并没有发生变化，那么这一块的资源并不会清空 CDN 缓存 1234567891011121314151617181920module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; vendors: &#123; test: /[\\\\/]node_modules[\\\\/]/, name: &quot;vendors&quot;, priority: -10 &#125;, utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 这样所有的 node_modules 下需要打包的资源都会打包到 vendors js 文件里面 如果是多页面应用还可以吧多次使用的资源的资源打包到同一个包里面，这样多个页面就可以共用这一个包 123456789101112131415module.exports = &#123; optimization: &#123; splitChunks: &#123; chunks: &quot;all&quot;, cacheGroups: &#123; utilCommon: &#123; name: &quot;common&quot;, minSize: 0, minChunks: 2, priority: -20 &#125; &#125; &#125;, &#125;&#125; 资源懒加载 这里主要以 vue 项目举例 假如我们的页面有多个路由，我们在访问其中一个路由的时候其实是不需要加载其他路由所需要的内容，这个时候可以使用懒加载的方式来减少首屏需要加载的资源 1234&#123; name: &quot;/home&quot;, component: () =&gt; import(&quot;./home.vue&quot;)&#125; 这个时候只有我们访问 /home 这个路由的时候才会加载 home 所需要的资源， 针对同一个路由中 也需要懒加载的组件的组件可以使用以下方式 1234567891011121314&lt;tempalte&gt; &lt;LazyLoad v-if=&quot;lazy&quot; /&gt;&lt;/tempalte&gt;&lt;script&gt;const LazyLoad = () =&gt; import(&quot;./LazyLoad.vue&quot;)export default &#123; data() &#123; return &#123; lazy: false &#125; &#125;&#125;&lt;/script&gt; vue 在内部做过处理，只有当 lazy = true， 需要渲染 LazyLoad 组件时，才会加载对应资源 React 路由懒加载 React.lazy 和 import 结合，使用的时候可以用 Suspense 组件包裹起来，可以在加载组件的时候提供占位效果 12345678910111213import React, &#123; Suspense &#125; from &#x27;react&#x27;;const OtherComponent = React.lazy(() =&gt; import(&#x27;./OtherComponent&#x27;));function MyComponent() &#123; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;Loading...&lt;/div&gt;&#125;&gt; &lt;OtherComponent /&gt; &lt;/Suspense&gt; &lt;/div&gt; );&#125; 通过以上操作，我们可以极大减少首屏加载所需要的资源大小，提高页面加载速度 Tree Shaking tree shaking 是一个术语，通常用于描述移除 JavaScript 上下文中的未引用代码。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。这个术语和概念实际上是兴起于 ES2015 模块打包工具 rollup。 使用了 tree shaking后， 如果一段代码我们并没有通过 import 方式引入，这段代码在打包的时候就不会打包进去，但是这个时候也会出现其他问题，因为在迭代过程中，可能之前我们引入了一些资源，但这些资源在后期迭代的过程中不在使用了，但是并没有从代码中移除，这个时候，这些资源也会被打包到代码中，并且项目越大，这种问题出现的几率越大。 因此webpack 扩展了这个检测能力，主要通过 package.json 的 sideEffect 属性来标记 当我们把 sideEffect 设置为 false 时， 代表所有的代码都不包含副作用，告诉 webpack 可以安全的删除所有的未使用的 export 导出。 如果部分代码存在副作用，我们通过一个数组来过滤掉这部分存在副作用的代码。 123456789101112&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: false&#125;&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot; ]&#125; 我在对 vue 项目进行代码 treeshaking 的时候遇到过这样一个问题，打包没有问题，但是发到测试环境后看，页面样式发生了混乱，推测是 可能是由于 vue 文件进行 treeshaking 时，所以 就把 vue 文件标为 副作用文件，不进行treeshaking 12345678&#123; &quot;version&quot;: &quot;1.0.0&quot;, &quot;sideEffect&quot;: [ &quot;./src/tool/effect.js&quot;， &quot;*.vue&quot;, &quot;*.less&quot; ]&#125; gzip 压缩 资源在经过网关的时候可以开启 gzip 压缩，使用了 gzip 后，静态文件可以被压缩 3 - 10 倍左右 经过以上操作，可以极大减少用户请求页面加载资源大小，减少服务器带宽压力 页面渲染阶段在页面渲染阶段 主要是用户让用户能够更快的看到页面，以及可操作，所以这个阶段就需要我们根据需求调整 资源加载 及 js 执行时间长度 延迟加载资源 对于部分第三方组件，例如支付，广告这些全局共用的js，可以等到使用的时候再去加载 从产品设计方面 针对部分阻塞页面加载及用户操作的资源可以通过用户的主动操作触发，而非页面一加载就执行 用户操作过程再用户操作过程中，可能有些操作会需要大量计算，由于浏览器是单线程操作，长时间的计算将会阻止用户操作，造成页面出现卡顿的现状,我们可以通过采用分段计算和优化计算消毒，或者采用替代方法。 使用全局加载动画，告诉用户当前属于什么状态。 canvas.toDataURL 可以采用 canvas.toBlob 方法替代（如果有使用的话） setTimeout， setInterval， requestAnimationFrame 等方式实现异步操作","updated":"2023-02-24T14:20:06.000Z","categories":[{"name":"performance","slug":"performance","permalink":"https://lxx1997.github.io/categories/performance/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"performance","slug":"performance","permalink":"https://lxx1997.github.io/tags/performance/"}]},{"title":"SPA-prerender","path":"2022/04/23/web/SPA-prerender/","text":"由于单页面应用只生成了一个HTML 文件，如果想要做 SEO 的话， H 标签，img 标签的 alt 这些并不会被爬虫抓取到，所以需要我们做预渲染，使得生成的html文件中包含需要 爬虫抓取的内容， react-snap 插件可以帮助实现这个操作 使用安装1yarn add --dev react-snap package.json123&quot;scripts&quot;: &#123;&quot;postbuild&quot;: &quot;react-snap&quot;&#125; 入口 (src/index.js)12345678import &#123; hydrate, render &#125; from &quot;react-dom&quot;;const rootElement = document.getElementById(&quot;root&quot;);if (rootElement.hasChildNodes()) &#123;hydrate(&lt;App /&gt;, rootElement);&#125; else &#123;render(&lt;App /&gt;, rootElement);&#125; 在使用 build 打包的时候，打包完成之后会执行我们添加的 postbuild 命令，然后将root下面的内容添加到 #root dom 里面，这样爬虫就可以从页面上抓取到关键词 问题 Q: 在日常发版过程中通常会采用自动化发版，我们公司采用的是 gitlab 的 CI/CD 环境进行发版，最后进行postbuild 操作的时候 发现无法预渲染，要怎么解决 A: 虚拟环境的话，可以采用 puppeteer 来模拟浏览器环境puppeteer 是 Node.js 的一个库可以用来模拟 chrome 环境1234// gitlab-ci.ymlapt-get install -yq gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget #install dependencies for puppeteer, which is a dependency for react-snapsh ./bash.sh #運行自定義腳本以更改 react-snap 上的選項以使其工作運行自定義腳本以更改 react-snap 上的選項以使其工作1234# bash.sh# modifies react-snap defaultOptions to add the --no-sandbox and --disable-setuid-sandbox flags so that puppeteer/chromium can run in the codebuild standard imagesed -i &quot;s/puppeteerArgs: \\[\\],/puppeteerArgs: \\[\\&quot;--no-sandbox\\&quot;, \\&quot;--disable-setuid-sandbox\\&quot;\\],/&quot; ./node_modules/react-snap/index.jsecho changed arguments in react-snap 123456789101112131415161718192021&quot;reactSnap&quot;: &#123; &quot;include&quot;: [ // 需要进行预渲染的页面 &quot;/prerender.html&quot;, ], &quot;puppeteerArgs&quot;: [ &quot;--no-sandbox&quot;, &quot;--disable-setuid-sandbox&quot;, &quot;--disable-web-security&quot; // 允许 接口跨域进行请求 ], &quot;viewport&quot;: &#123; // 预渲染的页面宽高，可以控制移动端适配和web端适配 &quot;width&quot;: 1400, &quot;height&quot;: 850 &#125;, &quot;userAgent&quot;: &quot;ReactSnap&quot;, // 环境，可以通过这个来区分是否是处于预渲染环境 &quot;crawl&quot;: false, &quot;concurrency&quot;: 1, &quot;inlineCss&quot;: false, &quot;removeStyleTags&quot;: true, &quot;skipThirdPartyRequests&quot;: false, &quot;puppeteerIgnoreHTTPSErrors&quot;: true&#125; Q: 页面存在国际化语言，页面再进行预渲染之后，在线上环境会出现文字先消失在出现的问题要怎么解决 A: 因为预渲染主要是把 页面渲染完成之后的内容重新写到html 里面，并不包含js文件，加载页面时，会去获取多语言文件，在多语言文件获取之前，通过key 去拿对应的文案时会获取不到，所以就变成了空白，文件加载完成之后，这个时候多语言文案就可以正常拿到了 可以采用先加载多语言文件再渲染页面的方式，或者再打包时就把对应多语言打包进去，放到window 对象上 12345678910111213loadLanguageJson(language).then(() =&gt; &#123; const rootElement:HTMLElement = document.getElementById(&quot;root&quot;)!; if (rootElement.hasChildNodes()) &#123; hydrate(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; else &#123; render(&lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, rootElement); &#125; &#125;)","updated":"2022-04-23T14:39:08.000Z","categories":[{"name":"SEO","slug":"SEO","permalink":"https://lxx1997.github.io/categories/SEO/"},{"name":"gitlab","slug":"gitlab","permalink":"https://lxx1997.github.io/categories/gitlab/"}],"tags":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"Javascript","slug":"Javascript","permalink":"https://lxx1997.github.io/tags/Javascript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SEO","slug":"SEO","permalink":"https://lxx1997.github.io/tags/SEO/"},{"name":"gitlab","slug":"gitlab","permalink":"https://lxx1997.github.io/tags/gitlab/"}]},{"title":"高性能JavaScript","path":"2022/03/26/reading/高性能JavaScript/","text":"最近读了一本关于如果写出性能更优的JavaScript的书，提取了一些相关的知识点 JavaScript 文件加载及执行我们都知道一个完整前端页面想要展示出来，需要包含 html， css，和JavaScript 文件，其中 html 是框架，css是样式，JavaScript负责交互。但是多数浏览器采用单一进程来处理用户界面ui和JavaScript脚本执行，同一时刻只能做一件事，所以JavaScript执行的时间越久浏览器等待的时间就会越久 浏览器页面在获取到页面时首先会先解析html元素，在解析的过程中，如果遇到css文件或者js文件的时候会去下载文件，下载完成之后然后再去解析文件，但是针对JavaScript文件来说，其实浏览器并不知道js有没有执行改变页面元素的操作，因此浏览器在下载和解析文件的时候，其实是一个暂停的操作，所以当 js 文件执行时间越久，页面空白的时间就越长 解决方式： 将script 脚本尽量放在页面的最下方，保证页面解析完成之后才回去解析JavaScript脚本 针对script 脚本的数量做限制，每遇到一个script标签，浏览器都会停止其他操作去解析script脚本,而script脚本越大，下载时间越长，数量越多，http链接的额外请求的消耗越大。 script 标签的async 属性和 defer 属性，async 属性可以让资源在下载过程中不阻塞浏览器的解析，当下载完成之后在解析脚本文件，defer 属性则是延迟加载 script 文件，当页面解析完成之后才会去加载脚本文件 动态加载脚本文件。对于首屏加载不需要的脚本文件，我们可以在使用的时候再去加载文件。我们可以动态创建script标签，当js文件加载完成之后，再把script标签 append 到html文档中 数据存储方式JavaScript中有四种基本数据存储位置 字面量 字面量代表自身，不存储在特定位置，JavaScript中的字面量有字符串、数字、布尔值、对象、数组、函数、正则表达式、null、undefined 本地变量 开发人员使用关键字 var，let const 定义的数据存储单元 数组元素 存储在JavaScript数组对象内部，以数字作为索引 对象成员 存储在JavaScript对象内部，以字符串作为索引 大多数情况下，从字面量和本地变量存取数据性能是微不足道的，访问数组元素和对象成员的代价则高一些 作用域作用域决定了那些数据能够被访问，作用域内的每个对象都被成为一个可变对象，每个对象以键值对的形式存在，当函数创建后，作用域链就会被创建此函数的作用域中科访问的数据对象所填充，在函数内部表现为 [[Scope]] 属性 函数在被执行的时候，就会创建一个执行环境，函数每次执行时对应的执行环境都是独一无二的，同时调用一个函数会创建多个执行环境，函数调用完成后，执行环境就会被销毁 函数的作用域链是以栈的形式存在的，当一个函数被创建时，会创建一个局部作用域放到栈的顶端，当函数执行完成后，作用域会从栈顶删除，当在函数中想要寻找一个变量时，执行环境会沿着作用域链向下寻找，最后到全局作用域，如果找到了变量，就返回变量所存储的内容，否则返回 undefined 因此如果我们查找的对象在作用域链中越深，查找就越耗费时间，因此我们可以在函数的局部作用域链中，创建一个新的变量来存储我们查找的对象 使用 with 和 try...catch... 方法可以修改函数的作用域链对象，但是实际并不推介这样做 闭包 闭包时 JavaScript 最强大的特性之一，它允许函数访问余部作用域链之外的数据，但是频繁的使用闭包有可能会造成问题。 平时我们使用函数时，会创建一个局部作用域，当函数执行完成后，这个局部作用域会被删除，但是由于引入了闭包，引用依然存在，导致这个局部作用域无法被销毁掉，造成了更多的内存开销，造成内存泄漏 对象 JavaScript的对象是基于原型，原型定义并实现了一个新创建的对象所必须包含的成员泪飙，原型对象为所有对象实例共享。 因此对象中有两种成员类型：实例成员和原型成员，可以用 hasOwnProperty 方法来判断对象是否包含特性的实例成员 当我们存取对象的属性或者方法时，会先查找对象的实例成员是否存在，如果不存在，则会沿着原型链进行查找，因此，对象在原型链存在的位置越深，查找起来越慢 因此我们要学会缓存对象成员的值，尽量避免在同一个函数中多次读取同一个实验对象 DOM对象DOM 是浏览器对象，是浏览器提供给JavaScript用于访问文档中的数据API,由于javascript和dom两个相互独立的功能只能通过接口彼此连接，因此会产生消耗。 我们每一次访问或者修改dom属性都会产生性能消耗，因此我们可以减少DOM的访问次数，把大部分的运算留在 ECMAScript 这一端 innerHTML 和 DOM方法 innerHTML相对来说要快一点，因为它在绝大部分浏览器中都运行的很快，但是对于大部分的日常操作而言，并没有太大区别，我们更应该根据可读性，稳定性，团队习惯和代码风格来综合决定使用哪种方式 HTML集合 document.getELementsByName() document.getELementsByClassName() document.getELementsByTagName() document.images document.links document.forms 这些集合的长度会随着页面元素的变动而变动，所以我们不能简单的使用集合的长度来作为判断，我们可以把集合拷贝一个普通数组，在普通数组上进行操作 在方位内集合属性可以采用局部变量的方式存储集合元素的部分属性，避免多次重复读取，浪费性能 重绘和重排 引起重绘的方法： 元素的颜色等非几何属性发生变化 引起重排的方法： 添加或者删除可见dom元素 元素的位置发生改变 元素的几何尺寸发生变化 内容发生改变 页面初始化 浏览器窗口改变以上这些改变都会造成浏览器需要重新计算页面元素的位置，而重绘则不需要重新计算页面元素位置，重排一定会引起重绘，但是重绘不一定会引起重排 我们在操作页面元素时，要尽量减少页面重绘及重排次数，每一次重排都需要大量的计算，消耗浏览器性能，可以将多次重绘重排整合成一次进行操作 将页面元素变为不可见元素，在修改元素的属性，此时只需要发生两次重排 使用 文档碎片在DOM外创建子树再拷贝回文档 拷贝元素，修改副本，在替换原始元素 浏览器尝试通过队列化修改和批量执行的方式最小化重排次数，当你查询布局信息时，比如偏移量，滚动位置，浏览器为了返回最新的值，会刷新队列并应用所有变更，因此我们可以设置局部变量用来存储布局信息，避免重复获取 使用事件委托 当页面存在大量需要一次或者多次绑定事件的元素，会占用更多的内存，我们可以事件委托，只需要在外层元素绑定一个处理器，就可以处理起子元素上的所有事件 算法及流程控制 减少迭代的工作量，对于常用且不便的数据进行缓存处理 减少迭代次数（达夫设备：循环展开技术，使得一次迭代中实际执行力多次迭代） 优化if...else...语句，最常用的判断放在最前面，这样可以减少对比次数 递归操作，根据情况缓存每一次递归操作的值 使用对象或者数组来缓存数据 快速响应的用户界面 任何javascript任务都不应当执行超过 100 ms 过长的运行时间会导致UI更新出现明显的延迟，从而对用户的体验造成负面影响 使用定时器来安排代码的延迟执行，把长时间运行脚本分解成一系列的小任务 使用web worker 开启新的 javascript线程","updated":"2022-03-26T14:21:26.000Z","categories":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/categories/reading/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/tags/reading/"}]},{"title":"服务端 渲染 - nextjs","path":"2021/09/14/web/ssr-nextjs-01/","text":"初始化项目123npx create-next-app# oryarn create next-app 如果想要添加特殊配置有以下选择 --ts，--typescript 使用TypeScript -e，--example [name][github-url]使用样例 --example-path --use-npm 应用页面路由 Routernextjs 路由匹配规则 /pages/example.js | /pages/example/index.js 匹配路由 /example /pages/example/[id].js 匹配路由 /example/1 /pages/example/[...args].js 匹配路由 /example/1/2.../n /pages/example/[[...args]].js 匹配路由 /example/.../n 12345678// /example/[id].js// 路由为 /example/1import &#123; useRouter &#125; from &quot;next/dist/client/router&quot;;const Index = (): JSX.Element =&gt; &#123; const router = useRouter() const query = router.query // &#123;id: 1&#125;&#125;","updated":"2021-09-14T14:31:56.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"SSR","slug":"SSR","permalink":"https://lxx1997.github.io/tags/SSR/"},{"name":"nextJs","slug":"nextJs","permalink":"https://lxx1997.github.io/tags/nextJs/"},{"name":"React","slug":"React","permalink":"https://lxx1997.github.io/tags/React/"}]},{"title":"threeJs 学习之路 - API 及 参数传递","path":"2021/08/15/frame/threeJs-study-api/","text":"THREE.Scene() 创建场景对象方法 add 添加物体，会被添加到坐标为 (0, 0, 0)的位置上 THREE.PerspectiveCamera() 这个对象是 threeJs 中相机的其中一种 透视摄像机参数有四个 视野角度 表示在显示器上看到的场景的范围，值是一个角度（值会 mod 360） 长宽比 长宽比的值会影响我们渲染物体的是否是正常的还是拉伸的，压扁的 远剪切面 近剪切面 物体所在的位置比摄像机的远剪切面远或者所在位置比近剪切面近的时候，该物体超出的部分将不会被渲染到场景中，根据我们渲染的物体的z轴的值和摄像机的z轴位置来决定的 THREE.WebGLRenderer() 创建一个渲染器实例属性 domElement 渲染器生成的dom元素，通过 appendChild 方法插入到页面中 setSize(width, height, updateStyle) 第二个参数决定是否以较低的分辨率来渲染 render(scene, camera) 渲染场景和摄像机","updated":"2023-03-15T03:48:08.305Z","categories":[],"tags":[]},{"title":"threeJs 学习之路 - 创建画布及绘制图形","path":"2021/08/15/frame/threeJs-study-01/","text":"因为threeJs 版本在不断更新，所以本文可能部分 api 被替换，如果出现问题，请百度或者查找官方文档对应api 初始化引入引入的话可以采用 npm 引入 或者直接通过 CDN 方式引入 npm 引入 123456npm install three// 引入const THREE = require(&quot;three&quot;)import THREE from &quot;three&quot; CDN 方式引入 CDN地址 1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/three.js/r128/three.js&quot;&gt;&lt;/script&gt; 创建画布 12345678910// 创建场景const scene = new THREE.Scene()// 创建一个摄像机const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 1000)// 实例化渲染器const renderer = new THREE.WebGLRenderer()// 设置渲染大小renderer.setSize(window.innerWidth, window.innerHeight)renderer.render(scene, camera)document.body.appendChild(renderer.domElement) 编写完上述代码后应该会出现一个黑色区域，这个就是threeJs创建的 canvas 画布 绘制元素绘制一个正方体 创建一个立方体 需要一个 BoxGeometry 对象，这个对象包含了立方体所有的定点(vertices)和面(faces) 然后对于这个立方体给一个材质，这里我们采用 MeshBasicMaterial 方法，并设置一个默认颜色 接下来需要一个网格（Mesh），这个网格包含了 几何体及其材质的对象，然后通过 Scene 中的 add 方法添加到页面上，如果与摄像机重叠，还需要移动摄像机的位置 最后通过 WebGLRenderer 的 render 方法渲染 如果想要动起来，这个时候需要我们更改摄像机或者立方体的位置,并通过定时器函数，重新渲染 123456789101112131415161718var geometry = new THREE.BoxGeometry()var material = new THREE.MeshBasicMaterial(&#123;color: 0x00ff00&#125;)let cube = new THREE.Mesh(geometry, material)camera.position.z = 5// scene 为之前创建的 THREE.Scene() 实例scene.add(cube)// renderer.render(scene, camera)function render() &#123; requestAnimationFrame(render) // 立方体旋转 旋转速度 cube.rotation.x += 0.1 cube.rotation.y += 0.1 // 修改摄像机的位置 // camera.position.set(x, y, z) renderer.render(scene, camera)&#125;render() 绘制线条 对于绘制线条 我们可以选择的材质只有 LineBasicMaterial 和 LineDashedMaterial 定义好材质之后，我们需要一个带有定点的 Geometry 或者 BufferGeometry 然后通过 THREE.Vector3(x, y, z) 定义线条的顶点，线条是画在连续的顶点之间的 最后 通过 THREE.Line(geometry, material) 将材质和顶点联系起来 123456789101112// LineDashedMaterial 创建 虚线性的 线条// LineBasicMaterial 创建 实线线条const material = new THREE.LineDashedMaterial(&#123;color: 0x0000ff&#125;)const points = []// 创建 3d 线条的各个顶点points.push(new THREE.Vector3(-10, 0, 20))points.push(new THREE.Vector3(0, 10, 20))points.push(new THREE.Vector3(10, 0, 20))// 通过 setFromPoints 设置线条的顶点const geometry = new THREE.BufferGeometry().setFromPoints(points)// 创建线条治理const line = new THREE.Line(geometry, material)","updated":"2021-08-15T01:38:18.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"threeJs","slug":"threeJs","permalink":"https://lxx1997.github.io/tags/threeJs/"},{"name":"webgl","slug":"webgl","permalink":"https://lxx1997.github.io/tags/webgl/"}]},{"title":"JavaScript 设计模式联系  -  创建型设计模式","path":"2021/06/14/web/design-parttern-01/","text":"简单工厂模式 简单工厂模式(Simple Factory) 又叫静态工厂模式，由一个工厂对象决定创建摸一种产品对象类的实例 简单工厂模式的理念就是创建对象，提取多个类似需求中相同部分，针对不同的地方进行特殊处理 1234567891011121314151617181920function factory(object) &#123; const Factory = new Object() // 相同的部分 Factory.name = object.name Factory.age = object.name // 不同的部分 switch(object.type) &#123; case &#x27;type1&#x27;: // 特殊处理 break; case &#x27;type2&#x27;: // 特殊处理 break; default: break; &#125; return Factory&#125; 工厂方法模式 工厂方法模式(Factory Methods) 通过对产品类的抽象使其创建业务，主要负责用于创建多累产品的实例 工厂方法模式的本意是将时间创建对象工作推迟到了子类当中，这样核心类就成为了抽象类，在使用工厂方法模式时，需要使用安全策略来防止我们每次获取到的不是想要的对象 安全策略1234567function Factory() &#123; if(this instanceof Factory) &#123; return this &#125; else &#123; return new Factory() &#125;&#125; 通过以上代码在实例化对象的时候判断一下是否是创建对象实例，如果不是则返回一个新的实例，以便能获取到预期的对象 工厂方式模式代码1234567891011121314151617function Factory(type, content) &#123; if(this instanceof Factory) &#123; return this[type](content) &#125; else &#123; return new Factory(type, content) &#125;&#125;Factory.prototype.Car = &#123;&#125;Factory.prototype.Pat = &#123; &#125;Factory.prototype.Clothes = &#123; &#125; 抽象工厂模式 抽象工厂模式(Abstract Factory) 通过对类的工厂抽象使其业务用于产品类簇的创建，而不是创建某一类产品的实例 抽象类工厂其实是实现子类继承父类的方法，我们需要通过传递子类以及要继承父类的名称，并且在抽象工厂方法中增加一次对抽象类存在性的判断，如果存在，子类继承父类的方法。子类继承了父类的所有的属性和方法，如果子类中没有方法或者属性覆盖父类方法，当调用的时候，会直接返回父类的属性和方法。 抽象类工厂的主要作用是，当子类调用了自己本身不存在且不需要的方法是，会给予提示 12345678910111213141516171819202122232425262728293031323334353637function Abstract(child, parent) &#123; if(typeof Abstract[parent] === &#x27;function&#x27;) &#123; // 定义一个空的父类 function F() &#123;&#125; F.prototype = new Abstract[parent]() child.constructor = child child.prototype = new F() &#125; else &#123; throw new Error(&#x27;未找到改抽象类&#x27;) &#125;&#125;Abstract.Car = function() &#123; this.type = &#x27;car&#x27;&#125;Abstract.Car.prototype = &#123; getName: function () &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;, getPrice: function() &#123; throw Error(&#x27;抽象类方法无法调用&#x27;) &#125;&#125;function Aodis() &#123; this.name = &#x27;aodi&#x27; this.price = 12312&#125;Abstract(Aodis, &#x27;Car&#x27;)console.log(Aodis)Aodis.prototype.getName = function() &#123; console.log(this.name)&#125;const aodi = new Aodis()aodi.getName()aodi.getPrice() 抽象类 抽象类是一种声明了但是无法使用的类，当你调用抽象类的方法时就会报错，我们可以手动在类型的方法中进行错误提示 123456789function Abstract() &#123;&#125;Abstract.prototype = &#123; getName() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;, getPrice() &#123; console.log(&#x27;抽象方法无法使用！！！&#x27;) &#125;&#125; 当我们通过继承或者直接使用的方式来调用抽象类中方法时，会直接抛出错误","updated":"2021-06-14T10:25:20.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"记一次在面试过程中遇到的 promise 编程题","path":"2021/04/01/interview/面试-题解/","text":"当时面试的时候遇到了这两个函数编程题，但是该死的是完全没有思路(悲伤) 利用 Promise 完成一个队列，队列中的任务数满了的话，后续任务不执行，当队列中的任务有完成的状态，才会添加新的任务进入队列 利用 Promise 完成一个 retry 函数，传入一个执行函数和一个计数器，在一定次数范围内，如果函数执行失败的话会再次尝试执行该函数，直到执行成功 面试结束之后，我上网上搜索了一下类似的问题，接下来是我总结之后的思路，以及最后成功的代码 Promise 队列 这个问题有以下几个重点 队列： 存放未执行的任务队列 计数器： 存放当前正在执行的任务数量 任务执行最大数量 添加任务函数 执行任务函数 接下根据我们上述描述的重点来创建一个任务队列执行类 1234567891011121314class Scheduler &#123; // 初始化任务队列，以及根据传入的数量来限制最大执行数量 constructor(maxCount) &#123; this.maxCount = count this.list = [] this.count = 0 &#125; add() &#123; &#125; start() &#123; &#125;&#125; 接下我们就要来编写添加函数了，在写添加函数之前我们首先思考一下这个添加函数里面应该注意那些东西 首先，如果我们想要在任务执行完成之后对执行结果操作的话，这个 add 函数必须返回一个 promise 函数 12345add(task) &#123; return new Promise(resolve =&gt; &#123; resolve() &#125;)&#125; 添加一个任务的时候，我们需要把这个任务添加到未执行的任务队列的存放起来 1234567add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(task()) &#125;) &#125;)&#125; 这个时候就出现了一个问题，我们应该怎样监控这个任务是否已经执行完成，这个时候 promise 的作用就来了，我们在 then 中就可以判断到函数是否执行成功 123456789add(task) &#123; return new Promise(resolve =&gt; &#123; resolve(() =&gt; &#123; this.list.push(Promise.resolve(task()).then()) // 如果 task 执行之后的返回值是一个promise对象则可以修改成以下形式 // this.list.push(task().then()) &#125;) &#125;)&#125; 添加函数先写到这里，然后我们来写执行函数，在start函数中我们需要做的就是判断一下正在执行任务数是否小于最大执行数，然后从待执行队列中取出一个任务并执行，然后将正在执行的任务数加上1 123456start() &#123; if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list.shift()() &#125;&#125; 接下来修改 add 函数 为当我们添加一个任务时，在最后执行一下执行函数，在执行任务完成之后，减少执行队列数，并触发执行函数，最后把任务的返回值 return 出来 123456789101112add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;)&#125; 接下来实例化任务队列，并创建一个异步执行方法和一个添加任务函数 123456789101112let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Scheduler &#123; constructor(count) &#123; this.list = [] this.maxCount = count this.count = 0 &#125; add(task) &#123; return new Promise(resolve =&gt; &#123; this.list.push(() =&gt; &#123; resolve(Promise.resolve(task()).then(s =&gt; &#123; this.count-- this.start() return s &#125;)) &#125;) this.start() &#125;) &#125; start() &#123; console.log(this.count) if(this.count &lt; this.maxCount) &#123; this.count++ this.list[0] &amp;&amp; this.list[0]() this.list.shift() &#125; &#125;&#125;let scheduler = new Scheduler(5)let timeout = (time) =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time) &#125;)&#125;let addTask = function addTask(time, order) &#123; scheduler.add(() =&gt; timeout(time)).then(() =&gt; &#123; console.log(time, order) &#125;)&#125;addTask(5000,&#x27;1&#x27;)addTask(1100,&#x27;2&#x27;)addTask(2200,&#x27;3&#x27;)addTask(3300,&#x27;4&#x27;)addTask(3300,&#x27;5&#x27;)addTask(3300,&#x27;6&#x27;)addTask(3300,&#x27;7&#x27;)addTask(2200,&#x27;8&#x27;) Promise retry 函数 function retry(fun, count) { if(count === 0) return let val = fun() if(val &gt; 3) { return val } else { return retry(fun, –count) }} function random() { return Math.random() * 5}console.log(retry(random, 5)) 这个问题现在看起来挺简单的，但是当时估计相差了，思路都理解错了，难受","updated":"2021-04-01T08:25:13.000Z","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://lxx1997.github.io/tags/interview/"},{"name":"promise","slug":"promise","permalink":"https://lxx1997.github.io/tags/promise/"}]},{"title":"JavaScript - 手写一个 Promise 方法","path":"2021/03/18/web/js-promise/","text":"ES6新增了一个用于处理异步操作数据的一个原生API，能够解决回调地狱的产生 常用的方法 Promise.resolve() Promise.reject() Promise.then() Promise.catch() Promise.finally() Promise.all() Promise.race() Promise.allSettled() Promise.any() 接下来我们来使用代码来实现这些操作 实现Promise 首先我们在创建 Promise 实例，会传入两个函数用来表示成功的回调以及失败的回调，然后我们可以设计 Promise 类中的内容大概是这个样子的 12345678910111213141516171819202122232425262728293031const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125;,4) &#125; reject(value) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;) &#125;&#125; 这样就实现了一个简单的Promise方法，并且更改状态之后就不可以在修改状态了,并且用两个变量来接收resolve和reject两个方法传入的值 Promise.then 1234567891011121314151617181920Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; 调用 then 方法时判断一下传入的是否是函数，如果是函数就直接调用，并把成功的参数传入最后的 return this 则是为了实现链式结构 Promise.catch 12345678910111213141516171819Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125; Promise.finally 1234Promise.prototype.finally = function(fn) &#123; fn() return this&#125; Promise.resolve 1234Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125; 这个稍微有些麻烦，我们需要判断传入的 value 是不是 Promise 类型的，如果是就可以直接返回，然后调用 .then 等方法，否则就需要我们创建一个 Promise 实例并返回 Promise.reject 1234Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125; 但是这里还有许多需要注意的地方，例如Promise.then中如果有 return 的话则需要以返回的状态和值为主，如果没有,就以上一次的状态和值为主同时还需要对代码使用 try...catch... 进行容错处理，使得在 catch 中能够拿到错误信息 代码修改如下12345678910111213141516171819Promise.prototype.then = function(resolve, reject) &#123; try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125;&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125; 实现Promise高级语法 Promise.all 12345678910111213141516171819202122232425262728Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; // 保证数组顺序返回正确 resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; Promise.race 1234567891011121314151617181920212223242526272829Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) break; &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; promise.allSettled 123456789101112131415161718192021222324252627282930313233343536373839404142Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125; 这些代码中还是有很多的bug 全部代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178const PANDING = &#x27;panding&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class Promise &#123; constructor(fn) &#123; this.state = PANDING this.resolveVal = null this.rejectVal = null fn(this.resolve.bind(this), this.reject.bind(this)) &#125; resolve(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = FULFILLED this.resolveVal = value || this.resolveVal &#125; reject(value) &#123; if(this.state !== PANDING) &#123; return &#125; this.state = REJECTED this.rejectVal = value || this.rejectVal &#125;&#125;Promise.resolve = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve) =&gt; &#123;resolve(value)&#125;)&#125;Promise.reject = function(value) &#123; if(value instanceof Promise) return value return new Promise((resolve, reject) =&gt; &#123;reject(value)&#125;)&#125;Promise.all = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let isReject = false for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; resolveVal[i] = res1 &#125;).catch(err =&gt; &#123; reject(err) isReject = true &#125;) &#125; else resolveVal.push(res) if(isReject) break &#125; resolve(resolveVal) &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.race = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; if(arr.length === 0) resolve() for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolve(res) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; reject(err) &#125; &#125;) &#125; else &#123; resolve(res) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.allSettled = function(arr) &#123; try &#123; if(arr instanceof Array) &#123; return new Promise((resolve, reject) =&gt; &#123; let resolveVal = [] let length = 0 if(arr.length === 0) resolve([]) for(let i = 0; i &lt; arr.length; i++) &#123; let res = getReturn(arr[i]) if(res instanceof Promise) &#123; res.then(res1 =&gt; &#123; if(res1) &#123; resolveVal[i] = &#123; status: FULFILLED, value: res1 &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;).catch(err =&gt; &#123; if(err) &#123; resolveVal[i] = &#123; status: REJECTED, value: err &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125;) &#125; else &#123; resolveVal[i] = &#123; status: FULFILLED, value: res &#125; if(++length === arr.length) resolve(resolveVal) &#125; &#125; &#125;) &#125; else throw new Error(&#x27;Promise.all must receive Array&#x27;) &#125; catch (error) &#123; if(error instanceof Error) throw error return Promise.reject(error) &#125;&#125;Promise.prototype.then = function(resolve, reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; let success = null let fail = null // 判断 传入参数的类型并绑定this typeof resolve === &#x27;function&#x27; &amp;&amp; (success = getReturn(resolve.call(this, this.resolveVal))) typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(success) return Promise.resolve(success) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.catch = function(reject) &#123; let s = setInterval(() =&gt; &#123; if(this.state !== PANDING) &#123; s &amp;&amp; clearInterval(s) try &#123; try &#123; let fail = null typeof reject === &#x27;function&#x27; &amp;&amp; (fail = getReturn(reject.call(this, this.rejectVal))) if(fail) return Promise.resolve(fail) return this &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; catch (error) &#123; return Promise.reject(error) &#125; &#125; &#125;,4)&#125;Promise.prototype.finally = function(fn) &#123; fn() return this&#125;function getReturn(val) &#123; if(typeof val === &#x27;function&#x27;) return val() return val&#125;","updated":"2021-03-18T05:15:52.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"浅浅的剖析一下 Vue 的执行顺序","path":"2021/02/08/vue/vue-learn-api-with-源码-implement/","text":"定义 Vue 构造函数1234567891011121314151617181920212223import &#123; initMixin &#125; from &#x27;./init&#x27;import &#123; stateMixin &#125; from &#x27;./state&#x27;import &#123; renderMixin &#125; from &#x27;./render&#x27;import &#123; eventsMixin &#125; from &#x27;./events&#x27;import &#123; lifecycleMixin &#125; from &#x27;./lifecycle&#x27;import &#123; warn &#125; from &#x27;../util/index&#x27;function Vue (options) &#123; if (process.env.NODE_ENV !== &#x27;production&#x27; &amp;&amp; !(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;) &#125; this._init(options)&#125;initMixin(Vue)stateMixin(Vue)eventsMixin(Vue) lifecycleMixin(Vue)renderMixin(Vue)export default Vue 定义了 一个 Vue 构造函数，这个构造函数传入的参数是 options，使用的时候通过 new 关键字来创建实例，然后调用了 _init 方法 根据传入的 options 配置来初始化 Vue 实例 初始化 initMixin1234567891011121314151617181920212223242526272829303132333435363738394041424344var uid$3 = 0;Vue.prototype._init = function (options) &#123; var vm = this; vm._uid = uid$3++; var startTag, endTag; // 是否记录 性能 if (config.performance &amp;&amp; mark) &#123; startTag = &quot;vue-perf-start:&quot; + (vm._uid); endTag = &quot;vue-perf-end:&quot; + (vm._uid); mark(startTag); &#125; vm._isVue = true; if (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; &#123; initProxy(vm); &#125; vm._self = vm; initLifecycle(vm); initEvents(vm); initRender(vm); callHook(vm, &#x27;beforeCreate&#x27;); initInjections(vm); // resolve injections before data/props initState(vm); initProvide(vm); // resolve provide after data/props callHook(vm, &#x27;created&#x27;); if (config.performance &amp;&amp; mark) &#123; vm._name = formatComponentName(vm, false); mark(endTag); measure((&quot;vue &quot; + (vm._name) + &quot; init&quot;), startTag, endTag); &#125; if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 通过上述代码，我们可以看到 Vue 在初始化的时候主要做了以下几件事 创建 Vue 实例 唯一标识符 _uid 根据 config 配置判断是否开启 性能监控 performance 设置 Vue 标识符 _isVue 为 true 代表当前实例是 Vue 实例 通过 option 的 _isComponents 属性判断当前 Vue 实例是否是组件，如果是组件就调用 initInternalComponent 函数，不是组件就调用 mergeOptions 方法，并将返回的参数赋予 Vue 实例的 $options 属性 调用 initProxy 方法，判断 proxy 代理是否存在，如果存在，使用 proxy 对 Vue 实例进行响应式监控和代理 设置 Vue 的 _self 属性 为自身实例 调用 initLifecycle 函数 初始化生命周期 调用 initEvents 方法 初始化事件对象 调用 initRender 方法 初始化渲染使用的方法 slot, scopedSlots, createElement, _c方法，并对 $attrs,$listeners 方法进行进行数据响应式处理 调用 beforeCreate 生命周期，由于此时 还没有任何数据或者方法挂载到 Vue 实例上，所以 无法访问 调用 initInjections 方法 初始化 inject 属性 调用 initState 方法 初始化 data,props,methods,computed,watch 属性，设置数据响应式处理，及将属性挂载到 Vue 实例上 调用 initProvide 方法 初始化 provide 属性 调用 created 生命周期，此时可以访问到 inject,data,props,methods,computed上属性的值 调用 $mount 方法 获取 元素节点 el 判断是否传入 render 函数，没有就初始化一个空 DOM 节点 调用 beforeMount 生命周期 设置 组件变化的监听方法，监听组件是否更新 设置 Vue 实例挂载状态为 true 调用 mounted 生命周期 stateMixin该函数主要针对 实例 $data, $props 进行数据响应式处理，不允许更新并且初始化实例 $set, $delete, $watch(并返回一个 撤销监听的方法) eventMixin初始化事件方法 $once, $on, $off, $emit lifecycleMixin初始化 _update, forceUpdate, destory 当组件发生更新操作或者卸载的时候会触发这些生命周期beforeUpdate, updated, beforeDestory, destoryed renderMixin在这个函数中 首先通过 installRenderHelpers 方法在 Vue 实例上注册了 协助渲染的函数 12345678910111213141516171819function installRenderHelpers (target) &#123; target._o = markOnce; // 定义静态节点 只渲染一次, v-once 指令 target._n = toNumber; // 转化为整型 target._s = toString; // 字符串转化 target._l = renderList; // 渲染 v-for 循环 target._t = renderSlot; // 渲染 slot target._q = looseEqual; // 判断 对象是否相等 target._i = looseIndexOf; // 获取 元素 在 数组中的位置 target._m = renderStatic; // 定义静态节点 只渲染一次, v-once 指令 target._f = resolveFilter; // 调用 filter 方法 target._k = checkKeyCodes; // 检查键盘事件 target._b = bindObjectProps; // 读取 元素的 attr 属性绑定到 props 上面 target._v = createTextVNode; // 创建 文本node 节点 target._e = createEmptyVNode; // 创建空节点 target._u = resolveScopedSlots; // 渲染 ScopedSlot target._g = bindObjectListeners; // 绑定事件函数到 on 方法上去 target._d = bindDynamicKeys; // 渲染传入 变量 的 attrs 属性 target._p = prependModifier; // 设置前置修饰符&#125; 然后初始化 $nextTick _render 解析 dom 元素并渲染(patch)Vue 再渲染 DOM 的时候即 mountComponent 方法中 会调用 _update 方法，并将 Vue 的 _render 函数的返回值 (一个 VNode 对象) 作为参数传入,第二个参数 hydrating 为 undefined 然后在 _update 方法中 通过 __patch__ 即 patch/createPatchFunction 方法渲染页面 我们来看一下 patch 方法做了哪些东西 12// vm.$el, vnodevar patch = createPatchFunction(&#123; nodeOps: nodeOps, modules: modules &#125;) 首先创造了 几个生命周期1var hooks = [&#x27;create&#x27;, &#x27;activate&#x27;, &#x27;update&#x27;, &#x27;remove&#x27;, &#x27;destroy&#x27;];","updated":"2021-02-08T03:02:00.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (八) - 指令","path":"2021/02/01/vue/vue-learn-api-with-源码-08/","text":"内置指令Vue 内置了以下几种指令 v-text v-html v-show v-if v-else v-else-if v-for v-on v-bind v-model v-slot v-pre v-cloak v-once 在源码中分为以下几种 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// v-html v-text v-modelvar directives$1 = &#123; model: model, text: text, html: html&#125;// v-on v-bind v-clockvar baseDirectives = &#123; on: on, bind: bind$1, cloak: noop&#125;;// v-if v-else v-else-iffunction processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// v-prefunction processPre (el) &#123; if (getAndRemoveAttr(el, &#x27;v-pre&#x27;) != null) &#123; el.pre = true; &#125;&#125;// v-for v-slotfunction processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// v-slotvar slotBinding = getAndRemoveAttrByRegex(el, slotRE);// v-oncefunction processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-showif (child.data.directives &amp;&amp; child.data.directives.some(isVShowDirective)) &#123; child.data.show = true;&#125; v-text / v-html123456789101112131415161718192021222324252627282930313233343536373839// dir 为 directive 中的 binding 属性/** arg: null end: 18 isDynamicArg: false modifiers: undefined name: &quot;text&quot; rawName: &quot;v-text&quot; start: 5 value: &quot;text&quot;*/function text (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;textContent&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;function html (el, dir) &#123; if (dir.value) &#123; addProp(el, &#x27;innerHTML&#x27;, (&quot;_s(&quot; + (dir.value) + &quot;)&quot;), dir); &#125;&#125;// addProp (当前元素实例, &#x27;textContent&#x27;, &#x27;_s(dir.value)&#x27;, dir, null)function addProp (el, name, value, range, dynamic) &#123; (el.props || (el.props = [])).push(rangeSetItem(&#123; name: name, value: value, dynamic: dynamic &#125;, range)); el.plain = false;&#125;// rangeSetItemfunction rangeSetItem (item, range) &#123; if (range) &#123; if (range.start != null) &#123; item.start = range.start; &#125; if (range.end != null) &#123; item.end = range.end; &#125; &#125; return item&#125; v-text 指令在 processAttrs 函数中 通过 addDirective 方法 添加一个 directive 属性，然后 通过 updateDOMProps 方法中的 elm[key] = cur 为 元素的 textContent 或者 innerHTML 属性赋值 12&lt;div v-text=&quot;text&quot;&gt;&lt;/div&gt;&lt;div v-html=&quot;text&quot;&gt;&lt;/div&gt; 注意：如果 v-text/v-html 指令所在的元素下的子元素，则不会被渲染 v-model123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function model (el, dir, _warn) &#123; warn$1 = _warn; var value = dir.value; var modifiers = dir.modifiers; var tag = el.tag; var type = el.attrsMap.type; &#123; // inputs with type=&quot;file&quot; are read only and setting the input&#x27;s // value will throw an error. if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;file&#x27;) &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot; type=\\&quot;file\\&quot;&gt;:\\n&quot; + &quot;File inputs are read only. Use a v-on:change listener instead.&quot;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; &#125; if (el.component) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else if (tag === &#x27;select&#x27;) &#123; genSelect(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;checkbox&#x27;) &#123; genCheckboxModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; &amp;&amp; type === &#x27;radio&#x27;) &#123; genRadioModel(el, value, modifiers); &#125; else if (tag === &#x27;input&#x27; || tag === &#x27;textarea&#x27;) &#123; genDefaultModel(el, value, modifiers); &#125; else if (!config.isReservedTag(tag)) &#123; genComponentModel(el, value, modifiers); // component v-model doesn&#x27;t need extra runtime return false &#125; else &#123; warn$1( &quot;&lt;&quot; + (el.tag) + &quot; v-model=\\&quot;&quot; + value + &quot;\\&quot;&gt;: &quot; + &quot;v-model is not supported on this element type. &quot; + &#x27;If you are working with contenteditable, it\\&#x27;s recommended to &#x27; + &#x27;wrap a library dedicated for that purpose inside a custom component.&#x27;, el.rawAttrsMap[&#x27;v-model&#x27;] ); &#125; // ensure runtime directive metadata return true&#125; v-model 指令主要针对于 input 输入框 及textarea 等需要输入或者状态变更的元素，v-model 相当于 v-bind:value + v-on:change 的组合体，在其他组件上不能使用 v-model v-show123456789101112131415161718192021222324// ref// def: &#123;bind: ƒ, update: ƒ, unbind: ƒ&#125;// expression: &quot;true&quot;// modifiers: &#123;&#125;// name: &quot;show&quot;// rawName: &quot;v-show&quot;// value: truebind: function bind (el, ref, vnode) &#123; var value = ref.value; vnode = locateNode(vnode); var transition$$1 = vnode.data &amp;&amp; vnode.data.transition; var originalDisplay = el.__vOriginalDisplay = el.style.display === &#x27;none&#x27; ? &#x27;&#x27; : el.style.display; console.log(ref,value, transition$$1) if (value &amp;&amp; transition$$1) &#123; vnode.data.show = true; enter(vnode, function () &#123; el.style.display = originalDisplay; &#125;); &#125; else &#123; el.style.display = value ? originalDisplay : &#x27;none&#x27;; &#125;&#125;, 取 ref.value 如果 v-show=&quot;false&quot; 则 ref.value 为 false 将 元素的display 属性设置为 null v-if/v-else/v-else-if123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 判断当前元素是否有 v-if，v-else， v-else-if 指令// 并将元素上的if,else,elseif 属性置为对应状态function processIf (el) &#123; var exp = getAndRemoveAttr(el, &#x27;v-if&#x27;); if (exp) &#123; el.if = exp; addIfCondition(el, &#123; exp: exp, block: el &#125;); &#125; else &#123; if (getAndRemoveAttr(el, &#x27;v-else&#x27;) != null) &#123; el.else = true; &#125; var elseif = getAndRemoveAttr(el, &#x27;v-else-if&#x27;); if (elseif) &#123; el.elseif = elseif; &#125; &#125;&#125;// 通过 addIfCondition 方法将 v-if 所在的元素放入 ifConditions 数组中function addIfCondition (el, condition) &#123; if (!el.ifConditions) &#123; el.ifConditions = []; &#125; el.ifConditions.push(condition);&#125;// markStatic$1if (node.ifConditions) &#123; for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 &lt; l$1; i$1++) &#123; var block = node.ifConditions[i$1].block; markStatic$1(block); if (!block.static) &#123; node.static = false; &#125; &#125;&#125;// genIfConditions 转换 IfConditions 中的元素function genIfConditions ( conditions, state, altGen, altEmpty) &#123; if (!conditions.length) &#123; return altEmpty || &#x27;_e()&#x27; &#125; var condition = conditions.shift(); if (condition.exp) &#123; return (&quot;(&quot; + (condition.exp) + &quot;)?&quot; + (genTernaryExp(condition.block)) + &quot;:&quot; + (genIfConditions(conditions, state, altGen, altEmpty))) &#125; else &#123; return (&quot;&quot; + (genTernaryExp(condition.block))) &#125; // v-if with v-once should generate code like (a)?_m(0):_m(1) function genTernaryExp (el) &#123; return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state) &#125;&#125; v-for 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// 判断是否含有 v-for 指令 然后通过 extend 方法将 parseFor 转出的参数扩展到 元素上function processFor (el) &#123; var exp; if ((exp = getAndRemoveAttr(el, &#x27;v-for&#x27;))) &#123; var res = parseFor(exp); if (res) &#123; extend(el, res); &#125; else &#123; warn$2( (&quot;Invalid v-for expression: &quot; + exp), el.rawAttrsMap[&#x27;v-for&#x27;] ); &#125; &#125;&#125;// 判断 for 循环function parseFor (exp) &#123; // 正则表达式匹配，循环数组是否正确 [exp, item, 10] var inMatch = exp.match(forAliasRE); if (!inMatch) &#123; return &#125; var res = &#123;&#125;; res.for = inMatch[2].trim(); // 针对 v-for=&quot;(item,index) in array&quot; 进行处理 去除 item / item,index var alias = inMatch[1].trim().replace(stripParensRE, &#x27;&#x27;); // 针对(item,index) in array 去除 , index var iteratorMatch = alias.match(forIteratorRE); if (iteratorMatch) &#123; res.alias = alias.replace(forIteratorRE, &#x27;&#x27;).trim(); res.iterator1 = iteratorMatch[1].trim(); if (iteratorMatch[2]) &#123; res.iterator2 = iteratorMatch[2].trim(); &#125; &#125; else &#123; res.alias = alias; &#125; // alias 对象别名 可以通过 alias 访问遍历数组的元素 // iterator1 遍历时第二个参数 return res&#125;// genFor 获取与 v-for 指令相关参数，调用 renderList 方法渲染数组function genFor ( el, state, altGen, altHelper) &#123; var exp = el.for; var alias = el.alias; var iterator1 = el.iterator1 ? (&quot;,&quot; + (el.iterator1)) : &#x27;&#x27;; var iterator2 = el.iterator2 ? (&quot;,&quot; + (el.iterator2)) : &#x27;&#x27;; if (state.maybeComponent(el) &amp;&amp; el.tag !== &#x27;slot&#x27; &amp;&amp; el.tag !== &#x27;template&#x27; &amp;&amp; !el.key ) &#123; state.warn( &quot;&lt;&quot; + (el.tag) + &quot; v-for=\\&quot;&quot; + alias + &quot; in &quot; + exp + &quot;\\&quot;&gt;: component lists rendered with &quot; + &quot;v-for should have explicit keys. &quot; + &quot;See https://vuejs.org/guide/list.html#key for more info.&quot;, el.rawAttrsMap[&#x27;v-for&#x27;], true /* tip */ ); &#125; el.forProcessed = true; // avoid recursion // 调用 renderList 方法 传入渲染函数 return (altHelper || &#x27;_l&#x27;) + &quot;((&quot; + exp + &quot;),&quot; + &quot;function(&quot; + alias + iterator1 + iterator2 + &quot;)&#123;&quot; + &quot;return &quot; + ((altGen || genElement)(el, state)) + &#x27;&#125;)&#x27;&#125;// rederListfunction renderList ( val, render) &#123; var ret, i, l, keys, key; if (Array.isArray(val) || typeof val === &#x27;string&#x27;) &#123; ret = new Array(val.length); for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i); &#125; &#125; else if (typeof val === &#x27;number&#x27;) &#123; ret = new Array(val); for (i = 0; i &lt; val; i++) &#123; ret[i] = render(i + 1, i); &#125; &#125; else if (isObject(val)) &#123; if (hasSymbol &amp;&amp; val[Symbol.iterator]) &#123; ret = []; // 利用 Symbol.iterator 方法 循环 对象val var iterator = val[Symbol.iterator](); var result = iterator.next(); while (!result.done) &#123; ret.push(render(result.value, ret.length)); result = iterator.next(); &#125; &#125; else &#123; keys = Object.keys(val); ret = new Array(keys.length); for (i = 0, l = keys.length; i &lt; l; i++) &#123; key = keys[i]; ret[i] = render(val[key], key, i); &#125; &#125; &#125; if (!isDef(ret)) &#123; ret = []; &#125; (ret)._isVList = true; return ret&#125; v-on 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980name = name.replace(onRE, &#x27;&#x27;);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);// addHandlerfunction addHandler (el,name,value,modifiers,important,warn,range,dynamic) &#123; modifiers = modifiers || emptyObject; // warn prevent and passive modifier /* istanbul ignore if */ if ( warn &amp;&amp; modifiers.prevent &amp;&amp; modifiers.passive ) &#123; warn( &#x27;passive and prevent can\\&#x27;t be used together. &#x27; + &#x27;Passive handler can\\&#x27;t prevent default event.&#x27;, range ); &#125; // normalize click.right and click.middle since they don&#x27;t actually fire // this is technically browser-specific, but at least for now browsers are // the only target envs that have right/middle clicks. if (modifiers.right) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;contextmenu&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;contextmenu&#x27;; delete modifiers.right; &#125; &#125; else if (modifiers.middle) &#123; if (dynamic) &#123; name = &quot;(&quot; + name + &quot;)===&#x27;click&#x27;?&#x27;mouseup&#x27;:(&quot; + name + &quot;)&quot;; &#125; else if (name === &#x27;click&#x27;) &#123; name = &#x27;mouseup&#x27;; &#125; &#125; // check capture modifier if (modifiers.capture) &#123; delete modifiers.capture; name = prependModifierMarker(&#x27;!&#x27;, name, dynamic); &#125; if (modifiers.once) &#123; delete modifiers.once; name = prependModifierMarker(&#x27;~&#x27;, name, dynamic); &#125; /* istanbul ignore if */ if (modifiers.passive) &#123; delete modifiers.passive; name = prependModifierMarker(&#x27;&amp;&#x27;, name, dynamic); &#125; var events; if (modifiers.native) &#123; delete modifiers.native; events = el.nativeEvents || (el.nativeEvents = &#123;&#125;); &#125; else &#123; events = el.events || (el.events = &#123;&#125;); &#125; var newHandler = rangeSetItem(&#123; value: value.trim(), dynamic: dynamic &#125;, range); if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers; &#125; var handlers = events[name]; /* istanbul ignore if */ if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler); &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler]; &#125; else &#123; events[name] = newHandler; &#125; el.plain = false;&#125; 修饰器 .stop 阻止默认事件 event.stopPropagation() .prevent 阻止默认事件 event.preventDefault() .capture 添加事件监听器使用 capture 模式 .self 只当事件从侦听器绑定的元素本身触发时才触发回调 .&#123;keyCode | keyAlias&#125; 只有特定键触发才会触发回调函数 .native 监听根元素的原生时间 .once 只触发一次回调 .left 点击鼠标左键触发 .right 点击鼠标右键触发 .middle 点击鼠标中键触发 .passive 以 &#123;passive: true&#125; 模式添加侦听器 v-bind 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566name = name.replace(bindRE, &#x27;&#x27;);value = parseFilters(value);isDynamic = dynamicArgRE.test(name);if (isDynamic) &#123; name = name.slice(1, -1);&#125;if ( value.trim().length === 0) &#123; warn$2( (&quot;The value for a v-bind expression cannot be empty. Found in \\&quot;v-bind:&quot; + name + &quot;\\&quot;&quot;) );&#125;if (modifiers) &#123; if (modifiers.prop &amp;&amp; !isDynamic) &#123; name = camelize(name); if (name === &#x27;innerHtml&#x27;) &#123; name = &#x27;innerHTML&#x27;; &#125; &#125; if (modifiers.camel &amp;&amp; !isDynamic) &#123; name = camelize(name); &#125; if (modifiers.sync) &#123; syncGen = genAssignmentCode(value, &quot;$event&quot;); if (!isDynamic) &#123; addHandler( el, (&quot;update:&quot; + (camelize(name))), syncGen, null, false, warn$2, list[i] ); if (hyphenate(name) !== camelize(name)) &#123; addHandler( el, (&quot;update:&quot; + (hyphenate(name))), syncGen, null, false, warn$2, list[i] ); &#125; &#125; else &#123; // handler w/ dynamic event name addHandler( el, (&quot;\\&quot;update:\\&quot;+(&quot; + name + &quot;)&quot;), syncGen, null, false, warn$2, list[i], true // dynamic ); &#125; &#125;&#125;if ((modifiers &amp;&amp; modifiers.prop) || ( !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name))) &#123; addProp(el, name, value, list[i], isDynamic);&#125; else &#123; addAttr(el, name, value, list[i], isDynamic);&#125; 修饰符 .prop 作为 DOM 的property绑定，而不是作为 attribute 绑定 。camel 将事件名转化为驼峰模式 .sync 会扩展一个更新父组件绑定值的 v-on 监听器 v-slot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118function processSlotContent (el) &#123; var slotScope; if (el.tag === &#x27;template&#x27;) &#123; slotScope = getAndRemoveAttr(el, &#x27;scope&#x27;); /* istanbul ignore if */ if (slotScope) &#123; warn$2( &quot;the \\&quot;scope\\&quot; attribute for scoped slots have been deprecated and &quot; + &quot;replaced by \\&quot;slot-scope\\&quot; since 2.5. The new \\&quot;slot-scope\\&quot; attribute &quot; + &quot;can also be used on plain elements in addition to &lt;template&gt; to &quot; + &quot;denote scoped slots.&quot;, el.rawAttrsMap[&#x27;scope&#x27;], true ); &#125; el.slotScope = slotScope || getAndRemoveAttr(el, &#x27;slot-scope&#x27;); &#125; else if ((slotScope = getAndRemoveAttr(el, &#x27;slot-scope&#x27;))) &#123; /* istanbul ignore if */ if (el.attrsMap[&#x27;v-for&#x27;]) &#123; warn$2( &quot;Ambiguous combined usage of slot-scope and v-for on &lt;&quot; + (el.tag) + &quot;&gt; &quot; + &quot;(v-for takes higher priority). Use a wrapper &lt;template&gt; for the &quot; + &quot;scoped slot to make it clearer.&quot;, el.rawAttrsMap[&#x27;slot-scope&#x27;], true ); &#125; el.slotScope = slotScope; &#125; // slot=&quot;xxx&quot; var slotTarget = getBindingAttr(el, &#x27;slot&#x27;); if (slotTarget) &#123; el.slotTarget = slotTarget === &#x27;&quot;&quot;&#x27; ? &#x27;&quot;default&quot;&#x27; : slotTarget; el.slotTargetDynamic = !!(el.attrsMap[&#x27;:slot&#x27;] || el.attrsMap[&#x27;v-bind:slot&#x27;]); // preserve slot as an attribute for native shadow DOM compat // only for non-scoped slots. if (el.tag !== &#x27;template&#x27; &amp;&amp; !el.slotScope) &#123; addAttr(el, &#x27;slot&#x27;, slotTarget, getRawBindingAttr(el, &#x27;slot&#x27;)); &#125; &#125; // 2.6 v-slot syntax &#123; if (el.tag === &#x27;template&#x27;) &#123; // v-slot on &lt;template&gt; var slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) &#123; &#123; if (el.slotTarget || el.slotScope) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.parent &amp;&amp; !maybeComponent(el.parent)) &#123; warn$2( &quot;&lt;template v-slot&gt; can only appear at the root level inside &quot; + &quot;the receiving component&quot;, el ); &#125; &#125; var ref = getSlotName(slotBinding); var name = ref.name; var dynamic = ref.dynamic; el.slotTarget = name; el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf &#125; &#125; else &#123; // v-slot on component, denotes default slot var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding$1) &#123; &#123; if (!maybeComponent(el)) &#123; warn$2( &quot;v-slot can only be used on components or &lt;template&gt;.&quot;, slotBinding$1 ); &#125; if (el.slotScope || el.slotTarget) &#123; warn$2( &quot;Unexpected mixed usage of different slot syntaxes.&quot;, el ); &#125; if (el.scopedSlots) &#123; warn$2( &quot;To avoid scope ambiguity, the default slot should also use &quot; + &quot;&lt;template&gt; syntax when there are other named slots.&quot;, slotBinding$1 ); &#125; &#125; // add the component&#x27;s children to its default slot var slots = el.scopedSlots || (el.scopedSlots = &#123;&#125;); var ref$1 = getSlotName(slotBinding$1); var name$1 = ref$1.name; var dynamic$1 = ref$1.dynamic; var slotContainer = slots[name$1] = createASTElement(&#x27;template&#x27;, [], el); slotContainer.slotTarget = name$1; slotContainer.slotTargetDynamic = dynamic$1; slotContainer.children = el.children.filter(function (c) &#123; if (!c.slotScope) &#123; c.parent = slotContainer; return true &#125; &#125;); slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken; // remove children as they are returned from scopedSlots now el.children = []; // mark el non-plain so data gets generated el.plain = false; &#125; &#125; &#125;&#125; v-pre 跳过这个元素和子元素的编译过程，显示原始的标签 v-cloak 无表达式，绑定一个空函数，隐藏未编译的 标签直到实例准备完成 v-once 123456789101112131415161718192021222324252627282930313233// 判断是否含有 v-once 指令function processOnce (el) &#123; var once$$1 = getAndRemoveAttr(el, &#x27;v-once&#x27;); if (once$$1 != null) &#123; el.once = true; &#125;&#125;// v-oncefunction genOnce (el, state) &#123; el.onceProcessed = true; if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.staticInFor) &#123; var key = &#x27;&#x27;; var parent = el.parent; while (parent) &#123; if (parent.for) &#123; key = parent.key; break &#125; parent = parent.parent; &#125; if (!key) &#123; state.warn( &quot;v-once can only be used inside v-for that is keyed. &quot;, el.rawAttrsMap[&#x27;v-once&#x27;] ); return genElement(el, state) &#125; return (&quot;_o(&quot; + (genElement(el, state)) + &quot;,&quot; + (state.onceId++) + &quot;,&quot; + key + &quot;)&quot;) &#125; else &#123; return genStatic(el, state) &#125;","updated":"2021-02-01T09:29:54.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (七) - 实例 property","path":"2021/02/01/vue/vue-learn-api-with-源码-07/","text":"$on $emit监听 Vue.$emit 发送的事件，回调函数会接收所有传入参数的参数 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// $on 监听事件Vue.prototype.$on = function (event, fn) &#123; var vm = this; if (Array.isArray(event)) &#123; for (var i = 0, l = event.length; i &lt; l; i++) &#123; vm.$on(event[i], fn); &#125; &#125; else &#123; (vm._events[event] || (vm._events[event] = [])).push(fn); // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup if (hookRE.test(event)) &#123; vm._hasHookEvent = true; &#125; &#125; return vm&#125;;// $emit 发送事件及参数Vue.prototype.$emit = function (event) &#123; var vm = this; &#123; var lowerCaseEvent = event.toLowerCase(); if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) &#123; tip( &quot;Event \\&quot;&quot; + lowerCaseEvent + &quot;\\&quot; is emitted in component &quot; + (formatComponentName(vm)) + &quot; but the handler is registered for \\&quot;&quot; + event + &quot;\\&quot;. &quot; + &quot;Note that HTML attributes are case-insensitive and you cannot use &quot; + &quot;v-on to listen to camelCase events when using in-DOM templates. &quot; + &quot;You should probably use \\&quot;&quot; + (hyphenate(event)) + &quot;\\&quot; instead of \\&quot;&quot; + event + &quot;\\&quot;.&quot; ); &#125; &#125; var cbs = vm._events[event]; if (cbs) &#123; cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs; var args = toArray(arguments, 1); var info = &quot;event handler for \\&quot;&quot; + event + &quot;\\&quot;&quot;; for (var i = 0, l = cbs.length; i &lt; l; i++) &#123; // 调用 事件监听的回调函数 invokeWithErrorHandling(cbs[i], vm, args, vm, info); &#125; &#125; return vm&#125;;// invokeWithErrorHandlingfunction invokeWithErrorHandling ( handler, context, args, vm, info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 主要是用了 事件发布订阅模式 (vm._events[event] || (vm._events[event] = [])).push(fn) 通过这段代码 将 $on 监听的事件名称及方法 存储到 Vue 的私有属性 _event 中，当使用 $emit 发送事件的时候会在 _event 中找到对应的时间名，然后调用 res = args ? handler.apply(context, args) : handler.call(context) 调用 回调函数 使用1234567// 发送事件this.$emit(&#x27;sayHi&#x27;, &#x27;hi&#x27;)// 接收事件this.$on(&#x27;sayHi&#x27;, function(msg) &#123; console.log(&#x27;say &#x27; + msg) // say hi&#125;) $once 监听一个自定义时间，只触发一次，触发之后移除监听器 12345678910Vue.prototype.$once = function (event, fn) &#123; var vm = this; function on () &#123; vm.$off(event, on); fn.apply(vm, arguments); &#125; on.fn = fn; vm.$on(event, on); return vm&#125;; 在 $once 函数内部定义了一个回调函数，用于 触发事件之后调用 $off 方法销毁事件监听器$emit 触发 $once 监听事件 $off 移除事件监听器 1234567891011121314151617181920212223242526272829303132333435Vue.prototype.$off = function (event, fn) &#123; var vm = this; // all if (!arguments.length) &#123; vm._events = Object.create(null); return vm &#125; // array of events if (Array.isArray(event)) &#123; for (var i$1 = 0, l = event.length; i$1 &lt; l; i$1++) &#123; vm.$off(event[i$1], fn); &#125; return vm &#125; // specific event var cbs = vm._events[event]; if (!cbs) &#123; return vm &#125; if (!fn) &#123; vm._events[event] = null; return vm &#125; // specific handler var cb; var i = cbs.length; while (i--) &#123; cb = cbs[i]; if (cb === fn || cb.fn === fn) &#123; cbs.splice(i, 1); break &#125; &#125; return vm&#125;; 使用 $off 方法移除监听器的时候可以选择性的传两个参数 event, fn 如果不传参数 默认移除所有的监听器事件 如果只传了 event 事件，移除对应事件下所有的监听器事件 如果同时提供了 event 事件和 回调，移除对应事件下的这个回调的监听器 使用123this.$off() // 移除所有this.$off(&#x27;test&#x27;) // 移除 test 下的所有监视器函数this.$off(&#x27;test&#x27;, fn) // 移除 test 下的 fn 回调函数 fn 是一个变量，指向回调函数地址 $mount 传入 el 为 DOM 元素 源码参考地址 使用123new Vue(&#123; render: (h) =&gt; h()&#125;).$mount(&#x27;#app&#x27;) $forceUpdate强制更新页面，仅影响实例本身和插入插槽内容的子组件 123456Vue.prototype.$forceUpdate = function () &#123; var vm = this; if (vm._watcher) &#123; vm._watcher.update(); &#125;&#125;; 原理是调用 Watcher 的 update 方法更新 DOM 元素 $nextTick Vue.nextTick $destroy源码123456789101112131415161718192021222324252627282930313233343536373839404142Vue.prototype.$destroy = function () &#123; var vm = this; if (vm._isBeingDestroyed) &#123; return &#125; callHook(vm, &#x27;beforeDestroy&#x27;); vm._isBeingDestroyed = true; // remove self from parent var parent = vm.$parent; if (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123; remove(parent.$children, vm); &#125; // teardown watchers if (vm._watcher) &#123; vm._watcher.teardown(); &#125; var i = vm._watchers.length; while (i--) &#123; vm._watchers[i].teardown(); &#125; // remove reference from data ob // frozen object may not have observer. if (vm._data.__ob__) &#123; vm._data.__ob__.vmCount--; &#125; // call the last hook... vm._isDestroyed = true; // invoke destroy hooks on current rendered tree vm.__patch__(vm._vnode, null); // fire destroyed hook callHook(vm, &#x27;destroyed&#x27;); // turn off all instance listeners. vm.$off(); // remove __vue__ reference if (vm.$el) &#123; vm.$el.__vue__ = null; &#125; // release circular reference (#6759) if (vm.$vnode) &#123; vm.$vnode.parent = null; &#125;&#125;; 在 $destroy 函数执行过程中，触发了 beforeDestroy 和 destroyed 生命周期函数 为防止多次调用，添加了是否正在销毁组件状态 同时移除所有的子组件，监听函数 销毁所有的事件监听函数，并置空 node 节点","updated":"2021-02-01T07:25:46.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (六) - 实例 property","path":"2021/01/29/vue/vue-learn-api-with-源码-06/","text":"$data源码12dataDef.get = function () &#123; return this._data &#125;;Object.defineProperty(Vue.prototype, &#x27;$data&#x27;, dataDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $data 设置监听方法，访问 $data 属性的时候 直接返回 Vue 的 _data 数据 不推介使用 $data 来访问 Vue 中 data 中的数据，因为 Vue 在内部已经做了映射，直接把 data 中的属性 映射到 Vue 实例上 $props源码12propsDef.get = function () &#123; return this._props &#125;;Object.defineProperty(Vue.prototype, &#x27;$props&#x27;, propsDef); 通过 Object.defineProperty 方法对 Vue 原型上的 $props 设置监听方法，访问 $props 属性的时候 直接返回 Vue 的 _props 数据 不推介使用 $props 来访问 Vue 中 props 中的数据，因为 Vue 在内部已经做了映射，直接把 props 中的属性 映射到 Vue 实例上 $el源码1234// $mount el = el &amp;&amp; inBrowser ? query(el) : undefined;// mountComponent vm.$el = el; 存储了 Vue 实例的根元素 $options源码12345678910111213141516171819202122// 初始化实例的时候传入 options 参数function Vue (options) &#123; if (!(this instanceof Vue) ) &#123; warn(&#x27;Vue is a constructor and should be called with the `new` keyword&#x27;); &#125; this._init(options);&#125;// _init 方法if (options &amp;&amp; options._isComponent) &#123; // optimize internal component instantiation // since dynamic options merging is pretty slow, and none of the // internal component options needs special treatment. initInternalComponent(vm, options); &#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); &#125; 使用Vue 也支持我们自定义 property 特性，可以通过 optionMergeStrategies 配置自定义特性的合并规则 访问的时候通过 this.$options.property 来访问 $parnet 指向当前组件的 父实例，如果没有父组件实例，则为 null $children 指向组件的子组件 是一个数组 $root 指向 Vue 实例的根组件，如果没有父组件，即指向自身 123vm.$parent = parent;vm.$root = parent ? parent.$root : vm;vm.$children = []; $slots [name]: Array&lt;VNode&gt; 用来访问插槽 源码12345678910111213141516171819202122232425262728293031323334353637383940414243// initRendervm.$slots = resolveSlots(options._renderChildren, renderContext);// resolveSlotsfunction resolveSlots ( children, context) &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; var slots = &#123;&#125;; for (var i = 0, l = children.length; i &lt; l; i++) &#123; var child = children[i]; var data = child.data; // remove slot attribute if the node is resolved as a Vue slot node if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot; &#125; // named slots should only be respected if the vnode was rendered in the // same context. if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; var name = data.slot; var slot = (slots[name] || (slots[name] = [])); if (child.tag === &#x27;template&#x27;) &#123; slot.push.apply(slot, child.children || []); &#125; else &#123; slot.push(child); &#125; &#125; else &#123; (slots.default || (slots.default = [])).push(child); &#125; &#125; // ignore slots that contains only whitespace for (var name$1 in slots) &#123; if (slots[name$1].every(isWhitespace)) &#123; delete slots[name$1]; &#125; &#125; return slots&#125; 在初始化渲染的时候，解析 DOM 树，通过 resolveSlots 方法 提取出 slots 对象 resolveSlots 方法 判断 slot 属性是否为空，然后将同一个 slot 下的 node 节点 合并成一个 slot 数组,最后通过 delete 方法删除 slot 为空的数组 使用123456789101112131415161718192021222324252627&lt;blog-post&gt; &lt;template v-slot:header&gt; &lt;h1&gt;About Me&lt;/h1&gt; &lt;/template&gt; &lt;p&gt;Here&#x27;s some page content, which will be included in vm.$slots.default, because it&#x27;s not inside a named slot.&lt;/p&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Copyright 2016 Evan You&lt;/p&gt; &lt;/template&gt; &lt;p&gt;If I have some content down here, it will also be included in vm.$slots.default.&lt;/p&gt;.&lt;/blog-post&gt;&lt;script&gt; Vue.component(&#x27;blog-post&#x27;, &#123; render: function (createElement) &#123; var header = this.$slots.header var body = this.$slots.default var footer = this.$slots.footer return createElement(&#x27;div&#x27;, [ createElement(&#x27;header&#x27;, header), createElement(&#x27;main&#x27;, body), createElement(&#x27;footer&#x27;, footer) ]) &#125; &#125;)&lt;/script&gt; $scopedSlots &#123; [name: string]: props =&gt; Array&lt;VNode&gt; | undefined &#125; 用来访问作用域插槽。对于包括 默认 slot 在内的每一个插槽，该对象都包含一个返回相应 VNode 的函数。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Vue.prototype._renderthis.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this。$slots);// 函数 normalizeScopedSlotsfunction normalizeScopedSlots ( slots, normalSlots, prevSlots) &#123; var res; var hasNormalSlots = Object.keys(normalSlots).length &gt; 0; var isStable = slots ? !!slots.$stable : !hasNormalSlots; var key = slots &amp;&amp; slots.$key; if (!slots) &#123; res = &#123;&#125;; &#125; else if (slots._normalized) &#123; // fast path 1: child component re-render only, parent did not change return slots._normalized &#125; else if ( isStable &amp;&amp; prevSlots &amp;&amp; prevSlots !== emptyObject &amp;&amp; key === prevSlots.$key &amp;&amp; !hasNormalSlots &amp;&amp; !prevSlots.$hasNormal ) &#123; // fast path 2: stable scoped slots w/ no normal slots to proxy, // only need to normalize once return prevSlots &#125; else &#123; res = &#123;&#125;; for (var key$1 in slots) &#123; if (slots[key$1] &amp;&amp; key$1[0] !== &#x27;$&#x27;) &#123; res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]); &#125; &#125; &#125; // expose normal slots on scopedSlots for (var key$2 in normalSlots) &#123; if (!(key$2 in res)) &#123; res[key$2] = proxyNormalSlot(normalSlots, key$2); &#125; &#125; // avoriaz seems to mock a non-extensible $scopedSlots object // and when that is passed down this would cause an error if (slots &amp;&amp; Object.isExtensible(slots)) &#123; (slots)._normalized = res; &#125; def(res, &#x27;$stable&#x27;, isStable); def(res, &#x27;$key&#x27;, key); def(res, &#x27;$hasNormal&#x27;, hasNormalSlots); return res&#125; $refs源码1234567891011121314151617181920212223242526272829303132333435363738394041var ref = &#123; create: function create (_, vnode) &#123; registerRef(vnode); &#125;, update: function update (oldVnode, vnode) &#123; if (oldVnode.data.ref !== vnode.data.ref) &#123; registerRef(oldVnode, true); registerRef(vnode); &#125; &#125;, destroy: function destroy (vnode) &#123; registerRef(vnode, true); &#125;&#125;;function registerRef (vnode, isRemoval) &#123; var key = vnode.data.ref; if (!isDef(key)) &#123; return &#125; var vm = vnode.context; var ref = vnode.componentInstance || vnode.elm; var refs = vm.$refs; if (isRemoval) &#123; if (Array.isArray(refs[key])) &#123; remove(refs[key], ref); &#125; else if (refs[key] === ref) &#123; refs[key] = undefined; &#125; &#125; else &#123; if (vnode.data.refInFor) &#123; if (!Array.isArray(refs[key])) &#123; refs[key] = [ref]; &#125; else if (refs[key].indexOf(ref) &lt; 0) &#123; // $flow-disable-line refs[key].push(ref); &#125; &#125; else &#123; refs[key] = ref; &#125; &#125;&#125; 通过 registerRef 方法 注册和移除旧的 VNode 使用12345678&lt;my-component ref=&quot;myComponent&quot;&gt;&lt;/my-component&gt;&lt;script&gt; export default &#123; mounted() &#123; console.log(this.$refs[&#x27;myComponent&#x27;]) &#125; &#125;&lt;/script&gt; $isServer12345678910111213var isServerRendering = function () &#123; if (_isServer === undefined) &#123; /* istanbul ignore if */ if (!inBrowser &amp;&amp; !inWeex &amp;&amp; typeof global !== &#x27;undefined&#x27;) &#123; // detect presence of vue-server-renderer and avoid // Webpack shimming the process _isServer = global[&#x27;process&#x27;] &amp;&amp; global[&#x27;process&#x27;].env.VUE_ENV === &#x27;server&#x27;; &#125; else &#123; _isServer = false; &#125; &#125; return _isServer&#125;; 判断 代码运行环境是否是服务端渲染,开启对应渲染和优化方法 $attrs 包含了父作用域中不作为 prop 被识别且获取的 attribute 绑定(除开 class 和 style)，当一个组件没有声明任何props时，这里会包含所有父作用域的绑定，并且可以通过 v-bind=&quot;$attrs&quot; 传入内部组件 12// function updateChildComponentvm.$attrs = parentVnode.data.attrs || emptyObject; $listeners 包含了父作用域中的 v-on(不包含 .natvie 修饰器) 事件监听器，可以通过 v-on=&quot;$listeners&quot; 传入内部组件 12vm.$listeners = listeners || emptyObject; $watch源码1234567891011121314151617181920212223Vue.prototype.$watch = function ( expOrFn, cb, options) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options) &#125; options = options || &#123;&#125;; options.user = true; var watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) &#123; try &#123; cb.call(vm, watcher.value); &#125; catch (error) &#123; handleError(error, vm, (&quot;callback for immediate watcher \\&quot;&quot; + (watcher.expression) + &quot;\\&quot;&quot;)); &#125; &#125; return function unwatchFn () &#123; watcher.teardown(); &#125;&#125;; 主要是通过 Watcher 构造函数及 createWatcher 方法对 Vue 实例的属性进行监控，然后返回一个取消观察的函数，用来停止触发回调 使用12345678910111213// 第一种使用this.$watch(&#x27;property&#x27;, cb)// 第二种使用this.$watch(&#x27;property&#x27;, cb, &#123; deep: true, immediate: true&#125;)// 第三种使用this.$watch(&#x27;property&#x27;, &#123; handler: cb, deep: true, immediate: true&#125;) $watch 方法会返回一个取消侦听函数，但是如果包含 immediate 选项时，不能在第一次回调时取消侦听给定的 property 12345678910111213141516// bad exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; unwatch()&#125;, &#123; deep: true, immediate: true&#125;)// good exampleconst unwatch = this.$watch(&#x27;property&#x27;, function() &#123; if(unwatch) &#123; unwatch() &#125;&#125;, &#123; deep: true, immediate: true&#125;) $set 参考Vue.set $delete 参考Vue.delete","updated":"2021-01-29T06:34:56.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (五) - 选项 / 组合 & 其他","path":"2021/01/28/vue/vue-learn-api-with-源码-05/","text":"parent主要用来存储 Vue 组件的父组件 mixins混入，主要用来开发 Vue组件中的可复用的功能 源码12345if (child.mixins) &#123; for (var i = 0, l = child.mixins.length; i &lt; l; i++) &#123; parent = mergeOptions(parent, child.mixins[i], vm); &#125;&#125; Vue 在合并选项的时候 判断力 mixins 属性是否存在，如果存在，通过递归调用的方法合并到当前组件上 使用12345678910111213var mixin = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; mixins: [mixin]&#125; extends源码具体理解可以参考 Vue.extend123if (child.extends) &#123; parent = mergeOptions(parent, child.extends, vm);&#125; 使用12345678910111213var extend = &#123; create() &#123; console.log(&#x27;create&#x27;) &#125;, methods: &#123; getInfo() &#123; console.log(&#x27;getInfo&#x27;) &#125; &#125;&#125;export default &#123; extends: extend&#125; provide/inject provide Object | () =&gt; Object inject Array&lt;string&gt; | [key:string]: string | Symbol | Object 父组件通过 provide 提供依赖，子孙组件通过 inject 将依赖注入到当前组件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 在 mergeOptionStract 配置中， provide 通过mergeData方法从父组件中绑定到子组件function initProvide (vm) &#123; var provide = vm.$options.provide; if (provide) &#123; vm._provided = typeof provide === &#x27;function&#x27; ? provide.call(vm) : provide; &#125;&#125;function initInjections (vm) &#123; var result = resolveInject(vm.$options.inject, vm); if (result) &#123; toggleObserving(false); Object.keys(result).forEach(function (key) &#123; /* istanbul ignore else */ &#123; defineReactive$$1(vm, key, result[key], function () &#123; warn( &quot;Avoid mutating an injected value directly since the changes will be &quot; + &quot;overwritten whenever the provided component re-renders. &quot; + &quot;injection being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125;); &#125; &#125;); toggleObserving(true); &#125;&#125;// 处理实例上的 inject 方法 返回处理之后的对象function resolveInject (inject, vm) &#123; if (inject) &#123; // inject is :any because flow is not smart enough to figure out cached var result = Object.create(null); var keys = hasSymbol ? Reflect.ownKeys(inject) : Object.keys(inject); for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; // #6574 in case the inject object is observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; var provideKey = inject[key].from; var source = vm; while (source) &#123; if (source._provided &amp;&amp; hasOwn(source._provided, provideKey)) &#123; result[key] = source._provided[provideKey]; break &#125; source = source.$parent; &#125; if (!source) &#123; if (&#x27;default&#x27; in inject[key]) &#123; var provideDefault = inject[key].default; result[key] = typeof provideDefault === &#x27;function&#x27; ? provideDefault.call(vm) : provideDefault; &#125; else &#123; warn((&quot;Injection \\&quot;&quot; + key + &quot;\\&quot; not found&quot;), vm); &#125; &#125; &#125; return result &#125;&#125; 使用12345678910111213141516// 父组件export default &#123; data() &#123; return &#123; bar: 342 &#125; &#125; provide: &#123; foo: &#x27;bar&#x27;, bar: this.bar &#125;&#125;// 子组件export default &#123; inject:[&#x27;foo&#x27;,&#x27;bar&#x27;]&#125; 高级使用技巧利用 Symbol 传递 12345678910111213const s = Symbol()const Provider = &#123; provide() &#123; return &#123; [s]: &#x27;foo&#x27; &#125; &#125;&#125;const Child = &#123; inject:&#123; s &#125;&#125; inject 的值作为 props 和 data 的初始值 1234567891011const child = &#123; inject: [&#x27;foo&#x27;], props: &#123; prop: &#123; default: this.foo &#125; &#125;, data() &#123; bar: this.foo &#125;&#125; name name 属性允许组件模板递归调用自身 delimiters 改变 纯文本插入分隔符 默认为[‘,‘] 源码12345678var defaultTagRE = /\\&#123;\\&#123;((?:.|\\r?\\n)+?)\\&#125;\\&#125;/g;var regexEscapeRE = /[-.*+?^$&#123;&#125;()|[\\]\\/\\\\]/g;var buildRegex = cached(function (delimiters) &#123; var open = delimiters[0].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); var close = delimiters[1].replace(regexEscapeRE, &#x27;\\\\$&amp;&#x27;); return new RegExp(open + &#x27;((?:.|\\\\n)+?)&#x27; + close, &#x27;g&#x27;)&#125;); 使用123new Vue(&#123; delimiters: [&#x27;$&#123;&#x27;,&#x27;&#125;&#x27;] // Vue 进行字符串切割替换的时候将会仿照 es6 的模板字符串&#125;) functional函数元组件 无状态(data)，无上下文(this)，没有响应式数据，相当于只是一个渲染组件，渲染之后就不会发生变化 1234567891011121314151617181920212223242526272829303132333435function createFunctionalComponent (Ctor,propsData,data,contextVm,children) &#123; var options = Ctor.options; var props = &#123;&#125;; var propOptions = options.props; if (isDef(propOptions)) &#123; for (var key in propOptions) &#123; props[key] = validateProp(key, propOptions, propsData || emptyObject); &#125; &#125; else &#123; if (isDef(data.attrs)) &#123; mergeProps(props, data.attrs); &#125; if (isDef(data.props)) &#123; mergeProps(props, data.props); &#125; &#125; var renderContext = new FunctionalRenderContext( data, props, children, contextVm, Ctor ); var vnode = options.render.call(null, renderContext._c, renderContext); if (vnode instanceof VNode) &#123; return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext) &#125; else if (Array.isArray(vnode)) &#123; var vnodes = normalizeChildren(vnode) || []; var res = new Array(vnodes.length); for (var i = 0; i &lt; vnodes.length; i++) &#123; res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext); &#125; return res &#125;&#125; 使用 context 参数 字段详解 props 提供所有 props 对象 children VNode 子节点的数组 slots 一个函数，返回了包含所有插槽的对象 scopedSlots 一个暴露传入的作用域插槽的对象，也已函数形式暴露普通插槽 data 传给组件的整个数据对象，作为 createElement 函数的第二个参数传入组件 parent 对父组件的引用 listeners 一个包含了所有父组件为当前组件注册的时间监听器对象，这是data.on的一个别名 injection 注入的 property 123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;function-component :list=&quot;list&quot; other=&quot;other&quot;&gt; this is a slot &#123;&#123;list.name&#125;&#125; &lt;div slot=&quot;default&quot;&gt; this is slot default &lt;/div&gt; &lt;/function-component&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; Vue.component(&#x27;function-component&#x27;, &#123; functional: true, props: &#123; list: &#123; type: Object, default: () =&gt; &#123; return &#123;&#125; &#125; &#125; &#125;, render: function (createElement, context) &#123; const header = context.scopedSlots.default() return createElement( &#x27;div&#x27;, [ createElement(&#x27;div&#x27;, [header[0]]), createElement(&#x27;div&#x27;, [header[1]]) ] ) &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 5, hidden: true, list: &#123; name: &#x27;listName&#x27;, value: &#x27;listValue&#x27; &#125; &#125; &#125;, computed: &#123; test() &#123; return &#123; test1: 4 &#125; &#125; &#125;, &#125;)&lt;/script&gt; model prop(可选) String event(可选) String 允许一个自定义组件在使用 v-model 时定制定制 prop 和 event，默认情况下，一个组件上的 v-model 会把 value 用作 prop 且把 input 用作 event，一些复杂的输入框可以使用 model 选项回避这些情况产生的冲突 源码12345678910111213141516171819function transformModel (options, data) &#123; var prop = (options.model &amp;&amp; options.model.prop) || &#x27;value&#x27;; var event = (options.model &amp;&amp; options.model.event) || &#x27;input&#x27; ;(data.attrs || (data.attrs = &#123;&#125;))[prop] = data.model.value; var on = data.on || (data.on = &#123;&#125;); var existing = on[event]; var callback = data.model.callback; if (isDef(existing)) &#123; if ( Array.isArray(existing) ? existing.indexOf(callback) === -1 : existing !== callback ) &#123; on[event] = [callback].concat(existing); &#125; &#125; else &#123; on[event] = callback; &#125;&#125; 在设置值的时候通过一个 ||(或) 来判断 model 是否赋值，否则取默认设置的 value 及 input 使用123456789101112131415161718&lt;input v-model=&quot;inputValue&quot;&gt;&lt;!-- input 组件内部 --&gt;&lt;script&gt; export default &#123; model: &#123; prop: &#x27;text&#x27; event: &#x27;change&#x27; &#125;, props: &#123; text: String &#125;, methods: &#123; handleChange(value) &#123; this.$emit(&#x27;change&#x27;, value) &#125; &#125; &#125;&lt;/script&gt; inheritAttrs 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例 property $attrs 可以让这些 attribute 生效，且可以通过 v-bind 显性的绑定到非根元素上 源码12345678910111213141516171819202122232425262728293031323334353637383940function updateAttrs (oldVnode, vnode) &#123; var opts = vnode.componentOptions; if (isDef(opts) &amp;&amp; opts.Ctor.options.inheritAttrs === false) &#123; return &#125; if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return &#125; var key, cur, old; var elm = vnode.elm; var oldAttrs = oldVnode.data.attrs || &#123;&#125;; var attrs = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] // #6666: IE/Edge forces progress value down to 1 before setting a max /* istanbul ignore if */ if ((isIE || isEdge) &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, &#x27;value&#x27;, attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125; 在更新的时候 判断一下 inheritAttrs 的值，如果为 false 直接返回 使用1234// 子组件export default &#123; inheritAttrs: false&#125; comments 主要作用是 是否保留渲染模板中的 HTML 注释","updated":"2021-01-28T06:03:16.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (四) - 选项 / DOM 及 生命周期函数、filters,directives,components","path":"2021/01/27/vue/vue-learn-api-with-源码-04/","text":"el，template render源码el 指定的元素作为 Vue 实例的挂载目标 主要是通过 Vue 实例的 $mount 方法 $mount 方法 主要 通过 el 获取到 DOM 元素 然后调用 mountComponents 方法 绑定到 Vue 实例上，最后返回 Vue 实例1234567Vue.prototype.$mount = function ( el, hydrating) &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined; return mountComponent(this, el, hydrating)&#125;; mountComponent 方法 判断 是否有render函数，没有提示至少要有template或者render函数 (tempalte,el,render 不同同时使用) 调用 beforeMount 声明周期 判断是否开启性能优化检查 对 vm 的 updateComponet 函数进行 监听变化，如果发生变化，触发 beforeUpdate 生命周期函数 Vue 实例上挂载了 node 节点后更改 Vue 是否挂载状态 调用 mounted 生命周期 返回 挂载了 DOM 元素的 Vue 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function mountComponent (vm, el, hydrating) &#123; vm.$el = el; if (!vm.$options.render) &#123; vm.$options.render = createEmptyVNode; &#123; /* istanbul ignore if */ if ((vm.$options.template &amp;&amp; vm.$options.template.charAt(0) !== &#x27;#&#x27;) || vm.$options.el || el) &#123; warn( &#x27;You are using the runtime-only build of Vue where the template &#x27; + &#x27;compiler is not available. Either pre-compile the templates into &#x27; + &#x27;render functions, or use the compiler-included build.&#x27;, vm ); &#125; else &#123; warn( &#x27;Failed to mount component: template or render function not defined.&#x27;, vm ); &#125; &#125; &#125; callHook(vm, &#x27;beforeMount&#x27;); var updateComponent; /* istanbul ignore if */ if (config.performance &amp;&amp; mark) &#123; updateComponent = function () &#123; var name = vm._name; var id = vm._uid; var startTag = &quot;vue-perf-start:&quot; + id; var endTag = &quot;vue-perf-end:&quot; + id; mark(startTag); var vnode = vm._render(); mark(endTag); measure((&quot;vue &quot; + name + &quot; render&quot;), startTag, endTag); mark(startTag); vm._update(vnode, hydrating); mark(endTag); measure((&quot;vue &quot; + name + &quot; patch&quot;), startTag, endTag); &#125;; &#125; else &#123; updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; &#125; // we set this to vm._watcher inside the watcher&#x27;s constructor // since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child // component&#x27;s mounted hook), which relies on vm._watcher being already defined new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, &#x27;beforeUpdate&#x27;); &#125; &#125; &#125;, true /* isRenderWatcher */); hydrating = false; // manually mounted instance, call mounted on self // mounted is called for render-created child components in its inserted hook if (vm.$vnode == null) &#123; vm._isMounted = true; callHook(vm, &#x27;mounted&#x27;); &#125; return vm&#125; 使用12345678910111213new Vue(&#123; el: &#x27;#app&#x27;, template: `&lt;div&gt;test&lt;/div&gt;`&#125;)new Vue(&#123; template: `&lt;div&gt;test&lt;/div&gt;`&#125;).$mount(&#x27;#app&#x27;)new Vue(&#123; el: &#x27;#app&#x27;, render: (h) =&gt; h()&#125;) 生命周期函数源码12345678910111213141516171819202122232425262728293031function callHook (vm, hook) &#123; // #7573 disable dep collection when invoking lifecycle hooks pushTarget(); var handlers = vm.$options[hook]; // 接收到的是一个数组 var info = hook + &quot; hook&quot;; if (handlers) &#123; for (var i = 0, j = handlers.length; i &lt; j; i++) &#123; invokeWithErrorHandling(handlers[i], vm, null, vm, info); &#125; &#125; if (vm._hasHookEvent) &#123; vm.$emit(&#x27;hook:&#x27; + hook); &#125; popTarget();&#125;function invokeWithErrorHandling (handler,context,args,vm,info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + &quot; (Promise/async)&quot;); &#125;); // issue #9511 // avoid catch triggering multiple times when nested calls res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 在 callHook 方法中，主要是针对组件 生命周期进行处理，调用 invokeWithErrorHandling 方法 执行生命周期函数 在 invokeWithErrorHandling 方法中，通过 call 和 apply 执行生命周期函数及传参 使用生命周期函数 beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed activated deactivated errorCaptured serverPrefetch 生命周期函数执行顺序 在 initMixin函数中，定义了 Vue 的 _init 函数，初始化 Vue 信息，合并 Vue 的 options 信息，初始化生命周期，初始化事件对象，初始化渲染方法 调用 beforeCreate 生命周期 不能访问到数据和dom元素，但是能够访问生命周期函数 初始化注册函数，初始化 data，props，methods，watch,provide 调用 created 生命周期 能获取到数据及方法，但是无法操作 dom 调用 $mount 方法挂载 DOM 元素 绑定 el 对应的 DOM 元素 调用 beforeMount 生命周期 调用 _update 挂载 DOM 元素, 使用 Watcher 构造函数 监听 updateComponent 方法，触发 beforeUpdate 生命周期 调用 mounted 生命周期 页面发生变化 时触发 updated 生命周期 页面销毁时时触发 $destroy 方法 调用 beforeDestroy 生命周期 清空 watcher，child，组件 及事件监听函数 调用 destroyed 生命周期 特殊的生命周期函数 activated/deactivated 只有被 keep-alive 组件包围的组件才有 这个生命周期函数 errorCaptured 全局报错信息的生命周期函数，报错捕获 directives源码请参照 Vue.directive 使用123456789export default &#123; directives: &#123; clip: &#123; insert: function() &#123;&#125;, bind: function() &#123;&#125; componentUpdate: function() &#123;&#125; &#125; &#125;&#125; filters源码请参照 Vue.filter 使用1234567export default &#123; filters: &#123; clip: function(value) &#123; return value &#125; &#125;&#125; components源码请参照 Vue.component 使用123456export default &#123; components: &#123; FirstComponent, SecondComponent &#125;&#125;","updated":"2021-01-27T14:16:53.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - Watcher 方法详解","path":"2021/01/27/vue/vue-learn-api-with-源码-watcher/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198var Watcher = function Watcher ( vm, // Vue 实例 expOrFn, // key值，watch 的属性 cb, // 回调函数 options, // 配置 &#123;lazy: true&#125; isRenderWatcher // 是否 在 Vue 实例上记载 Watcher ) &#123; this.vm = vm; if (isRenderWatcher) &#123; vm._watcher = this; &#125; vm._watchers.push(this); // options if (options) &#123; this.deep = !!options.deep; // 深度监听 针对 对象 this.user = !!options.user; this.lazy = !!options.lazy; this.sync = !!options.sync; this.before = options.before; &#125; else &#123; this.deep = this.user = this.lazy = this.sync = false; &#125; this.cb = cb; this.id = ++uid$2; // uid for batching this.active = true; this.dirty = this.lazy; // for lazy watchers this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // parse expression for getter if (typeof expOrFn === &#x27;function&#x27;) &#123; // 判断 传入的 watch 函数 是否是函数，如果是函数，直接设置为 getter 函数 this.getter = expOrFn; &#125; else &#123; // 如果是对象，提取 函数 this.getter = parsePath(expOrFn); if (!this.getter) &#123; this.getter = noop; warn( &quot;Failed watching path: \\&quot;&quot; + expOrFn + &quot;\\&quot; &quot; + &#x27;Watcher only accepts simple dot-delimited paths. &#x27; + &#x27;For full control, use a function instead.&#x27;, vm ); &#125; &#125; this.value = this.lazy ? undefined : this.get();&#125;;/** * Evaluate the getter, and re-collect dependencies. */Watcher.prototype.get = function get () &#123; pushTarget(this); // 设置 Dep 构造函数的 target 为当前 Watcher 实例 var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); // 调用 getter 函数，并将 vue 实例作为参数传进去 &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (&quot;getter for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; else &#123; throw e &#125; &#125; finally &#123; // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;;/** * Add a dependency to this directive. */// 此处 添加发布订阅模式，将 发布订阅模式 与 watcher 关联起来Watcher.prototype.addDep = function addDep (dep) &#123; var id = dep.id; if (!this.newDepIds.has(id)) &#123; this.newDepIds.add(id); this.newDeps.push(dep); if (!this.depIds.has(id)) &#123; dep.addSub(this); &#125; &#125;&#125;;/** * Clean up for dependency collection. */Watcher.prototype.cleanupDeps = function cleanupDeps () &#123; var i = this.deps.length; while (i--) &#123; var dep = this.deps[i]; if (!this.newDepIds.has(dep.id)) &#123; dep.removeSub(this); &#125; &#125; var tmp = this.depIds; this.depIds = this.newDepIds; this.newDepIds = tmp; this.newDepIds.clear(); tmp = this.deps; this.deps = this.newDeps; this.newDeps = tmp; this.newDeps.length = 0;&#125;;/** * Subscriber interface. * Will be called when a dependency changes. */Watcher.prototype.update = function update () &#123; /* istanbul ignore else */ if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;;/** * Scheduler job interface. * Will be called by the scheduler. */Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; try &#123; this.cb.call(this.vm, value, oldValue); &#125; catch (e) &#123; handleError(e, this.vm, (&quot;callback for watcher \\&quot;&quot; + (this.expression) + &quot;\\&quot;&quot;)); &#125; &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;;/** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */Watcher.prototype.evaluate = function evaluate () &#123; this.value = this.get(); this.dirty = false;&#125;;/** * Depend on all deps collected by this watcher. */Watcher.prototype.depend = function depend () &#123; var i = this.deps.length; while (i--) &#123; this.deps[i].depend(); &#125;&#125;;/** * Remove self from all dependencies&#x27; subscriber list. */Watcher.prototype.teardown = function teardown () &#123; if (this.active) &#123; // remove self from vm&#x27;s watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. if (!this.vm._isBeingDestroyed) &#123; remove(this.vm._watchers, this); &#125; var i = this.deps.length; while (i--) &#123; this.deps[i].removeSub(this); &#125; this.active = false; &#125;&#125;;","updated":"2021-01-27T13:45:28.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (三) - 选项 / 数据","path":"2021/01/24/vue/vue-learn-api-with-源码-03/","text":"data在 data 中的数据 在 vue2 中会使用 Object.defineProperty 方法监听数据变化（vue3 采用 proxy）当数据发生变化的时候，会带动页面发生变化 在使用data的时候推介使用 返回一个初始对象的函数的方法，如果 data 是一个纯粹的对象，会造成 Vue 所有实例共享同一个引用数据对象 源码1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm) &#123; var data = vm.$options.data; data = vm._data = typeof data === &#x27;function&#x27; ? getData(data, vm) : data || &#123;&#125;; if (!isPlainObject(data)) &#123; data = &#123;&#125;; warn( &#x27;data functions should return an object:\\n&#x27; + &#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;, vm ); &#125; // proxy data on instance var keys = Object.keys(data); var props = vm.$options.props; var methods = vm.$options.methods; var i = keys.length; while (i--) &#123; var key = keys[i]; &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a data property.&quot;), vm ); &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( &quot;The data property \\&quot;&quot; + key + &quot;\\&quot; is already declared as a prop. &quot; + &quot;Use prop default value instead.&quot;, vm ); &#125; else if (!isReserved(key)) &#123; proxy(vm, &quot;_data&quot;, key); &#125; &#125; // observe data observe(data, true /* asRootData */);&#125; 上述源码 主要是判断一下 data 的 类型以及判断 data 定义的变量名是否在 props 及 methods 中是否也存在，之后调用 observe 方法给 data 对象添加数据监听 123456789101112function getData (data, vm) &#123; // #7573 disable dep collection when invoking data getters pushTarget(); try &#123; return data.call(vm, vm) &#125; catch (e) &#123; handleError(e, vm, &quot;data()&quot;); return &#123;&#125; &#125; finally &#123; popTarget(); &#125;&#125; 数据映射，将 data 的数据映射到 Vue 实例上，这样我们通过 Vue.property 的方法也能访问到 data 上的数据 使用1234567export default &#123; data() &#123; return &#123; parameter: &#x27;parameter&#x27; &#125; &#125;&#125; props源码123456789101112131415161718192021222324252627282930313233function normalizeProps (options, vm) &#123; var props = options.props; if (!props) &#123; return &#125; var res = &#123;&#125;; var i, val, name; if (Array.isArray(props)) &#123; // 判断 props 类型 第一种是传递数组 [&#x27;props1&#x27;, &#x27;props2&#x27;] i = props.length; while (i--) &#123; val = props[i]; if (typeof val === &#x27;string&#x27;) &#123; name = camelize(val); res[name] = &#123; type: null &#125;; &#125; else &#123; warn(&#x27;props must be strings when using array syntax.&#x27;); &#125; &#125; &#125; else if (isPlainObject(props)) &#123; // 判断 props 类型 第二种是传递带有类型检查的对象 for (var key in props) &#123; val = props[key]; name = camelize(key); res[name] = isPlainObject(val) ? val : &#123; type: val &#125;; &#125; &#125; else &#123; warn( &quot;Invalid value for option \\&quot;props\\&quot;: expected an Array or an Object, &quot; + &quot;but got &quot; + (toRawType(props)) + &quot;.&quot;, vm ); &#125; options.props = res;&#125; 使用 props 有两种使用方式 数组方式 子组件用一个数组接收父组件传递的props props: [&#39;props1&#39;, &#39;props2&#39;]缺点就是无法做类型检查，无法控制接收到的 props 的数据类型及默认值 对象方式 子组件用一个对象接收父组件传入的props对象属性上有以下参数 type props 的数据类型，单个类型 直接判断 type: String ，多个类型 传递数组 type: [String, Array] default 默认值，如果父组件没有传递此 props，将会自动取默认值 require 是否必传 validator 自定义验证函数123456789101112export default &#123; // props: [&#x27;props1&#x27;, &#x27;props2&#x27;] props: &#123; props1: &#123; type: String, default: &#x27;&#x27;, require: true, validator: () =&gt; &#123;&#125; &#125;, props: Number &#125;&#125; propsData 使用 new 创建 Vue 实例的时候使用 源码 此源码也包含 props1234567891011121314151617181920212223242526272829303132333435363738394041424344454647function initProps (vm, propsOptions) &#123; var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; // cache prop keys so that future props updates can iterate using Array // instead of dynamic object key enumeration. var keys = vm.$options._propKeys = []; var isRoot = !vm.$parent; // root instance props should be converted if (!isRoot) &#123; toggleObserving(false); &#125; var loop = function ( key ) &#123; keys.push(key); var value = validateProp(key, propsOptions, propsData, vm); /* istanbul ignore else */ &#123; var hyphenatedKey = hyphenate(key); if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) &#123; warn( (&quot;\\&quot;&quot; + hyphenatedKey + &quot;\\&quot; is a reserved attribute and cannot be used as component prop.&quot;), vm ); &#125; defineReactive$$1(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( &quot;Avoid mutating a prop directly since the value will be &quot; + &quot;overwritten whenever the parent component re-renders. &quot; + &quot;Instead, use a data or computed property based on the prop&#x27;s &quot; + &quot;value. Prop being mutated: \\&quot;&quot; + key + &quot;\\&quot;&quot;, vm ); &#125; &#125;); &#125; // static props are already proxied on the component&#x27;s prototype // during Vue.extend(). We only need to proxy props defined at // instantiation here. if (!(key in vm)) &#123; proxy(vm, &quot;_props&quot;, key); &#125; &#125;; for (var key in propsOptions) loop( key ); toggleObserving(true);&#125;此方法主要是在初始化的时候 将propsData，props进行响应式处理 使用12345new Vue（&#123; propsData: &#123; msg: &#x27;123 &#125;&#125; computed源码123456789101112131415161718192021222324252627282930313233343536function initComputed (vm, computed) &#123; // 创建一个 watcher 对象 var watchers = vm._computedWatchers = Object.create(null); // 判断当前页面渲染类型 是否是服务端渲染 var isSSR = isServerRendering(); for (var key in computed) &#123; // 遍历 computed 对象 获取属性的返回值 var userDef = computed[key]; var getter = typeof userDef === &#x27;function&#x27; ? userDef : userDef.get; if (getter == null) &#123; warn( (&quot;Getter is missing for computed property \\&quot;&quot; + key + &quot;\\&quot;.&quot;), vm ); &#125; // 如果 当前页面不是服务端渲染，调用 watcher 方法监听 computed 数值变化 if (!isSSR) &#123; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions ); &#125; if (!(key in vm)) &#123; // 关键的一步，判断 computed 定义的变量在props及data中是否有值 defineComputed(vm, key, userDef); // 给 computed 的属性添加 get 方法 &#125; else &#123; if (key in vm.$data) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined in data.&quot;), vm); &#125; else if (vm.$options.props &amp;&amp; key in vm.$options.props) &#123; warn((&quot;The computed property \\&quot;&quot; + key + &quot;\\&quot; is already defined as a prop.&quot;), vm); &#125; &#125; &#125;&#125; defineComputed 函数 主要作用是设置 映射到 Vue 实例上的 computed 属性的 get 和 set 方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051function defineComputed ( target, key, userDef) &#123; // 同样，首先判断一下是否是服务端渲染 var shouldCache = !isServerRendering(); if (typeof userDef === &#x27;function&#x27;) &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef); sharedPropertyDefinition.set = noop; &#125; else &#123; sharedPropertyDefinition.get = userDef.get ? shouldCache &amp;&amp; userDef.cache !== false ? createComputedGetter(key) : createGetterInvoker(userDef.get) : noop; sharedPropertyDefinition.set = userDef.set || noop; &#125; if (sharedPropertyDefinition.set === noop) &#123; sharedPropertyDefinition.set = function () &#123; warn( (&quot;Computed property \\&quot;&quot; + key + &quot;\\&quot; was assigned to but it has no setter.&quot;), this ); &#125;; &#125; Object.defineProperty(target, key, sharedPropertyDefinition);&#125;function createComputedGetter (key) &#123; return function computedGetter () &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125; &#125;&#125;function createGetterInvoker(fn) &#123; return function computedGetter () &#123; return fn.call(this, this) &#125;&#125; 使用123456789101112131415export default &#123; computed: &#123; parameter1() &#123; return 1 &#125;, parameter2: &#123; get() &#123; return 2 &#125;, set() &#123; this.parameter1 = 4 &#125; &#125; &#125;&#125; methods源码123456789101112131415161718192021222324252627function initMethods (vm, methods) &#123; var props = vm.$options.props; for (var key in methods) &#123; &#123; if (typeof methods[key] !== &#x27;function&#x27;) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; has type \\&quot;&quot; + (typeof methods[key]) + &quot;\\&quot; in the component definition. &quot; + &quot;Did you reference the function correctly?&quot;, vm ); &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; warn( (&quot;Method \\&quot;&quot; + key + &quot;\\&quot; has already been defined as a prop.&quot;), vm ); &#125; if ((key in vm) &amp;&amp; isReserved(key)) &#123; warn( &quot;Method \\&quot;&quot; + key + &quot;\\&quot; conflicts with an existing Vue instance method. &quot; + &quot;Avoid defining component methods that start with _ or $.&quot; ); &#125; &#125; vm[key] = typeof methods[key] !== &#x27;function&#x27; ? noop : bind(methods[key], vm); // 调用 函数的bind 方法，绑定 methods 方法的 this 到 Vue 实例上 &#125;&#125; 使用 不推介使用箭头函数来命名 methods 函数 此时 函数的 this 指向了 父级作用域上下文12345678910export default &#123; methods: &#123; fn1() &#123; // todo... &#125;, fn2() &#123; // todo... &#125; &#125;&#125; watchVue 中 watch 主要用于监听 data，props，computed 对象中的属性发生变化，一旦发生变化就会触发对应的函数，更新对应数据及页面结构 源码12345678910111213141516171819202122232425262728function initWatch (vm, watch) &#123; for (var key in watch) &#123; var handler = watch[key]; if (Array.isArray(handler)) &#123; for (var i = 0; i &lt; handler.length; i++) &#123; createWatcher(vm, key, handler[i]); &#125; &#125; else &#123; createWatcher(vm, key, handler); &#125; &#125;&#125;function createWatcher ( vm, expOrFn, handler, options) &#123; if (isPlainObject(handler)) &#123; options = handler; handler = handler.handler; &#125; if (typeof handler === &#x27;string&#x27;) &#123; handler = vm[handler]; &#125; return vm.$watch(expOrFn, handler, options)&#125; 在 initWatch 的时候， 首先针对传入的 watch对象进行遍历watch 的属性如果是数组，数组内的函数会异议调用，其他情况会直接创建 watch vm Vue 实例 watch vue 组件上的 watch 对象 在 createWatcher 函数里面，因为传入的handler 可能是对象，所以做了兼容处理，之后要调用了 Vue 实例上的 $watch 方法来实现属性的监听, $watch 方法 我们会在接下进行讲解，现在先有个印象 vm Vue 实例 expOrFn 要进行数据监控的变量名 handler 回调函数，数据发生改变后执行此函数，吧改变后的值传递回来，也可以是对象，但是对象中必须要包含 handler 属性且是一个函数或者一个键，可以通过它在 vm 上找到对应函数 options 配置参数 针对对象进行特殊处理，防止无法监听到对象值的变化 使用在看了源码中的 initWatch 函数和 createWatcher 函数之后，根据对 watch 内部参数的处理我们可以猜到在使用 watch 的时候我们可以传递 数组、对象、函数、字符串 回调函数不推介使用 箭头函数，因为箭头函数的上下文已经绑定了，不会指向 Vue 实例 1234567891011121314151617181920export default &#123; watch: &#123; // Vue 在监控到 a 发生变化之后 会执行 methods 方法 即 vm[&#x27;methods&#x27;] a: &#x27;methods&#x27;, // Vue 在监控到 b 发生变化之后 会执行此回调函数 b: function() &#123;&#125;, // 针对对象属性监听，在 createWatcher 函数中 会对对象进行处理，取出回调函数 及 options 配置 // c 发生变化之后 会调用 对象中 handler 函数 c: &#123; handler: &#x27;methods&#x27;, deep: true &#125; // d 放生变化之后，数组中的每一个函数都会被执行，数组内部 watch 方法的执行和以上三种类似 d: [&#x27;methods&#x27;, function()&#123;&#125;, &#123; handler: function() &#123;&#125; &#125;], // 此种方法针对对象的某一个值进行监听，在 Vue 中会对 `key:&#x27;e-f&#x27; 进行处理，精准查找到 e 对象下的 f 属性 &#x27;e.f&#x27;: function() &#123;&#125; &#125;&#125;","updated":"2021-01-24T14:38:26.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (二) - 全局 api","path":"2021/01/20/vue/vue-learn-api-with-源码-02/","text":"Vue.extend({})源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function initExtend (Vue) &#123; /** * Each instance constructor, including Vue, has a unique * cid. This enables us to create wrapped &quot;child * constructors&quot; for prototypal inheritance and cache them. */ Vue.cid = 0; var cid = 1; /** * Class inheritance */ Vue.extend = function (extendOptions) &#123; extendOptions = extendOptions || &#123;&#125;; var Super = this; // 使用 super 继承Vue 实例 var SuperId = Super.cid; // 存储 Vue 实例的 cid var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] // 优化，如果多次使用同一个 Vue.extend 返回的是同一个 Vue.extend ,使用缓存，减少不必要的内存消耗 &#125; var name = extendOptions.name || Super.options.name; if (name) &#123; validateComponentName(name); // 检验 Vue extend 的name 属性是否合法 &#125; var Sub = function VueComponent (options) &#123; this._init(options); &#125;; /** 原型继承，将 vue 的原型 集成到子类 Sub 构造函数上，同时添加唯一标识符 */ Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; Sub.cid = cid++; /** 调用 mergeOptions 方法 将 extend的所有属性 合并到 Vue的 options 属性上 */ Sub.options = mergeOptions( Super.options, extendOptions ); Sub[&#x27;super&#x27;] = Super; // For props and computed properties, we define the proxy getters on // the Vue instances at extension time, on the extended prototype. This // avoids Object.defineProperty calls for each instance created. // 如果包含 props 属性，重新初始化 props if (Sub.options.props) &#123; initProps$1(Sub); &#125; // 如果包含 computed 属性，重新初始化 computed if (Sub.options.computed) &#123; initComputed$1(Sub); &#125; // allow further extension/mixin/plugin usage Sub.extend = Super.extend; Sub.mixin = Super.mixin; Sub.use = Super.use; // create asset registers, so extended classes // can have their private assets too. ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type]; &#125;); // enable recursive self-lookup 启动递归查找 if (name) &#123; Sub.options.components[name] = Sub; &#125; // keep a reference to the super options at extension time. // later at instantiation we can check if Super&#x27;s options have // been updated. // 在分机处保留对超级选项的引用时间。稍后在实例化时，我们可以检查Super的选项是否已更新。 Sub.superOptions = Super.options; Sub.extendOptions = extendOptions; Sub.sealedOptions = extend(&#123;&#125;, Sub.options); // cache constructor cachedCtors[SuperId] = Sub; // 在此处赋值，缓存 当前 Vue extend return Sub &#125;;&#125; 通过以上源码，我们可以看出 Vue 在 extend 的时候主要做了以下几个事情 首先进行兼容处理，保证传入的对象不为空 创建一个变量 Super 用来存储 Vue 实例，并且存储 Vue 的 cid 判断当前 extend 是否已经被使用过，如果已经使用过，直接返回，以减少内存消耗 创建一个新的构造函数 Sub ，原型指向 Super 的原型，并创建一个唯一的 cid 接下来通过 mergeOptions 方法，将传入的 参数 与 Vue 实例的 options(data,lifeCycle,methods,props,methods 等) 合并，遵循 Vue 内部 config 中定义的optionMergeStrategies 配置 初始化 props 和 computed 属性 重新对 extend，mixin，use，filter，directive，component 属性进行赋值 最后 通过 _Ctor 缓存 当前创建的 Vue.extend 实例 返回 当前 Sub 构造函数，该构造函数 具有 Vue 所有属性及方法 使用 1234567891011121314151617181920212223var Profile = Vue.extend(&#123; data() &#123; return &#123; name: &#x27;lxx&#x27;, age: 24, &#125; &#125;, computed: &#123; time() &#123; return new Date.getTime() &#125; &#125;, mounted() &#123; this.getName() &#125; methods: &#123; getName() &#123; console.log(this.name) &#125; &#125;&#125;)new Profile().$mount(&#x27;#app&#x27;) 当我们 使用 Vue.extend 为 Vue 扩展一些信息的时候，会根据 Vue 的 optionMergeStrategies 配置的默认属性合并规则进行属性 合并，这样我们在任意组件都可以使用到这些属性和方法 Vue.nextTick([callback: Function,context: Object]) Vue 更新页面并不是同步更新的，而是采用异步更新的。 浏览器有一个更新循环 tick，这个 tick 时间间隔大概十几毫秒，Vue 在到浏览器执行下一个 tick 的时间段内搜集所有需要更新的 Dom 数据，在 下一个 tick 循环到来的时候同步更新到页面上。这时候就会造成一个问题，如果我们想在改变数据之后立刻获取页面的数据的话，这时候还没有触发浏览器的 tick 更新，页面没有变化，我们是获取不到更新后的 DOM 数据 使用 Vue.nextTick 可以使我们在页面更新完成之后获取 DOM 源码123456789101112131415161718192021222324function nextTick (cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, &#x27;nextTick&#x27;); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125; // $flow-disable-line if (!cb &amp;&amp; typeof Promise !== &#x27;undefined&#x27;) &#123; return new Promise(function (resolve) &#123; _resolve = resolve; &#125;) &#125;&#125; 在 timerFunc() 函数 中 通过判断 Promise MutationObserver 及 setImmediate函数是否存在 如在就使用对应函数，不存在就使用setTimeout方法 使用123Vue.nextTick(() =&gt; &#123; // 获取更新后的 Dom&#125;) Vue.set(target: Object | Array, index: Number | string, value: any) 用于修改一些 Vue 响应式无法监听到的对象属性变更，同时触发视图更新 源码123456789101112131415161718192021222324252627282930function set (target, key, val) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val &#125; if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ); return val &#125; if (!ob) &#123; target[key] = val; return val &#125; defineReactive$$1(ob.value, key, val); ob.dep.notify(); return val&#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 key 是否属于 target 判断 传入 target 对象 是否是 Vue 实例 调用 defineReactive$$1 监听数据变化 调用 发布订阅模式 的 发布方法 使用1Vue.set(target, key, value) Vue.delete(target: Object | Array, index: Number | string) 删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。 源码1234567891011121314151617181920212223242526function del (target, key) &#123; if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot delete reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.splice(key, 1); return &#125; var ob = (target).__ob__; if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid deleting properties on a Vue instance or its root $data &#x27; + &#x27;- just set it to null.&#x27; ); return &#125; if (!hasOwn(target, key)) &#123; return &#125; delete target[key]; if (!ob) &#123; return &#125; ob.dep.notify(); &#125; 首先判断传过来的 target 是否存在，及数据类型是否是基本数据类型 判断 target 是否是数组，以及 key 值 是否可用，然后调用 Array 的 slice 方法替换数组数据 判断 传入 target 对象 是否是 Vue 实例 删除 target[key] 调用 发布订阅模式 的 发布方法 使用1Vue.delete(target, key) Vue.directive( id: string, [definition]: Function | Object ) 此方法主要是为了给 Vue 设置自定义指令 及获取 Vue 指令 源码首先 定义了一个 platformDirectives 存储 directive 指令的属性，然后通过 extend 方法，将 platformDirectives 上的属性 复制到 Vue.options.directives 上123456var platformDirectives = &#123; model: directive, show: show&#125;;extend(Vue.options.directives, platformDirectives) directive 对象的属性 12345var directive = &#123; inserted: function() &#123;&#125;, componentUpdated: function()&#123;&#125;&#125; install12345678910111213141516171819202122232425262728inserted: function inserted (el, binding, vnode, oldVnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; // #6903 if (oldVnode.elm &amp;&amp; !oldVnode.elm._vOptions) &#123; mergeVNodeHook(vnode, &#x27;postpatch&#x27;, function () &#123; directive.componentUpdated(el, binding, vnode); &#125;); &#125; else &#123; setSelected(el, binding, vnode.context); &#125; el._vOptions = [].map.call(el.options, getValue); &#125; else if (vnode.tag === &#x27;textarea&#x27; || isTextInputType(el.type)) &#123; el._vModifiers = binding.modifiers; if (!binding.modifiers.lazy) &#123; el.addEventListener(&#x27;compositionstart&#x27;, onCompositionStart); el.addEventListener(&#x27;compositionend&#x27;, onCompositionEnd); // Safari &lt; 10.2 &amp; UIWebView doesn&#x27;t fire compositionend when // switching focus before confirming composition choice // this also fixes the issue where some browsers e.g. iOS Chrome // fires &quot;change&quot; instead of &quot;input&quot; on autocomplete. el.addEventListener(&#x27;change&#x27;, onCompositionEnd); /* istanbul ignore if */ if (isIE9) &#123; el.vmodel = true; &#125; &#125; &#125;&#125;, 我们可以看到在 inserted 函数中对 指令绑定的元素做了一个判断， 针对 select，textarea标签及 input 标签且属性是 是文本输入类型的元素做了特殊处理 componentUpdated 123456789101112131415161718192021componentUpdated: function componentUpdated (el, binding, vnode) &#123; if (vnode.tag === &#x27;select&#x27;) &#123; setSelected(el, binding, vnode.context); // in case the options rendered by v-for have changed, // it&#x27;s possible that the value is out-of-sync with the rendered options. // detect such cases and filter out values that no longer has a matching // option in the DOM. var prevOptions = el._vOptions; var curOptions = el._vOptions = [].map.call(el.options, getValue); if (curOptions.some(function (o, i) &#123; return !looseEqual(o, prevOptions[i]); &#125;)) &#123; // trigger change event if // no matching option found for at least one value var needReset = el.multiple ? binding.value.some(function (v) &#123; return hasNoMatchingOption(v, curOptions); &#125;) : binding.value !== binding.oldValue &amp;&amp; hasNoMatchingOption(binding.value, curOptions); if (needReset) &#123; trigger(el, &#x27;change&#x27;); &#125; &#125; &#125;&#125; 在 componentUpdated 方法中 对select 标签的元素做了特殊处理，渲染其子元素 option bind,update,unbind 针对元素的 display 进行处理 使用insert 函数传入参数有四个 el 当前指令挂载的元素节点 binding v-[name]:[arg].[modifies].[modifies]=&quot;[expression]&quot; name: 指令名 value: 指令的绑定值 oldValue: 指令绑定的前一个值，value参数改变之前的值 expression: 字符串形式的指令表达式 arg: 传递指令的参数 modifiers: 包含修饰符的对象 首先 如果 express 没有话 不会获取到 value, 如果想要获取 value，就要包含有 expression, 则该 expression 必须在 data 或者 computed 上必须要在第一层上 就算是 expression 用 ex1.ex2 或者 ex1[ex2],value 的值为 data[ex1] 或者 computed[ex1] 当 expression 为一个可以计算的表达式的时候 例如 1+1, ex1 + 1 等，value 的结果为 expression 计算之后的结果 vnode 虚拟node节点 oldVnode 上一个虚拟 DOM 节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;div id=&quot;app&quot;&gt; &lt;div&gt;this is test for directive&lt;/div&gt; &lt;div v-test:test2.test1=&quot;test3&quot;&gt;&#123;&#123;test3&#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; Vue.directive(&#x27;test&#x27;, &#123; bind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;4&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 4 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; */ &#125;, // 使用 componentUpdated 可以监控元素节点数据变化 展示的 更新之后的数据 componentUpdated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue) /** el: &lt;div&gt;9&lt;/div&gt; binding: arg: &quot;test2&quot; def: &#123;bind: ƒ, componentUpdated: ƒ&#125; expression: &quot;test3&quot; modifiers: &#123;test1: true&#125; name: &quot;test&quot; rawName: &quot;v-test:test2.test1&quot; value: 9 vnode VNode&#123;&#125; oldValue VNode&#123;&#125; // 此处存放的是 value 未被更改为4的时候的节点 */ &#125;, // 在元素bind的时候 可能updated方法就已经执行， // 此时 bind时候 的el对象是更新之后的对象,即 testChild 为 8 test3 为 9 // 但是 Vnode 及 oldVNode 还是元素未发生更改之前的元素节点 updated:function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;updated&#x27;) &#125;, // 指令解绑的时候触发 可以使用 v-if 控制元素隐藏和显示来触发 unbid unbind: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;unbind&#x27;) &#125;, // 页面一渲染就会触发 insert: function(el, binding, vnode, oldValue) &#123; console.log(el,binding,vnode,oldValue, &#x27;insert&#x27;) &#125;, &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: () =&gt; &#123; return &#123; test3: 4, testChild: 4 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.test3 = 9, this.testChild = 8 &#125;, 1000) &#125;, &#125;) &lt;/script&gt; Vue.filter(id:string, definition: Function)源码123456789101112131415161718192021222324252627282930var ASSET_TYPES = [ &#x27;component&#x27;, &#x27;directive&#x27;, &#x27;filter&#x27;];ASSET_TYPES.forEach(function (type) &#123; Vue[type] = function ( id, definition ) &#123; if (!definition) &#123; return this.options[type + &#x27;s&#x27;][id] &#125; else &#123; /* istanbul ignore if */ if (type === &#x27;component&#x27;) &#123; validateComponentName(id); &#125; if (type === &#x27;component&#x27; &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id; definition = this.options._base.extend(definition); &#125; if (type === &#x27;directive&#x27; &amp;&amp; typeof definition === &#x27;function&#x27;) &#123; definition = &#123; bind: definition, update: definition &#125;; &#125; this.options[type + &#x27;s&#x27;][id] = definition; return definition &#125; &#125;; &#125;);&#125; 以上代码 是 ‘component’, ‘directive’, ‘filter’ 三个全局API 注册到 Vue 实例上的方法 如果是 component 则检查 组件名称是否是合格的组件名称 然后在判断 是否是 definition 参数是否是对象，如果是，则使用 Vue 实例的 extend 方法扩展全局的 extend 属性 如果是 directive 如果传入的 definition 是函数 则默认调用 bind 和 update 方法 使用123456&lt;div&gt;&#123;&#123; test | uppcase&#125;&#125;&lt;div&gt;&lt;script&gt;Vue.filter(&#x27;uppcase&#x27;, function(value) &#123; return value &amp;&amp; value.toUpperCase()&#125;&lt;/script&gt; Vue.component(id: string, definition: Function | Object)源码请查看 Vue.filter 的讲解 使用12345Vue.componet(&#x27;my-component&#x27;, &#123; data() &#123;return &#123;&#125;&#125; methods: &#123;&#125; computed: &#123;&#125;&#125;) definition 可以传递 Vue.extend({}),也可以直接传一个对象，Vue会自动调用 Vue.extend 方法 Vue.use(plugin)源码12345678910111213141516171819function initUse (Vue) &#123; Vue.use = function (plugin) &#123; var installedPlugins = (this._installedPlugins || (this._installedPlugins = [])); if (installedPlugins.indexOf(plugin) &gt; -1) &#123; // 判断是否 安装过此插件 return this &#125; // additional parameters var args = toArray(arguments, 1); args.unshift(this); if (typeof plugin.install === &#x27;function&#x27;) &#123; plugin.install.apply(plugin, args); // 调用 plugin 的 install 函数 &#125; else if (typeof plugin === &#x27;function&#x27;) &#123; plugin.apply(null, args); // 直接执行 plugin 函数 &#125; installedPlugins.push(plugin); return this &#125;;&#125; 使用12// plugin必须是一个函数 或者包含 install 的对象 Vue.use(plugin) Vue.mixin(plugin)源码123456function initMixin$1 (Vue) &#123; Vue.mixin = function (mixin) &#123; this.options = mergeOptions(this.options, mixin); return this &#125;;&#125; 此方法 调用了 mergeOptions 方法将 传入的参数 与 Vue 的 options 属性合并 使用 这个方法会影响 所有创建的 Vue 组件，不推介使用，但是可以用于 optionMergeStrategies 自定义 选项12345678910111213Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: &#x27;hello!&#x27;&#125;)// =&gt; &quot;hello!&quot; Vue.compile将一个模板字符串编译成 render 函数 源码没看懂，有时间再来研究(2021-01-24)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798function createCompileToFunctionFn (compile) &#123; var cache = Object.create(null); return function compileToFunctions ( template, options, vm ) &#123; options = extend(&#123;&#125;, options); var warn$$1 = options.warn || warn; delete options.warn; /* istanbul ignore if */ &#123; // detect possible CSP restriction try &#123; new Function(&#x27;return 1&#x27;); &#125; catch (e) &#123; if (e.toString().match(/unsafe-eval|CSP/)) &#123; warn$$1( &#x27;It seems you are using the standalone build of Vue.js in an &#x27; + &#x27;environment with Content Security Policy that prohibits unsafe-eval. &#x27; + &#x27;The template compiler cannot work in this environment. Consider &#x27; + &#x27;relaxing the policy to allow unsafe-eval or pre-compiling your &#x27; + &#x27;templates into render functions.&#x27; ); &#125; &#125; &#125; // check cache var key = options.delimiters ? String(options.delimiters) + template : template; if (cache[key]) &#123; return cache[key] &#125; // compile var compiled = compile(template, options); // check compilation errors/tips &#123; if (compiled.errors &amp;&amp; compiled.errors.length) &#123; if (options.outputSourceRange) &#123; compiled.errors.forEach(function (e) &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + (e.msg) + &quot;\\n\\n&quot; + generateCodeFrame(template, e.start, e.end), vm ); &#125;); &#125; else &#123; warn$$1( &quot;Error compiling template:\\n\\n&quot; + template + &quot;\\n\\n&quot; + compiled.errors.map(function (e) &#123; return (&quot;- &quot; + e); &#125;).join(&#x27;\\n&#x27;) + &#x27;\\n&#x27;, vm ); &#125; &#125; if (compiled.tips &amp;&amp; compiled.tips.length) &#123; if (options.outputSourceRange) &#123; compiled.tips.forEach(function (e) &#123; return tip(e.msg, vm); &#125;); &#125; else &#123; compiled.tips.forEach(function (msg) &#123; return tip(msg, vm); &#125;); &#125; &#125; &#125; // turn code into functions var res = &#123;&#125;; var fnGenErrors = []; res.render = createFunction(compiled.render, fnGenErrors); res.staticRenderFns = compiled.staticRenderFns.map(function (code) &#123; return createFunction(code, fnGenErrors) &#125;); // check function generation errors. // this should only happen if there is a bug in the compiler itself. // mostly for codegen development use /* istanbul ignore if */ &#123; if ((!compiled.errors || !compiled.errors.length) &amp;&amp; fnGenErrors.length) &#123; warn$$1( &quot;Failed to generate render function:\\n\\n&quot; + fnGenErrors.map(function (ref) &#123; var err = ref.err; var code = ref.code; return ((err.toString()) + &quot; in\\n\\n&quot; + code + &quot;\\n&quot;); &#125;).join(&#x27;\\n&#x27;), vm ); &#125; &#125; return (cache[key] = res) &#125;&#125; 使用123456789var res = Vue.compile(&#x27;&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;&#x27;)new Vue(&#123; data: &#123; msg: &#x27;hello&#x27; &#125;, render: res.render, staticRenderFns: res.staticRenderFns&#125;) Vue.observable(object)让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象 源码123456789101112131415161718192021function observe (value, asRootData) &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; var ob; if (hasOwn(value, &#x27;__ob__&#x27;) &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++; &#125; return ob &#125; 调用了 通過 new Observer() 在 Observer 内部通过 walk 方法 调用 defineReactive$$1 进行对象响应式处理 使用12345678const state = Vue.observable(&#123; count: 0 &#125;)const Demo = &#123; render(h) &#123; return h(&#x27;button&#x27;, &#123; on: &#123; click: () =&gt; &#123; state.count++ &#125;&#125; &#125;, `count is: $&#123;state.count&#125;`) &#125;&#125; Vue.version提供 Vue 的版本号 1Vue.version = &#x27;2.6.12&#x27;;","updated":"2021-01-20T09:18:54.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（二）Vue3 生命周期","path":"2021/01/17/vue/vue3-vite-typescript-02/","text":"Vue3 继承了 Vue2 的所有生命周期函数，所以 Vue2 的生命周期的应用方式同样适用于 Vue3。同时 Vue3 还新增了一些新的生命周期。 原有的生命周期函数我们这边不做过多的赘述，我们来讲解一下 Vue3 相对于 Vue2 变更了和新增了哪些生命周期函数 beforeUnmount unmounted 这两个生命周期替代了 Vue2 的 beforeDestory 和 destoryed生命周期，两者的作用是一致的，都是在组件卸载的时候调用的，在 Vue3 还可以使用 unmout API 来卸载应用 renderTracked 跟踪 虚拟DOM 渲染时候调用，接收 debugger event 作为参数组件第一次渲染的时候调用，数据发生改变不会调用 12345678910111213141516&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; &#125;&lt;/script&gt; renderTriggered 当虚拟 DOM 重新渲染为 triggered.Similarly 为renderTracked，接收 debugger event 作为参数。此事件告诉你是什么操作触发了重新渲染，以及该操作的目标对象和键触发属性值的变更的时候触发 12345678910111213141516171819&lt;p&gt;Cart: &#123;&#123;cart&#125;&#125;&lt;/p&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; cart: 1 &#125; &#125;, // key: 渲染的属性的键名 // target: 渲染属性的键值对,值是修改之后的值 // type: 对当前属性的操作 renderTracked(&#123;key, target, type&#125;) &#123; &#125; mounted() &#123; setTimeout(() =&gt; &#123;this.cart++&#125;, 10000) &#125; &#125;&lt;/script&gt; 123456// 创建应用const app = createApp(&#123;&#125;)app.mount(&quot;#app&quot;)// 卸载应用app.unmount(&quot;#app&quot;) setup -&gt; created 和 beforeCreate setup 在 创建组件之前执行，作为组合式 API 的入口点,return 的返回值可以渲染到页面上 传参 props 父组件传入的 props 对象，是响应式的，prop 发生变化时会同时发生更新 注意不能使用结构赋值，否则会失去响应式的特性，如果想要解构出 props 中的属性可以选择使用 toRefs 来完成此操作 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div&gt; &lt;!-- 记录 Vue3 生命周期的相关使用方法 --&gt; &lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt; &lt;/setup-hook&gt; &lt;div&gt;test text&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import components from &#x27;./components/index&#x27;export default &#123; components: &#123; ...components &#125;, data() &#123; return &#123; time: 1000 &#125; &#125;, mounted() &#123; setTimeout(() =&gt; &#123; this.time += 1000 &#125;, 1000) &#125;, methods: &#123; handleSuccess() &#123; console.log(&#x27;success&#x27;) &#125; &#125;,&#125;&lt;/script&gt; 12345678910111213141516171819&lt;div&gt; &lt;div&gt;当前时间：&#123;&#123;time&#125;&#125;&lt;/div&gt; &lt;div&gt;截取props&#123;&#123;newTime&#125;&#125;&lt;/div&gt; &lt;div&gt;toRefs(props)&#123;&#123;refTime&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script lang=&quot;ts&quot;&gt;import &#123;toRefs&#125; from &#x27;vue&#x27;export default &#123; setup(props) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) return &#123; newTime, refTime &#125; &#125;&#125;&lt;/script&gt; 使用 toRefs 解构 props 的时候 如果想要直接访问 需要访问其 value 属性，下面是打印出来的解构出来的值,最后需要使用 return 抛出需要渲染和使用的变量及方法 context 暴露了三个组件的 property (attrs, slots, emit) attrs 为父组件在子组件上传递的属性(未被props接收)slots 为父组件在子组件中传入的插槽 默认有一个 default 插槽emit 这是一个执行函数，相当于 Vue.$emit() 可以用于发送事件 context 是一个普通的 JavaScript 非响应式对象，可以安全的使用 ES6 的解构赋值操作 1234567891011121314151617181920&lt;!-- 父组件 --&gt;&lt;setup-hook :time=&quot;time&quot; other=&quot;other&quot; :other-time=&quot;time&quot; @success=&quot;handleSuccess&quot;&gt; &lt;span&gt; 23123&lt;/span&gt; &lt;template v-slot:title&gt; 23123&lt;/template&gt; &lt;template v-slot:bottom&gt; 23123&lt;/template&gt;&lt;/setup-hook&gt;&lt;!-- 子组件 --&gt;&lt;script&gt; setup(props, &#123;attrs, emit, slots&#125;) &#123; let &#123;time: newTime&#125; = props let &#123;time: refTime&#125; = toRefs(props) console.log(refTime) console.log(attrs, slots) emit(&#x27;success&#x27;) return &#123; newTime, refTime &#125; &#125;,&lt;/script&gt; 因此在执行 setup 的时候组件实例还未被创建，只能访问 props, attrs, slots, emit实例，无法访问 data, computed, methods setup 在最后会有一个返回值，这个返回值是包含我们需要渲染或者在其他生命周期需要使用的变量的对象。 我们在使用 setup 需要注意以下几点： setup 中的 this 并不是 Vue 实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。 如果在 setup 中，我们定义了一个引用类型的变量，并针对这个变量进行了延时修改，这时修改之后的值并不会改变页面渲染，因为我们定义的并不是一个响应式类型的数据，如果想要创建一个响应式类型的数据，可以使用 reactive 来创建 1let obj = reactive(&#123;value: 1, label: &#x27;object&#x27;&#125;) 如果我们定义的是一个基础类型的变量，此时也想要他实现响应式的一个变化，这是可以使用 ref 来创建，访问对象的值可以通过访问变量的 value 属性 1234const count = ref(0)console.log(count.value) // 0// 此外还可以对 ref 内部进行类型指定const count = ref&lt;string | number&gt;(0) setup 的返回值可以在其他生命周期或者函数中直接通过 this 调用，并且已进行过响应式处理 在 setup 中还新增了一下几种 生命周期钩子，这些钩子函数只能在 setup 中使用 onBeforeMountonMountedonBeforeUpdateonUpdatedonBeforeUnmountonUnmountonErrorCapturedonRenderTrackedonRenderTriggered 具体使用方法与生命周期函数类似，但是注意以上这些只能在 setup 中使用 12345setup() &#123; onMounted(() =&gt; &#123; console.log(&#x27;mounted&#x27;) &#125;)&#125; Vue3 还提供了 provide 和 inject 方便在 setup 中进行 提供和注入 1234567setup() &#123; provide(&#x27;title&#x27;, &#x27;this is a title&#x27;)&#125;setup() &#123; const title = inject(&#x27;title&#x27;, &#x27;default value&#x27;)&#125;","updated":"2021-01-17T14:24:46.000Z","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/categories/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/categories/vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"},{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/tags/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/tags/vite/"}]},{"title":"Vue3 + Vite + TypeScript 项目实战 -----（一）搭建项目","path":"2021/01/15/vue/vue3-vite-typescript-01/","text":"Vue3 新版出来了这么久，虽然之前也有联系过搭建，但是并没有测试过多的东西，趁着闲暇时间，打算从头采坑，记录自己的 Vue 3.0 的爬坑历程 搭建项目 本次项目搭建采用尤雨溪大大开发的 Vite，这是尤大最近开发出的新的 Web 开发工具具有以下优点 快速的冷启动 即时的模块热更新 真正的按需编译 使用 vite 极大的提高了前端的开发性能及开发速度 全局安装 Vite 123456789// 全局安装 vite-appnpm i -g vite-app// 创建项目npm init vite-app &lt;project-name&gt;cd project-nameyarn || npm install 安装 必要第三方插件 安装 TypeScript 1npm install -D typescript 根目录(src)下新增 shim.vue.d.ts 文件 123456789101112declare module &#x27;*.vue&#x27; &#123; import &#123; Component &#125; from &#x27;vue&#x27; const component: Component export default component&#125;// 或者declare module &#x27;*.vue&#x27; &#123; import Vue from &#x27;vue&#x27; // const component: defineComponent&lt;&#123;&#125;,&#123;&#125;,any&gt; export default Vue&#125; 修改 main.js 为 main.ts 并修改 index.html 文的引用 安装 vue-router vue3.0 最好安装最新的版的 vue-router，版本错误的话无法使用路由进行跳转 1npm install vue-router@4 然后在 src 目录下新建 router 目录，在目录下新建 index.ts 文件 从 vue-router 引入 createRouter 和 createWebHashHistory(或者createWebHistory) 1import &#123;createRouter, createWebHashHistory&#125; from &#x27;vue-router&#x27; 然后新建 一个 route对象，存放路由配置，使用 createRouter 方法 创建 router 对象，最后通过 export default 导出 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;../views/home/index.vue&#x27;), redirect: &#x27;/index&#x27;, children: [ &#123; path: &#x27;/login&#x27;, component: () =&gt; import(&#x27;../views/login/index.vue&#x27;) &#125;, ] &#125;,]var router = createRouter(&#123; history: createWebHashHistory(), routes&#125;)export default router 在 mian.ts 对象中 通过 import 引入，并用 Vue 的 use 方法 注册到 Vue 实例上 12import router from &#x27;./router&#x27;createApp(App).use(router).mount(&#x27;#app&#x27;) 使用 Vue 状态管理工具 Vuex 123456789101112131415161718192021222324// 安装npm install vuex@next// 使用// /src/store/index.tsimport Vuex from &#x27;vuex&#x27;const store = new Vuex.Store(&#123; // ... modules: &#123;&#125;, state: () =&gt; &#123; return &#123; name: &#x27;lxx&#x27; &#125; &#125;, mutations: &#123;&#125;, actions: &#123;&#125;, getters: &#123;&#125;&#125;)export default store// 注册import store from &#x27;./store&#x27;createApp(App).use(router).use(store).mount(&#x27;#app&#x27;) 使用 sass 语法 12345// 安装 sassyarn add sass// 安装完成之后 将 sass 从 dependencies 移动到 devDependencies// 使用时 在 style 后加 lang=&quot;scss&quot; 如果想要对 Vite 构建的 Vue3.0应用进行新的配置，首先需要在根目录创建一个 vite.config.js 文件 配置路径别名1234567891011const path = require(&quot;path&quot;)function resolve(dir) &#123; return path.join(__dirname, dir)&#125;module.export = &#123; alias: &#123; &#x27;/@/&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 此时访问 src 目录下的文件就可以通过 /@/来进行访问 12// 访问 src 目录下的 component 目录下的 index 文件import Component from &#x27;/@/component&#x27; 为什么要使用 /@/ 而不是直接 @/ 呢，在这里 Vite 的官方配置给我们做了解释 当别名为文件系统路径的时候，请使用绝对路径，相对别名值将按原样使用，并不会解析为文件路径，所有要使用 /@/ 来代表绝对路径","updated":"2021-01-15T14:56:10.000Z","categories":[{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/categories/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/categories/vite/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"},{"name":"Vue3","slug":"Vue3","permalink":"https://lxx1997.github.io/tags/Vue3/"},{"name":"vite","slug":"vite","permalink":"https://lxx1997.github.io/tags/vite/"}]},{"title":"JavaScript 原型链","path":"2021/01/14/web/js-prototype-chain/","text":"当我们定义了一个函数或者对象的时候，自带有属性中有一个属性 __proto__，这个属性又被称作原型链，指向构造当前函数的 prototype 1234567function Test() &#123; this.a = 1&#125;const test = new Test()console.log(test.__proto__) // &#123;constructor: f&#125;console.log(Test.prototype) // &#123;constructor: f&#125;console.log(test.__proto__ === Test.prototype) // true 当我们继续打印 Test.prototype.__proto__ 的时候会发现 Test 的构造函数是 Object，即 1console.log(Test.prototype.__proto__ === Object.prototype) // true 这个时候就会发现有些特殊的事情，当我们在 Test 的 prototype 属性上添加一些属性或者 Object 的 prototype 上添加一些属性，这时通过 new 构造出来的实例能不能访问到这些属性或者方法呢，接下来让我们尝试一下 12345678910111213141516171819202122 function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 console.log(test.a) // 1 console.log(test.b) // 3 console.log(test.c) // 4~~~~这个时候如果我们在 test 实例上新增一个属性 b 并赋值，这时侯打印出来的 test.b 的值是多少呢~~~js function Test() &#123; this.a = 1 &#125; const test = new Test() Test.prototype.b = 3 Object.prototype.c = 4 test.b = 5 console.log(test.b) // b 这是因为 使用 new 构造函数的时候，会自动继承构造函数上的所有方法及属性，当我们在访问实例的某个属性的时候，会现在实例对象上查找是否包含有这个属性，如果包含就直接返回，不包含的话就会在实例的原型链 __proto__ 上继续查找，如果仍未找到，则会继续通过 __proto__一级一级的向上查找，直到找到 原型链的最后一级 Object,如果仍未找到就返回 undefined constructor 在实例的自身属性及 __proto__ 属性上有一个 contructor 属性，该属性指向 构造当前实例的 构造函数 1234567function Test() &#123; this.a = 1&#125;const test = new Test()// 这是因为 使用 new 构造函数的时候 把 Test 的所有属性都赋予了 testtest.__proto__.constructor // f Test() &#123;this.a = 1&#125;test.constructor // f Test() &#123;this.a = 1&#125; 判断是否包含属性 如何判断 实例的属性 是在实例自身身上还是在原型链上呢，这时候可以通过 Object.hasOwnProperty 123456789101112function Test() &#123; this.a = 1&#125;const test = new Test()Test.prototype.b = 3Object.prototype.c = 4console.log(test.hasOwnProperty(&#x27;a&#x27;)) // trueconsole.log(test.hasOwnProperty(&#x27;b&#x27;)) // falseconsole.log(test.hasOwnProperty(&#x27;c&#x27;)) // falseconsole.log(&#x27;a&#x27; in test) // trueconsole.log(&#x27;b&#x27; in test) // trueconsole.log(&#x27;v&#x27; in test) // true 属性 b 和 c 是挂载到 test 的原型链上的属性，并不属于 test 自身，所以通过 Object.hasOwnProperty 访问的时候返回为 false 特殊的原型 Object 和 Function 123Function.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // trueObject.__proto__ === Function.__proto__ // true","updated":"2021-01-14T14:57:43.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"prototype","slug":"prototype","permalink":"https://lxx1997.github.io/tags/prototype/"}]},{"title":"JavaScript - this 指向问题","path":"2021/01/11/web/js-this-point/","text":"this 的指向问题一直是 JavaScript 中一个很重要的问题，我们在日常编程中，经常会遇到在函数中执行的时候，发现从 this 中取不到我们想要的东西，面试的过程中，this 也是经常会被面试官问到的一个问题。 接下来，我们将会在此篇文章中详细的讲解一个 JavaScript 中 this 的获取及指向问题 this 指向在 JavaScript 中一个特殊的关键字 this，通过 this 我们可以获取当前代码块执行环境的对象 我们可以通过 this.xxx 来获取到 this 所代表的对象的属性 this 取何值，取决于 this 所处代码块为谁调用的 总结一下 this 指向几种情况 普通函数调用的时候，this 指向 window 又称作默认绑定 来看下面这一段代码 123456var name = &#x27;zhangsan&#x27;function fn() &#123; var name = &#x27;lisi&#x27; console.log(this.name)&#125;fn() 猜一下上述代码 输出的 name 是什么？ 对的，输出的 zhangsan，也许你会问为什么 函数 fn 里面的 this 不是指向函数 fn，这是因为在全局中通过 var 创建的变量也会默认挂载在 window 对象中， 调用 fn() 函数的时候，直接调用相当于 window.fn()，此时 this 指向调用函数 fn 的对象 即 window，所以输出的是 zhangsan。 需要注意一点的是，这段代码在浏览器执行和在 node 环境在执行输出的结果是不一样，因为在 node 环境中 全局对象是 global，而不是 window。 通过对象方法调用的时候，函数的 this 指向这个对象 又称作隐式绑定 我们对以上代码再次进行改装 12345678910var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: function() &#123; console.log(this.name) &#125;&#125;var fn = obj.fnobj.fn()fn() 上述代码输出的是什么呢？可能有会说输出的都是 lisi，因为函数 fn 位于 obj 对象里，所以它的 this 指向 obj，但是我们想说这是一种错误的理解方式，因为 this 的指向不是由他位于哪个代码块中决定，而是由它所在的代码块由谁调用来决定。 我们知道函数在执行之前都会经过解析，然后在栈内存中存放解析后的键值对，当解析到 obj 的时候，因为 obj 的类型是 Object 所以会在栈内存中开辟一个新的栈内存，用来存储 obj 的键值对，然后将新建的栈内存通过引用赋予 obj，当解析到 obj 的 fn 函数的时候，同样会开辟一个新的栈内存 AAAFFF000，这个栈内存用来存放 fn 的函数字符串 当我们通过 obj 来调用的时候，可以理解为 AAAFFF000 这个栈内存 上下文对象是 obj， 此时通过 this 调用的时候，this 指的就是 obj 这个对象 而将 obj.fn 赋值于 fn 的时候，由于 obj.fn 是一个引用对象，所以将 obj.fn 的引用地址复制给了 fn，然后调用 fn 相当于在 window 的环境下执行 AAAFFF000 这个代码块，此时的 this 指向 window 所以输出的是 12// &#x27;lisi&#x27;// &#x27;zhangsan&#x27; 接下来我们对这段代码进行进一步改造，然后看一下它的执行结果 12345678910111213var name = &#x27;zhangsan&#x27;var obj = &#123; name: &#x27;lisi&#x27;, fn: (function() &#123; console.log(this.name) return function() &#123; console.log(this.name) &#125; &#125;)()&#125;var fn = obj.fnobj.fn()fn() 你猜到这段代码输出的结果了吗？ 这段代码输出的结果是 123// &#x27;zhangsan&#x27;// &#x27;lisi&#x27;// zhangsan 大家看 obj 对象中的 fn 函数，这个函数是一个自执行函数，会在解析的时候就执行，这个时候上下文对象是 window，所以输出的是 ‘zhangsan’ 然后返回一个函数，此时这个 obj.fn 就等于这个 return 回来的函数 后面的输出的数据执行方法和上一个例子是一样的，这里就不在多做赘述 特殊的例子: 回调函数模式 123456789function foo() &#123; function test() &#123; console.log(this) &#125; return test&#125;foo()() // window// 因为 foo() 执行的相当于返回了 test 再一次调用和调用 test() 方法相等// foo()() === test() 特殊情况：参数赋值的情况 首先上代码 123456789101112var a = 3function foo() &#123; console.log(this)&#125;function bar(fn) &#123; fn()&#125;var obj = &#123; a: 2, foo: foo&#125;bar(obj.foo) // window 在 bar 函数中， fn 为形参，在调用 bar 函数传入 obj.foo 实参的时候，实际上相当于隐形的将 obj.foo 赋值于 fn，fn进行调用的时候，正好符合 this 的默认绑定规则，此时 this 指向 window 总结起来就一句话 函数每次执行的都会有自己的 this 指向，函数单独调用的时候(包括自调用函数)，this 执行 window，以对象的方法调用时候，this 隐式绑定为 该对象 显示绑定 call，bind，apply bind,call,apply都可以改变函数的 this 指向 1234567891011var obj = &#123; a: 1&#125;var a = 2function test() &#123; console.log(this.a)&#125;test() // 2test.call(obj) // 1test.bind(obj) // 1test.apply(obj) // 1 其中 call 和 apply 在改变 this 指向的时候会自动调用函数，而 bind 只会改变 this 指向并不会执行函数 call 和 bind 是可以传入多个参数 call(this, arg1, arg2, …), apply 多个参数需要放到数组里面 apply(this, [arg1, arg2, arg3…]) 通过构造函数 new 关键字创建的，this 指向实例对象 在通过 new 关键字构造函数时，主要做了以下四件事 首先创建了一个空对象 然后连接到原型，将 obj 的 __proto__ 指向构造函数的 prototype123class A &#123;&#125;var a = new A()a.__proto__ === A.prototype 通过 .call(obj) 将 function 的 this 指向 obj 返回创建的这个对象 123456function Fn() &#123; console.log(this) this.a = 1&#125;var fn = new Fn() // Fn&#123;&#125;console.log(fn.a) // 1 如果 Fn 函数 中 return 了一个对象 obj，new 的时候 this 会指向这个 obj对象 1234567function Fn() &#123; console.log(this) this.a = 1 return &#123;&#125;&#125;var fn = new Fn() // &#123;&#125;console.log(fn.a) // undefined 通常来说，优先级的顺序大概是 new &gt; call/bind/apply &gt; 隐式绑定 &gt; 默认绑定 12345678910111213141516var a = &#x27;window&#x27;function test() &#123; console.log(this.a)&#125;var obj = &#123; a: &#x27;obj’, test: test&#125;var obj2 = &#123; a: &#x27;obj2&#x27;&#125;test() // windowtest.call(obj) // objobj.test.call(obj2) // obj2new obj.test() // undefined this 指向 test&#123;&#125; 特殊的 this 指向es6 的箭头函数 先来看一下普通函数的 this 指向 123456789function b() &#123; function a()&#123; console.log(this) &#125; let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()// &#123;a: fn(), c:fn()&#125; obj2.c()// window&#125;let obj = &#123;b&#125;obj.b()//使函数b内上下文this为obj 如果加上箭头函数 123456789function b() &#123; let a = () =&gt; console.log(this) let c = function() &#123;a()&#125; let obj2 = &#123;a,c&#125; obj2.a()//&#123;b: fn()&#125; obj2.c()//&#123;b: fn()&#125;&#125;let obj = &#123;b&#125;obj.b()//&#123;b:fn()&#125; 从上面的例子可以看出，箭头函数在调用的时候，指向声明的时候所在的上下文 也可以说 箭头函数 是没有 this，他的 this 全由所处上下文对象的 this 指向决定，一旦this 指向确定，无法通过 new/call/bind/apply/隐式绑定/显示绑定等方法修改this指向","updated":"2021-01-11T01:30:46.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"this","slug":"this","permalink":"https://lxx1997.github.io/tags/this/"}]},{"title":"跟着 Vue源码学习 Vue api 系列 (一) - 全局配置","path":"2021/01/09/vue/vue-learn-api-with-源码-01/","text":"此篇文章用来记录 Vue 中 Api 在 Vue源码中的具体实现方法，以便更好的理解 Vue 的各种 Api 的使用方法 全局配置Vue 的全局配置参数是存放在 config 里面的，我们可以通过修改 config 中的 properties 1234567891011121314151617181920212223Config = &#123; // user optionMergeStrategies: &#123; [key: string]: Function &#125;; silent: boolean; productionTip: boolean; performance: boolean; devtools: boolean; errorHandler: ?(err: Error, vm: Component, info: string) =&gt; void; warnHandler: ?(msg: string, vm: Component, trace: string) =&gt; void; ignoredElements: Array&lt;string | RegExp&gt;; keyCodes: &#123; [key: string]: number | Array&lt;number&gt; &#125;; // platform isReservedTag: (x?: string) =&gt; boolean; isReservedAttr: (x?: string) =&gt; boolean; parsePlatformTagName: (x: string) =&gt; string; isUnknownElement: (x?: string) =&gt; boolean; getTagNamespace: (x?: string) =&gt; string | void; mustUseProp: (tag: string, type: ?string, name: string) =&gt; boolean; // private async: boolean; // legacy _lifecycleHooks: Array&lt;string&gt;;&#125; 1. silent Boolean silent 配置 主要用于判断是否输出 Vue 所有的日志和警告 默认为 false 不取消日志和警告输出 设置为 true 取消日志和警告输出12345var hasConsole = typeof console !== &#x27;undefined&#x27;;// hasConsole 用于判断 window对象中 是否包含有 console 这个属性if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace));&#125; 2. optionMergeStrategies Object 自定义选项合并策略，覆盖已有值 主要用于 mixin 和 Vue.extend() 方法时对子组件和父组件 有相同属性时的合并策略 以下的 parentVal，parent 等父参数 只有 Vue.extend 或者 extends 传入对应类型数据时才有数据 Vue源码 自带的属性 el，propsData，provide 子组件和父组件如果有相同的方法，以子组件为主 el propsData12345678910111213141516var defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal&#125;;strats.el = strats.propsData = function (parent, child, vm, key) &#123; if (!vm) &#123; warn( &quot;option \\&quot;&quot; + key + &quot;\\&quot; can only be used during instance &quot; + &#x27;creation with the `new` keyword.&#x27; ); &#125; // 在这里进行了判断，如果 child 存在 就返回 child 否则返回 parent // 表明在合并的过程中 el 和 propsData 以子的为准 return defaultStrat(parent, child)&#125;; provide strats.provide = mergeDataOrFn; data123456789101112131415161718function (parentVal, childVal, vm ) &#123; // childVal 是 组件的 data 函数 if (!vm) &#123; // 判断 vue 的 data 对象是一个函数 保证各个组件之间的数据互不影响 if (childVal &amp;&amp; typeof childVal !== &#x27;function&#x27;) &#123; warn( &#x27;The &quot;data&quot; option should be a function &#x27; + &#x27;that returns a per-instance value in component &#x27; + &#x27;definitions.&#x27;, vm ); // 如果子的值不是函数 返回父的值 return parentVal &#125; return mergeDataOrFn(parentVal, childVal) &#125; return mergeDataOrFn(parentVal, childVal, vm)&#125;; margeDataOrFn 方法1234567891011121314151617181920212223242526272829303132333435363738// 合并数据function mergeDataOrFn (parentVal, childVal, vm) &#123; if (!vm) &#123; // in a Vue.extend merge, both should be functions if (!childVal) &#123; return parentVal &#125; if (!parentVal) &#123; return childVal &#125; // when parentVal &amp; childVal are both present, // we need to return a function that returns the // merged result of both functions... no need to // check if parentVal is a function here because // it has to be a function to pass previous merges. return function mergedDataFn () &#123; return mergeData( typeof childVal === &#x27;function&#x27; ? childVal.call(this, this) : childVal, typeof parentVal === &#x27;function&#x27; ? parentVal.call(this, this) : parentVal ) &#125; &#125; else &#123; return function mergedInstanceDataFn () &#123; // instance merge var instanceData = typeof childVal === &#x27;function&#x27; ? childVal.call(vm, vm) : childVal; var defaultData = typeof parentVal === &#x27;function&#x27; ? parentVal.call(vm, vm) : parentVal; if (instanceData) &#123; return mergeData(instanceData, defaultData) &#125; else &#123; return defaultData &#125; &#125; &#125;&#125; margeData 方法set方法详解1234567891011121314151617181920212223242526272829function mergeData (to, from) &#123; if (!from) &#123; return to &#125; var key, toVal, fromVal; // 判断是否有 Symbol 数据类型，避免合并数据的时候遗漏 Symbol 类型属性 // Reflect.ownKeys(obj) 可以遍历出 Symbol 类型属性 // Object.keys,Object.values 无法遍历出 Symbol 类型属性 var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from); for (var i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; // in case the object is already observed... if (key === &#x27;__ob__&#x27;) &#123; continue &#125; toVal = to[key]; fromVal = from[key]; if (!hasOwn(to, key)) &#123; set(to, key, fromVal); &#125; else if ( toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal); &#125; &#125; return to&#125; watch12345678910111213141516171819202122232425function (parentVal, childVal, vm, key) &#123; // work around Firefox&#x27;s Object.prototype.watch... if (parentVal === nativeWatch) &#123; parentVal = undefined; &#125; if (childVal === nativeWatch) &#123; childVal = undefined; &#125; /* istanbul ignore if */ if (!childVal) &#123; return Object.create(parentVal || null) &#125; &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; // parent 存在 则和 child 合并，否则判断 child 是否是数组，返回 数组 ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret&#125;; hooks，watch 会把子组件和父组件相同的钩子函数合并到一个数组上，父组件的钩子函数先执行 声明周期函数(在此不一一列举了)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var LIFECYCLE_HOOKS = [ &#x27;beforeCreate&#x27;, &#x27;created&#x27;, &#x27;beforeMount&#x27;, &#x27;mounted&#x27;, &#x27;beforeUpdate&#x27;, &#x27;updated&#x27;, &#x27;beforeDestroy&#x27;, &#x27;destroyed&#x27;, &#x27;activated&#x27;, &#x27;deactivated&#x27;, &#x27;errorCaptured&#x27;, &#x27;serverPrefetch&#x27;];LIFECYCLE_HOOKS.forEach(function (hook) &#123; strats[hook] = mergeHook;&#125;);// 使用方法function mergeHook (parentVal, childVal) &#123; /** * 下面这个三目表达式可以拆分成下列样式 * var test1 = Array.isArray(childVal) ? childVal : [childVal] * var test2 = parentVal ? parentVal.concat(childVal) : test1 * var test3 = childVal ? test2 : parentVal * 如果 childVal 存在，就执行 test2 语句 不存在 则取 parentVal * test2 语句中 如果 parentVal 存在， 则与 childVal 连接成一个新数组 否则执行 test1 语句 * test1 语句中 如果 childVal 是数组 就取 childVal 否则就转成数组 */ var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal; // 对 获得的 res 进行去重 return res ? dedupeHooks(res) : res&#125;function dedupeHooks (hooks) &#123; var res = []; for (var i = 0; i &lt; hooks.length; i++) &#123; // 如果 res 数组中不存在 hooks[i],就插入 hooks[i] 否则略过 if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]); &#125; &#125; return res&#125; component directive filter123456789101112function mergeAssets (parentVal, childVal, vm, key) &#123; // 以 parentVal 为原型 创建对象 res.prototype === parentVal var res = Object.create(parentVal || null); if (childVal) &#123; //判断 childVal 的类型 assertObjectType(key, childVal, vm); // 通过 extend 方法将 childVal 的属性复制到 res 上 并覆盖相同属性的数据 return extend(res, childVal) &#125; else &#123; return res &#125;&#125; components，directives，filters 使用了原型继承，返回合并后的新对象 props methods inject computed 1234567891011function (parentVal, childVal, vm, key) &#123; if (childVal &amp;&amp; &quot;development&quot; !== &#x27;production&#x27;) &#123; assertObjectType(key, childVal, vm); &#125; if (!parentVal) &#123; return childVal &#125; var ret = Object.create(null); // 合并 parentVal 和 childVal extend(ret, parentVal); if (childVal) &#123; extend(ret, childVal); &#125; return ret&#125;; props，methods，computed，inject 采用对象合并的方法，先合并父组件，在合并子组件，如果父组件和子组件有相同的属性，子组件会覆盖父组件的属性 简单的使用示例 1234567891011121314151617181920212223242526272829303132Vue.config.optionMergeStrategies._myOptions = (parntVal, childVal, vm) =&gt; &#123; console.log(parntVal, childVal, vm) return parntVal ? childVal ? childVal + parntVal : 0 : childVal &#125;const B = &#123; _myOptions: 3&#125;const C = &#123; _myOptions: 3&#125;Vue.component(&#x27;test&#x27;, &#123; mixins: [B,C], data() &#123; return &#123; test: 1 &#125; &#125;, _myOptions: 2, mounted() &#123; console.log(this.$options._myOptions) // 8 &#125;, template: `&lt;div&gt; children &lt;/div&gt;`&#125;)const app = new Vue(&#123; el: &#x27;#app&#x27;, template: ` &lt;div&gt; test &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `&#125;) devtools 12// detect devtoolsvar devtools = inBrowser &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__; errorHandler 默认是 undefined 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。 123Vue.config.errorHandler = (err, vm, info) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, err, vm, info)&#125; 源码位置1234567891011121314function globalHandleError (err, vm, info) &#123; if (config.errorHandler) &#123; try &#123; return config.errorHandler.call(null, err, vm, info) &#125; catch (e) &#123; // if the user intentionally throws the original error in the handler, // do not log it twice if (e !== err) &#123; logError(e, null, &#x27;config.errorHandler&#x27;); &#125; &#125; &#125; logError(err, vm, info);&#125; warnHandler 默认值是 undefined，只会在开发环境下生效，生产环境下会被忽略 123Vue.config.warnHandler = (msg, vm, trace) =&gt; &#123; console.error(&#x27; 错误拦截:&#x27;, msg, vm, trace)&#125; 源码12345678warn = function (msg, vm) &#123; var trace = vm ? generateComponentTrace(vm) : &#x27;&#x27;; if (config.warnHandler) &#123; config.warnHandler.call(null, msg, vm, trace); &#125; else if (hasConsole &amp;&amp; (!config.silent)) &#123; console.error((&quot;[Vue warn]: &quot; + msg + trace)); &#125;&#125;; ignoredElements Array 默认是一个空字符串，是一个由 字符串或者正则表达式组成的数组 作用是为了屏蔽 Vue 的组件验证的时候，自定义组件(Web Components API)报错提示功能，匹配到数组里面的组件名称的时候，会过滤掉提示 1234567Vue.config.ignoredElements = [ &#x27;my-custom-web-component&#x27;, &#x27;another-web-component&#x27;, // 用一个 `RegExp` 忽略所有“ion-”开头的元素 // 仅在 2.5+ 支持 /^ion-/] 源码位置 123456789101112131415function isUnknownElement$$1 (vnode, inVPre) &#123; return ( !inVPre &amp;&amp; !vnode.ns &amp;&amp; !( config.ignoredElements.length &amp;&amp; config.ignoredElements.some(function (ignore) &#123; return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag &#125;) ) &amp;&amp; config.isUnknownElement(vnode.tag) )&#125; keyCodes {[key: string]: number | Array} 给 v-on 自定义键位别名123456789Vue.config.keyCodes = &#123; v: 86, f1: 112, // camelCase 不可用 mediaPlayPause: 179, // 取而代之的是 kebab-case 且用双引号括起来 &quot;media-play-pause&quot;: 179, up: [38, 87]&#125; 123&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;&lt;input type=&quot;text&quot; @keyup.179=&quot;method&quot;&gt;&lt;!-- 以上两种方法等效 --&gt; performance boolean 默认为 false 设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪 productionTip boolean 默认为 true， 设置为 false 阻止 vue 在启动时生成生产提示信息","updated":"2021-01-09T14:17:53.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/categories/SourceCode/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"Vue 组件之间通讯的各种情况","path":"2021/01/07/vue/vue-components-transfer-data/","text":"我们都知道 Vue 的两大核心是组件化和数据驱动，在 Vue 中，组件之间的值传递是一种十分常见的事情，那么你到底知道多少种组件的值传递的方法呢，接下来由我来带领大家了解一下 Vue 组件之间的关系Vue 的组件根据其在页面上的位置，我认为大致可以分为以下几种: 父子组件 什么是父子组件呢？ 假如现在页面中有一个根组件ParentComponent,现在我们需要在这个根组件中加入其他内容，例如一张图片，一段具有事件和样式的文字等，我们可以假设这个加入内容的组件名称为ChildrenComponent, 这个新加入的组件ChildrenComponent 相对与 ParentComponent就是子组件, ParentComponent 就是 ChildrenComponent 的父组件，如下所示 123&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 兄弟组件 什么是兄弟组件呢？以上面的父子组件为例，假如现在加入的不是一个组件，而是加入多个组件，加入的这些组件之间的关系就是兄弟组件的关系 12345&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 非父子，兄弟关系的组件 这种组件的关系是怎么形成的呢，可能就是位于不同父组件下的子组件之间的关系 1234&lt;parent-component&gt; &lt;children-component&gt;&lt;/children-component&gt;&lt;/parent-component&gt;&lt;other-component&gt;&lt;/other-component&gt; 比如这种，children-component 和 other-component 之间的关系都是即非父子，兄弟关系组件 当然以上说法都不是特别组件，因为 Vue 是一个单页面组件，都位于同一个根组件下面，所以 Vue 中的组件之间都或多或少都是有一些关系 Vue 组件之间的通讯上面介绍完了组件，我们现在介绍一下不同组件之间应该如何通讯 父子组件 Vue 组件上有个特殊的属性 Props 可以取到通过 v-bind指令或者直接通过 属性 传值 传递过来参数，通常用于父子组件传值 123&lt;parent-component&gt; &lt;children-component :type=&quot;type&quot; name=&quot;name&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 此时子组件可以通过 props 来获取父组件传递过来的参数 123456789101112131415161718// children-componentexport default &#123; // 第一种 (不推介，因为没有类型检测，不利于开发) props: [&#x27;type&#x27;, &#x27;name&#x27;], // 第二种 (推介，可以检查通过 props 传递过来值的类型，利于排错和开发) props: &#123; type: &#123; type: Array, // 如果需要兼容多重类型检查可以使用数组 [Array, Object, String] default: () =&gt; &#123; return [] &#125; &#125;, name: &#123; type: String, default: &#x27;&#x27; &#125; &#125;&#125; 子组件向父组件传值可以采用 $emit() 来发送事件，父组件采用 v-on 来监听事件发生 123456// 子组件export default &#123; mounted() &#123; this.$emit(&#x27;change&#x27;) &#125;&#125; 1234&lt;parent-component&gt; &lt;!-- v-on: 也可以简化成 @ --&gt; &lt;children-component v-on:change=&quot;handleChange&quot;&gt;&lt;/children-component&gt;&lt;/parent-component&gt; 当然我们也可以采用 v-model 来传递参数，但是此时子组件必须要用 props 接收 一个名叫 value 的值，当事件触发时，把新的值通过自定义的 input 事件抛出 因为 v-model 等价 v-bind:value 和 v-on:input $parent 和 $children 也可以实现父子组件之间传值 但是 Vue 并不推介我们使用这种方法来进行父子组件传值通讯，只是作为访问组件的应急方法，更推介采用 props 和events($emit,$on) 父子组件之间也可以通过 $refs 方法来进行通讯 在子组件上添加属性 ref 值为 refValue, 父组件可以通过 this.$refs[refValue] 或者 this.$refs.refValue 来访问和调用子组件上面的方法和值 注意： 使用 $ref 获取子组件必须是子组件已经在页面中加载成功了，即在 除beforeCreate, created, destoryed 生命周期函数以外的其他声明周期调用，如果组件是手动控制显示和隐藏，即使用 v-if，此时可以采用 this.$nextTick(() =&gt; &#123;this.$refs[refValue]&#125;) 方法来访问子组件的方法 兄弟组件之间的传值 通过共有的父组件来进行传值 子组件通过 $emit 方法调用父组件的方法，然后通过父组件来调用其他的子组件来实现兄弟组件之间之间传值 通过 $parent 方法 同父子组件传值，可以使用，但是不推介 非父子，兄弟关系的组件 Vuex Vue 状态管理工具 可以使用 Vue 的状态管理工具来进行传值 123456789101112131415161718192021222324252627282930313233// store.js/** * state: 存储状态管理对象及数据 * mutations: 同步修改 state 的属性的值，同时只有 mutations 能够修改 state 的值 使用时通过 commit 来调用 * actions: 异步修改 state 的属性的值，通过调用 mutations 的方法来修改 通过 dispatch 方法调用 */ export default &#123; state: &#123; type：1 &#125;, mutations: &#123; setType(state, type) &#123; state.type = type &#125;, &#125;, actions: &#123; setType(&#123;commit&#125;, type) &#123; commit(&#x27;setType&#x27;, type) &#125; &#125;&#125;// a 组件export default &#123; mounted() &#123; this.$store.dispatch(&#x27;setType&#x27;, 1) &#125;&#125;// b 组件export default &#123; mounted() &#123; this.$store.state.type &#125;&#125; 关于 Vuex 的更多使用方法请百度查找官方使用文档 Vue bus 也叫中央事件总线 定义一个全局的 Vue，通过挂载到 window 对象或者 Vue 实例上面，此时可以通过 Vue bus 的 $emit 和 $on 方法来进行事件传递 123456789101112// 第一种var bus = new Vue()// 发送事件bus.$emit(&#x27;patch&#x27;)// 接收事件bus.$on(&#x27;patch)// 第二种 Vue.$bus = new Vue()// 发送事件Vue.$bus.$emit(&#x27;patch&#x27;)// 接收事件Vue.$bus.$on(&#x27;patch) 进阶方法以上都是一些比较简单的组件之间传值的方法，相信在座的各位基本上都用到过，接下来介绍一些比较高端的方法，这些方法我们可能没有用过，也可能没有听说过，接下来让我来带领大家去了解他们，使用他们 $attrs 和 $listeners 此方法适用于多层父子组件结构进行通讯，因为层级过多，此时使用 $emit 和 $on 方法来进行传值，你需要在需要通讯的两个祖孙组件之间的每个组件都要写上重复的 $emit 和 $on, 增加事件追踪难度，同时难以阅读 此时可以采用 $attrs 和 $listeners来进行传值 这种方法所采用的办法就是将祖父组件的 传给 父组件的 属性和监听事件传递给孙组件 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!-- 函数我就不写了，只是做一个简略的展示 --&gt; &lt;!-- grandfather 组件 --&gt; &lt;grand-father&gt; &lt;a-parent :a=&quot;a = 4444&quot; :b=&quot;b = 5555&quot; @getData=&quot;handleGetData&quot; @passData=&quot;handlePassdata&quot;&gt;&lt;/a-parent&gt; &lt;/grand-father&gt; &lt;!-- parent 组件 --&gt; &lt;a-parent&gt; &lt;b-children v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;&gt;&lt;/b-children&gt; &lt;/a-parent&gt; &lt;script&gt; ... // 默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上 props:[] // 注意如果在此处使用了props接收了参数， 则通过 v-bind 传递给子组件的 $attrs 中就会缺失对应参数 mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; ... &lt;/script&gt; &lt;!-- children 组件 --&gt; &lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt; &lt;script&gt; ... mounted() &#123; console.log(this.$attrs) // &#123;a: 4444, b: 55555&#125; // 如果此时 props 接收了 参数 a 那么 console 的值为 &#123; b: 55555 &#125; // a 的值 也可以通过 $emit 方法传递给祖组件 console.log(this.$listeners) // &#123; getData: f(), passData: f()&#125; &#125; methods: &#123; passData(val) &#123; // 此处发送的事件名称需要与祖组件监听方法一致 即 @passData this.$emit(&#x27;passData&#x27;, val) &#125; &#125; ... &lt;/script&gt; provide 和 inject 父组件通过 provide 提供变量，子组件通过 inject 注入变量，不管子组件多深，只要调用了 inject 就可以注入 provide 中的数据，而不是局限于只能从当前父组件的 prop 属性来获取数据，只要在父组件的生命周期内，子组件都可以调用 123456789101112131415161718192021222324&lt;!-- grandfather 组件 --&gt;&lt;grand-father&gt; &lt;a-parent&gt;&lt;/a-parent&gt;&lt;/grand-father&gt;&lt;script&gt; ... provide: &#123; test: &#x27;test&#x27; &#125; ...&lt;/script&gt;&lt;!-- parent 组件 --&gt;&lt;a-parent&gt; &lt;b-children&gt;&lt;/b-children&gt;&lt;/a-parent&gt;&lt;!-- children 组件 --&gt;&lt;input v-model=&quot;$attrs.a&quot; @input=&quot;passData($attrs.a)&quot; /&gt;&lt;script&gt; ... inject:[&#x27;test&#x27;] ...&lt;/script&gt; boradcast 和 dispatch 这种方法我不太了解，贴上代码，大家自己体会 (＾－＾) vue1.0中提供了这种方式，但vue2.0中没有，但很多开源软件都自己封装了这种方式，比如min ui、element ui和iview等。 比如如下代码，一般都作为一个mixins去使用, broadcast是向特定的父组件，触发事件，dispatch是向特定的子组件触发事件，本质上这种方式还是on和emit的封装，但在一些基础组件中却很实用。 123456789101112131415161718192021222324252627282930313233function broadcast(componentName, eventName, params) &#123; this.$children.forEach(child =&gt; &#123; var name = child.$options.componentName; if (name === componentName) &#123; child.$emit.apply(child, [eventName].concat(params)); &#125; else &#123; broadcast.apply(child, [componentName, eventName].concat(params)); &#125; &#125;);&#125;export default &#123; methods: &#123; dispatch(componentName, eventName, params) &#123; var parent = this.$parent; var name = parent.$options.componentName; while (parent &amp;&amp; (!name || name !== componentName)) &#123; parent = parent.$parent; if (parent) &#123; name = parent.$options.componentName; &#125; &#125; if (parent) &#123; parent.$emit.apply(parent, [eventName].concat(params)); &#125; &#125;, broadcast(componentName, eventName, params) &#123; broadcast.call(this, componentName, eventName, params); &#125; &#125;&#125;;","updated":"2021-01-07T13:11:23.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"component","slug":"component","permalink":"https://lxx1997.github.io/tags/component/"}]},{"title":"new Object() 和 Object.create() 的区别","path":"2021/01/04/web/deferent-in-new-Object-object-create/","text":"今天我们来谈一谈通过 new Object() 和 Object.create() 创造的对象有什么区别 首先这两个方法都可以用来创建一个对象 12345var a = new Object()var a = Object.create()// 或者var a = new Object(obj)var a = Object.create(obj) 但是这两个方法创建的对象是有一些不同 new Object() 创建的对象是通过构造函数创建的对象，添加的属性是在自身实例下面Object.create() 创建的对象可以理解为继承一个对象，添加的属性是在 __proto__ 属性下面 123456var a = &#123;a: 1&#125;var b = new Object(a)console.log(b) // &#123;a: 1&#125;var c = Object.create(a)console.log(c) // &#123;&#125;console.log(c.__proto__) // &#123;a: 1&#125; new Object() 创建空对象的时候也是有 __proto__ 原型链的Object.create() 创建空对象是没有 __proto__ 原型链的 123456var b = new Object()console.log(b) // &#123;&#125;console.log(b.__proto__) // &#123;a: 1&#125;var c = Object.create(a) // 此时有数据，不多描述console.log(c) // &#123;&#125;console.log(c.__proto__) // undefined 使用 Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) 创建的对象访问时，p的值不可修改，不可枚举 1234var c = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;) // 此时有数据，不多描述console.log(c) // &#123;p: 42&#125;c = Object.create(&#123;&#125;, &#123;p: 42&#125;) // 此时会报错 VM587:1 Uncaught TypeError: Property description must be an object: 42 要求我们 p 的值 42，要放在一个对象中Object.keys(c) // []","updated":"2021-01-04T12:46:00.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"Vue keep-alive 组件状态缓存","path":"2021/01/04/vue/vue-keep-alive/","text":"这段时间做项目时，老板要求要缓存一些页面的表单数据，于是想到了 vue 的 keep-alive ，在使用时，自己也犯了一些错误，在此记录一下 首次使用 在阅读文档的时候，没有理解文档的内容，keep-alive 组件，vue官方文档给的解释是 匹配首先检查组件自身的name选项，如果name选项不可用，则匹配他的局部注册名称，但是不知怎的被我理解成为了 路由配置的name属性，结果闹了一个大乌龙 然后，自己怎么测试都发现不能缓存页面状态，最后使用面向百度编程找到了自己的错误 如何使用 为了方便我们不用新增一个组件，就把组件的name添加到 keep-alive 组件中，在这里我采用了一个取巧的方法 保证组件的 name 属性与对应路由的 name 属性保持一致 提取我们所需要的路由对象 这个方法根据我们传入的路由名称 动态提取出我们需要的路由对象，而不是获取所有的路由对象 12345678910function handleGetRoutes(routeName) &#123; let routeObj = Object.create(null) asyncRoutes.map((item) =&gt; &#123; if (item.name === routeName) &#123; routeObj = item &#125; return item &#125;) return routeObj&#125; 通过递归的方法获取到所有的 name 属性 1234567891011121314151617const routes = handleGetRoutes(&#x27;Classify&#x27;)let includes = []this.handleGetRouteName(routes, includes)handleGetRouteName(obj, arr) &#123; if ( obj.children &amp;&amp; obj.children instanceof Array &amp;&amp; obj.children.length &gt; 0 ) &#123; const length = obj.children.length for (let i = 0; i &lt; length; i++) &#123; this.handleGetRouteName(obj.children[i], arr) &#125; &#125; arr.push(obj.name) &#125;, 最后在 keep-alive 组件中使用 123&lt;keep-alive :include=&quot;includes&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; 其他用法 生命周期函数 activated,deactivated include include 表示只有匹配到的组件才会被缓存 exclude exclude 表示只有匹配到的组件才不会被缓存include和exclude允许组件有条件的缓存，有三种表示方式 1234567891011121314&lt;!-- 字符串 --&gt; &lt;keep-alive include=&quot;a,b&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 正则表达式 --&gt; &lt;keep-alive :include=&quot;/a|b/&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;!-- 数组 --&gt; &lt;keep-alive :include=&quot;[&#x27;a&#x27;,&#x27;b&#x27;]&quot;&gt; &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt; &lt;/keep-alive&gt; max max 表示 最大缓存组件个数，缓存组件达到最大个数后，添加新的缓存组件，最久未被访问的实例会被销毁掉","updated":"2021-01-04T09:35:02.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"发布订阅模式及观察者","path":"2021/01/04/reading/发布订阅模式及观察者/","text":"观察者模式 观察者模式的目的就是为了实现松耦合，面对接口编程 在观察者模式里面，有一个实例对象–被观察者(Subject)，他维护一套观察者(observer)的结合，这些 Observer 实现相同的接口，subject 只需要知道，通知 Observer 需要调用哪个统一的方法 发布订阅模式 在发布订阅模式里，发布者并不会直接通知订阅者，发布者和订阅者彼此不相识，通过第三方来进行函数调用 发布者 只需要告诉 第三方 我要 发送 的信息是 XXX 订阅者 只需要告诉 第三方 我要 订阅 的消息是 XXX 当 第三方 接收到 发布者 发送的消息且是 XXX 时，就会报消息推送给订阅了 XXX 的 订阅者，当然也有可能是 订阅者 自己过来拿取 在发布订阅模式中，发布者和订阅者不是松耦合，而是完全解耦的 总结 从表面上看 观察者模式只有两个角色 观察者和被观察者发布订阅模式中有三个角色 发布者、订阅者和第三方 深层次 观察者模式 是松耦合关系发布订阅模式 是完全不存在耦合 使用层次 观察者模式 多用于单个应用内部发布订阅模式 更多的是一种跨应用的模式 参考文章Observer vs Pub-Sub pattern","updated":"2021-01-04T06:30:30.000Z","categories":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/categories/design-pattern/"}],"tags":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/tags/design-pattern/"},{"name":"function","slug":"function","permalink":"https://lxx1997.github.io/tags/function/"}]},{"title":"Vue源码阅读 part 01","path":"2021/01/02/vue/vue-code-part-01/","text":"Vue源码目录结构 compiler 编译 Vue 使用字符串作为模板 在编译文件夹中存放对 模板字符串 解析的算法，抽象语法树，优化core 核心 Vue 构造函数，以及生命周期等方法platforms 平台 针对运行的环境(browser/andriod/ios) 的不同实现 也是 vue 的入口server 服务端 将 vue 用在服务器端的代码sfc 单文件组件shared 共用工具、方法 vue 具体文件 shared/constant 常量 ASSET_TYPES 每一个 vue 组件需要挂载的成员 LIFECYCLE_HOOKS 生命周期函数 hook shared/utils 工具方法 isPrimitive 判断是否为基本数据类型 123456789function isPrimitive (value: any): boolean %checks &#123; return ( typeof value === &#x27;string&#x27; || typeof value === &#x27;number&#x27; || // $flow-disable-line typeof value === &#x27;symbol&#x27; || typeof value === &#x27;boolean&#x27; )&#125; toRawType 获取传入参数的数据类型 1234const _toString = Object.prototype.toStringfunction toRawType (value: any): string &#123; return _toString.call(value).slice(8, -1)&#125; isPromise 判断是否是 Promise 函数 1234567function isPromise (val: any): boolean &#123; return ( isDef(val) &amp;&amp; typeof val.then === &#x27;function&#x27; &amp;&amp; typeof val.catch === &#x27;function&#x27; )&#125; toString 重写字符串转化 针对特殊的数据类型 object，array 进行处理 1234567function toString (val: any): string &#123; return val == null ? &#x27;&#x27; : Array.isArray(val) || (isPlainObject(val) &amp;&amp; val.toString === _toString) ? JSON.stringify(val, null, 2) : String(val)&#125; makeMap 针对需要缓存的数据map映射，提高速度 12345678910111213function makeMap ( str: string, expectsLowerCase?: boolean): (key: string) =&gt; true | void &#123; const map = Object.create(null) const list: Array&lt;string&gt; = str.split(&#x27;,&#x27;) for (let i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true &#125; return expectsLowerCase ? val =&gt; map[val.toLowerCase()] : val =&gt; map[val]&#125; cached 使用闭包检查是否缓存 1234567function cached&lt;F: Function&gt; (fn: F): F &#123; const cache = Object.create(null) return (function cachedFn (str: string) &#123; const hit = cache[str] return hit || (cache[str] = fn(str)) // 第一次调用的时候 hit 是没有值的，但是后面调用的时候，因为闭包原理，cache里面就存储了值 &#125;: any)&#125; camelize 将-字符连接的变量转化为驼峰模式 1234const camelizeRE = /-(\\w)/gconst camelize = cached((str: string): string =&gt; &#123; return str.replace(camelizeRE, (_, c) =&gt; c ? c.toUpperCase() : &#x27;&#x27;)&#125;) hyphenate 将驼峰模式转化为-字符连接的变量 1234const hyphenateRE = /\\B([A-Z])/gconst hyphenate = cached((str: string): string =&gt; &#123; return str.replace(hyphenateRE, &#x27;-$1&#x27;).toLowerCase()&#125;) looseEqual 判断两个对象是否相等 js中判断对象是否相等比较的是引用类型因此对比两个对象对象相等有以下步骤 首先判断传入参数 a, b 的引用类型是否一致，如果一致则返回true 然后判断传入的 a,b 的类型是否是 Object 类型 遍历 a 对象的成员，如果 a 中每个成员都在 b 中并且对应成员相等 遍历 b 对象的成员，如果 b 中每个成员都在 a 中并且对应成员相等 如果成员是引用类型，使用递归123456789101112131415161718192021222324252627282930313233343536function looseEqual (a: any, b: any): boolean &#123; if (a === b) return true const isObjectA = isObject(a) const isObjectB = isObject(b) if (isObjectA &amp;&amp; isObjectB) &#123; try &#123; const isArrayA = Array.isArray(a) const isArrayB = Array.isArray(b) if (isArrayA &amp;&amp; isArrayB) &#123; // 这一步判断 a 和 b 两个对象的长度是否相等 return a.length === b.length &amp;&amp; a.every((e, i) =&gt; &#123; return looseEqual(e, b[i]) &#125;) &#125; else if (a instanceof Date &amp;&amp; b instanceof Date) &#123; return a.getTime() === b.getTime() &#125; else if (!isArrayA &amp;&amp; !isArrayB) &#123; const keysA = Object.keys(a) const keysB = Object.keys(b) // 这一步判断 a 和 b 两个对象的长度是否相等 return keysA.length === keysB.length &amp;&amp; keysA.every(key =&gt; &#123; return looseEqual(a[key], b[key]) &#125;) &#125; else &#123; /* istanbul ignore next */ return false &#125; &#125; catch (e) &#123; /* istanbul ignore next */ return false &#125; &#125; else if (!isObjectA &amp;&amp; !isObjectB) &#123; return String(a) === String(b) &#125; else &#123; return false &#125;&#125; once 利用闭包， 使函数只调用一次 123456789function once (fn: Function): Function &#123; let called = false return function () &#123; if (!called) &#123; called = true fn.apply(this, arguments) &#125; &#125;&#125; Vue 知识点 性能优化 vue 运行在浏览器中，所以需要考虑性能每次数据的更新都是更新虚拟 DOM (模板解析) 因此将经常使用的字符串和算法进行缓存垃圾回收机制原则中有一个统计现象 “使用的越多的数据，一般都会频繁的使用” 每次创建一个数据，就会考虑是否将其回收 数据达到一定限额的时候就会考虑到垃圾回收(不是实时更新) 每次 都判断对象是否需要回收，需要就遍历 对对象进行划分，统计，往往一个数据使用完以后就不在使用了 如果一个对象在一次回收中还保留下来，统计的结果结果就是这个对象会比较持久的在内存中驻留 vue 模板中 的 指令， 每次数据发生变化都有可能带来 指令 的解析，所以解析就是字符串处理，一般会消耗一定的性能","updated":"2021-01-02T15:37:19.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"03 - Vue源码解读-发布订阅模式","path":"2020/12/21/vue/vue-template-publish-subscribe/","text":"发布订阅模式代理方法 将 app._data 中的成员给映射到 vue 实例上面，由于app.data 已经是响应式的对象了，所以只需要让app访问的成员去访问 app._data 的对应成员 引入一个函数 proxy(target, src, prop),target 的操作映射到 src.prop 上面 (当时没有 es6 的 Proxy 语法) 使用一个新的方法来处理 Observer 方法对属性进行处理，将这个方法封装到 initData 方法中 12345678910111213141516171819202122JGVue.prototype.initData = function () &#123; let keys = Object.keys(this._data) // 响应式化 setReactive for (let k = 0; k &lt; keys.length; k++) &#123; setReactive(this._data, vm) &#125; // 代理 for (let k = 0; k &lt; keys.length; k++) &#123; // 将 this._data[keys[k]] 映射到 this[keys[i]] // 访问这个属性的时候相当于访问 this._data 的这个属性 Object.defineProperty(this, keys[k], &#123; enumerable: true, configurable: true, get() &#123; return this._data[keys[k]] &#125;, set(newValue) &#123; this._data[key[i]] = newValue &#125; &#125;) &#125;&#125; 或者以下方法 12345678910111213141516171819202122232425JGVue.prototype.initData = function () &#123; let keys = Object.keys(this._data) // 响应式化 setReactive for (let k = 0; k &lt; keys.length; k++) &#123; setReactive(this._data, vm) &#125; // 代理 for (let k = 0; k &lt; keys.length; k++) &#123; // 将 this._data[keys[k]] 映射到 this[keys[i]] // 访问这个属性的时候相当于访问 this._data 的这个属性 proxy(this, &#x27;_data&#x27;, keys[k]) &#125;&#125;function proxy(target, prop, key) &#123; Object.defineProperty(target, key, &#123; enumerable: true, configurable: true, get() &#123; return target[prop][key] &#125;, set(newValue) &#123; target [prop][key[i]] = newValue &#125; &#125;)&#125;","updated":"2020-12-21T06:06:22.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"03 - Vue源码解读-响应式","path":"2020/12/18/vue/vue-template-responsive/","text":"响应式原理 我们在使用 Vue 的时候，复制属性获得属性都是直接使用Vue实例 我们在设计属性值的时候，页面数据更新 Object.defineProperty(obj, key, &#123;&#125;)123456789101112// 注意 value 和 writable 不可以和 get set 连用Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue &#125;, get()&#123; console.log(value) return value &#125;&#125;) 使用 Object.defineProperty() 实现数据监控 123456789101112131415161718192021222324252627282930313233343536373839404142const data = &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, like: [ &#123;juice: &#x27;juice&#x27;&#125; ], other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;约的人&#x27;, time: &#x27;12m&#x27; &#125; &#125;&#125;function setPerperties(obj, key, value, enumerable) &#123; console.log(obj, key, value, !!enumerable) Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue &#125;, get()&#123; console.log(value) return value &#125; &#125;)&#125;function setReactive(o) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key]) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item) &#125;) &#125; else &#123; setPerperties(o, key, o[key], true) &#125; &#125;)&#125;setReactive(data) 针对数组中的特殊方法进行响应式化处理 push 向数组的最后添加元素，并返回新的数组长度 unshift 向数组的开始添加元素，并返回新的数组长度 pop 删除数组的最后一个元素，并返回被删除的元素 shift 删除数组的第一个元素，并返回被删除的元素 reverse 翻转数组，并返回翻转之后的数组 sort 数组排序 splice 向/从数组中添加/删除项目，然后返回被删除的项目，rrayObject.splice(index,howmany,item1,…..,itemX) (删除的位置, 删除的个数， 插入的新元素) vue2 中数组发生变化，设置 length 没法通知（Vue3 中使用Proxy语法解决了这个问题） 加进来的元素也应该是响应式的 技巧：如果一个函数已经定义了，但是我们需要扩展其功能，我们一般的处理方法 使用一个临时的函数名存储函数 重新定义原来的函数 定义扩展的功能 调用临时的那个函数12345678910111213function func() &#123; console.log(&#x27;old property&#x27;)&#125;// 第一步let _tempFn = func// 第二步func = function() &#123; // 第四步 _tempFn() // 第三步 console.log(&#x27;new property&#x27;)&#125;func() 如何修改数组的扩展函数 不能直接修改数组的 prototype 修改要进行响应式化的数组的原型(proto) 原型式继承：修改原型链结构 继承关系： arr -&gt; Array.prototype -&gt; Object.prototype -&gt; … 修改之后： arr -&gt; 改写的方法 -&gt; Array.prototype -&gt; Object.prototype -&gt; …12345678910111213141516let arr = []let ARRAY_METHOD = [&#x27;pop&#x27;, &#x27;unshift&#x27;, &#x27;push&#x27;, &#x27;shift&#x27;, &#x27;reverse&#x27;, &#x27;sort&#x27;, &#x27;splice&#x27;]let arrayMethods = Object.create(Array.prototype)ARRAY_METHOD.map(item =&gt; &#123; arrayMethods[item] = function() &#123; Array.from(arguments).map(item =&gt; &#123; setReactive(item) &#125;) // 在这里对数据进行响应式化 let res = Array.prototype[item].apply(this, arguments) return res &#125;&#125;)arr.__proto__ = arrayMethods vue做了兼容，如果浏览器兼容proto，就使用 原型式继承 不兼容就使用 混入法 将方法一个个的加入到 arr 中 将方法整合到设置响应式方法中 123456789101112131415function setReactive(o) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key]) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; console.log(o[key]) o[key].__proto__ = arrayMethods // 拦截数组，进行数组响应式 o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item) &#125;) &#125; else &#123; setPerperties(o, key, o[key], true) &#125; &#125;)&#125; 对 对象 或者 数组 重新赋值 如何设置响应式 setPerperties() 函数的set方法中 重新调用一次 setReactive() 变更页面 在 JGVue 函数中调用 setReactive 方法 把 this._data 设置成响应式类型，同时传递 vue 实例到 Object.defineProperty 123456function JGVue(options) &#123; this._data = options.data setReactive(this._data, this) this._template = document.querySelector(options.el) // vue 中这里是DOM this.mount() // 挂载&#125; 修改 setReactive 方法 1234567891011121314function setReactive(o, vm) &#123; Object.keys(o).map(key =&gt; &#123; if(Object.prototype.toString.call(o[key]) === &#x27;[object Object]&#x27;) &#123; setReactive(o[key], vm) &#125; else if(Object.prototype.toString.call(o[key]) === &#x27;[object Array]&#x27;) &#123; o[key].__proto__ = arrayMethods // 拦截数组，进行数组响应式 o[key].map(item =&gt; &#123; if(Object.prototype.toString.call(item) === &#x27;[object Object]&#x27; || Object.prototype.toString.call(item) === &#x27;[object Array]&#x27;) setReactive(item, vm) &#125;) &#125; else &#123; setPerperties.call(vm, o, key, o[key], true) &#125; &#125;)&#125; 修改 setPerperties 函数 1234567891011121314function setPerperties(obj, key, value, enumerable) &#123; let _that = this Object.defineProperty(obj, key, &#123; enumerable: !!enumerable, configurable: true, set (newValue)&#123; value = newValue _that.mountComponent() &#125;, get()&#123; return value &#125; &#125;)&#125;","updated":"2020-12-18T09:40:59.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"02 - Vue源码解读-渲染模型","path":"2020/12/17/vue/vue-template-render/","text":"判断元素 vue 本质上是使用 HTML 字符串作为模板，将字符串模板转化为 AST(抽象语法树) ,再转换成 VNode 模板 -&gt; AST AST -&gt; VNode VNode -&gt; DOM 最消耗性能的是字符串解析(模板 -&gt; AST) 小例子： let s = “1 + 2 (3 + 4 (5 + 6))” 得到结果建议：将字符串表达式转化为波兰式表达式，使用栈结构来运算 1 vue源码如何区分HTML标签和自定义组件? vue源码把所有可用的HTML标签都存起来 使用柯里化操作将需要遍历的 HTML 标签存储起来 1234567891011121314function makeMap(keys) &#123; const obj = Object.create(null) keys.map(item =&gt; &#123; obj[item] = true return item &#125;) return function(key) &#123; return !!obj[key] &#125;&#125;let htmlkey = [&#x27;p&#x27;,&#x27;div&#x27;,&#x27;a&#x27;,&#x27;ul&#x27;,&#x27;li&#x27;,&#x27;ol&#x27;,&#x27;dl&#x27;]const htmlMap = makeMap(htmlkey)htmlMap(&#x27;div&#x27;) // truehtmlMap(&#x27;img&#x27;) // false 函数柯里化 虚拟 DOM 的 render 方法 vue项目 模板转化为抽象语法树 页面一开始加载需要渲染 每一个属性(响应式)数据在发生变化时要渲染 watch，computed每次需要渲染的时候，模板就会被解析一次 render 的作用是将虚拟DOM 转化为真正的DOM 虚拟DOM 可以降级理解为AST 一个项目运行的时候，模板是不会变得，就表示AST是不会变得 将虚拟DOM 缓存起来，生成一个函数，只需要传入参数，就可以的到真正的DOM123456789101112&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;div&gt; &#123;&#123;other.name&#125;&#125; &#123;&#123;other.behavior.name&#125;&#125; &#123;&#123;other.behavior.time&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173function JGVue(options) &#123; this._data = options.data this._template = document.querySelector(options.el) // vue 中这里是DOM this.mount() // 挂载&#125;JGVue.prototype.mount = function() &#123; // 需要提供一个render方法生成虚拟dom this.render = this.createRenderFn() this.mountComponent()&#125;JGVue.prototype.mountComponent = function() &#123; // 执行mountComponent let mount = () =&gt; &#123; // 调用update方法渲染dom this.update(this.render()) &#125; mount.call(this) // 本质上应该交给watcher来调用，此操作并不会改变this的指向&#125;/* * 在真正的 vue 中使用了 二次提交的设计结构 * 1 在页面中 DOM 和虚拟 DOM 是一一对应的关系 * 数据发生变化的时候，就会通过 diff 方法 对比需要更新的虚拟 DOM 节点，更新 DOM * 凡是解析就会涉及到 AST * 2 现有AST和数据生成VNode * 3 将新的VNode 和旧的 VNode 比较(diff)更新(update)*/// 生成render 函数，缓存抽象语法树（使用虚拟DOM来模拟）JGVue.prototype.createRenderFn = function() &#123; // 获取抽象语法树 let ast = getVnode(this._template) console.log(ast) // Vue: 将AST + data =&gt; VNode return function render() &#123; // 将带坑的VNode (ast) 转化为真正的带数据的VNode let _temp = combine(ast, this._data) console.log(_temp) return _temp &#125;&#125;// 将虚拟DOM渲染到页面中 diff算法就在这里JGVue.prototype.update = function(data) &#123; let dom = parseVnode(data) let app = document.getElementById(&quot;app&quot;) let parent = app.parentNode parent.replaceChild(dom, app)&#125;// node 为页面中真实的 DOM 节点// 使用递归的方法提取出 DOM 节点中所有的子孙节点// Vue源码中使用 栈 的方式// 由HTML DOM -&gt; VNode， 将这个函数当做compiler函数function getVnode(node) &#123; let nodeType = node.nodeType let _vnode = null // 判断nodeType类型 if(nodeType === 1) &#123; // 元素节点 let nodeName = node.nodeName // 获取 node 元素的 所有 attribute 属性， 是一个伪数组，需要转换成 对象 let attrs = node.attributes let _attrs = Object.create(null) for(let i = 0; i &lt; attrs.length; i++) &#123; _attrs[attrs[i].nodeName] = attrs[i].nodeValue &#125; _vnode = new VNode(nodeName, _attrs, undefined, nodeType) // 然后处理元素节点的所有自节点 let childNodes = node.childNodes for(let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendCild(getVnode(childNodes[i])) &#125; &#125; else if(nodeType === 3) &#123; // 文本节点 // 文本节点没有 tag 属性 data属性 _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType) &#125; return _vnode&#125;// 将带有‘&#123;&#123;&#125;&#125;’的虚拟DOM和传入的data数据结合起来，生成带有数据的DOM树function combine(node, data) &#123; let _type = node.type let _data = node.data let _value = node.value let _tag = node.tag let _children = node.children let _vnode = null // 判断nodeType类型 if(_type === 1) &#123; // 元素节点 _vnode = new VNode(_tag, _data, _value, _type) // 然后处理元素节点的所有自节点 _children.map(item =&gt; _vnode.children.push(combine(item, data))) &#125; else if(_type === 3) &#123; // 文本节点 _value = _value.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ const split = createSplitAttribute(g.trim()) return split(data) &#125;); // 文本节点没有 tag 属性 data属性 _vnode = new VNode(_tag, _data, _value, _type) &#125; return _vnode&#125;// 将虚拟dom 转化为真实DOMfunction parseVnode(vnode) &#123; const &#123;tag, data, type, value, children&#125; = vnode let dom = null if(type === 1) &#123; dom = document.createElement(tag) for(let key in data) &#123; dom.setAttribute(key, data[key]) &#125; dom.nodeType = type for(let i = 0; i &lt; children.length; i++) &#123; dom.appendChild(parseVnode(children[i])) &#125; &#125; else if(type === 3) &#123; dom = document.createTextNode(tag) dom.nodeValue = value dom.nodeType = type &#125; return dom&#125;// 使用柯里化 存储需要替换的内容function createSplitAttribute(g) &#123; let paths = g.split(&#x27;.&#x27;) return function splitAttribute(data) &#123; let res = data // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // res = res[item] // &#125;) //2. let prop while(prop = paths.shift()) &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 console.log(res, prop) res = res[prop] &#125; return res &#125;&#125;const options = &#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;约的人&#x27;, time: &#x27;12m&#x27; &#125; &#125; &#125;&#125;const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/gclass VNode &#123; /* * tag: node.nodeValue * data: node.attributes =&gt; obj =&gt; &#123;node.attribute.nodeName: node.attribute.nodeValue&#125; */ constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCase() this.data = data this.value = value this.type = type this.children = [] &#125; appendCild(vnode) &#123; this.children.push(vnode) &#125;&#125;let app = new JGVue(options)","updated":"2020-12-17T07:01:25.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"函数 - 函数反柯里化（uncurrying）","path":"2020/12/17/web/fucntion-uncurrying/","text":"参考链接 函数柯里化 含义 柯里化：是固定部分参数,返回一个接受剩余参数的函数,也称为部分计算函数,目的是为了缩小适用范围，创建一个针对性更强的函数，核心思想是把多参数传入的函数拆成单(部分)参数函数，内部再返回下一个单(部分)参数函数，依次处理剩余函数 反柯里化：扩大适用范围，创建一个应用范围更广的函数，使本来只有特定对象才适用的方法，扩展到更多对象 通用实现 12345678910111213141516171819202122232425// 第一种实现方式Function.prototype.unCurrying = function() &#123; const self = this // ...rest 方法相当于使用es6语法的解构赋值使用rest接收入参数组，相当于arguments rest的值是传入的所有参数组成的一个数组 return function(...rest) &#123; return Function.prototype.call.apply(self, rest) &#125;&#125;const push = Array.prototype.push.unCurrying()/* * 1 为 Function 原型添加 unCurrying 方法，并在执行的时候保存执行 unCurrying 的方法到self * 2 借用apply把要借用的函数作为this环境赋予call，并传入之后的形参作为参数执行*/// 第二种实现方式Function.prototype.unCurrying = function() &#123; return this.call.bind(this)&#125;// 第三种实现方式function unCurrying(fn) &#123; return function(tar, ...argu) &#123; return fn.apply(tar, argu) &#125;&#125; 使用反柯里化 1234567891011121314Function.prototype.unCurrying = function() &#123; const self = this return function(...rest) &#123; console.log(rest, &#x27;uncurrying rest&#x27;) return Function.prototype.call.apply(self, rest) &#125;&#125;const push = Array.prototype.push.unCurrying()~function(...rest) &#123; console.log(rest, &#x27;before&#x27;) push(rest, 4, 5) console.log(rest, &#x27;after&#x27;)&#125;(1,2,3) 反柯里化其实反映的是一种思想 - 扩大方法的适用范围 12345678910111213141516Function.prototype.unCurrying = function() &#123; const self = this return function(...rest) &#123; console.log(rest, &#x27;uncurrying rest&#x27;) return Function.prototype.call.apply(self, rest) // Array.prototype.push.call(&#123;a: 3&#125;, 4, 5) &#125;&#125;const push = Array.prototype.push.unCurrying()~function() &#123; let rest = &#123;a: 3&#125; console.log(rest, &#x27;before&#x27;) push(rest, 4, 5) console.log(rest, &#x27;after&#x27;)&#125;(1,2,3) 只要是方法就可以借用 unCurrying 方法 123456789101112131415161718192021222324252627282930313233343536373839 // call var call = Function.prototype.call.unCurrying() function $(id) &#123; return this.getElementById(id) &#125; // call() call($, document, &#x27;demon&#x27;) /* * 解题步骤 * =&gt; Function.prototype.call.apply(Function.prototype.call, [$, document, &#x27;demon&#x27;]) * =&gt; Function.prototype.call.call($, document, &#x27;demon&#x27;) * =&gt; $.call(document, &#x27;demon&#x27;) * =&gt; document.getElementById(&#x27;demon) */ // unCurrying 借用自己本身 const unCurrying = Function.prototype.unCurrying.unCurrying() const map = unCurrying(Array.prototype.map) map(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) /* * const map = unCurrying(Array.prototype.map) 步骤 * =&gt; Function.prototype.call.apply(Function.prototype.unCurrying, [Array.prototype.map]) * =&gt; Function.prototype.unCurrying.call(Array.prototype.map) * =&gt; Array.prototype.map.unCurrying() * =&gt; map = Array.prototype.map.unCurrying() * =&gt; map(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) * =&gt; Function.prototype.call.apply(Array.prototype.map, [&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n]) * =&gt; Array.prototype.map.call(&#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;, n =&gt; n + n) * =&gt; &#123;0: 4, 1: &#x27;a&#x27;, 2: null, length: 3&#125;.map(n =&gt; n + n) * =&gt; &#123;0: 8, 1: &#x27;aa&#x27;, 2: 0, length: 3&#125; */ ~~~~#### 总结 函数柯里化 ~~~js function(arg1, arg2) // function(arg1)(arg2) function(arg1, arg2, arg3) // function(arg1)(arg2)(arg3) function(arg1, arg2, arg3, arg4) // function(arg1)(arg2)(arg3)(arg4) 反柯里化 1obj.fn(arg1, arg2) // fn(obj, arg1, arg2) 终点知识解析 Function.prototype.call.apply(self, rest) 小例子： 1Math.Max.apply([], [1, 2, 3]) 先执行 apply 将 math 替换成 []然后在执行 Max 并传入[1,2,3],此时因为 apply 的关系 [1,2,3]扁平化为1,2,3 Function.prototype.call.apply(self, rest)过程 Function.prototype.call.apply(Array.prototype.push, rest) Array.prototype.push.call(...rest) 所以在传递 rest 的时候，需要操作的对象放在第一位，方便 call 绑定 this rest[0].push(rest.shift(1)) 123456var obj = &#123;a: 3&#125;Array.prototype.push.call(obj, 4, 5) // 2obj // &#123;0: 4, 1: 5, a: 3, length: 2&#125;var obj = &#123;a: 3, b: 3&#125;Array.prototype.push.call(obj, 4, 5) // 2obj //&#123;0: 4, 1: 5, a: 3, b: 3, length: 2&#125;","updated":"2020-12-17T03:00:35.000Z","categories":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/categories/design-pattern/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/tags/design-pattern/"},{"name":"function","slug":"function","permalink":"https://lxx1997.github.io/tags/function/"}]},{"title":"函数 - 函数柯里化（Currying）","path":"2020/12/17/web/function-currying/","text":"参考文章 函数反柯里化 函数柯里化其实本身是固定一个可以预期的参数，并返回一个特定的函数，处理批特定的需求，增加了函数的适用性，降低了函数的适用范围 柯里化函数通用实现 1234567891011function currying(fn) &#123; var slice = Array.prototype.slice, // 取出传入的多个参数(不包含第一位) _args = slice.call(arguments, 1) return function() &#123; var _inargs = slice.call(arguments) // 将创建柯里化函数传入的参数与后传入的参数进行合并 return fn.apply(null, _args.concat(_inargs)) &#125;&#125; 提高适用性 解决了兼容性问题，但同时也会再来，使用的不便利性，不同的应用场景往，要传递很多参数，以达到解决特定问题的目的。有时候应用中，同一种规则可能会反复使用，这就可能会造成代码的重复性。 123456789101112131415161718192021function square(i) &#123; return i * i;&#125;function dubble(i) &#123; return i *= 2;&#125;function map(handeler, list) &#123; return list.map(handeler);&#125;var mapSQ = currying(map, square);mapSQ([1, 2, 3, 4, 5]);mapSQ([6, 7, 8, 9, 10]);mapSQ([10, 20, 30, 40, 50]);var mapDB = currying(map, dubble);mapDB([1, 2, 3, 4, 5]);mapDB([6, 7, 8, 9, 10]);mapDB([10, 20, 30, 40, 50]); 缩小了函数的适用范围，但同时提高函数的适性 12345678910111213141516171819202122232425262728function Ajax() &#123; this.xhr = new XMLHttpRequest();&#125;Ajax.prototype.open = function(type, url, data, callback) &#123; this.onload = function() &#123; callback(this.xhr.responseText, this.xhr.status, this.xhr); &#125; this.xhr.open(type, url, data.async); this.xhr.send(data.paras);&#125;&#x27;get post&#x27;.split(&#x27; &#x27;).forEach(function(mt) &#123; Ajax.prototype[mt] = currying(Ajax.prototype.open, mt);&#125;);var xhr = new Ajax();xhr.get(&#x27;/articles/list.php&#x27;, &#123;&#125;,function(datas) &#123; // done(datas) &#125;);var xhr1 = new Ajax();xhr1.post(&#x27;/articles/add.php&#x27;, &#123;&#125;,function(datas) &#123; // done(datas) &#125;); 延迟执行 不断地柯里化，累计传入的参数，最后执行 12345678910111213141516171819202122232425262728293031var add = function() &#123; var _this = this, _args = arguments return function() &#123; if (!arguments.length) &#123; var sum = 0; for (var i = 0, i&lt; _args.length; i++ &#123; sum += _args[i] &#125; return sum &#125; else &#123; // 通过函数的push方法，存储每一次调用的返回参数到 _args 中 Array.prototype.push.apply(_args, arguments) // arguments.callee 返回的是arguments所在函数本身，此操作相当于return return arguments.callee &#125; &#125;&#125;add(1)(2)(3)(4)();//10// 通用的写法var curry = function(fn) &#123; var _args = [] return function cb() &#123; if (arguments.length == 0) &#123; return fn.apply(this, _args) &#125; Array.prototype.push.apply(_args, arguments); return cb; &#125;&#125; 固定异变因素 提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 123456789Function.prototype.bind = function(context) &#123; var _this = this, _args = Array.prototype.slice.call(arguments, 1); // arguments [this, arg1, arg2 ...] return function() &#123; // 绑定 this 到创建柯里化函数时绑定的this，同时合并参数 return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) &#125;&#125;","updated":"2020-12-17T01:16:37.000Z","categories":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/categories/design-pattern/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"design-pattern","slug":"design-pattern","permalink":"https://lxx1997.github.io/tags/design-pattern/"},{"name":"function","slug":"function","permalink":"https://lxx1997.github.io/tags/function/"}]},{"title":"javascript-data-methods","path":"2020/12/16/web/javascript-data-methods/","text":"全局函数（function） decodeURI() 解码某个编码的URI encodeURI() 把字符串编码为URI decodeURIComponent() 解码一个编码的URI组件 encodeURIComponent() 把字符串编码为URI组件 escape() 对字符串进行编码 eval() 计算javascript字符串并把它作为脚本来执行 isFinite() 检查某个值是否为有穷大的数 isNaN() 检查某个值是否是数字 Number() 把对象的值转化为数字 parseFloat() 解析一个字符串并返回一个浮点数 parseInt() 解析一个字符串并返回一个整数 String() 把对象的值转为字符串 unescape() 对由escape()编码的字符串进行解码 数组（Array） concat() 连接两个或者更多的数组，并返回结果 copyWithin(target, start, end) 将数组的指定位置拷贝元素到数组的另一个指定位置中 （target 指的是元素复制的位数， start指的是元素开始复制的位置，end指的是元素结束复制的位数） entries() 返回一个数组的迭代对象，包含数组的键值对[index, vlaue] every() 检测数组元素的每个元素是否符合条件，如果都满足条件， 返回true，如果不满足返回false some() 检测数值中某个元素是否符合条件，如果有一个符合，返回true，如果全不符合，返回false fill() 使用一个固定值来填充数组 filter() 用于筛选数组，返回符合条件的一个新的数组 find() 返回符合传入测试的数组元素 findIndex() 返回符合传入测试数组元素的索引 forEach() 数组的每一个元素都执行一次回调函数 map() 循环遍历数组中的每一个值，可以用于修改数组 from() Array.from() 通过给定的对象创建一个数组 indexOf() 搜索数组中国的元素，并返回所在位置 includes() 判断一个数组是否包含一个指定的值 isArray() 判断对象是否是数组 join() 把数组中的元素以某个标识拼接为字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 pop() 删除数组中的最后一个元素，并返回删除的元素 push() 向数组的末尾添加一个或多个元素，并返回新的长度 reduce() 计算元素，可以用于计算数组，筛选，遍历，从左到右 reduceRight() 计算元素，可以用于计算数组，筛选，遍历，从右到左 reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice(start, end) 选取数组的一部分，并选取一个新数组 sort() 对元素数组进行排序， 可以自定义排序规则 splice(index, many, item) 从数组中添加和删除元素 toString() 将数组转化为字符串，并返回结果 unshift() 向数组开头添加一个或多个元素，并返回新的长度 valueOf() 返回数组对象的原始值 时间对象（Date）方法* date.Date() 返回当日的日期和事件 * date.getDate() 从Date对象中返回一个月的某一天 * date.getDay() 从Date对象中返回一周中的某一天 * Date.getMonth() 返回Date对象的月份（0-11）真实月份需要加 * date.getFullYear() 返回四位数字的年份 * date.getYear() 返回两位数字的年份 * date.getHours() 返回对象的小时数 * date.getMinutes() 返回对象的分钟数 * date.getSeconds() 返回对象的秒数 * date.getMilliseconds() 返回对象的毫秒数 * date.getTime() 返回1970年1月1日至今的毫秒数 * date.getUTCDate() 从Date对象中返回世界时一个月的某一天 * date.getUTCDay() 从Date对象中返回世界时一周中的某一天 * date.getUTCMonth() 返回Date对象的世界时月份（0-11）真实月份需要加 * date.getUTCFullYear() 返回世界时四位数字的年份 * date.getUTCYear() 返回世界时两位数字的年份 * date.getUTCHours() 返回对象世界时的小时数 * date.getUTCMinutes() 返回对象世界时的分钟数 * date.getUTCSeconds() 返回对象世界时的秒数 * date.getUTCMilliseconds() 返回对象世界时的毫秒数 * date.parse() 获取1970年1月1日午夜到制定日期（字符串）的毫秒数 * date.setDate() 设置某一天 * date.setFullYear() 设置Date对象的年份 * date.setMonth() 设置月份 * date.setHours() 设置日期的小时 * date.setMillisecoends() 设置毫秒数 * date.setTime() 以毫秒设置date对象 * date.setMinutes() 设置分钟 * date.setSeconds() 设置秒 * date.toDateString() 把对象的日期部分转化为字符串 * date.toJSON() 以json数据格式返回日期字符串 * date.toLocaleDateString() 根据本地时间格式，把Date对象的日期部分转为字符串 * date.toLocaleTimeString() 根据本地时间格式，把Date对象的日期部分转为字符串 * date.toLocaleString() 根据本地时间格式，把Date对象转为字符串 * date.valueOf() 返回date对象的原始值 简单的时间函数* 获取当前日期 12345678910111213141516171819202122232425262728293031323334// 以年月日格式获取时间getNewDate() &#123; var date = new Date() date.setTime(date.getTime())// 获取上个月的日期（这一行去掉就是获取今天计算机上的日期了） var now = date var year = now.getFullYear() // 年 var month = now.getMonth() + 1 // 月 var day = now.getDate() // 日 var clock = year + &#x27;-&#x27; if (month &lt; 10) &#123; clock += &#x27;0&#x27; &#125; clock += month + &#x27;-&#x27; if (day &lt; 10) &#123; clock += &#x27;0&#x27; &#125; clock += day return clock&#125;// 以年月日 时分秒获取时间// fmt 为传入的日期格式 // yyyy-MM-dd hh:mm:ss 年月日 时分秒// yyyy-MM-dd 年月日getNowTime(fmt) &#123; var date = new Date() var o = &#123; &#x27;M+&#x27;: date.getMonth() + 1, // 月份 &#x27;d+&#x27;: date.getDate(), // 日 &#x27;h+&#x27;: date.getHours(), // 小时 &#x27;m+&#x27;: date.getMinutes(), // 分 &#x27;s+&#x27;: date.getSeconds(), // 秒 &#x27;q+&#x27;: Math.floor((date.getMonth() + 3) / 3), // 季度 &#x27;S&#x27;: date.getMilliseconds() // 毫秒 &#125; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + &#x27;&#x27;).substr(4 - RegExp.$1.length)) &#125; for (var k in o) &#123; if (new RegExp(&#x27;(&#x27; + k + &#x27;)&#x27;).test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : ((&#x27;00&#x27; + o[k]).substr((&#x27;&#x27; + o[k]).length))) &#125; return fmt&#125; * 获取当前日期之前或者之后一段时间的日期 123456// 通过setTime将时间设置为当前时间100分钟之后，然后获取设置之后的时间getTime() &#123; var date = new Date() date.setTime(date.getTime + 1000 * 60 * 100) var newDate = date.getFullYear() + &#x27;-&#x27; + (Number(date.getMonth()) + 1) + &#x27;-&#x27; + date.getDate() + &#x27; &#x27; + date.getHours() + &#x27;:&#x27; + date.getMinutes() + &#x27;:&#x27; + date.getSeconds()&#125; * 比较两个时间的大小 1234567891011// 比较传入的时间大小 时间格式为 yyyy-MM-dd hh:mm:ss// 通过date.parse()获取传入时间的毫秒数， 通过new Date() 转化为日期格式，在进行大小比较Compare(time1, time2) &#123; const date1 = new Date(Date.parse(time1.replace(/-/g, &#x27;/&#x27;))) const date2 = new Date(Date.parse(time2.replace(/-/g, &#x27;/&#x27;))) if (date1 &gt; date2) &#123; return &#x27;时间1 大于 时间2&#x27; &#125; else &#123; return &#x27;时间2 大于 时间1&#x27; &#125;&#125; * 计算所选时间是第几周(当前月第几周，当前年份第几周) 12345678910111213141516171819202122getYearWeek(year,month,date)&#123; /* dateNow是当前日期 dateFirst是当年第一天 dataNumber是当前日期是今年第多少天 用dataNumber + 当前年的第一天的周差距的和在除以7就是本年第几周 */ let dateNow = new Date(year, parseInt(month) - 1, date); let dateFirst = new Date(year, 0, 1); let dataNumber = Math.round((dateNow.valueOf() - dateFirst.valueOf()) / 86400000); return Math.ceil((dataNumber + ((dateFirst.getDay() + 1) - 1)) / 7); &#125;getMonthWeek(year,month,date)&#123; /* month = 6 - w = 当前周的还有几天过完(不算今天) year + month 的和在除以7 就是当天是当前月份的第几周 */ let dateNow = new Date(year, parseInt(month) - 1, date); let w = dateNow.getDay();//星期数 let d = dateNow.getDate(); return Math.ceil((d + 6 - w) / 7); &#125; 数学对象（Math） Math.E 返回算术常亮e，即自然对数的底数（约等于2.718） Math.LN2 返回2的自然对数（约等于0.693） Math.LEN10 返回10的自然对数（约等于2.302） Math.LOG2E 返回以2为底的e的对数（约等于1.414） Math.LOG10E 返回以10为底的e的对数（约等于0.434） Math.PI 返回圆周率（约等于3.14159） Math.SQRT1_2 返回 2 的平方根的倒数（约等于 0.707） Math.SQRT2 返回 2 的平方根（约等于 1.414） Math.abs() 返回数的绝对值 Math.acos() 返回数的反余弦值 Math.asin() 返回数的反正弦值 Math.atan() 以介于 -PI/2 与 PI/2 弧度之间的数值来返回 x 的反正切值 Math.atan2(y,x) 返回从 x 轴到点 (x,y) 的角度（介于 -PI/2 与 PI/2 弧度之间） Math.ceil() 向上取整 Math.cos() 返回余弦值 Math.exp() 返回e的指数 Math.floor() 向下取整 Math.log() 返回自然数的对数 Math.max(x, y) 返回最大值 Math.min(x, y) 返回最小值 Math.pow(x, y) 返回x的y次幂 Math.random() 返回0~1之间的随机数 Math.round() 把数四舍五入为最接近的整数 Math.sin() 返回数的正弦 Math.sqrt() 返回数的平方根 Math.tan() 返回角的正切 Math.toSource() 返回对象的源代码 Math.valueOf() 返回Math对象的原始值 字符串对象（String） charAt() 返回指定位置的字符 charCodeAt() 返回指定位置的字符的Unicode编码 concat() 连接两个或者更多字符串，并返回新的字符串 fromCharCode() 将Unicode编码转为字符 indexOf() 返回某个指定的字符串值在字符串首次出现的位置 includes() 查找字符串中是否包含指定的字符串 lastIndexOf() 从后向前搜索字符串，并从起始位置(0)开始返回字符串最后出现的位置 match() 查找找到一个或者多个正则表达式匹配 repeat() 复制字符串指定次数，并将它们连接在一起返回 replace() 在字符串中查找匹配的字符串，并替换与正则表达式匹配的字符串 search() 查找与正则表达式相匹配的值 slice() 提取字符串的片段，并在新的字符串中返回被提取的部分 split() 把字符串分割为字符串数组 startsWith() 查看字符串是否以指定的子字符串开头 substr(start, num) 从起始索引号提取字符串中指定数目的字符 substring(start,end) 提取两个字符串索引之间的字符 toLowerCase() 将字符串转化为小写 toUpperCase() 将字符串转化为大写 trim() 去除字符串两边的空白 toLocaleLowerCase() 根据本地主机的语言环境把字符串转化为小写 toLocaleUpperCase() 根据本地主机的语言环境把字符串转换为大写 toString() 返回一个字符串 valueOf() 返回某个字符串对象的原始值 anchor(text) 创建一个HTML锚 big() 用大号字体显示字符串 blink() 闪动文本 (不能用于IE,Chrome,或者Safari) bold() 使用粗体显示字符串 fixed() 用打字机文本显示字符串 fontcolor() 用指定的颜色来显示字符串 fontsize() 使用指定的尺寸来显示字符串 italics() 使用斜体显示字符串 link() 将字符串显示为连接 small() 使用小字号来显示字符串 strike() 用于显示加删除线的字符串 sub() 把字符串显示为下标 sup() 把字符串显示为上标 async await ​ async用于申明一个function是异步的，而await用于等待一个异步方法执行完成，await只能出现在async之后 async ​ async 定义的函数是一个promise对象，如果函数中return 一个直接良，async会把这个直接量通过peomise.resolve()封装成Promise对象 async函数返回的是一个Promise对象，所以最外层不能用await获取其返回值，可以用过原始的.then()链来处理这个Promise对象 ​ Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致 await ​ await是个运算符，用于组成表达式，await表达式的运算结果取决于它等的东西 ​ 如果它等到的不是一个Promise对象，那await表达式的运算结果就是它等到的东西 ​ 如果他等到的是一个Promise对象，await会阻塞后面的代码，等着Promise对象resolve 然后得到resolve的值，作为await表达式的运算结果 ​ async函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个Promise对象中异步执行 async/await 帮我们干了啥 ​ async会将气候的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来 12345678function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;takeLongTime().then(v =&gt; &#123; console.log(&quot;got&quot;, v);&#125;); 12345678910function takeLongTime() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(&quot;long_time_value&quot;), 1000); &#125;);&#125;async function test() &#123; const v = await takeLongTime(); console.log(v);&#125;test(); async/await的优势在与处理then链 ​ 单一的Promise并不能发现async/await的优势，如果处理多个Promise组成的then链时，优势就能体现出来了 假设一个业务分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果，如果使用setTimeout来模拟异步操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125;// setTimeOutfunction doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt();// async/awaitasync function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt(); ​ 现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果 12345678910111213141516171819202122232425262728async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time1, time2); const result = await step3(time1, time2, time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;// setTimeOutfunction doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; &#123; return step2(time1, time2) .then(time3 =&gt; [time1, time2, time3]); &#125;) .then(times =&gt; &#123; const [time1, time2, time3] = times; return step3(time1, time2, time3); &#125;) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125; 获取屏幕宽高获取屏幕高度方法- document.body.clientWidth ==&gt; BODY对象宽度 - document.body.clientHeight ==&gt; BODY对象高度 - document.documentElement.clientWidth ==&gt; 可见区域宽度 - document.documentElement.clientHeight ==&gt; 可见区域高度 - 网页可见区域宽： document.body.clientWidth - 网页可见区域高： document.body.clientHeight - 网页可见区域宽： document.body.offsetWidth (包括边线的宽) - 网页可见区域高： document.body.offsetHeight (包括边线的高) - 网页正文全文宽： document.body.scrollWidth - 网页正文全文高： document.body.scrollHeight - 网页被卷去的高： document.body.scrollTop - 网页被卷去的左： document.body.scrollLeft - 网页正文部分上： window.screenTop - 网页正文部分左： window.screenLeft - 屏幕分辨率的高： window.screen.height - 屏幕分辨率的宽： window.screen.width - 屏幕可用工作区高度： window.screen.availHeight - 屏幕可用工作区宽度： window.screen.availWidth 部分jQuery函数- $(window).height() //浏览器时下窗口可视区域高度 - $(document).height() //浏览器时下窗口文档的高度 - $(document.body).height() //浏览器时下窗口文档body的高度 - $(document.body).outerHeight(**true**) //浏览器时下窗口文档body的总高度 包括border padding margin - $(window).width() //浏览器时下窗口可视区域宽度 - $(document).width()//浏览器时下窗口文档对于象宽度 - $(document.body).width() //浏览器时下窗口文档body的高度 - $(document.body).outerWidth(**true**) //浏览器时下窗口文档body的总宽度 包括border padding HTML精确定位:scrollLeft,scrollWidth,clientWidth,offsetWidth- scrollHeight: 获取对象的滚动高度。 - scrollLeft:设置或获取位于对象左边界和窗口中目前可见内容的最左端之间的距离 - scrollTop:设置或获取位于对象最顶端和窗口中可见内容的最顶端之间的距离 - scrollWidth:获取对象的滚动宽度 - offsetHeight:获取对象相对于版面或由父坐标 offsetParent 属性指定的父坐标的高度 - offsetLeft:获取对象相对于版面或由 offsetParent 属性指定的父坐标的计算左侧位置 - offsetTop:获取对象相对于版面或由 offsetTop 属性指定的父坐标的计算顶端位置 - event.clientX 相对文档的水平座标 - event.clientY 相对文档的垂直座标 - event.offsetX 相对容器的水平坐标 - event.offsetY 相对容器的垂直坐标 - document.documentElement.scrollTop 垂直方向滚动的值 - event.clientX+document.documentElement.scrollTop 相对文档的水平座标+垂直方向滚动的量","updated":"2020-12-16T05:59:28.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"array","slug":"array","permalink":"https://lxx1997.github.io/tags/array/"},{"name":"method","slug":"method","permalink":"https://lxx1997.github.io/tags/method/"}]},{"title":"01 - Vue源码解读-数据驱动-dom生成","path":"2020/12/16/vue/vue-VirtualDOM-template/","text":"本片文章根据bilibili vue源码分析 视频练习及知识点记录 模仿vue原理 实现简单的DOM模板替换123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; is &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950let data = &#123; name: &#x27;SoulReader&#x27;, behavior: &#x27;writing&#x27;&#125;/* * 惰性匹配 .+? 匹配所有包含在&#123;&#123;&#125;&#125;里面的元素分组 * 贪婪匹配 .+ 匹配包含在&#123;&#123;&#125;&#125;里面的元素 会忽略中间的&#123;&#123;&#125;&#125;部分*/const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/gfunction compiler(template, data) &#123; const tempChilen = template.childNodes const length = tempChilen.length for(let i = 0; i &lt; length; i++) &#123; const nodeType = tempChilen[i].nodeType /* * nodeType * 1 代表元素节点 * 2 代表文本节点 */ if(nodeType === 3) &#123; // 代表是文本节点 /* * nodeValue 只有文本节点才有，nodeName只有元素节点才有 */ tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ return data[g.trim()] &#125;); &#125; else if(nodeType === 1) &#123; compiler(tempChilen[i], data) &#125; &#125;&#125;const node = document.getElementById(&#x27;app&#x27;)console.log(node)/* * 不能直接用获取到的 node 因为 DOM 是引用类型 * 需要利用 DOM 元素自带的 cloneNode 方法复制出一个新的node节点 * 参数传 true 表示复制当前节点的所有子孙节点，否则只复制当前节点 */const copyNode = node.cloneNode(true)compiler(copyNode, data)console.log(copyNode)/* * 调用 DOM 元素自带的 replaceChild( newNode, oldNode) 替换子节点方法*/app.parentNode.replaceChild(copyNode, node) 模板 要求一直在内存中 不会发生变化数据 数据发生变化后，会引起 DOM 的变化DOM 由模板和数据生成的页面 由 DOM 产生 对 DOM 渲染方法进行封装 123456789&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;div&gt; &#123;&#123;name&#125;&#125; &#123;&#123;behavior&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;人员：&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;行为：&#123;&#123;behavior&#125;&#125;&lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/* * Vue源码习惯 * 1 内部的数据使用 _ 开头 * 2 只读数据用 $ 开头*/function LikeVue(options) &#123; this._el = options.el this._data = options.data this.$el = this._templateDOM = document.querySelector(this._el) this.$parent = this._templateDOM.parentNode this.render()&#125;function compiler(template, data) &#123; const tempChilen = template.childNodes const length = tempChilen.length for(let i = 0; i &lt; length; i++) &#123; const nodeType = tempChilen[i].nodeType if(nodeType === 3) &#123; // 代表是文本节点 /* * nodeValue 只有文本节点才有，nodeName只有元素节点才有 */ tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; /* * 第一个参数是正则表达式匹配到的东西 * 第二个参数及以后是第 n-1 个分组 */ return data[g.trim()] &#125;); &#125; else if(nodeType === 1) &#123; compiler(tempChilen[i], data) &#125; &#125;&#125;// 渲染LikeVue.prototype.render = function() &#123; this.compiler()&#125;// 编译LikeVue.prototype.compiler = function() &#123; let template = document.querySelector(this._el) compiler(template, this._data) this.update(template)&#125;// 更新DOMLikeVue.prototype.update = function(template) &#123; this.$parent.replaceChild(template, document.querySelector(this._el))&#125;const options = &#123; el: &#x27;#app&#x27;, data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27; &#125;&#125;const curlyRE = /\\&#123;\\&#123;(.+?)\\&#125;\\&#125;/glet Vue = new LikeVue(options) 对函数进行改造，使其能够转换DOM中多层嵌套的对象，例如other.behavior.name 12345678910111213141516171819202122232425262728293031323334// 修改data对象里面的属性为多层嵌套data: &#123; name: &#x27;优·库里伍德·海尔赛兹&#x27;, behavior: &#x27;吃橘子&#x27;, other: &#123; name: &#x27;相川步&#x27;, behavior: &#123; name: &#x27;魔装少女&#x27;, time: &#x27;12min&#x27; &#125; &#125;&#125;// 新增一个函数用来处理模板中多层嵌套的对象function splitAttribute(data, g) &#123; let res = data // 1. // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 // res = res[item] // &#125;) //2. let paths = g.split(&#x27;.&#x27;) let prop while(prop = paths.shift()) &#123; res = res[prop] &#125; return res&#125;// 修改正则表达式替换函数的回调函数的返回值tempChilen[i].nodeValue = tempChilen[i].nodeValue.replace(curlyRE, (_, g) =&gt; &#123; return splitAttribute(data, g.trim())&#125;); 函数柯里化 目的是为了缓存一些内容，减少解析 柯里化: 一个函数原本有多个参数，传入一个参数，生成一个新函数，由新函数来接收剩余的参数，运行得到结果 偏函数: 一个函数原本有多个参数，传入一部分参数，生成一个新函数，由新函数来接收剩余的参数，运行得到结果 高阶函数: 一个函数，参数是一个函数，该函数对参数函数进行加工，得到加工后的函数123456789101112131415161718192021function createSplitAttribute(g) &#123; let paths = g.split(&#x27;.&#x27;) return function splitAttribute(data) &#123; let res = data // g.split(&#x27;.&#x27;).map(item =&gt; &#123; // res = res[item] // &#125;) //2. let prop while(prop = paths.shift()) &#123; // 当对一个变量赋值对象时，是对象的引用，变量中的某个值发生变化，对象中对应的值也会发生变化 // 但是给变量重新赋值对象，并不会造成原先对象的值发生变化，因为此时变量的引用已经发生变化，不在指向源对象 res = res[prop] &#125; return res &#125;&#125;// 调用const split = createSplitAttribute(g.trim())return split(data) 虚拟DOM 思路和深拷贝类似 将 真正的DOM 转化为 虚拟DOM 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 虚拟DOM 减少了回流和重绘 提高了速度/* * &lt;div /&gt; =&gt; &#123;tag: &#x27;div&#x27;&#125; * &lt;div title=&quot;1&quot; class=&quot;c&quot; /&gt; =&gt; &#123;tag: &#x27;div&#x27;,data: &#123;title: &#x27;1&#x27;, class: &#x27;c&#x27;&#125;&#125; * &lt;div&gt;&lt;div /&gt;&lt;/div&gt; =&gt; &#123;tag: &#x27;div&#x27;, children: [&#123;tag: &#x27;div&#x27;&#125;]&#125;*/class VNode &#123; /* * tag: node.nodeValue * data: node.attributes =&gt; obj =&gt; &#123;node.attribute.nodeName: node.attribute.nodeValue&#125; */ constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCase() this.data = data this.value = value this.type = type this.children = [] &#125; appendCild(vnode) &#123; this.children.push(vnode) &#125;&#125;// node 为页面中真实的 DOM 节点// 使用递归的方法提取出 DOM 节点中所有的子孙节点// Vue源码中使用 栈 的方式function getVnode(node) &#123; let nodeType = node.nodeType let _vnode = null // 判断nodeType类型 if(nodeType === 1) &#123; // 元素节点 let nodeName = node.nodeName // 获取 node 元素的 所有 attribute 属性， 是一个伪数组，需要转换成 对象 let attrs = node.attributes let _attrs = Object.create(null) for(let i = 0; i &lt; attrs.length; i++) &#123; _attrs[attrs[i].nodeName] = attrs[i].nodeValue &#125; _vnode = new VNode(nodeName, _attrs, undefined, nodeType) // 然后处理元素节点的所有自节点 let childNodes = node.childNodes for(let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendCild(getVnode(childNodes[i])) &#125; &#125; else if(nodeType === 3) &#123; // 文本节点 // 文本节点没有 tag 属性 data属性 _vnode = new VNode(undefined, undefined, node.nodeValue, nodeType) &#125; return _vnode&#125;let app = document.querySelector(&#x27;#app&#x27;)let app1 = getVnode(app)console.log(app1) 将 虚拟DOM 转化为 真正的DOM 12345678910111213141516171819202122function parseVnode(vnode) &#123; const &#123;tag, data, type, value, children&#125; = vnode let dom = null if(type === 1) &#123; dom = document.createElement(tag) for(let key in data) &#123; dom.setAttribute(key, data[key]) &#125; dom.nodeType = type for(let i = 0; i &lt; children.length; i++) &#123; // dom.append(parseVnode(children[i])) dom.appendChild(parseVnode(children[i])) &#125; &#125; else if(type === 3) &#123; dom = document.createTextNode(tag) dom.nodeValue = value dom.nodeType = type &#125; return dom&#125;const dom = parseVnode(app1)console.log(dom, &#x27;dom&#x27;)","updated":"2020-12-16T02:54:22.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"vue-源码","path":"2020/12/15/vue/vue-源码常用方法/","text":"本片文章只用于引导自己如何对源码进行探索，因为看到源码的时候是一脸懵逼，完全不知道该从那个地方看起，所以用本篇文章记录一下自己的解读顺序，以免自己忘记 LIFECYCLE_HOOKS vue 钩子函数 beforeCreatecreatedbeforeMountemountedbeforeUpdateupdatedbeforeDestorydestoryedactivateddeactivatederrorCapturedserverPrefetch SOME USERFUL METHODS 判断浏览器类型1234567891011121314// packages/vue-template-compiler/browser.jsvar inBrowser = typeof window !== &#x27;undefined&#x27;;var inWeex = typeof WXEnvironment !== &#x27;undefined&#x27; &amp;&amp; !!WXEnvironment.platform;var weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();var isIE = UA &amp;&amp; /msie|trident/.test(UA);var isIE9 = UA &amp;&amp; UA.indexOf(&#x27;msie 9.0&#x27;) &gt; 0;var isEdge = UA &amp;&amp; UA.indexOf(&#x27;edge/&#x27;) &gt; 0;var isAndroid = (UA &amp;&amp; UA.indexOf(&#x27;android&#x27;) &gt; 0) || (weexPlatform === &#x27;android&#x27;);// Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1var isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === &#x27;ios&#x27;);var isChrome = UA &amp;&amp; /chrome\\/\\d+/.test(UA) &amp;&amp; !isEdge;var isPhantomJS = UA &amp;&amp; /phantomjs/.test(UA);var isFF = UA &amp;&amp; UA.match(/firefox\\/(\\d+)/); makeMap 创建一个闭包判断函数，判断元素是否存在 1234567891011121314// packages/vue-template-compiler/build.jsfunction makeMap (str, expectsLowerCase) &#123; var map = Object.create(null); var list = str.split(&#x27;,&#x27;); for (var i = 0; i &lt; list.length; i++) &#123; map[list[i]] = true; &#125; return expectsLowerCase ? function (val) &#123; return map[val.toLowerCase()]; &#125; : function (val) &#123; return map[val]; &#125;&#125;var isBuiltInTag = makeMap(&#x27;slot,component&#x27;, true)isBuiltInTag(&#x27;slot&#x27;) // true remove 123456789// packages/vue-template-compiler/build.jsfunction remove (arr, item) &#123; if (arr.length) &#123; var index = arr.indexOf(item); if (index &gt; -1) &#123; return arr.splice(index, 1) &#125; &#125;&#125; set 123456789101112131415161718192021222324252627282930313233343536373839function set (target, key, val) &#123; // 判断传入的 target 是否是 undefined 类型或者基础数据类型 if (isUndef(target) || isPrimitive(target) ) &#123; warn((&quot;Cannot set reactive property on undefined, null, or primitive value: &quot; + ((target)))); &#125; // 判断 target 是否是数组，以及 key 是否一个正常的数组序号 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); // 在数组的 key 位替换成 val target.splice(key, 1, val); return val &#125; // target 为对象的话且 key 不是 Object 的属性，避免修改 Object 的属性，造成对象污染 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val &#125; // 每个被双向绑定的 数据 都有一个 __ob__ 对象 var ob = (target).__ob__; // 如果 target 对象是 Vue 实例 或者 ob有值，则禁止向 Vue 实例上添加动态响应式属性 if (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123; warn( &#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27; + &#x27;at runtime - declare it upfront in the data option.&#x27; ); return val &#125; // 如果不是 Vue 实例 直接添加属性 if (!ob) &#123; target[key] = val; return val &#125; // 在对象上定义被动特性 defineReactive$$1(ob.value, key, val); // 触发 通知事件 ob.dep.notify(); return val&#125;","updated":"2020-12-15T01:34:37.000Z","categories":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"},{"name":"SourceCode","slug":"SourceCode","permalink":"https://lxx1997.github.io/tags/SourceCode/"}]},{"title":"H5基于canvas实现电子签名并生成PDF文档","path":"2020/12/14/web/H5基于canvas实现电子签名并生成PDF文档/","text":"转载前端大全 前言电子签名通俗来说就是通过技术手段实现在电子文档上加载电子形式的签名，其作用类似于纸质合同上的手写签名或加盖的公章。虽然电子签名多年来合法性一直遭到质疑，但其在企业工作流审批、请柬、单据保全等场景应用广泛，最近的项目中就有这样一个手写签名并生成PDF文件的需求。 实现思路使用canvas来实现手写签名的功能，然后将canvas转化为图片，贴在签名的位置；将整个需要生成文档的dom区域使用html2canvas插件转成一张大图；使用JsPDF插件将上述图片生成PDF文档；对于文件内容较多的情况，需要合理选择分页位置；生成签名 在tsx中定义canvas画布 1&lt;canvas className=&#123;styles.canvas&#125; ref=&#123;canvasDom&#125; width=&quot;350&quot; height=&quot;150&quot; /&gt; 注意：Canvas的宽高必须要使用内联样式定义，这是因为Canvas标签有自己的默认宽高300px×150px。它内联样式定义的width和height是绘画区域（画布）实际宽度和高度，绘制的图形都是在这个上面。如果在style外链文件中定义其width和height，那么这个width和height是Canvas在浏览器中被渲染的高度和宽度。如果Canvas中没有直接定义width和height没或值不正确，就会被设置成默认值{width:300px，height:150px}。所以，如果你在style中外链文件中设置了canvas {width: 200px; height: 200px;}，却没有直接在canvas上定义画布宽高，那么此时你输出canvas.height 值依旧为150，canvas.width值依旧为300。也就是一块150×300的画布在200×200的区域渲染，因而图片会出现拉伸、变形等现象。 定义签名函数 12345678910111213141516const writing = ( beginX: number, beginY: number, stopX: number, stopY: number, ctx: any, ) =&gt; &#123; ctx.beginPath(); // 开启一条新路径 ctx.globalAlpha = 1; // 设置图片的透明度 ctx.lineWidth = 3; // 设置线宽 ctx.strokeStyle = &#x27;red&#x27;; // 设置路径颜色 ctx.moveTo(beginX, beginY); // 从(beginX, beginY)这个坐标点开始画图 ctx.lineTo(stopX, stopY); // 定义从(beginX, beginY)到(stopX, stopY)的线条（该方法不会创建线条） ctx.closePath(); // 创建该条路径 ctx.stroke(); // 实际地绘制出通过 moveTo() 和 lineTo() 方法定义的路径。默认颜色是黑色。 &#125;; 注册监听事件12345678910111213141516171819let beginX: number, beginY: number;const canvas: HTMLCanvasElement = canvasDom.current;const ctx = canvas.getContext(&#x27;2d&#x27;);ctx.fillStyle = &#x27;#fff&#x27;;ctx.fillRect(0, 0, canvas.width, canvas.height);canvas.addEventListener(&#x27;touchstart&#x27;, function(event: any) &#123; event.preventDefault(); // 阻止在canvas画布上签名的时候页面跟着滚动 beginX = event.touches[0].clientX - this.offsetLeft; beginY = event.touches[0].pageY - this.offsetTop;&#125;);canvas.addEventListener(&#x27;touchmove&#x27;, (event: any) =&gt; &#123; event.preventDefault(); // 阻止在canvas画布上签名的时候页面跟着滚动 event = event.touches[0]; let stopX = event.clientX - canvas.offsetLeft; let stopY = event.pageY - canvas.offsetTop; writing(beginX, beginY, stopX, stopY, ctx); beginX = stopX; // 这一步很关键，需要不断更新起点，否则画出来的是射线簇 beginY = stopY;&#125;); 注意： 在注册“touchstart”和“touchmove”事件时，需要阻止默认事件，否则页面会跟着手势上下滑动。移动端的每个触摸事件对象中都包括了touches这个属性，它用于描述位于屏幕上的所有手指的一个列表，获取当前事件对象我们习惯性的使用event = event.touches[0],而在PC端则不需要这么操作。offsetLeft值跟offsetTop值跟父级元素没关系，而是跟其上一级的定位元素(除position:static外的所有定位如fixed,relative,absolute元素)有关系。若上一级定位元素都没有除position:staice外的定位，则这个偏移量是相对于body而言的。需要理清移动端事件对象的几个属性，⏬clientX/clientY: 触摸位置距离当前body可视区域的x,y坐标;pageX/pageY: 对于整个页面来说，触摸位置距离body左上角的x,y坐标，包括被scrollTop和scrollLeft的值；screenX/screenY: 触摸位置距离显示器左边和顶部的x,y距离。所以，在获取结束点坐标的时候，如果当前页面没有出现滚动条，使用clientY和pageY计算差别不大，如果页面比较长，出现了滚动条，那么就必须要使用pageY来计算。clientX同理，但是移动端通常横向滚动的场景不多，所以用clientX来计算即可。 在签名（touchmove）这个动作过程中，我们需要不断的更新起点位置，否则画出来是这样🔽图片其实这个原理和微积分很相似，线段本质上就是由无穷多个小线段组成，宏观一点来看可以把线段当成一个个长度很小的小线段首尾相连构成。所以我一直觉得编程编到最后就是考验一个人的数学能力，交并集、逻辑思维、算法等都能看到数学的身影。最后生成签名如下：图片 生成PDF文档html2canvas是一款将HTML代码转换成Canvas的插件，因此需要用一个div包裹住需要打印的内容区域，获得这个dom节点。1234567html2Canvas(dom, &#123; allowTaint: true, width: dom.offsetWidth, //设置获取到的canvas宽度 height: dom.offsetHeight, //设置获取到的canvas高度 x: 0, //页面在水平方向滚动的距离 y: 0, //页面在垂直方向滚动的距离&#125;)注意：此处需要设置width和height及x,y，否则当页面内容只有一页的时候没有问题，但是若页面内容有很多页的时候，就会出现生成的图片只有一小部分有内容的现象。问题就出现在这个配置参数上，若没有设置宽高，则默认只取当前视口的内容，丢弃掉其他超出当前视口的内容。设置打印参数：123456789101112131415161718192021222324252627282930313233const print = () =&gt; &#123; let dom: HTMLElement = pdfDom.current; html2Canvas(dom, &#123; allowTaint: true, width: dom.offsetWidth, //设置获取到的canvas宽度 height: dom.offsetHeight, //设置获取到的canvas高度 x: 0, //页面在水平方向滚动的距离 y: 0, //页面在垂直方向滚动的距离 &#125;).then((canvas: HTMLCanvasElement) =&gt; &#123; let canvasWidth = canvas.width; let canvasHeight = canvas.height; let pageHeight = (canvasWidth / 592.28) * 841.89; // 一页A4 pdf能显示的canvas高度 let imgWidth = 595.28; // 设置图片宽度和A4纸宽度相等 let imgHeight = (592.28 / canvasWidth) * canvasHeight;//等比例换算成A4纸的高度 let totalHeight = imgHeight; // 需要打印的图片总高度，初始状态和图片高度相等 let pageData = canvas.toDataURL(&#x27;image/png&#x27;, 1.0); let PDF = new JsPDF(&#x27;p&#x27;, &#x27;pt&#x27;, &#x27;a4&#x27;, true); if (totalHeight &lt; pageHeight) &#123; // PDF.addImage(pageData, &#x27;JPEG&#x27;, 0, 0, imgWidth, imgHeight); // 从顶部开始打印 &#125; else &#123; let top = 0; // 打印初始区域 while (totalHeight &gt; 0) &#123; PDF.addImage(pageData, &#x27;JPEG&#x27;, 0, top, imgWidth, imgHeight); // 从图片顶部往下top位置开始打印 totalHeight -= pageHeight; top -= 841.89; if (totalHeight &gt; 0) &#123; PDF.addPage(); &#125; &#125; &#125; PDF.save(&#x27;test.pdf&#x27;); &#125;); &#125;;选择分页位置 按照上述步骤生成了一份PDF文档，但是当PDF页数有很多的时候，会有这样的问题可以看到，分页的时候从这段文字这里懒腰截断了。这显然不是我们想要看到的效果，如何解决这个问题呢？🤔 PDF文档页数较少的情况可以在开发测试的时候预先在将要分页的地方插入一个padding，就是提前预留分页位置 PDF文档页数较多对于这种情况，笔者尝试遍历要打印的dom节点的子节点，将每一页所能打印的dom节点高度累加，若超过了页面所能承载的最大高度，则将最后一个节点增加padding，打印完毕将样式还原。这种方法因为要计算每个dom节点的高度，非常耗性能，也要求页面dom元素的颗粒度较细，否则会出现一个页面有大块空白，完全无法模拟出word生成pdf的那种效果，所以就不展开讨论了。如若有读者有比较好的解放方案，欢迎不吝赐教，感谢~❤️","updated":"2020-12-14T09:15:09.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxx1997.github.io/tags/canvas/"}]},{"title":"前端性能优化 - 转载","path":"2020/12/11/web/前端性能优化/","text":"前言当我们去面试的时候，很大概率会被面试官问这么一个问题：你有尝试过对项目做性能优化吗？或者你了解哪些性能优化的方法？听到这个问题的你可能是这样的： 似曾相识但又说不清楚，往往只能零散地说出那么几点，难以做到有条理的回答。那么，本文就带你简单了解前端性能优化的几个主要方面，旨在抛砖引玉。 一、资源的合并和压缩web前端应用的开发与部署过程： 输入url到页面显示出来的过程： 请求过程中一些潜在的性能优化点： dns是否可以通过缓存减少dns查询时间？ 网络请求的过程如何走最近的网络环境？ 相同的静态资源是否可以缓存？ 能否减少http请求的大小和次数？ 能否进行服务端渲染？ 总结：深入理解http请求的过程是前端性能优化的核心。 优化核心 减少http请求数量； 减少请求资源的大小； google首页案例学习 html压缩； css压缩； js的压缩和混乱； 文件合并； 开启gzip； 1.html压缩HTML代码压缩就是压缩一些在文本文件中有意义，但是在HTML中不显示的字符，包括空格，制表符，换行符等，还有一些其他意义的字符，如HTML注释也可以被压缩； 一个简单的计算： google的流量，占到整个互联网的40%，预计2016年全球网络流量将达到1.3ZB(1ZB = 10^9TB)，那么google在2016年的流量就是1.3ZB * 40%，如果google每1MB请求减少一个字节，每年可以节省流量近500TB流量。 如何进行html压缩 使用在线网站进行压缩； nodejs提供的html-minifier工具； 后端模板引擎渲染压缩； 2.css代码压缩分为两部分： 无效代码的压缩； css语义合并； 如何进行css压缩 使用在线网站进行压缩； 使用html-minifier对html中的css进行压缩； 使用clean-css对css进行压缩； 3.js压缩与混乱（丑化）包括： 无效字符的删除（空格，回车等）； 剔除注释； 代码语义的缩减和优化； 代码保护（如果代码不经处理，客户端可直接窥探代码漏洞）； JS压缩与混乱（丑化） 使用在线网站进行压缩：https://tool.oschina.net/jscompress/ 使用html-minifier对html中的js进行压缩； 使用uglify.js2对js进行压缩； 4.文件合并文件合并的好处： 左边的表示使用http长链接keep-alive但不合并请求的情况，需要分三次去获取a.js、b.js、c.js；右边是使用长链接并且合并请求的情况，只需要发送一次获取合并文件a-b-c.js的请求，就能将三个文件都请求回来。 不合并请求有下列缺点： 文件与文件之间有插入的上行请求，会增加N-1个网络延迟； 受丢包问题的影响更严重：因为每次请求都可能出现丢包的情况，减少请求能有效减少丢包情况； keep-alive本身也存在问题：经过代理服务器时可能会被断开； 文件合并存在的问题 首屏渲染问题：当请求js文件的时候，如果页面渲染只依赖a.js文件，由于文件合并，需要等待合并后的a-b-c.js文件请求回来才能继续渲染，这样就会导致页面渲染速度变慢。这种情况大多出现在现代化的前端框架，如Vue等的使用过程中； 缓存失效问题：合并后的文件a-b-c.js中只要其中一个文件（比如a.js）发生变化，那么整个合并文件都将失效，而不采用文件合并就不会出现这种情况； 使用建议 公共库合并：将不经常发生变化的公共组件库文件进行合并； 将不同页面的js文件单独合并：比如在单页面应用SPA中，当路由跳转到具体的页面时才请求该页面需要的js文件； 如何进行文件合并 使用在线网站进行文件合并； 使用nodejs实现文件合并； 使用webpack等前端构件化工具也可以很好地实现； 二、图片相关的优化有损压缩过程： 一张JPG图片的解析分别要进行： 颜色空间的转换：从RGB的颜色空间转到其他的颜色空间 ； 进行重采样：区分高频和低频的颜色变换； 进行DCT过程：对高频的颜色采样结果进行压缩，这样压缩的收益会比较大； 再对数据进行量化； 最后进行编码（encoding）； 最终得到JPEG-Compressed Image Data，即真正显示出来的JPG图片。虽然这是一种有损压缩，但是很多情况下，这些损失的数据并不影响显示； png8/png24/png32之间的区别 png8：256色 + 支持透明； png24：2^24色 + 不支持透明； png32：2^32色 + 支持透明； 不同格式图片常用的业务场景 jpg有损压缩，压缩率高，支持透明；应用：大部分不需要透明图片的业务场景； png支持透明，浏览器兼容好；应用：大部分需要透明图片的业务场景； webp（2010年由谷歌推出）压缩程度更好，在ios webview中有兼容性问题；应用：安卓全部； svg矢量图，代码内嵌，相对较小，用于图片样式相对简单的场景；应用：比如logo和iconfont； 1.图片压缩针对真实图片情况，舍弃一些相对无关紧要的色彩信息，对图片进行压缩；比如在线压缩网站：https://tinypng.com/ 2.css雪碧图将网站上用到的一些图片整合到一张单独的图片中，从而减少网站HTTP请求数量。原理为：设定整张雪碧图可示区域，将想要显示的图标定位到该处（左上角）；缺点：整合图片比较大时，一次加载比较慢。 如天猫的雪碧图： 很多情况下，并不是所有的小图标都放在一张雪碧图中，而是会适当进行拆分。现在使用雪碧图的场景比较少了。 自动生成雪碧图样式的网站：http://www.spritecow.com/ 选中雪碧图中对应的图标，就会生成对应的样式。 3.网页内联图片（Image inline）将图片的内容内嵌到html当中，减少网站的HTTP请求数量，常用于处理小图标和背景图片。网页内联图片写法为： 1&lt;imgsrc=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA...&quot;alt=&quot;&quot;&gt; 浏览器上的表现形式为： 这里提供一个将：image 转 DataUrI的网址：http://tool.c7sky.com/datauri/ 缺点： 浏览器不会缓存内联图片资源； 兼容性较差，只支持ie8以上浏览器； 超过1000kb的图片，base64编码会使图片大小增大，导致网页整体下载速度减慢； 所以要根据场景使用，不过内联图片减少HTTP请求的优点还是很显著的。比如，在开发中小于4KB或8KB的图片都会通过构建工具自动inline到HTML中，这种情况下Image inline带来的图片大小增长其实是比增加HTTP请求次数更优的。 4.矢量图SVG与iconfont使用iconfont解决icon问题 应尽量使用该方式，比如可以采用阿里巴巴矢量图库： 可以选择格式进行下载： 可以看到它们的大小有着明显的差异： 使用SVG进行矢量图的控制 SVG意为可缩放矢量图形（Scalable Vector Graphics）。SVG 使用 XML 格式定义图像。下为示例： 在线转换网站：http://www.bejson.com/convert/image_to_svg/ 5.webpwebp的优势体现在它具有更优的图像压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha透明以及动画的特性。在JPEG和PNG上的转化效果都非常优秀、稳定和统一。安卓上不存在兼容性问题，推荐安卓下使用。 以下为淘宝网首页请求的图片： 可以看到，图片中大量地添加了webp格式的选择。.jpg_.webp表示当浏览器支持webp时采用webp格式，否则采用jpg格式。 下面为B站首页的图片，可以看到基本都采用了webp格式： 同一张图片jpg格式和webp格式压缩率有着明显的差异： 可以通过在线网站将图片转换为webp：https://zhitu.isux.us/ 像图片这样的静态文件可以存放在CDN服务器上，让CDN服务器批量地将图片转换成Webp格式； 三、浏览器渲染引擎与阻塞1.渲染的主要模块版本一： 版本二： 一个渲染引擎主要包括：HTML解析器，CSS解析器，javascript引擎，布局layout模块，绘图模块： HTML解析器：解释HTML文档的解析器，主要作用是将HTML文本解释成DOM树； CSS解析器：它的作用是为DOM中的各个元素对象计算出样式信息，为布局提供基础设施； Javascript引擎：使用Javascript代码可以修改网页的内容，也能修改css的信息，javascript引擎能够解释javascript代码，并通过DOM接口和CSS树接口来修改网页内容和样式信息，从而改变渲染的结果； 布局（layout）：在DOM创建之后，Webkit需要将其中的元素对象同样式信息结合起来，计算他们的大小位置等布局信息，形成一个能表达这所有信息的内部表示模型； 绘图模块（paint）：使用图形库将布局计算后的各个网页的节点绘制成图像结果； 2.渲染过程浏览器渲染页面的整个过程：浏览器会从上到下解析文档。 浏览器解析时遇见 HTML 标记，就会调用HTML解析器解析为对应的 token （一个token就是一个标签文本的序列化）并构建 DOM 树（就是一块内存，保存着tokens，建立它们之间的关系）。在生成DOM的最开始阶段（应该是Bytes → characters后），并行发起css、图片、js的请求，无论他们是否在HEAD标签中。 注意：发起js文件的下载请求（request）并不需要DOM处理到那个script节点； 遇见 style/link 标记 调用解析器 处理 CSS 标记并构建 CSS样式树； 遇见 script 标记 调用 javascript解析器处理script标记，绑定事件、修改DOM树/CSS树等； 将 DOM树 与 CSS树 合并成一棵渲染树（Render Tree）。 布局（Layout）：根据渲染树中各节点的样式和依赖关系，计算出每个节点在屏幕中的位置； 绘图（Painting）：按照计算出来的结果：要显示的节点、节点的CSS与位置信息，通过显卡，把内容画到屏幕上； 经过第一次Painting之后DOM、CSSOM、Render Tree都可能会被多次更新，比如JS修改了DOM或者CSS属性时，Layout和Painting就会被重复执行。除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 补充： \\1. HTML中可能会引入很多的css、js这样的外部资源，这些外部资源在浏览器端是并发加载的。但是浏览器会对同一域名进行并发数量（度）的限制，即单个域名的并发度是有限的； \\2. 所以，经常将大部分的资源托管到CDN服务器上，并且设置3~4个CDN域名。防止只有一个CDN域名的情况下，达到了浏览器外部资源并发请求数目的上限，导致很多资源无法做到并发请求。所以，应设置多个CDN域名； 3.css阻塞只有通过link引入的外部css才会产生阻塞： style标签中的样式： 由html解析器进行解析； 不阻塞浏览器渲染（可能会产生“闪屏现象”）； 不阻塞DOM解析； link引入的外部css样式（推荐使用的方式）： 由CSS解析器进行解析； 阻塞浏览器渲染：由于css已经加载完毕，所以整个渲染过程是带样式的，所以这种阻塞可以避免“闪屏现象”； 阻塞其后面的js语句的执行：这个不难理解，js文件中经常会出现DOM操作，操作过程中有可能涉及到css样式的修改。实际上，这些修改往往是依赖于之前引入的css设定的样式的，所以css会阻塞js的执行； 不阻塞DOM的解析； 优化核心理念：尽可能快的提高外部css加载速度： 使用CDN节点进行外部资源加速； 对css进行压缩(利用打包工具，比如webpack，gulp等)； 减少http请求数，将多个css文件合并； 优化样式表的代码； 4.js阻塞 阻塞DOM解析: 原因：浏览器不知道后续脚本的内容，如果先去解析了下面的DOM，而随后的js删除了后面所有的DOM，那么浏览器就做了无用功，浏览器无法预估脚本里面具体做了什么操作，例如像document.write这种操作，索性全部停住，等脚本执行完了，浏览器再继续向下解析DOM；可以通过给script标签添加defer和async属性，异步引入js文件，以此来解决这一问题。 阻塞页面渲染: 原因：js中也可以给DOM设置样式，浏览器同样等该脚本执行完毕，再继续干活，避免做无用功； 阻塞后续js的执行: 原因：js是按顺序执行的，这样可以维护依赖关系，例如：必须先引入jQuery再引入bootstrap； 不阻塞资源的加载： 这并不与上面矛盾，因为不可能由于加载一个js文件就把其他资源的加载都阻塞了。针对这种常见的情况，浏览器会通过预加载的方式加载后续的资源； 5.总结 css的解析和js的执行是互斥的（互相排斥），css解析的时候js停止执行，js执行的时候css停止解析； 无论css阻塞，还是js阻塞，都不会阻塞浏览器加载外部资源（图片、视频、样式、脚本等）； 因为览器始终处于一种：“先把请求发出去”的工作模式，只要是涉及到网络请求的内容，无论是：图片、样式、脚本，都会先发送请求去获取资源，至于资源到本地之后什么时候用，由浏览器自己协调。显然这种做法效率很高； WebKit 和Firefox 都进行了【预解析】这项优化。在执行js脚本时，浏览器的其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树 四、懒加载和预加载1.懒加载图片进入可视区域之后再请求图片资源的方式称为图片懒加载。适用于图片很多，页面很长的业务场景，比如电商； 懒加载的作用： 减少无效资源的加载： 比如一个网站有十页图片，用户只查看了第一页的图片，这就没必要将十页图片全都加载出来； 并发加载的资源过多会阻塞js的加载，影响网站正常的使用： 由于浏览器对某一个host name是有并发度上限的，如果图片资源所在的CDN和静态资源所在的CDN是同一个的话，过多图片的并发加载就会阻塞后续js文件的并发加载。 懒加载实现的原理： 监听onscroll事件，判断可视区域位置： 图片的加载是依赖于src路径的，首先可以为所有懒加载的静态资源添加自定义属性字段，用于存储真实的url。比如是图片的话，可以定义data-src属性存储真实的图片地址，src指向loading的图片或占位符。然后当资源进入视口的时候，才将src属性值替换成data-src中存放的真实url。 1&lt;img src=&quot;&quot; class=&quot;image-item&quot; alt=&quot;&quot; lazyload = &quot;true&quot; data-src=&quot;TB27YQvbm_I8KJjy0FoXXaFnVXa_!!400677031.jpg_180x180xzq90.jpg_.webp&quot;&gt; 懒加载实例 可以使用元素的getBoundingClientRect().top来判断当前位置是否在视口内，也可以使用元素距离文档顶部的距离offsetTop和scrollTop是否小于视口高度来判断： 下面是我针对getBoundingClientRect的补充getBoundingClientRect 有四个属性 top - 获取到的是元素上边框到浏览器顶部的距离，包含html和body的边框及margin，padding bottom - 获取到的是元素下边框到浏览器顶部的距离，包含html和body的边框及margin，padding left - 获取到的是元素左边框到浏览器左边的距离，包含html和body的边框及margin，padding right - 获取到的是元素右边框到浏览器左边的距离，包含html和body的边框及margin，padding 举例 比如手机淘宝首页： 当快要滚动到需要展示的图片时才进行图片的请求，可以看到图片上有一个lazyload的属性： 2.预加载预加载与懒加载正好是相反的过程：懒加载实际上是延迟加载，将我们所需的静态资源加载时间延后；而预加载是将图片等静态资源在使用之前的提前请求，这样资源在使用到时能从缓存中直接加载，从而提升用户体验； 预加载的作用： 提前请求资源，提升加载速度：使用时只需要读取浏览器缓存中提前请求到的资源即可； 维护页面的依赖关系：比如WebGL页面，会依赖一些3D模型，这些都是页面渲染所必须的资源。如果资源都没有加载完毕就进行页面的渲染，就会造成非常不好的体验。 所以时常使用预加载的方式维护页面渲染的依赖关系，比如将WebGL页面依赖的3D模型加载完之后才进行页面渲染。这样渲染的过程就不会有任何阻碍，具有较好的用户体验； 预加载的实例 例如九宫格抽奖业务，每个奖品都有一个选中态和非选中态，实际上这是由两张图片组合而成的。由于每个奖品的选中过程都是一瞬间，这就对图片的选中态和非选中态切换效率要求很高，如果选中态的图片没有预加载的话显然是来不及的。 所以，实际上对于九宫格中所有图片选中态的样式和对应的图片都需要进行预加载，从而让我们在抽奖的过程中，能够瞬间从缓存中读取到选中态的图片，从而不影响抽奖效果的展示。 除此之外还有网站登录或活动时需要用到的动画，这是在动画需要的每帧图片都完全预加载完之后才会进行显示的。 五、重绘与回流1.CSS图层浏览器在渲染一个页面时，会将页面分为很多个图层，图层有大有小，每个图层上有一个或多个节点。在渲染 DOM的时候，浏览器所做的工作实际上是： 1、获取DOM后分割为多个图层； 2、对每个图层的节点计算样式结果（Recalculate style–样式重计算）； 3、为每个节点生成图形和位置（Layout–回流和重布局）； 4、将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘）； 5、图层作为纹理上传至GUI； 6、复合多个图层到页面上生成最终屏幕图像（Composive Layers–图层重组）； 2.创建图层的条件 拥有3D或透视变换的css属性（prespective transform ）； 使用加速视频解码的&lt;video&gt;节点； 拥有3D(WebGL)上下文或加速的2D上下文的&lt;canvas&gt;节点； CSS3动画的插件（如Flash）； 拥有加速css过滤器的元素； transform：如translateZ(0) opacity filter will-change：哪一个属性即将发生变化，进而进行优化。 下面是本人针对will-change的一些补充 不要使用will-change声明对太多属性或元素的更改 给浏览器足够的时间来工作，不要对已经发生的变化进行优化 变更生效之后移除掉will-change 最好使用js来进行属性的赋值和移除 有选择的在css中使用will-change 用于反复交互或者不断变化的元素 3.重绘（Repaint）重绘是一个元素外观的改变所触发的浏览器行为，比如background-color、outline等属性。这些属性不影响布局，只影响元素的外观，风格，会造成DOM元素的重新渲染，这个过程称为重绘。 需要注意的是：重绘是以图层为单位，如果图层中某个元素需要重绘，那么整个图层都需要重绘。比如一个图层包含很多节点，其中有个gif图，gif图的每一帧，都会重回整个图层的其他节点，然后生成最终的图层位图。 因此，可以通过特殊的方式来强制gif图单独为一个图层（translateZ(0)或者translate3d(0,0,0)；CSS3的动画也是一样（好在绝大部分情况浏览器自己会为CSS3动画的节点创建图层）； 所以：将频繁重绘回流的DOM元素作为一个独立图层，那么这个DOM元素的重绘和回流只会该图层；原则上是要尽量避免新建图层的，因为这会导致图层重组（Composive Layers）时候的计算量增大。所以，只有当某些DOM元素频繁重绘回流时，才新建一个独立图层放置它们； 只会触发重绘的属性 12345678910111213141516//部分属性colorborder-styleborder-radiusvisibilitytext-decorationbackgroundbackground-imagebackground-positionbackground-repeatbackground-sizeoutline-coloroutlineoutline-styleoutline-widthbox-shadow 4.回流（Reflow）当render tree中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流（reflow）； 当页面布局和几何属性改变时就需要回流； 回流必将引起重绘，而重绘不一定会引起回流； 触发页面重布局（回流）的属性 频繁触发重绘和回流，会导致UI频繁渲染。在渲染的过程中由于阻塞了js线程的执行，最终导致js执行变慢。 5.触发回流的常见操作 增加、删除、修改 DOM 结点； 移动 DOM 的位置； 修改 CSS 样式； Resize 窗口；移动端没有这个问题，因为移动端的缩放没有影响布局视口（vw/vh）； 修改网页的默认字体； 获取某些DOM元素的属性(width，height等)； 注：display：none 会触发 Reflow，而visibility：hidden 只会触发 Repaint，因为没有发生位置变化； 6.示例案例一：淘宝轮播图 可以使用Chrome浏览器调试工具的Performance来观察淘宝首页一个轮播图引起的重绘回流过程： Update Layer Tree回流和重布局： Paint重绘： Composite Layers图层重组： 案例二：播放器 通过Chrome调试工具的Layers选项查看图层，及新增图层的原因： 视频播放的过程中，video标签的DOM元素会一直重绘，所以把它限制在一个图层上是非常好的，这样只会涉及到这个图层的重绘，而不会影响其他图层的元素。 图层不能滥用，否则会在图层重组的过程中严重消耗性能！ 比如可以将淘宝首页的所有的DOM元素都变为一个图层：在html标签中的全局样式（*）中添加transform:translateZ(0)来触发新建图层： 还可以通过添加：will-change: transform属性新建图层； 再次查看此时的图层情况，可以看到此时首页的图层非常之多，十分地卡： 7.实战优化点如果我们需要使得动画或其他节点渲染的性能提高，需要做的就是减少浏览器在运行时所需要做的下列工作： 计算需要被加载到节点上的样式结果（Recalculate style–样式重计算）； 为每个节点生成图形和位置（Layout–回流和重布局）； 将每个节点填充到图层中（Paint Setup和Paint–重绘）； 组合图层到页面上（Composite Layers–图层重组）； 1、使用translate替代top等属性来改变位置； 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;htmllang=&quot;en&quot;&gt;&lt;head&gt; &lt;metacharset=&quot;UTF-8&quot;&gt; &lt;metaname=&quot;viewport&quot;content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; /*方法1*/ position: relative; top: 0; /*方法2*/ /* transform: translateY(0); */ width: 200px; height: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;divid=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; setTimeout(() =&gt; &#123; document.getElementById(&quot;box&quot;).style.top = &#x27;100px&#x27; //document.getElementById(&quot;box&quot;).style.transform = &#x27;translateY(100px)&#x27; &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用top属性改变正方形位置时，存在重绘和回流Layout： 而使用translate属性改变正方形位置时，并不会引起重绘和回流： 比如有的网站会有一些左右飘动的浮窗，由于这些浮窗是采用定时器来实现的，如果每经过100ms就改变浮窗的位置。这种时候使用transform来替代top/left的话1s内就减少了十次回流，十分有利于网页速度的提升。 2、使用opacity替代visibility： 使用visibility不触发重排，但是依然重绘； 直接使用opacity既触发重绘，又触发重排（GPU底层设计如此！）； opacity配合图层使用，既不触发重绘也不触发重排； 原因：透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改opacity本身必须是一个单独的图层。 3、将多次改变DOM元素样式属性的操作合并成一次操作： 预先定义好class，然后通过修改DOM的className来添加样式； 4、把DOM离线后再修改： 由于display属性为none的元素不在渲染树中，对隐藏的元素操作不会引发其他元素的重排。如果要对一个元素进行复杂的操作时，可以先隐藏它，操作完成后再显示。这样只在隐藏和显示时触发2次回流； 5、不要把获取某些DOM节点的属性值放在一个循环里当成循环的变量 当向浏览器请求某些 style信息的时候，浏览器就会清空（flush）队列，比如： ffsetTop，offsetLeft，offsetWidth，offsetHeight； scrollTop/Left/Width/Height； clientTop/Left/Width/Height； width，height； 浏览器为了获取最精确的值，需要刷新内部队列。因为队列中可能存在影响到这些值的操作，即使没有，浏览器也会强行刷新渲染队列。这样就无法利用渲染队列的缓存来避免回流过于频繁了，所以在使用到DOM元素这些相关的属性时，可以将获取到的属性值存在一个变量中，而不是每次都去重新获取。 6、不要使用table布局： 因为很小的一个改动都会造成整个table的重新布局；所以尽量使用div布局； 7、启用GPU硬件加速： 原理为：浏览器会检测一些特定的css属性，当DOM元素拥有这些css属性的时候，浏览器就会对该DOM元素启动GPU硬件加速；比如：transform: translateZ(0)和transform: translate3d(0, 0, 0)这两个属性都可以启动硬件加速；硬件加速同样不能滥用，否则会导致图层过多，导致合并图层时消耗大量性能。 8、动画实现速度的选择： 因为动画的每次变化都会引起重绘和回流，所以要根据业务场景适当地在动画帧数（顺畅程度）和回流次数中进行平衡； 9、为动画元素新建图层，提高动画元素的z-index； 10、利用文档碎片(documentFragment)——vue使用了该种方式提升性能 如果我们要在一个ul中添加10000个li，如果不使用文档碎片，那么我们就需要使用append进行10000次的追加，这会导致页面不停地回流，非常地消耗资源： 1234567var oUl = document.createElement(&quot;ul&quot;); for(var i=0;i&lt;10000;i++)&#123; var oLi = document.createElement(&quot;li&quot;); oUl.appendChild(oLi); &#125; document.body.appendChild(oUl); 我们可以引入createDocumentFragment()方法，它的作用是创建一个文档碎片。先将要插入10000个li添加到文档碎片里，然后再一次性添加到document中。即文档碎片相当于一个临时仓库，这样能够大量减少DOM操作： 12345678910111213141516//先创建文档碎片var oFragment = document.createDocumentFragment(); //再创建ul标签var oUl = document.createElement(&quot;ul&quot;); for(var i=0;i&lt;10000;i++)&#123; //创建li标签 var oLi = document.createElement(&quot;li&quot;); //先附加在文档碎片中 oFragment.appendChild(oLi); &#125;//将文档碎片添加到ul标签中 oUl.appendChild(oFragment);//将ul标签添加到body标签中document.body.appendChild(oUl); 11、如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。 12、采用虚拟DOM； 13、使用requestAnimationFrame制作动画：详细内容如下。 8.请求动画帧（requestAnimationFrame）window.requestAnimationFrame() ：该方法会告诉浏览器在重绘之前调用指定的函数： 参数：该方法以一个回调函数作为参数，这个回调函数会在浏览器重绘之前被调用； 回调函数会被自动传入一个参数：DOMHighResTimeStamp，标识requestAnimationFrame()开始触发回调函数的当前时间； 返回值： 一个非零的整数，也称为请求ID，是回调列表中唯一的标识，没有其他意义； window.cancelAnimationFrame(requestID)：该方法取消一个先前通过调用window.requestAnimationFrame()方法添加到计划中的动画帧请求。requestID是先前调用window.requestAnimationFrame()方法时返回的ID。 用途 当无法使用CSS3制作动画的情况下，使用这种方法替代定时器制作动画； 由于重绘就调用的机制，制作的动画频率与浏览器的刷新频率一致，不会出现闪动，保证了动画的流畅； 示例 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box&#123; height: 200px; width: 200px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; let i = 0 //获取请求ID let id = requestAnimationFrame(move) function move()&#123; i++ document.getElementById(&#x27;box&#x27;).style.transform = `translateX($&#123;i&#125;px)` //递归调用requestAnimationFrame,更新请求ID,实现动画效果 id = requestAnimationFrame(move) &#125; setTimeout(() =&gt; &#123; //2s后停止动画 cancelAnimationFrame(id) &#125;, 2000); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、函数防抖与节流1.函数防抖 概念：不断触发一个函数，在规定时间内只让最后一次生效，前面都不生效； 实现：定时器； 应用：搜索时等用户完整输入内容后再发送查询请求； 代码实现 1234567891011function debounce(fn,delay)&#123; var timer = null // 清除上一次延时器 return function()&#123; clearTimeout(timer) // 重新设置一个新的延时器 timer = setTimeout(() =&gt; &#123; fn.call(this) &#125;, delay); &#125; &#125; 使用函数防抖可以减少事件触发的次数和频率，在某些情况下可以起到优化的作用。比如：搜索框，对于核心业务非搜索的网站，一般都是等待用户完整输入内容后才发送查询请求，一次来减少服务器的压力。像百度这样的核心业务为搜索的网站，服务器性能足够强大，所以不进行函数防抖处理； 2.函数节流 概念：不断触发一个函数后，执行第一次，只有大于设定的执行周期后才会执行第二次，以此控制函数执行频率； 实现：定时器，标识； 应用：在游戏中，可以设定人物攻击动作的最快频率，无论手速多快也无法超越这一频率； 代码实现 123456789101112131415161718/* 节流函数：fn:要被节流的函数，delay：规定的时间 */functionthrottle(fn, delay)&#123; // 记录上一次函数出发的时间 var lastTime = 0 return function()&#123; // 记录当前函数触发的时间 var nowTime = new Date().getTime() // 当当前时间减去上一次执行时间大于这个指定间隔时间才让他触发这个函数 if(nowTime - lastTime &gt; delay)&#123; // 绑定this指向 fn.call(this) //同步时间 lastTime = nowTime &#125; &#125;&#125; 七、浏览器存储1.Cookie Cookie翻译过来是小甜饼的意思，是网景公司的前雇员 Lou Montulli 在1993年3月发明的； Cookie是纯文本格式，不包含任何可执行的代码信息，伴随着用户请求在 Web 服务器和浏览器之间传递； Cookie本质上属于http的范畴，因为http协议本身是无状态的，服务端是没有办法区分请求来自于哪个客户端，即便是来自于同一个客户端的多次请求，服务端也无法进行区分。所以引入了Cookie去维持客户端的状态（比如每个账号的购物车状态都不一样）。 Cookie的生成方式 客户端生成： 在 JavaScript 中通过 document.cookie 属性，你可以创建、维护和删除 Cookie；设置 document.cookie 属性的值并不会删除存储在页面中的所有 Cookie，它只简单的创建或修改字符串中指定的 Cookie。 服务端生成： Web 服务器通过在HTTP响应头中添加 Set-Cookie字段来创建一个 Cookie，可以在该字段中添加HttpOnly属性禁止JavaScript脚本访问Cookie，以此来避免跨域脚本 (XSS) 攻击。 Cookie的缺陷 安全性：由于Cookie在HTTP中是明文传递的，其中包含的数据都可以被他人访问，出现篡改、盗用等问题； 大小限制：Cookie的大小限制在4KB左右，若要做大量存储显然不是理想的选择； 增加流量：因为Cookie是绑定域名对应的服务器的，所以对同一个域名的每次请求都会在Request Header中带上Cookie。 一方面：增加对服务器的请求时间； 另一方面：导致大部分不需要用到Cookie信息的场合下流量的浪费；这样浏览器对同一域名的每一次请求都会多出4KB流量，对于大型网站来说这是很大的损耗。 因此要慎用Cookie，不要在Cookie中存储重要和敏感的数据。 Cookie性能优化的方法 将存放静态资源的CDN服务器域名与主站的域名独立开来。这样每次请求静态文件的时候就不需要携带Cookie，从而可以节省很多流量。 举例 比如在百度进行登录的时候，请求头里面就会有Set-Cookie字段，其中的BDUSS就是标识用户登录状态的字符串： Set-Cookie中的httponly属性表示的是禁止js脚本访问cookie，这样能够一定程度防范XSS攻击； 在Chrome调试工具的Application选项中查看Cookies信息，可以发现该Cookie已经被网站“种”到Domain：.baidu.com这个域名下了，并且该Cookie也设置了HttpOnly属性： 此后浏览器的每次请求都会在请求头Request Headers中携带这一Cookie信息。刷新页面后可以看到，请求头中携带了Cookie信息BDUSS： 这样服务器就知道这是已经登录的用户了。 但是不是所有的请求都需要携带Cookie信息，比如优酷： 可以看到请求index.css文件时也携带了Cookie，但是这是不必要的，这就会导致流量的浪费。 解决方法就是上面所说的：将CDN域名和主域名独立出来； 百度就是这样解决的： 可以看到请求这个静态资源的url并不是.baidu.com，而是静态资源服务器CDN；并且该请求的请求头中不会携带Cookie信息： 设置和获取Cookie 设置Cookie的方式很简单，key和value值通过等号连接： 1document.cookie = &quot;userName=zhangsan&quot; 打开Application选项查看当前Cookie，可以看到Cookie已被改变： 获取Cookie： 1document.cookie 备注： \\1. 静态资源是不会携带Cookie的； \\2. Cookie一般都是后台种的，很少让前端来直接写； \\3. Cookie分:持久级别、session级别； \\4. Cookie一般用于存放session ID与服务器端进行通信； 2.Web Storage Web Storage分为SessionStorage和LocalStorage专门用于客户端浏览器的本地存储，同时空间比Cookie大很多，一般支持5-10M； 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制； LocalStorageLocalStorage是HTML5设计出来专门用于存储浏览器信息的： 大小为5~10M左右； 仅在客户端中使用，不和服务端进行通信； 接口封装较好，提供了js进行读写等操作的API； 采用浏览器本地缓存方案，可直接使用浏览器本地缓存，提升网页渲染的速度； 举例 比如通过Chrome调试工具的Application选项可以查看淘宝中LocalStorage存储的数据： 这些数据只要不手动清除，即使关闭页面也都会存在。当需要使用图片、js/css文件等资源时就不用重新向服务器发出请求，而是可以直接使用LocalStorage中的缓存，这就是LocalStorage缓存的优势； 而Cookie就不一样了，里面存储的数据都是要带到服务器端的，例如用户登录状态，统计信息等数据： 设置和获取LocalStorage LocalStorage提供了相对简单的API，采用的也是key和value的形式。 设置时通过： 1localStorage.setItem(&quot;key&quot;, &quot;value&quot;) 查看LocalStorage，同样设置成功了： 获取时通过： 1localStorage.getItem(&quot;key&quot;) 其他方法 12345//该方法接受一个键名作为参数，并把该键名从存储中删除。localStorage.removeItem(&#x27;key&#x27;); //调用该方法会清空存储中的所有键名localStorage.clear(); SessionStorageSessionStorage用于存储浏览器的会话信息，标签页关闭之后它存储的数据就会被清空，而LocalStorage的数据不会被清空，这是二者的区别： 大小为5~10M左右； 仅在客户端使用，不和服务端进行通信； 接口封装较好； 可对表单信息进行维护；比如添加表单过程中进行了刷新，可以将刷新前填写的信息写入SessionStorage中，这样即使刷新后数据也不会丢失；还有一种场景：分页的表单在进行前进或后退时，如果将信息保存在SessionStorage中就不会丢失； 设置和获取SessionStorage 设置SessionStorage的方法与设置LocalStorage的方法类似： 12345//设置sessionStorage.setItem(&quot;key&quot;, &quot;value&quot;)//获取sessionStorage.getItem(&quot;key&quot;) 通过Application选项查看SessionStorage，可见已成功修改： 其他方法 12345//该方法接受一个键名作为参数，并把该键名从存储中删除。sessionStorage.removeItem(&#x27;key&#x27;); //调用该方法会清空存储中的所有键名sessionStorage.clear(); 3.IndexedDBIndexedDB是浏览器提供的一种API，用于存储客户端中大量的结构化数据。该API使用索引来实现对数据的高性能搜索。虽然WebStorage对于存储较少量的数据时很有用（采用key/value的方式），但对于存储更大量的结构化数据来说，还是IndexedDB表现更加优异。 IndexedDB的应用 为应用创建离线版本； 可以在浏览器中打印indexedDB对象： 4.PWAPWA（Progressive Web Apps）是一种Web App新模型（标准），并不是具体指某一种前沿的技术或者某一个单一的知识点。从英文缩写就能看出，这是一个渐进式的Web App，是通过一系列新的Web特性，配合优秀的UI交互设计，逐步增强用户的体验； PWA的要求 可靠：在没有网络的环境中也能提供基本的页面访问，而不会出现”未连接到互联网”的情况； 快速：针对网页渲染及网络数据访问有较好优化； 融入（Engaging）：应用可以被增加到手机桌面，并且和普通应用一样有全屏、推送等特性； 5.Service WorkerService Worker是一个脚本，可以使浏览器独立于当前网页，在后台运行。为实现一些不依赖页面或者用户交互的特性打开了一扇大门。在未来这些特性将包括推送信息，背景后台同步，geofencing（地理围栏定位）等它将推出的第一个首要特性，就是拦截和处理网络请求的能力，包括以编程方式来管理被缓存的响应。 即Service Worker可以帮助浏览器执行大规模的运算而不阻碍主线程的执行。 Service Worker的应用 使用拦截和处理网络请求的能力，实现一个离线应用； 使用Service Worker在后台运行的同时能和页面通信的能力，去实现大规模后台数据的处理； Service Worker应用过程 示例 通过Chrome调试工具的Application选项可以查看淘宝的Service Workers信息： 当我们刷新淘宝网页的时候，查看Network选项，可以从请求文件的size栏发现大量的文件都是从Service Worker缓存中请求回来的： 这样的话就可以利用Service Worker的缓存进行网站的性能优化。 以下列淘宝请求同一js文件为例，从Service Worker中加载使用了7ms： 使用Ctrl + F5强制刷新后，向服务器请求同一文件花了100ms： 这就是使用Service Worker性能上带来的优势。由于是从本地缓存中读取的资源，所以资源读取的速度和整体的性能都会有一个明显的提升。 八、HTTP通用缓存策略1.缓存的简介 缓存定义： 浏览器在本地磁盘上将用户之前请求的数据存储起来，当访问者再次需要改数据的时候无需再次发送请求，直接从浏览器本地获取数据 缓存的好处： 减少请求的个数； 节省带宽，避免浪费不必要的网络资源； 减轻服务器压力； 提高浏览器网页的加载速度，提高用户体验； 2.缓存相关的header字段可以通过Chrome浏览器调试工具中的Network选项查看浏览器请求资源的情况： 注意不要勾选图中方框内的选项，否则有些请求会被过滤； Cache-Control字段服务器可通过httpheader中的Cache-Control字段控制客户端与服务器端之间的缓存策略，它的属性值有： max-age该字段指定了缓存的最大有效时间，以下为淘宝的一张图片： 在max-age属性指定的时间未到期前，客户端不会向服务器发起请求，而是从缓存中直接读取该图片。上图中可以看到浏览器直接从ServiceWorker的缓存中读取了该图片资源。 Expires字段同样可以指定缓存的有效期，不过这是HTTP1.0中的字段，优先级比HTTP1.1中的Cache-Control字段的max-age属性低； s-maxage缓存设备总体来说有两种：浏览器（客户端）和CDN服务器； 其中浏览器属于private类型缓存设备，表示只有浏览器才可以对资源进行缓存； CDN服务器属于public类型缓存设备，这种设备可以对源服务器上的资源进行缓存。并且，这种缓存对于任何用户来说都是可以访问的； s-maxage的优先级在Expires和max-age三者之中是最高的，用于指定public类型缓存设备（比如CDN）上资源的有效期。如下图所示，该资源设定了该字段后，浏览器既不会使用浏览器缓存，也不会向服务器请求资源，而是向public类型的缓存设备（如CDN服务器）请求资源： private服务器端可以通过该属性指定某一资源只能被浏览器（客户端）缓存，而不能被代理缓存服务器（CDN）缓存。 public服务器端可以通过该属性指定某一资源，既可以被浏览器缓存，也可以被代理缓存服务器缓存； no-cacheno-cache属性规定了浏览器要先向服务器端发送请求确认缓存资源的新鲜度，才能决定是否使用缓存；如下图所示： no-store该属性指定了浏览器无论缓存资源是否过期直接跳过缓存，重新向服务器请求资源。no-store属性用的比较少。 Expires字段这是http1.0的规范；它的值为一个绝对时间的GMT(格林威治标准时间)格式时间字符串，如Mon, 10 Jun 2015 21:31:12 GMT； 该字段指定了浏览器缓存资源的过期时间，在指定的时间到期前，浏览器可以直接从本地缓存中读取数据，而无需再次向服务器发起请求，属于强缓存；相比于max-age与s-maxage优先级最低，在这两个属性存在的情况下Expires字段会失效； 标识资源变化的字段Last-Modified/If-Modified-Since二者是基于客户端和服务端协商的缓存机制，标识资源最后更新时间的字段。last-modified字段位于response header中，If-Modified-Since字段位于request header中，二者配合着Cache-Control字段使用。 当服务器上的资源发生改变时会同步更新last-modified的字段值，当Expires字段或max-age属性指定的时间到期后，客户端会在请求头中携带If-Modified-Since字段，与服务器端资源的last-modified字段值进行比较： 情况一：如果二者相等说明资源自last-modified字段指定的时间以后都没有发生变化，此时服务器返回状态码304，属于协商缓存； 情况二：如果二者不相等说明资源发生了更新，服务器返回最新的资源和最新的last-modified字段值，此时的状态码为200； 举例 下图表示状态码为304的响应： 请求头中If-Modified-Since字段的值为Mon, 23 Mar 2020 18:14:15 GMT： 响应头中Last-Modified字段的值为Mon, 23 Mar 2020 18:14:15 GMT： 二者相等，说明资源没有发生变化，所以服务器返回状态码304，属于协商缓存，浏览器继续使用本地缓存； If-Modified-Since字段的值就是服务器端上一次响应资源中的Last-Modified字段值； Last-Modified的缺点 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET； 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断（比如淘宝每ms都会更新数据）； 某些服务器端不能获取精确的修改时间； 所以有了 Etag/If-None-MatchEtag字段是HTTP1.1中的标准，是一个唯一标识服务器端资源的hash值，该字段存在于响应头（reponse header）中；与请求头（request header）中的If-None-Match字段及Cache-Control字段配合使用。 只要服务器端的资源发生变化Etag值就会改变，相比于Last-Modified字段优先级更高且更有效；当Expires值或者Cache-Control字段中的max-age值到期时，客户端会在请求头中携带If-None-Match字段，该字段值为服务器端上一次响应资源中的Etag值，并与服务器端上最新资源的Etag值进行比较： 情况一：如果两个字段值相等，说明资源未发生改变，服务器端拒绝响应，返回状态码304，属于协商缓存； 情况二：如果两个字段值不相等说明服务器端上的资源发生了改变，服务器在响应中返回最新的资源和Etag值，此时状态码为200； 举例 下图表示状态码为304的响应： 请求头中If-None-Match字段值为2da25d4039...： 响应头中Etag字段值为2da25d4039...： 二者相等，说明资源没有发生变化，所以服务器返回状态码304，属于协商缓存，浏览器继续使用本地缓存； 总结： 利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符； Last-Modified与ETag是可以一起使用的，由于Etag的优先度更高，所以服务器会优先比较Etag和If-None-Match。一致的情况下，才会继续比对Last-Modified和If-Modified-Since，最后才决定是否返回状态码304。 3.缓存策略缓存分类 强缓存： 不会向服务器发送请求，直接从本地缓存中获取数； 请求资源的的状态码为: 200 ok(from memory cache)； 协商缓存： 向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存； 如果命中，则返回状态码304通知浏览器从缓存中读取资源； 强缓存与协商缓存的区别 分级缓存策略 最下层的200状态 这一层由Expires/Cache-Control字段控制： 当两者都存在时，Cache-Control会覆盖Expires，只要这些字段没有失效，浏览器都会直接使用本地缓存，属于强缓存； 1.Expires（HTTP1.0版本有效）是绝对时间； 2.Cache-Control（HTTP1.1版本有效）是相对时间； 缓存的来源大概有两种memory cache和disk cache： 可以看到，从memory cache中读取缓存不需要时间，从disk cache中读取缓存则需要一定时间。 相对时间与绝对时间与服务器的设置有关，当服务器设置Atime（最后访问时间）时，二者相等；当服务器设置Mtime（绝对修改时间）时，Expires从资源的创建开始计算过期时间，Max-age从请求发起的时间开始计算过期时间； 下图便是淘宝中采用强缓存的例子，状态码为200，图片资源都是从浏览器缓存memory cache中读取，所以请求时间为0ms： 中间的304状态 这一层由last-modified/Etag控制。当下一层失效时或用户点击refresh/F5时，浏览器就会向服务器发起请求，如果服务器上的相关资源没有更新，则返回状态码304，属于协商缓存； 下图便为协商缓存的情况，状态码为304。也可以这样理解：只要状态码是304都属于协商缓存： 最上层的200状态 当浏览器本身没有缓存或者下一层失效时，或者用户点击了Ctrl + F5强制刷新时，浏览器会直接向服务器请求最新的资源； 如下图所示： 用户行为对缓存的影响 缓存策略过程分析如图所示，该流程图表示服务器端在处理资源时采用缓存策略的过程： 首先服务器判断资源是否可以复用，不可复用则在Cache-Control字段中添加no-store属性； 可以复用的情况下，判断资源是否要求强一致？若是，则在Cache-Control字段中添加no-cache属性，这样不管缓存资源是否过期，都要求客户端或缓存代理服务器首先向服务器确认资源的新鲜度，属于协商缓存； 随后服务器指定是否允许Web代理缓存资源（比如CDN服务器缓存），如果允许则在Cache-Control字段中添加public属性，并指定代理缓存服务器上资源的有效期s-maxage；不允许则添加private属性，表示只能由客户端浏览器缓存资源，并设定缓存的有效期max-age； 随后，根据情况在客户端浏览器中，选择强缓存或者协商缓存； 九、服务端性能优化1.CDN服务器定义网站通常将其所有的服务器都放在同一个地方，当用户群增加时，公司就必须在多个地理位置不同的服务器上部署内容。为了缩短http请求的时间，我们应该把大量的静态资源放置的离用户近一点。 内容发布网络CDN（Content Delivery Networks）就是其中一种方式。CDN是一组分布在多个不同地理位置或网段的web服务器，用于更加有效的向用户发布内容。 基本思路 尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定； 通过在网络各处放置节点服务器，在现有的互联网基础之上构成一层智能虚拟网络； CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。 基础架构最简单的CDN网络由一个DNS服务器和几台缓存服务器组成： 1、当用户点击网站页面上内容的URL时，经过本地DNS系统解析，DNS系统最终会将域名的解析权交给CNAME指向的CDN专用的DNS服务器； 关于DNS解析，不一定由DNS服务器响应，一般从缓存中读取。比如电脑缓存、浏览器缓存、路由器缓存、运行商缓存等。如果缓存中没有找到，才一级一级地查询：本地DNS-&gt; 权限DNS -&gt; 顶级DNS -&gt; 根DNS。全球只有13台根DNS服务器。 2、CDN的DNS服务器将CDN的全局负载均衡设备的IP地址返回给用户； 3、用户向CDN的全局负载均衡设备发起内容URL访问请求； 4、CDN全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求； 5、区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括： 基于以上这些条件的综合分析之后，CDN区域负载均衡设备会向CDN全局负载均衡设备返回一台CDN缓存服务器的IP地址。 根据用户IP地址，判断哪一台服务器距用户最近； 根据用户所请求的URL中携带的内容名称，判断哪一台服务器上有用户所需内容； 查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力； 6、CDN全局负载均衡设备把服务器的IP地址返回给用户； 7、用户向CDN缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端；如果这台CDN缓存服务器上并没有用户想要的内容，但是区域均衡设备依然将它分配给了用户，那么这台CDN服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地； 应用场景 网站站点/应用加速： 站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，使用CDN服务器存储，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。 移动应用加速： 移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。 视音频点播/大文件下载分发加速； 视频直播加速； 总结简单点说CDN服务器相当于顺丰快递分布于全国各地的仓库，主仓库将快递运送到这些分仓库，用户可以就近取货，由此加快了速度。 除此之外CDN服务器还有许多高级功能，比如防止DDOS攻击等，这里就不展开了； 2.SSR(Server Side Rendering)依赖现代框架如Vue和React构建的网站，往往会存在一定的问题，比如Vue框架。 Vue渲染面临的问题 首屏渲染时，要先下载和解析app.js（打包过后的Vue.js）之后，才能开始渲染页面。 优化方案 构建层模板编译：将模板编译的任务放在了构建层中完成，而不是浏览器； 数据无关的Prerender的方式； 服务端渲染：即将浏览器端进行的运算的一部分转移到服务器端上； 通常采用服务端渲染（SSR）的方式进行优化。所谓SSR就是利用服务器端优秀的计算能力，将一部分的页面渲染任务交由服务器端进行处理。以下为服务端渲染SSR的流程图： 服务端渲染可以很好地优化首屏渲染的问题；可以根据业务需求，适当地分配客户端和服务器端的渲染部分，综合利用客户端和服务器端的计算能力，从而达到性能优化的目的。 本文作者：AhuntSun 本文链接：https://www.cnblogs.com/AhuntSun-blog/p/12641050.html","updated":"2020-12-11T03:05:09.000Z","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://lxx1997.github.io/categories/frontEnd/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxx1997.github.io/tags/html/"}]},{"title":"深拷贝、浅拷贝","path":"2020/12/09/web/deep-copy-light-copy/","text":"前言 简单值（基本类型值）总是通过值复制的方式来赋值/传递 null,undefined,symbol,string,number,boolean 复杂值（对象和函数）总是通过引用复制的方式来赋值/传递 object, array, function 由于引用指向的值本身而非变量，因此一个引用无法更改另一个引用的指向 不能通过引用一个新的引用来更改旧的引用的指向，只能修改新旧引用共同指向的值 如果通过值复制的方式来传递复合值，就需要创建一个复本，这样传递的就不是原始值foo(a.slice())，foo中的操作不会影响到a指向的数组 因此会发现复杂值的赋值的时候，例如 a = obj，当我们改变a中某个属性的值时，这是obj里面对应属性的值也发生了变化，这种就是浅拷贝 如果a的属性的值发生改变，obj对应属性的值不发生变化，这种就是深拷贝 浅拷贝 浅拷贝拷贝的是引用地址，实现方式有以下几种 Object.assign(target, obj1, obj2...)将第二个参数及以后的参数合并到第一个对象里 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 for...in...遍历每一个属性，将他们复制给新的对象，对象必须是多层的状态下才能实现浅拷贝 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 $.extend(boolean?, &#123;&#125;, obj1, obj2...) jquery的对象扩展方法,boolean如果为true是深拷贝，不填就是浅拷贝，将第三个参数及以后的参数合并到第二个对象里 – 前提传入的参数都是多层嵌套，单层的话是深拷贝 es6新方法 扩展运算符 ... – 前提传入的参数都是多层嵌套，单层的话是深拷贝 Array.prototype.concat(),Array.prototype.slice()slice和concat方法不会修改原数组，只会返回一个浅复制了原数组中的一个新数组 对象会发生变化，String,Number,boolean不会发生变化 深拷贝深拷贝拷贝的是对象的数据而不是地址 JSON.stringify(),JSON.parse(), 但是使用 这种方法进行深拷贝会有一些几个问题 这个方法对于对象中包含函数不使用，因为不会拷贝函数 如果属性的值为 undefined，会在深拷贝的过程被删除 RegExp，Error 对象会失去原本属性变成 &#123;&#125; Sympbol 不能被序列化 会丢失对象原型 存在循环引用的时候，无法正确实现深拷贝 es6新方法 扩展运算符 ... – 前提传入的参数都是多层嵌套，单层的话是深拷贝 loadsh 手动进行递归赋值","updated":"2020-12-09T02:58:38.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"Symbol详解","path":"2020/12/04/web/Symbol详解/","text":"定义Symbol 12var sym = Symbol()var sym1 = Symbol(&#x27;foo&#x27;) Symbol(&#39;foo&#39;)并不会强制将字符串foo转化成symbol类型，他每次都会创建一个新的symbol类型 因此Symbol(&#39;foo&#39;) !== Symbol(&#39;foo&#39;) 如果想要创建一个Symbol包装器对象，可以使用Object()函数 1234var sym = Symbol(&#x27;foo&#x27;)typeof sym // &#x27;symbolvar symObj = Object(sym)typeof symObj // &#x27;object&#x27; 全局共享的Symbol 可以使用Symbol.for()或Symbol.keyFor()方法从全局的symbol注册表设置和取得symbol 在对象中查找symbol属性 Object.getOwnPropertySymbols()查找一个给定对象的符号属性时返回一个symbol类型的数组，数组可能为空 属性 Symbol.iterator 为每一个对象定义了默认的迭代器，可以被for...of循环使用 12345678910111213141516171819202122232425当需要对一个对象进行迭代时，它的`@@iterator`方法都会在不传参情况下被调用，返回的迭代器用于获取要迭代的值一些内置类型拥有默认的迭代器行为* `Array.prtotype[@@iterator]()`* `TypedArray.prtotype[@@iterator]()`* `String.prtotype[@@iterator]()`* `Map.prtotype[@@iterator]()`* `Set.prtotype[@@iterator]()`**自定义迭代器**~~~js var myIterable = &#123;&#125; myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3; &#125; [...myIterable] // [1,2,3] for (var x of myIterable) &#123; console.log(x) / 1 -&gt; 2 -&gt; 3 &#125;~~~如果一个迭代器没有返回一个迭代器对象，那么他是一个不合格的迭代器，在运行时将会抛出异常 Symbol.asyncIterator 是一个用于访问对象的@@asyncIteratir方法的内建符号，一个异步可迭代对象必须要有Symbol.asyncIterator 12345678910111213141516const myAsyncIterable = new Object();myAsyncIterable[Symbol.asyncIterator] = async function*() &#123; yield &quot;hello&quot;; yield &quot;async&quot;; yield &quot;iteration!&quot;;&#125;;(async () =&gt; &#123; for await (const x of myAsyncIterable) &#123; console.log(x); // expected output: // &quot;hello&quot; // &quot;async&quot; // &quot;iteration!&quot; &#125;&#125;)(); Symbol.match指定了匹配的是正则表达式而不是字符串，String.prototype.match()方法会调用此函数 1234const regexp = /foo/regexp[Symbol.match] = falseconsole.log(&#x27;foo&#x27;.startWith(regexp)) // trueconsole.log(&#x27;baz&#x27;.startWith(regexp)) // false Symbol.replace这个属性指定了当一个字符串替换所匹配字符串时调用的方法，String.prototype.replace()会调用此方法 123456789class Replace &#123; constructor(value) &#123; this.value = value &#125; [Symbol.replace](string) &#123; return `s/$&#123;string&#125;/$&#123;this.value&#125;/g` &#125;&#125;console.log(&#x27;foo&#x27;.replace(new Replace(&#x27;bar&#x27;))) // s/foo/bar/g Symbol.search指定了一个搜索方法，这个方法接受用户输入的正则表达式，返回改正则表达式在字符串中匹配到的下标 String.prototype.search()会调用此方法 123456789class caseInsensitiveSearch &#123; constructor(value) &#123; this.value = value.toLowerCase() &#125; [Symbol.search](string) &#123; return string.toLowerCase().indexOf(this.value) &#125;&#125;console.log(&#x27;foobar&#x27;.search(new caseInsensitiveSearch(&#x27;BaR&#x27;))); // 3 Symbol.split指向一个正则表达式的索引处分割字符串的方法，这个方法通过String.prototype.split()调用 123456789/a/[Symbol.split](&#x27;aba&#x27;, 3)var exp = &#123; pat: &#x27;in&#x27; [Symbol.split](str) &#123; return str.split(this.pat) &#125;&#125;&#x27;dayinlove&#x27;.split(exp) Symbol.hasInstance 可以判断某对象是否为某构造器的实例，应此你们可以用它自定义instanceof操作符在某个类上的行为 1234567class Array1 &#123; static [Symbol.hasInstance](instance) &#123; return Array.isArray(instance) &#125;&#125;console.log([] instanceof Array1) // true Symbol.isConcatSpreadable符号用于配置某对象作为Array.prototype.concat()方法的参数时是否展开数据元素 1234567const a = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]const b = [1, 2, 3]let ab = a.concat(b) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 1, 2, 3]b[Symbol.isConcatSpreadable] = falseab = a.concat(b) // [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, Array[1, 2, 3]] Symbol.toStringTag作为对象的属性键使用，对用的属性值应该为字符串类型，内置的Object.prototype.toString()方法会读取这个标签并把它包含在自己的返回值里面 加上toStringTag属性，你的类也可以自定义类型标签 123456class myClass &#123; get [Symbol.toStringTag]() &#123; return &#x27;myClass&#x27; &#125;&#125;console.log(Object.prototype.toString.call(new myClass())) // &#x27;[object myClass]&#x27; Symbol.for()方法会根据给定的键key，来从运行时的symbol注册表中找到对应的symbol，如果找到了就返回，没有找到就新建一个symbol并加入到全局symbol的注册表中 12345678Symbol.for(&#x27;foo&#x27;) // 全局注册 fooSymbol.for(&#x27;foo&#x27;) // 返回上一个全局注册的fooSymbol.for(&#x27;foo&#x27;) === Symbol.for(&#x27;foo&#x27;) // trueSymbol(&#x27;foo&#x27;) === Symbol(&#x27;foo&#x27;) // falsevar sym = Symbol.for(&#x27;mario&#x27;)sym.toSstring() // &#x27;Symbol(mario)&#x27; Symbol.keyFor() 用来获取全局symbol注册表中与某个symbol关联的键 123456789// 创建一个全局 Symbol var globalSym = Symbol.for(&quot;foo&quot;); Symbol.keyFor(globalSym); // &quot;foo&quot;var localSym = Symbol(); Symbol.keyFor(localSym); // undefined，// 以下Symbol不是保存在全局Symbol注册表中Symbol.keyFor(Symbol.iterator) // undefined","updated":"2020-12-04T07:23:00.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"Symbol","slug":"Symbol","permalink":"https://lxx1997.github.io/tags/Symbol/"},{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"}]},{"title":"你不知道的javascript中卷 知识点摘录","path":"2020/12/03/reading/你不知道的javascript中卷/","text":"第一章 类型和语法 内置类型 空值 null typeof null === &#39;object&#39; 未定义 undefined typeof undefined === &#39;undefined&#39; 布尔值 boolean typeof true === &#39;boolean&#39; 数字 number typeof 42 === &#39;number&#39; 字符串 string typeof &#39;42&#39; === &#39;string&#39; 对象 object typeof &#123;life: 42&#125; === &#39;object&#39; 符号 symbol typeof Symbol() === &#39;symbol&#39; typeof function() &#123;/* .. */&#125; === &#39;function&#39; typeof [1,2,3] === &#39;object&#39; 数组是object的一个子类型 对变量执行typeof操作时，得到的结果并不是该变量的类型，而是该变量持有的值的类型，因为javascript中的变量没有类型 undefined 和 undeclared 已在作用域中声明但还没有赋值的变量是undefined，还没有在作用域声明过的变量是undeclared 数组 delete运算符可以将单元从数组中删除，但是数据的length属性并不会发生变化 如果字符串键值能够被强制类型转换为十进制数字的话，他就会被当做数字索引来处理 123var a = []a[&#x27;13&#x27;] = 43a.length // 14 类数组 - 有时候需要将类数组转换为真正的数组 通过for循环遍历类数组，将类数组的每一个元素复制到新的数组里 slice 返回的是类数组的一个数组复本Array.prototype.slice.call(arguments) concatArray.prototype.concat.apply([], arguments) spliceArray.prototype.splice.call(arguments, 0) Array.form() 字符串 字符串和数据的确很相似，都是类数组，都有length属性，以及indexOf和concat方法，但是字符串是不可变的，数组是可变的 字符串可以借用数组的非变更方法来处理字符串Array.prototype.join.call(a, &#39;-),Array.prototype.map.call(a, function() &#123;/* .. */&#125;) 字符串反转 可以先将字符串转成数组反转后再转成字符串string.split(&#39;&#39;).reverse().join(&#39;&#39;) 包含复杂的字符，可以使用工具库 数字 数字常亮一般用十进制表示，数字前面的0可以省略，小数部分最后面的0也可以省略 指数模式 5E10 === 50000000000 === 50000000000.toExponential() //5e+10 .toFixed() 指定小数部分的显示位数 输出结果实际上是给定数字的字符串形式，如果指定的小数部分显示位数多余实际位数就用0补齐 .toPrecision() 用来指定有效位数的显示位数 对于.运算符，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符1234542.toFixed(3) // SyntaxError(42).toFixed(3) // &#x27;42.000&#x27;0.42.toFixed(3) // &#x27;0.420&#x27;42..toFixed(3) // &#x27;42.000&#x27;42 .toFixed(3) // &#x27;42.000&#x27; 数字常量的格式123450xf3 // 243的16进制0363 // 243的八进制// es60o363 // 243的八进制0b11110011 // 243的二进制 极小数运算 为了保证精准，可以设置一个误差范围值（机械精度）Number.EPSILON1234567891011// 如果没有Number.EPSILON，自己定义Number.EPSILON，如果有直接拿来使用if(!Number.EPSILON) &#123; Number.EPSILON = Math.pow(2, -52)&#125;function numbersCloseEnoughToEqual(n1, n2) &#123; return Math.abs(n1 - n2) &lt; Number.EPSILON&#125;var a = 0.1 + 0.2var b = 0.3numbersCloseEnoughToEqual(a, b) // true Number.MAX_VALUE 为 Math.pow(2, 53) - 1 即 2^53-1 在es6中被定义为Number.MAX_SAFE_INTEGER 最小整数是 -Math.pow(2, 53) + 1 在es6中被定义为Number.MIN_SAFE_INTEGER 整数检测 Number.isInteger(..) 检查一个值是否是安全的整数 Number.isSafeInteger(..) a | 0可以将变量a中的数值转化为32位有符号整数，因为数位运算符|只适用32位整数，因此与0进行操作即可截取a中的32位数位 特殊数值 不是值的值undefined类型只有一个值 undefined, null类型也只有一个值，即nullnull指空值，不能作为标识符，不能将其作为变量来使用和赋值, undefined指没有值，是一个标识符，可以被当做变量使用和赋值 undefined是一个内置标识符，他的值为undefined，通过void运算符即可得到该值 12var a = 42console.log(void a, a) // undefined 42 特殊的数字 NaN 它与自身不相等，需要用isNaN or Number.isNaN方法来判断是否是NaN 无穷数 可以从有穷到无穷，但是无法从无穷到有穷 ±Infinity 零值 加法和减法无法的到0值 JSON.stringify(-0) =&gt; &#39;0&#39; JSON.parse(&#39;-0&#39;) =&gt; &#39;0&#39; 特殊等式 Object.is() 主要用来处理特殊的相等比较 ==和===的效率更高，更为通用 值和引用 简单值（基本类型值）总是通过值复制的方式来赋值/传递 null,undefined,symbol,string,number,boolean 复杂值（对象和函数）总是通过引用复制的方式来赋值/传递 object, array, function由于引用指向的值本身而非变量，因此一个引用无法更改另一个引用的指向不能通过引用一个新的引用来更改旧的引用的指向，只能修改新旧引用共同指向的值如果通过值复制的方式来传递复合值，就需要创建一个复本，这样传递的就不是原始值foo(a.slice())，foo中的操作不会影响到a指向的数组 原生函数 String() Number() Boolean() 通过Boolean创建的真值并不是真正意义的真值 ，它总是true Array() Object() Function() RegExp() Date() Error() Symbol() 原生函数可以被当做构造函数来使用 1234var a = new String(&#x27;hello world&#x27;)typeof a // objecta instanceof String // trueObject.prototype.toString.call(a) // &#x27;[object String]&#x27; 内部属性[[Class]]typeof 返回值为object的对象都包含有一个内部属性[[Class]],这个属性无法直接访问，可以通过Object.prototype.toString.call(..)来查看 Null的内部属性为[object Null] Undefined的内部属性为[object Undefined] 封装对象包装如果想要自行封装基本类型值，可以使用Object(..)函数，一般不推介使用封装对象部分封装对象封装基本类型时获取到的值并非我们想要的值(Boolean) 拆封想要得到封装对象中的基本类型值，可以使用valueOf()函数在使用的时候回发生隐式拆分 原生函数 Array(..)Array构造函数只带一个数字参数时，会被作为数组的预设长度 对于一个有长度的空数组，无法使用map(..)但是可以使用join(..),因为join(..)首先嘉定数组不为空，然后通过length属性来遍历其中的元素 1234Array.apply( null, &#123; length: 3 &#125; ) // 等价于Array(undefined, undefined, undefined)// apply的第二个参数可以是数组或者类数组 永远不要创建和使用空单元数组 Object(..)、Function(..)、RegExp(..) 同理，尽量不要使用动态定义正则表达式可以使用new RegExp(pattern, flags)来定义 Date(..) 和 Error(..)创建日期对象使用new Date(), Date(..)可以带参数，用来指定日期和时间Date.now()自动获取当前时间戳 Error(..)主要是为了获得当前运行栈的上下文，与throw一起使用 Symbol(..)符号具有唯一性的特殊值符号可以用作属性名，但无论是在代码还是开发控制台中都无法查看和访问它的值，只会 显示为诸如 Symbol(Symbol.create) 这样的值 原生原型 原生函数都有自己的prototype对象，包含其对应子类型所特有的行为特征所有的函数都可以调用Function.prototype的apply(..), call(..), bind(..) Function.prototype 是一个函数 RegExp.prototype 是一个正则表达式 Array.prototype 是一个数组 强制类型转换 值类型转换 - 类型转换发生在静态类型语言的编译阶段，强制类型转换发生在动态类型语言的运行时(runtime)，又可以区分为”隐式强制类型转换”和”显示强制类型转换” 抽象值操作 toString() - 负责处理非字符串到字符串的强制类型转换 JSON.stringify() undefined,function, symbol,循环引用的对象都不能用JSON.stringify进行处理，会被自动忽略，在数组中则会返回null如果需要对含有非法JSON值的对象作字符串化，或者对象中的某些值无法被序列化时，需要定义toJSON()方法返回一个安全的JSON值 toJSON返回的是一个能够被字符串化的安全的JSON值，然后再由JSON.stringify对其进行字符串化 我们可以向JSON.stringify()传递一个可选参数replacer, 可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些被排除 12345678910var a = &#123; b: 42, c: &#x27;42&#x27;. d: [1,2,3]&#125;// replacer为数组的话，必须是一个字符串数组JSON.stringify(a, [&#x27;b&#x27;, &#x27;c&#x27;]) // &quot;&#123;&quot;b&quot;:42,&quot;c&quot;:&quot;42&quot;&#125;&quot; JSON.stringify(a, function(k,v) &#123; if(k!==&quot;c&quot;) return v&#125;) // &quot;&#123;&quot;b&quot;:42,&quot;d&quot;:[1,2,3]&#125;&quot; JSON.stringify 还有一个可选参数space用来指定输出的缩进格式。space 为正整数时是指定 每一级缩进的字符数，它还可以是字符串 12345678var a = &#123; b: 42, c: &quot;42&quot;, d: [1,2,3]&#125;; JSON.stringify( a, null, 3 ); // &quot;&#123; &quot;b&quot;: 42, &quot;c&quot;: &quot;42&quot;, &quot;d&quot;: [ 1, 2, 3 ] &#125;&quot; JSON.stringify( a, null, &quot;-----&quot; ); // &quot;&#123; // -----&quot;b&quot;: 42, // -----&quot;c&quot;: &quot;42&quot;, // -----&quot;d&quot;: [ // ----------1, // ----------2, // ----------3 // -----] // &#125;&quot; toNumber() true转换为1，false转化为0，undefined转化为NaN，null转化为0 在进行转化时，抽象操作ToPrimitive会首先检查该值是否有valueOf方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString的返回值来强制类型转换，如果都不返回基本值，就会报TypeError toBoolean 假值包含 undefined，null，false，+0，-0，NaN, “” 会被转换为false 显示强制类型转换 String(), Number() a.toString() 一元运算符+ 日期显示转化为数字 new Date() or +new Date() new Date().getTime() Date.now() 奇特的~运算符 返回2的补码 ~x ≈ -(x+1)~a.indexOf(b)强制转化为真假值 字位截除 ~~ or x | 0 只适用于32位数字 显示解析数字字符串 Number() 不允许出现非数字字符 parseInt() 允许出现非数字字符 第二个参数表示进制类型 parseFloat() Boolean() !! 隐式强制类型转换 字符串和数字之间的隐式强制类型转换如果 + 的其中一个操作数是字符串，则执行字符串拼接，否则执行数字加法“[]+{} {} + []” =&gt; [object Object] 0第一个表达式{} 被当做空对象来对待 第二个表达式{}被当做代码块来看待隐式转换如果有valueOf方法则是会先调用valueOf方法然后通过ToString抽象操作将返回值转为字符串 String直接调用ToString() 123456var a = &#123; valueOf: function() &#123; return 42&#125;, toString: function() &#123; return 4 &#125;&#125;a + &#x27;&#x27; // &#x27;42&#x27;String(a) // &#x27;4&#x27; 会将字符串转化为数字 布尔值到数字的隐式强制类型转换 隐式强制转换成布尔值 || &amp;&amp; - 选择器运算符， 他们的返回值是两个操作数中的一个然后返回他的值 符号的强制类型转换符号不能被强制类型转换为数字，但可以被强制类型转为布尔值 宽松相等 == 严格相等 === 12345var x = 1 || &#x27;1&#x27;var y = truex == y // truenull == undefined // true 对象和非对象之间的比较，对象会先toString然后才与非对象进行比较 满足a == 2 &amp;&amp; a == 3为true 12345678var i = 2Number.prototype.valueOf = function() &#123; return i++&#125;var a = new Number(42)console.log(a + &#x27;&#x27;) // 2console.log(a + &#x27;&#x27;) // 3 123456789101112131415161718192021222324252627&quot;0&quot; == null; // false &quot;0&quot; == undefined; // false &quot;0&quot; == false; // true -- 晕！ &quot;0&quot; == NaN; // false &quot;0&quot; == 0; // true &quot;0&quot; == &quot;&quot;; // false false == null; // false false == undefined; // false false == NaN; // false false == 0; // true -- 晕！ false == &quot;&quot;; // true -- 晕！ false == []; // true -- 晕！ false == &#123;&#125;; // false &quot;&quot; == null; // false &quot;&quot; == undefined; // false &quot;&quot; == NaN; // false &quot;&quot; == 0; // true -- 晕！ &quot;&quot; == []; // true -- 晕！ &quot;&quot; == &#123;&#125;; // false 0 == null; // false 0 == undefined; // false 0 == NaN; // false 0 == []; // true -- 晕！ 0 == &#123;&#125;; // false 极端的例子 1234567891011121314151617181920212223242526272829 [] == ![] // true 2 == [2] // true &quot;&quot; == [null] // true 0 == &quot;\\n&quot; // true &quot;\\n&quot;等空字符串被toNumber强制转换成0 ~~~ * 抽象关系比较 a &lt; b - a和b的一方一个是数字，另一方将会被转化成数字进行比较 a &lt; b - a和b的一方两个都是字符串，将会按照字母顺序进行比较* **语法** * 语句与表达式 * 语句的结果值 语法不允许我们获取语句的结果值并将其赋值给另一个变量，如果需要可以使用`eval`来获取结果值 或者 `do&#123;..&#125;`代码块 ~~~js var a,b a = eval(&quot;if(true)&#123;b=4+38&#125;&quot;) a // 42 a = do &#123; if(true) &#123; b = 4 + 38 &#125; &#125; a // 42 ++和--++a 先执行加法运算然后返回a++ 先返回然后执行加法运算–a 先执行减法运算然后返回a– 先返回然后执行减法运算 ,逗号运算符将多个独立的表达式语句串联成一个语句 上下文规则 大括号 &#123;&#125; 对象常量123var a = &#123; b: 10&#125; 标签 / 代码块在这里是一个普通的代码块，可以和let块级作用域声明一起使用123&#123; b: foo()&#125; 标签语句 使用break和continue都可以带标签，实现goto那样的跳转continue foo 代表执行foobreak 代表跳出foo函数，从foo结束的位置开始执行 1234567891011foo: &#123; other: &#123; console.log(2) bar: &#123; console.log( &quot;Hello&quot; ); break foo; console.log( &quot;never runs&quot; ); &#125; &#125; console.log( &quot;World&quot; );&#125; 对象解构&#123;...obj&#125; - 赋值 / 命名参数对象解构 else if 和可选代码块 运算符优先级 &amp;&amp; &gt; || 短路 &amp;&amp; 和 ||可以造成逻辑短路 &amp;&amp; 运算符的优先级高于 ||，而 || 的优先级又高于 ? :。 try..finally.. switch() &#123; case &#125; 第二章 异步和性能 异步 异步是关于现在和将来的时间间隙，而并行是关于能够同时发生的事情,并行计算最常见的工具就是进程和线程。进程和线程独立运行，但多个线程能够共享单个进程的内存 事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存的 并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。 并发运行的进程之间可能会存在相互影响，如果进程之间没有影响的话，不确定性是完全可以接受的 交互的程序可以采用协调交互顺序来处理这样的竞态条件，通过给请求固定获取位置，使得交互的两个程序无论请求顺序如何，最后返回的结果顺序是固定的。 竞态 - 只有第一个运行完成的程序起作用 协作 - 取到一个长期运行的“进程”，并将其分割成多个步骤或多批任务，使得其他并发“进程”有机会将自己的运算插入到事件循环队列中交替运行，事件循环队列的交替运行会提高 站点 /App 的响应（性能） 1234567891011121314var res = []function response(data) &#123; var chunk = data.splice(0,1000) res = res.concat( chunk.map(val =&gt; val * 2) ) if(data.length &gt; 0) &#123; // 通过setTimeout 方法将函数放到异步执行队列，不影响现有函数执行 setTimeout(function() &#123; response(data) &#125;, 0) &#125;&#125; 任务 - 类似于排队，严格指定任务队列中函数的先后执行顺序 回调 避免回调地狱 代码会变得非常复杂难以维护及更新 Promise","updated":"2020-12-03T06:41:36.000Z","categories":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/categories/reading/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/tags/reading/"}]},{"title":"typescript - Pick","path":"2020/12/02/web/typescript-pick/","text":"什么是Pick就是从一个符合类型中，取出几个想要的类型的组合 12345678910111213type Pick&lt;T, K extends keyof T&gt; = &#123; [key in k]: T[key]&#125;interface TState &#123; name: string; age: number; like: string[]&#125;// if i just want one or two attribute of TState// we can use Pick to get the attribute we wantinterface TSingleState extends Pick&lt;TState, &#x27;name&#x27; | &#x27;age&#x27;&gt; &#123;&#125; 泛型中的extends 并不是用来继承的，而是用来约束类型的，所以K extends keyof T，应该是说key被约束在T的key中，不能超出这个范围 原文链接","updated":"2020-12-02T02:21:41.000Z","categories":[],"tags":[{"name":"typescrript","slug":"typescrript","permalink":"https://lxx1997.github.io/tags/typescrript/"}]},{"title":"Object的方法","path":"2020/11/26/web/Object的方法/","text":"属性 Object.length 值为1 Object.prototype 可以为所有的Object类型的对象添加属性 方法 Object.assign() 用于将所有可枚举属性的值从一个或多个源对象分配到目标对象，并返回目标对象 此方法只会拷贝源对象自身的并且可枚举的属性到目标对象，该方法调用源对象的get和目标对象的set，如果为了将属性定义复制到原型应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() Object.assign()是浅拷贝,会改变源对象的值 Object.create() 创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ Object.defineProperty() Object.defineProperties() Object.entries() Object.freeze() Object.getOwnPropertyDescriptor() Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.getPrototypeOf() Object.is() Object.isExtensible() Object.isFrozen() Object.isSealed() Object.keys() Object.preventExtensions() Object.seal() Object.setPrototypeOf() Object.values() 属性 Object.prototype.constructor 返回创建实例对象的Object构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 所有的对象都会从他的原型上继承一个constructor属性 Object.prototype.proto 该特性已从Web标准中删除，但是目前一些浏览器仍然支持，但是在未来某个时间停止使用，请尽量不要使用该特性 该属性是一个访问器属性(一个getter函数和setter函数)，暴露了通过它访问的对象的内部prototype(一个对象或null) 推介使用Object.getPrototypeOf/Reflect.getPrototypeOf和Object.setPrototypeOf/Reflect.setPrototypeOf(设置对象的prototype是一个缓慢的过程，会影响性能，应该尽量避免) Object.prototype.noSuchMethod Object.prototype.count 已被废弃 Object.prototype.parent 已被废弃 方法 Object.prototype.defineGetter() Object.prototype.defineGetter() Object.prototype.lookupGetter() Object.prototype.lookupSetter() Object.prototype.hasOwnProperty() Object.prototype.isPprototypeOf() Object.prototype.propertyIsEnumerable() Object.prototype.toSource() Object.prototype.toLocaleString() Object.prototype.toString() Object.prototype.unwatch() Object.prototype.valueOf() Object.prototype.watch() Object.prototype.eval() 已废弃","updated":"2020-11-26T09:54:45.000Z","categories":[],"tags":[]},{"title":"《你不知道的javascript上卷》 知识点摘录","path":"2020/11/24/reading/你不知道的javascript上卷/","text":"第一章 作用域和闭包 编译器查找类型 赋值操作的目标是谁(LHS) 和 谁是赋值操作的源头(RHS) RHS如果在所有嵌套的作用域中遍寻不到所需的变量，引擎就会爆出ReferenceError异常，如果找到了变量，但是要对变量的值进行不合理的操作，引擎就会抛出另一种类型的错误TypeError LHS如何在全局作用域中也无法找到目标变量，就会在全局作用域中创建一个具有该名称的变量，并将其返还给引擎，但是在‘严格模式’下执行的时候并不会创建一个全局变量，而是会和RHS一样抛出ReferenceError eval javascript的eval() 函数可以接受一个字符串作为参数，并将其中的内容视为javascript代码，尽量不要使用eval，会对系统安全造成影响 1eval(&#x27;var b = 3&#x27;) with with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对 象的属性也会被处理为定义在这个作用域中的词法标识符 尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中 12345with(obj) &#123; a = 3; b = 4; c = 5;&#125; 匿名函数 匿名函数没有名称标识符，函数表达式可以是匿名的，而函数声明则不可以省略函数名 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难 如果没有函数名，引用自身时只能使用arguments.callee引用 匿名函数省略了对于代码可读性很重要的函数名 具名函数 有名称标识符 立即执行函数表达式 (function()&#123; &#125;)() try/catch分句会创建一个块级作用域，其中声明的变量仅在catch内部有效 let为其声明的变量隐式地了所在的块作用域。 垃圾收集 利用作用域进行垃圾回收，变量显式声明块作用域 变量及函数在内的所有声明都会在任何代码被执行前首先被处理，定义声明在编译阶段进行，赋值声明在执行阶段进行先有声明后有赋值函数声明会被提升，函数表达式及具名函数不会被提升在变量提升过程中，函数会被首先提升，其次才是变量尽管重复的声明会被忽略掉，但是出现后面的函数声明可以覆盖前面的 模块模式 必须有外部的封闭函数，函数必须至少被调用一次，每一次调用都会创建一个新的模块实例 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有状态 修改模块实例的内容通过在模块实例内部保留对公共API对象的内部引用，可以从内部对模块是咧进行修改，包括添加或删除方法和属性，修改他们的值 现代模块机制 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 封装模块var MyModules = (function Manager() &#123; var modules = &#123;&#125; fucntion define(name, deps, impl) &#123; // 通过for循环将deps里面的参数赋值为modules中的数据 for(var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]] &#125; // 通过apply将deps作为参数传给impl，并改变impl函数this的指向，使其指向impl modules[name] = impl.apply(impl, deps) &#125; function get(name) &#123; return modules[name] &#125; return &#123; define: define, get: get &#125;&#125;)()// 定义模块MyModules.define( &quot;bar&quot;, [], function() &#123; function hello(who) &#123; return &quot;Let me introduce: &quot; + who; &#125; return &#123; hello: hello &#125;;&#125;); MyModules.define(&#x27;foo&#x27;, [&#x27;bar&#x27;], function(bar) &#123; var hungry = &#x27;hippo&#x27; function awesome() &#123; console.log(bar.hello(hangry).toUpperCase()) &#125; return &#123; awesome &#125;&#125;) 通过同一个构造模块函数构造的模块之间可以作为参数使用 作用域 作用域链是基于动态作用域的，而不是代码中的作用域嵌套 123456789function foo() &#123; console.log( a ); // 2 &#125; function bar() &#123; var a = 3; foo();&#125; var a = 2; bar(); 第二章 this和对象原型 this提供了一种更优雅的方式来隐式传递一个对象引用，因此可以将API设计得更加简洁并且易于复用 this是在运行的时候绑定的，并不是在编写的时候绑定的，它的上下文取决于函数调用时用的耕种条件。 当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 其中一个属性，会在函数执行的过程中用到 this 的綁定 默认绑定 - 如果函数直接使用不带有任何修饰的函数引用进行调用，使用默认绑定规则，如果使用了严格模式，全局对象将无法使用默认绑定，因此this会绑定到undefined 隐式绑定 - 如果函数调用位置含有上下文对象，隐式绑定规则会把函数调用中ths绑定到这个上下文对象，对象属性引用链中只有最顶层或者说最后一层会影响调用位置 隐式丢失 - 被隐式绑定的函数会丢失绑定对象，会应用默认绑定，从而把this绑定到全局对象或者undefined上(取决于是否是严格模式) 123456function foo() &#123; console.log( this.a ); &#125; function doFoo(fn) &#123; // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！ &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = &quot;oops, global&quot;; // a 是全局对象的属性 doFoo( obj.foo ); // &quot;oops, global&quot; 显示绑定 - JavaScript的宿主环境会提供一些特殊的函数，如果传入的是一个原始值(Number, String, Boolean)，原始值会被转成它对应的对象形式(new String(..), new Number(..), new Boolean(..))，这种通常认为是装箱 call(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，call的参数是直接放进去的，函数会默认执行一次 apply(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，apply的参数是一个数组，函数会默认执行一次 band(this, argument) 第一个对象用来绑定this，调用函数时指向这个this，band的参数是直接放进去的，函数不会默认执行一次 12345678910111213141516171819202122232425262728293031function test() &#123; console.log(arguments[0], &#x27;b&#x27;) console.log(this.a, &#x27;a&#x27;)&#125;var obj = &#123; a: 10, b: 20&#125;test(13)console.log(&#x27;call&#x27;)test.call(obj, obj.b)console.log(&#x27;apply&#x27;)test.apply(obj, [obj.b])console.log(&#x27;bind&#x27;)var test1 = test.bind(obj, obj.b)test()test1()// console13 bundefined acall20 b10 aapply20 b10 abindundefined bundefined a20 b10 a 显示绑定变种 硬绑定 1234function foo(something) &#123; console.log( this.a, something ); return this.a + something; &#125; var obj = &#123; a:2 &#125;; var bar = function() &#123; return foo.apply( obj, arguments ); &#125;; var b = bar( 3 ); // 2 3 console.log( b ); // 5 ES5 中提供了内置的方法 Function.prototype. bind API调用的上下文 许多第三方库以及javascript内置函数，提供了一个可选参数，统称为上下文，作用和bind(..)，确保回调函数使用指定的this 12345function foo(el) &#123; console.log( el, this.id ); &#125; var obj = &#123; id: &quot;awesome&quot; &#125;; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome new绑定 - 函数在new表达式中被调用时，它是一个构造函数，会初始化新创建的对象，称之为构造函数调用 使用new来调用函数，会自动执行下面操作 创建一个全新的对象 这个新对象会被执行[[原型]]连接 这个新对象会绑定到函数调用的this 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象 this绑定优先级 默认绑定 &lt; 隐式绑定 &lt; 显示绑定 &lt; new绑定 判断this 判断是否在new中调用，绑定的是新创建的对象 是否通过call，apply，bind，绑定的是指定对象 判断是否在某个上下文对象中调用，绑定的是上下文对象 以上全部满足使用默认绑定，绑定到全局对象，严格模式下为undefined 对象 主要类型 - string,number,boolean,null,undefined,object 内置对象 - String,Number,Boolean,Array,Function,Object,Date,RegExp,Error 判断一个对象的类型 typeof 返回值是字符串 instanceof 返回值是boolean Object.prototype.toString.call(obj) 返回值是字符串 &#39;[object Object]&#39; 对象属性访问 - .a语法通常称为属性访问，[a]通常称为键访问，可以接受任意任意字符串作为属性名。 对象中，属性名永远都是字符串，如果使用string以外的其他值作为属性名，首先会被转成字符串 可计算属性名 - 属性键根据构造函数时传入的键值参数变化 属性和方法 - 函数不属于某个对象，只是相同函数对象的多个引用 复制对象 Object.assign(..)方法实现浅复制，它会遍历一个或者多个原对象的可枚举的自有键并将它们复制到目标对象，最后返回目标对象。object.assign使用=操作符来赋值，所以源对象属性的一些特性(比如writable)不会被复制到目标对象 属性描述符 Object.getOwnPropertyDescriptor(obj, key) 123456&#123; value: , writable: true, enumerable: true, configurable: true&#125; writable 决定是否可以修改属性的值 Configurable 如果属性是可配置的，就可以使用defineProperty(..)来修改 Enumerable 控制属性是否会出现在对象的属性枚举中，如果为false，遍历的时候不会出现在枚举中，但是仍然可以正常访问 不变性 对象常量 - 结合writable: false 和configurable: false就可以创建一个真正的常量属性（不可修改，重定义或者删除） 禁止扩展 - 如果想要禁止一个对象添加新属性并保留已有属性，可以使用Object.preventExtensions(..) 密封 - Object.seal(..)会创建一个密封的对象，这个方法实际上会在一个现有对象的基础上调用Object.preventExtensions(..)并把所有的属性标记为configurable: false，密封之后不仅不能添加新属性，也不能重新配置或者删除任何现有属性 冻结 - Object.freeze(..)会创建一个冻结对象，实际上会在一个现有对象的基础上调用Object.seal(..)，并将所有数据访问属性标记为writable: false 存在性 可用通过 in和Object.hasOwnProperty来检查属性是否在对象中，所有的普通对象都可以连接到Object.hasOwnProperty，但是通过Object.create()创建的对象无法访问Object.hasOwnProperty,这时可以通过Object.prototype.hasOwnProperty.call(obj, a),它借用基础的hasOwnProperty方法并显示绑定到obj上面 混合对象”类” 类理论","updated":"2020-11-24T05:50:50.000Z","categories":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/categories/reading/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/tags/reading/"}]},{"title":"《你不知道javascript》 知识点摘录","path":"2020/11/20/reading/《你不知道javascript》 读后感/","text":"第一部分 类型和语法 &amp;&amp; 运算符的优先级高于 ||, 而 || 的优先级高于 ? :, &amp;&amp; || 是左关联， ? : 是右关联 在 try...catch...中，如果包含在for循环中，在一定情况下会在i++执行之前执行，如果在try...catch...中，加入yield, 由于yield的特性，try并未结束，因此catch、finally并不会立即执行 finally中的return会覆盖try和catch中的return的返回值 switch switch中的匹配算法是=== case 中的表达式尽量不要使用 &amp;&amp; or ||，因为匹配的数值并一定严格相等 判断字段类型 typeof instanceof Object.prototype.toString.call(obj) 再给html标签添加id标签的时候回默认添加一个和标签相同名称的全局变量 在script标签中是使用javascript语言，如果语句中包含&lt;/script&gt;则会被视为script标签的结束，应该使用&quot;&lt;/sc&quot; + &quot;ript&gt;&quot;来代替 第二部分 异步和性能 尽量避免发送同步的ajax请求，因为这样会锁定浏览器的UI,并且阻塞所用的用户交互 javascript从不跨线程共享数据 New Promise() Promise.all()Promise.all可以将多个Promise实例包装成一个新的Promise实例，同时，成功和失败的返回值是不同的, 成功的时候返回一个结果数据，失败的时候则最先被reject失败的状态的值 返回的成功的结果的数据顺序和Promise.all接收到的数组顺序是一致的如果有一个promise被拒绝， 主Promise.all()就会被立刻拒绝，并丢弃来自其他所有promise的全部结果 1234567891011121314function add(fun1, fun2) &#123; return Promise.all([fun1, fun2]).then(values =&gt; &#123; return values &#125;)&#125;const fun1 = new Promise((resolve, reject) =&gt; &#123; resolve(2) &#125;)const fun2 = new Promise((resolve, reject) =&gt; &#123; resolve(4) &#125;)add(fun1, fun2).then(values =&gt; &#123; console.log(values) // [2, 4]&#125;) Promise.race Promise.race 竞赛模式 只要传入的数组里面那个结果先出来，就返回哪个结果（不论返回的接口是成功还是失败） 1234567891011121314151617let p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#x27;success&#x27;) &#125;,1000)&#125;)let p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;failed&#x27;) &#125;, 500)&#125;)Promise.race([p1, p2]).then((result) =&gt; &#123; console.log(result)&#125;).catch((error) =&gt; &#123; console.log(error) // 打开的是 &#x27;failed&#x27;&#125;) 调用Promise的then()时，只传入一个完全处理函数，一个默认拒绝处理函数就会顶替上来，把错误重新抛出，是的错误可以沿着Promise链传递下去，知道遇到显式定义的拒绝处理函数 Promise.finally 通常用来处理被丢弃或者忽略的promise, 如果有需要释放的资源可以在finally进行释放 Promise.none 所有的promise都被拒绝才返回 Promise.any 至少需要一个promise完成就返回 Promise.first 只要第一个Promise完成，后续任何拒绝和完成都会忽略 Promise.last 只有最后一个完成的Promise胜出 并发迭代 Promise.map 12345678910111213141516171819202122// 封装Promise.mapif(!Promise.map) &#123; Promise.map = function(vals, cb) &#123; return Promise.all( vals.map(function(val) &#123; return new Promise( function(resolve) &#123; cb(val, resolve) &#125;) &#125;) ) &#125;&#125;// 使用Promise.mapPromise.map([p1, p2, p3], function(pr, done) &#123; promise.resolve(pr).then((v) =&gt; &#123; done(v * 2) &#125;, done)&#125;).then((values) =&gt; &#123; console.log(values)&#125;) try...catch... 不能和Promise连用，try...catch...只有在同步的情况下才能捕捉到异常，任何异步的错误都将无法捕捉到 一些无效的使用Promise API: new Promise(null)、 Promise.all()、Promise.race(42) 生成器 function *foo()&#123; &#125; 定义生成器函数 123function *foo() &#123; // what to do...&#125; 调用生成器函数 123456789// 在此处创建了一个生成器foofunction *foo(x, y) &#123; return x + y&#125;// 创建一个的迭代器对象，将迭代器对象赋值给了变量itvar it = foo(3, 4)// 调用it.next() 指示生成器从当前的位置继续运行，停留在下一个yield或者生成器结束var res = it.next()res.value // 7 需要的next() 调用比yield语句多一个，因为第一个next()用来启动一个生成器，并运行到第一个yield处，第二个next()调用完第一个被暂停的yield表达式，第三个next()调用完成第二个yield，依次类推 可以通过next向yield表达式传值 yield 和 next()组合起来，在生成器的执行过程中，构成了一个双向消息传递系统 12345678910function *foo(x) &#123; var y = x * (yield &quot;hello&quot;) return y&#125;var it = foo(6) //初始化一个迭代器 itvar res = it.next()res.value // hellovar res = it.next(7)res.value // 42 最后一个next()由return来回答 value为return 出来的值，如果生成器中没有return，会有一个假定的，隐式的return，会在默认的情况下回答最后的next()调用提出的问题 多个迭代器 12345678910111213141516171819202122232425262728293031function *foo() &#123; var x = yield 2 z++ console.log(z, &#x27;z&#x27;) var y = yield (x * z) console.log(x,y,z)&#125;var z = 1var it1 = foo() // 第一个迭代器var it2 = foo() // 第二个迭代器var val1 = it1.next().valuevar val2 = it2.next().valueconsole.log(val1, val2, &quot;val1, val2&quot;)val1 = it1.next(val2 * 10).valueval2 = it2.next(val1 * 5).valueconsole.log(val1, val2, &quot;val1, val2, two&quot;)it1.next(val2 / 2)it2.next(val1 / 4)// console// 2 2 val1, val2// 2 z// 3 z// 40 600 val1, val2, two// 20 300 3// 200 10 3 多个迭代器交互的时候，生成器中包含有全局变量时，会对全局变量造成污染 可以用于记录函数生成的最后一个值 1234567891011121314151617181920var something = (function () &#123; var nextVal return &#123; [Symbol.interator]: function() &#123; return this &#125;, next: function() &#123; if(nextVal === undefined) &#123; nextVal = 1 &#125; else &#123; nextVal = (3 * nextVal) + 6 &#125; return &#123;done: false, value: nextVal&#125; &#125; &#125;&#125;)()something.next().value // 1something.next().value // 9something.next().value // 33 es6新增了一个for ... of ...循环，意味着可以通过原生循环语法自动贴袋标准迭代器 123456for (var v of something) &#123; console.log(v) if(v &gt; 10) &#123; break; &#125;&#125; 终止生成器 for ... of ... 循环内的break会触发finally语句，终止生成器，也可以在外部调用it.return(..)手动终止生成器的迭代器实例 调用it.return之后会立刻终止生成器，运行finally语句","updated":"2020-11-20T01:44:55.000Z","categories":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/categories/reading/"}],"tags":[{"name":"reading","slug":"reading","permalink":"https://lxx1997.github.io/tags/reading/"}]},{"title":"golang-切割字符串和拼接字符串","path":"2020/11/12/golang/golang-切割字符串和拼接字符串/","text":"今天在Leecode上面练习用go语言做题，偶遇一题 剑指 Offer 58 - II. 左旋转字符串 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab” 示例： 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 然后我想起来前些天偶然遇到的一个题，有用到这部分的知识 然后我急忙把对应代码复制过来，然后点击提交，令人激动的是竟然成功了，但是运行内存及时间太不理想 提交时间 提交结果 运行时间 内存消耗 语言16分钟前 通过 72 ms 9.1 MB Go 代码如下12345678910111213func reverseLeftWords(s string, n int) string &#123; var char int = n for char &lt; len(s) &#123; newstr = newstr + string(s[char]) char++ &#125; var char2 int = 0 for char2 &lt; n &#123; newstr = newstr + string(s[char2]) char2++ &#125; return newstr&#125; 然后我就打算使用golang自带的字符串切割的方法 结果还是比较理想的 提交时间 提交结果 运行时间 内存消耗 语言几秒前 通过 0 ms 3.5 MB Go 代码差不多只有一行123func reverseLeftWords(s string, n int) string &#123; return string([]byte(s)[n:]) + string([]byte(s)[:n])&#125; 字符串切割 string([]byte(s)[n:m])string([]byte(s)[n:m]) : 首先是通过byte方法将字符串转为字节 s代表需要转换的字符串 n代表切割的起始位置，省略代表从第0位开始 m代表切割的终点位置，省略代表到末尾结束 最后通过string()方法再将字节转为字符串 但是这种方法并不适用于带有中文的字符串 string([]rune(s)[n:m])首先是通过byte方法将字符串转为字节 s代表需要转换的字符串 n代表切割的起始位置，省略代表从第0位开始 m代表切割的终点位置，省略代表到末尾结束 最后通过string()方法再将字节转为字符串","updated":"2020-11-12T06:07:23.000Z","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://lxx1997.github.io/tags/golang/"}]},{"title":"vue中使用typescript","path":"2020/10/22/vue/vue中使用typescript/","text":"在此记录一下Vue中使用typescript时 遇到的一些问题 Cannot find module ‘./xxx/xxx’ or its corresponding type declarations原因是ts识别不了vue文件，在引入的最后加上.vue就可以了12345// 错误的写法import TestLayout from &#x27;./components/test-layout&#x27;// 正确的写法import TestLayout from &#x27;./components/test-layout.vue&#x27; 获取DOM元素时提示 Type &#39;HTMLElement | null&#39; is not assignable to type &#39;HTMLElement&#39;. Type &#39;null&#39; is not assignable to type &#39;HTMLElement&#39; eg: 1this.scaleBox = document.querySelector(&#x27;.scale-box&#x27;) 对获取到的信息做一次类型转换或者类型断言 12this.scaleBox = &lt;HTMLDivElement&gt;document.querySelector(&#x27;.scale-box&#x27;)this.scaleBox = document.querySelector(&#x27;.scale-box&#x27;) as HTMLElement 同时贴上我在网上找到的tslint配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214// tslint.json&#123; &quot;defaultSeverity&quot;: &quot;warning&quot;, &quot;extends&quot;: [ &quot;tslint:recommended&quot; ], &quot;linterOptions&quot;: &#123; &quot;exclude&quot;: [ &quot;node_modules/**&quot; ] &#125;, &quot;rules&quot;: &#123; &quot;indent&quot;: [true, &quot;spaces&quot;, 2], &quot;interface-name&quot;: false, &quot;no-consecutive-blank-lines&quot;: false, &quot;object-literal-sort-keys&quot;: false, &quot;ordered-imports&quot;: false, &quot;quotemark&quot;: [true, &quot;single&quot;] &#125;, // 禁止自动检测末尾行必须使用逗号，always总是检测，never从不检测，ignore忽略检测 &quot;trailing-comma&quot;: [true, &#123; &quot;singleline&quot;: &quot;never&quot;, &quot;multiline&quot;: &#123; &quot;objects&quot;: &quot;ignore&quot;, &quot;arrays&quot;: &quot;always&quot;, &quot;functions&quot;: &quot;never&quot;, &quot;typeLiterals&quot;: &quot;ignore&quot; &#125; &#125;], // 禁止给类的构造函数的参数添加修饰符 &quot;no-parameter-properties&quot;: false, // 禁止使用 debugger &quot;no-debugger&quot;: false, // 禁止行尾有空格 &quot;no-trailing-whitespace&quot;: false, // 禁止无用的表达式 &quot;no-unused-expression&quot;: true, // 定义过的变量必须使用 &quot;no-unused-variable&quot;: true, // 变量必须先定义后使用 &quot;no-use-before-declare&quot;: true, // 禁止使用 var &quot;no-var-keyword&quot;: true, // 必须使用 === 或 !==，禁止使用 == 或 !=，与 null 比较时除外 &quot;triple-equals&quot;: true, // 指定类成员的排序规则 &quot;member-ordering&quot;: false, // 禁止将 this 赋值给其他变量，除非是解构赋值 &quot;no-this-assignment&quot;: [ false, &#123; &quot;allowed-names&quot;: [ &quot;^self$&quot;, &quot;^that$&quot; ], &quot;allow-destructuring&quot;: true &#125; ], // 必须使用箭头函数，除非是单独的函数声明或是命名函数 &quot;only-arrow-functions&quot;: [ true, &quot;allow-declarations&quot;, &quot;allow-named-functions&quot; ], // 禁止出现空代码块，允许 catch 是空代码块 &quot;no-empty&quot;: [ true, &quot;allow-empty-catch&quot; ], // 禁止无用的类型断言 &quot;no-unnecessary-type-assertion&quot;: true, // 使用 return; 而不是 return undefined; &quot;return-undefined&quot;: true, // 禁止对 array 使用 for in 循环 &quot;no-for-in-array&quot;: true, &quot;comment-format&quot;: [ true, &quot;check-space&quot; ], // 单行注释格式化规则 // 定义函数时如果用到了覆写，则必须将覆写的函数写到一起 &quot;adjacent-overload-signatures&quot;: true, // 禁止对函数的参数重新赋值 &quot;no-parameter-reassignment&quot;: true, // if 后面必须有 &#123;，除非是单行 if &quot;curly&quot;: [ true, &quot;ignore-same-line&quot; ], // for in 内部必须有 hasOwnProperty &quot;forin&quot;: true, // 禁止在分支条件判断中有赋值操作 &quot;no-conditional-assignment&quot;: true, // 禁止使用 new 来生成 String, Number 或 Boolean &quot;no-construct&quot;: true, // 禁止 super 在一个构造函数中出现两次 &quot;no-duplicate-super&quot;: true, // 禁止在 switch 语句中出现重复测试表达式的 case &quot;no-duplicate-switch-case&quot;: true, // 禁止出现重复的变量定义或函数参数名 &quot;no-duplicate-variable&quot;: [ true, &quot;check-parameters&quot; ], // 禁止使用 eval &quot;no-eval&quot;: true, // 禁止对对象字面量进行类型断言（断言成 any 是允许的） &quot;no-object-literal-type-assertion&quot;: true, // 禁止没必要的 return await &quot;no-return-await&quot;: true, // 禁止在数组中出现连续的逗号，如 let foo = [,,] &quot;no-sparse-arrays&quot;: true, // 禁止 throw 字符串，必须 throw 一个 Error 对象 &quot;no-string-throw&quot;: true, // switch 的 case 必须 return 或 break &quot;no-switch-case-fall-through&quot;: true, // 使用实例的方法时，必须 bind 到实例上 &quot;no-unbound-method&quot;: [ true, &quot;ignore-static&quot; ], // 使用 &#123; ...foo, bar: 1 &#125; 代替 Object.assign(&#123;&#125;, foo, &#123; bar: 1 &#125;) // 前者的类型检查更完善 &quot;prefer-object-spread&quot;: true, // parseInt 必须传入第二个参数 &quot;radix&quot;: true, // 必须使用 isNaN(foo) 而不是 foo === NaN &quot;use-isnan&quot;: true, // // // 可维护性 // 这些规则可以增加代码的可维护性 // // 禁止函数的循环复杂度超过 20，https://en.wikipedia.org/wiki/Cyclomatic_complexity &quot;cyclomatic-complexity&quot;: [ true, 20 ], // 禁止使用废弃（被标识了 @deprecated）的 API &quot;deprecation&quot;: true, // 一个缩进必须用四个空格替代 &quot;indent&quot;: [ true, &quot;spaces&quot;, 4 ], // 禁止出现重复的 import &quot;no-duplicate-imports&quot;: true, // 禁止一个文件中出现多个相同的 namespace &quot;no-mergeable-namespace&quot;: true, // 文件类型必须时 utf-8 &quot;encoding&quot;: true, // import 语句中，关键字之间的间距必须是一个空格 &quot;import-spacing&quot;: true, // 接口可以 implement extend 和 merge &quot;interface-over-type-literal&quot;: true, // new 后面只必须有一个空格 &quot;new-parens&quot;: true, // 类型断言必须使用 as Type，禁止使用 &lt;Type&gt; // &lt;Type&gt; 容易被理解为 jsx &quot;no-angle-bracket-type-assertion&quot;: true, // 禁止连续超过三行空行 &quot;no-consecutive-blank-lines&quot;: [ true, 3 ], // 禁止使用特殊空白符（比如全角空格） &quot;no-irregular-whitespace&quot;: true, // 禁止使用 JSDoc，因为 TypeScirpt 已经包含了大部分功能 &quot;no-redundant-jsdoc&quot;: true, // 禁止使用三斜杠引入类型定义文件 &quot;no-reference-import&quot;: true, // 禁止变量定义时赋值为 undefined &quot;no-unnecessary-initializer&quot;: true, // 小数必须以 0. 开头，禁止以 . 开头，并且不能以 0 结尾 &quot;number-literal-format&quot;: true, // 必须使用 a = &#123;b&#125; 而不是 a = &#123;b: b&#125; &quot;object-literal-shorthand&quot;: true, // 变量申明必须每行一个，for 循环的初始条件中除外 &quot;one-variable-per-declaration&quot;: [ true, &quot;ignore-for-loop&quot; ], // if 后的 &#123; 禁止换行 &quot;one-line&quot;: true, // 必须使用单引号，jsx 中必须使用双引号 &quot;quotemark&quot;: [ true, &quot;single&quot;, &quot;jsx-double&quot;, &quot;avoid-template&quot;, &quot;avoid-escape&quot; ], // 行尾必须有分号 &quot;semicolon&quot;: [ true, &quot;always&quot;, &quot;ignore-interfaces&quot; ], // 函数名前必须有空格 &quot;space-before-function-paren&quot;: [ true, &quot;asyncArrow&quot; ], // 括号内首尾禁止有空格 &quot;space-within-parens&quot;: [ true, 0 ], // 禁止 finally 内出现 return, continue, break, throw 等 // finally 会比 catch 先执行 &quot;no-unsafe-finally&quot;: true&#125;","updated":"2020-10-22T07:45:24.000Z","categories":[],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"一些惊艳的字符串处理方法","path":"2020/09/24/web/number-format-methods/","text":"数字格式化 描述：将一串123483245678 处理成为 123,483,245,678 eg1:自己写的一个比较麻烦的方法 123456789101112131415161718 // 只实现了整数，其他同理，最好在获取到参数之后进行验证，是否符合自己的需求 function formatNumber(value) &#123; console.log(value) let arrStr = [] const arr = (value + &#x27;&#x27;).split(&#x27;,&#x27;) for(let i = 0; i &lt; arr.length; i++) &#123; let index = 0 for(let j = arr[i].length - 1; j &gt;= 0;j--) &#123; if(index !== 0 &amp;&amp; index % 3 === 0) &#123; arrStr= [&#x27;,&#x27;,...arrStr] &#125; arrStr= [arr[i][j],...arrStr] index++ &#125; &#125; return arrStr.join(&#x27;&#x27;)&#125;formatNumber(1234567890) eg2:toLocaleString 1(123456789).toLocaleString(&#x27;en-US&#x27;) eg3:正则表达式 12345function formatNumber(str) &#123; return str.replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, &#x27;,&#x27;)&#125;console.log(formatNumber(&quot;123456789&quot;)) eg4: 12345678910111213141516function formatNumber(str) &#123; let arr = [], count = str.length while (count &gt;= 3) &#123; arr.unshift(str.slice(count - 3, count)) count -= 3 &#125; // 如果是不是3的倍数就另外追加到上去 str.length % 3 &amp;&amp; arr.unshift(str.slice(0, str.length % 3)) return arr.toString()&#125;console.log(formatNumber(&quot;1234567890&quot;)) eg5: 123456789function formatNumber(str) &#123; // [&quot;0&quot;, &quot;9&quot;, &quot;8&quot;, &quot;7&quot;, &quot;6&quot;, &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, &quot;2&quot;, &quot;1&quot;] return str.split(&quot;&quot;).reverse().reduce((prev, next, index) =&gt; &#123; return ((index % 3) ? next : (next + &#x27;,&#x27;)) + prev &#125;)&#125;console.log(formatNumber(&quot;1234567890&quot;))","updated":"2020-09-24T07:49:01.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"method","slug":"method","permalink":"https://lxx1997.github.io/tags/method/"}]},{"title":"react-学习之路-配置","path":"2020/09/18/react/react-study-config/","text":"Q: 如何配置路径别名 A: 前置条件 安装 npm react-app-rewired --save-dev 根目录（即src所在目录）创建config-overrides.js, 添加如下内容 12345678910const &#123; override, fixBabelImports, addWebpackAlias &#125; = require(&#x27;customize-cra&#x27;)const path = require(&#x27;path&#x27;)function resolve(dir) &#123; return path.join(__dirname, &#x27;.&#x27;, dir)&#125;module.exports = override( addWebpackAlias(&#123; [&quot;@&quot;]: path.resolve(__dirname, &quot;src&quot;) &#125;)) 修改 package.json 中的启动命令 123&quot;script&quot;: &#123; &quot;dev&quot;: &quot;react-app-rewired start&quot;&#125; 修改完成之后重新启动","updated":"2020-09-18T01:53:38.000Z","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"}]},{"title":"react - 学习之路 - 问题解决集锦","path":"2020/09/18/react/react-study-error/","text":"Q: 如何将带有html标签的字符串以html的形式在div等元素中显示出来 A: 使用元素的 dangerouslySetInnerHTML 可以将带有html标签的字符串转化为html 1dangerouslySetInnerHTML=&#123;&#123; __html:item.content&#125;&#125;（vue中直接使用v-html就可以成功转化）","updated":"2020-09-18T01:49:13.000Z","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"}]},{"title":"react 项目中使用less","path":"2020/09/03/react/react-less-loader/","text":"插件安装 1npm install react-app-rewired customize-cra babel-plugin-import -D 在项目根目录创建文件 config-overrides.js 1234const &#123;...&#125; = require(&#x27;customize-cra&#x27;);module.exports = override( ...); react 按需加载配置 12345678const &#123; override, fixBabelImports &#125; = require(&quot;customize-cra&quot;);module.exports = override( fixBabelImports(&#x27;import&#x27;, &#123; libraryName: &#x27;antd&#x27;, libraryDirectory: &#x27;es&#x27;, style: true,//或者css, true代表运用less &#125;),); 修改package.json 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;react-app-rewired start&quot;, &quot;build&quot;: &quot;react-app-rewired build&quot;, &quot;test&quot;: &quot;react-app-rewired test&quot;, &quot;eject&quot;: &quot;react-app-rewired eject&quot;&#125;, 编译less文件 1234567yarn add --dev less less-loader //less-loader用5.0版本，高版本停用了一些配属性//config-overrides.js内容const &#123; override,addLessLoader&#125; = require(&quot;customize-cra&quot;);module.exports = override( addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123;&#125; &#125;),); 装饰器 123456npm install -D @babel/plugin-proposal-decorators//config-overrides.jsconst &#123; override, addDecoratorsLegacy&#125; = require(&#x27;customize-cra&#x27;);module.exports = override( addDecoratorsLegacy()); 问题解决 出现如下报错 ValidationError: Invalid options object. Less Loader has been initialized using an options object that does not match the API schema.options has an unknown property ‘modifyVars’. These properties are valid:object { lessOptions?, prependData?, appendData?, sourceMap?, implementation? }。 解决方案将 1234addLessLoader(&#123; javascriptEnabled: true, modifyVars: &#123;&#125;&#125;), 修改为 123456addLessLoader(&#123; lessOptions: &#123; javascriptEnabled: true, modifyVars: &#123;&#125; &#125;&#125;),","updated":"2020-09-03T07:30:35.000Z","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/tags/webpack/"},{"name":"less","slug":"less","permalink":"https://lxx1997.github.io/tags/less/"},{"name":"react-app-rewired","slug":"react-app-rewired","permalink":"https://lxx1997.github.io/tags/react-app-rewired/"},{"name":"customize-cra","slug":"customize-cra","permalink":"https://lxx1997.github.io/tags/customize-cra/"}]},{"title":"重拾 react","path":"2020/08/28/react/react-study/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 生命周期 routerWillLeave 路由跳转前确认 return false 取消本次跳转 return 返回提示信息，在离开Route前提示用户进行确认 12345678910import &#123; Lifecycle &#125; from &#x27;react-router&#x27;const Home = React.createClass(&#123; // 假设 Home 是一个 route 组件，它可能会使用 // Lifecycle mixin 去获得一个 routerWillLeave 方法。 mixins: [ Lifecycle ], routerWillLeave(nextLocation) &#123; if (!this.state.isSaved) return &#x27;Your work is not saved! Are you sure you want to leave&#x27; &#125;,&#125;)","updated":"2020-08-28T07:11:36.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"}]},{"title":"重拾 react - React模板 antd","path":"2020/08/28/react/react-study-antd/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 antd 是一款优秀的react 前端页面框架 插件使用 插件： antd 安装： npm install -S antd 使用： import &#123;Layout, Button&#125; from &#39;antd&#39; 组件 布局 Layout 12import &#123;Layout&#125; from &#x27;antd&#x27;const &#123;Header,Side,Content,Footer&#125; = Layout","updated":"2020-08-28T04:05:15.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"antd","slug":"antd","permalink":"https://lxx1997.github.io/tags/antd/"}]},{"title":"重拾 react - React-Router","path":"2020/08/28/react/react-study-router/","text":"由于最近一段时间一直在使用vue做项目，最近打算重拾react，在此记录react的点滴学习，实时更新 插件使用 插件： react-router-dom 安装： npm install -S react-router-dom 使用： import &#123;Router&#125; from &#39;react-router-dom&#39; Router 配置的方法 第一种 123456789101112131415import &#123; Redirect &#125; from &#x27;react-router&#x27;React.render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Dashboard&#125; /&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125; /&gt; &lt;Route path=&quot;inbox&quot; component=&#123;Inbox&#125;&gt; &lt;Route path=&quot;/messages/:id&quot; component=&#123;Message&#125; /&gt; &#123;/* 跳转 /inbox/messages/:id 到 /messages/:id */&#125; &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body) 第二种 12345678910111213141516171819202122const routeConfig = [ &#123; path: &#x27;/&#x27;, component: App, indexRoute: &#123; component: Dashboard &#125;, childRoutes: [ &#123; path: &#x27;about&#x27;, component: About &#125;, &#123; path: &#x27;inbox&#x27;, component: Inbox, childRoutes: [ &#123; path: &#x27;/messages/:id&#x27;, component: Message &#125;, &#123; path: &#x27;messages/:id&#x27;, onEnter: function (nextState, replaceState) &#123; replaceState(null, &#x27;/messages/&#x27; + nextState.params.id) &#125; &#125; ] &#125; ] &#125;]React.render(&lt;Router routes=&#123;routeConfig&#125; /&gt;, document.body) 组件类型 Router 最外层路由，包裹所有的路由 HashRouter 哈希路由 BrowserRouter 历史路由 Route 路由页面地址 Link 路由跳转 IndexRoute 用来设置一个默认路由 Redirect 路由重定向 Switch 有Switch标签，则其中的Route在路径相同的情况下，只匹配第一个，这个可以避免重复匹配 IndexLink 只有定义的路由被渲染后才激活 导航路由 历史路由模式 123// somewhere like a redux/flux action file:import &#123; browserHistory &#125; from &#x27;react-router&#x27;browserHistory.push(&#x27;/some/path&#x27;) 哈希路由模式 123// somewhere like a redux/flux action file:import &#123; HashHistory &#125; from &#x27;react-router&#x27;HashHistory.push(&#x27;/some/path&#x27;)","updated":"2020-08-28T03:52:22.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"react","slug":"react","permalink":"https://lxx1997.github.io/tags/react/"},{"name":"router","slug":"router","permalink":"https://lxx1997.github.io/tags/router/"}]},{"title":"electron - 使用javascript编写pc应用 - 01","path":"2020/08/20/frame/electron-study-01/","text":"在electron官网根据文档指示，下载了一个electron模板并安装依赖成功运行 练习项目git地址 版本发布 插件： electron-packager 安装： npm install -g electron-packager 打包： package&quot;: &quot;electron-packager ./ demo_app --platform=win32 --out ../demo_app_release --version 1.4.13 --overwrite --icon=./images/app.ico 模块 electron 提供了许多api来方便我们调用 Dialog模块 showOpenDialog(browserWindow, options, callback) _browserWindow_ BrowserWindow (可选) 打包 Q: react 文件打包之后，访问index.html,文件报错找不到js和css文件 A: react 路由模式由 history模式修改为 hash模式, package.json 里面添加配置 homePage: &#39;.&#39; Q: 使用electron打包，窗口白屏，无法加载文件 A: 将package.json, electron的入口文件，（以及预加载文件preload.js）复制到react打包后的项目 build文件夹中， 然后修改electron的入口文件 electron.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const &#123;app, BrowserWindow&#125; = require(&#x27;electron&#x27;)const path = require(&#x27;path&#x27;)const url = require(&#x27;url&#x27;)// const &#123; url &#125; = require(&#x27;inspector&#x27;)function createWindow () &#123; // 隐藏菜单栏 // Menu.setApplicationMenu(null) const mainWindow = new BrowserWindow(&#123; width: 800, height: 600, // icon: path.join(__dirname, &#x27;/assets/img/2.jpg&#x27;), // title: &#x27;this is a electron&#x27; webPreferences: &#123; javascript: true, plugins: true, nodeIntegration: true, // 是否集成 Nodejs webSecurity: false, preload: path.join(__dirname, &#x27;preload.js&#x27;) &#125; &#125;) // and load the index.html of the app. // mainWindow.loadFile(path.join(__dirname, &#x27;index.html&#x27;)) // Open the DevTools. // mainWindow.webContents.openDevTools() // mainWindow.loadURL(&#x27;http://localhost:3000/&#x27;) // 加载应用----react 打包 mainWindow.loadURL(url.format(&#123; pathname: path.join(__dirname, &#x27;./index.html&#x27;), protocol: &#x27;file:&#x27;, slashes: true &#125;))&#125;app.whenReady().then(() =&gt; &#123; createWindow() console.log(&#x27;ready&#x27;) app.on(&#x27;activate&#x27;, function () &#123; if (BrowserWindow.getAllWindows().length === 0) createWindow() &#125;)&#125;)app.on(&#x27;window-all-closed&#x27;, function () &#123; if (process.platform !== &#x27;darwin&#x27;) app.quit()&#125;)","updated":"2020-08-20T01:30:05.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"html","slug":"html","permalink":"https://lxx1997.github.io/tags/html/"},{"name":"electron","slug":"electron","permalink":"https://lxx1997.github.io/tags/electron/"},{"name":"css","slug":"css","permalink":"https://lxx1997.github.io/tags/css/"}]},{"title":"第三方插件安装采坑  -  01","path":"2020/08/19/webpack/npm-third-party-plugin-in/","text":"此博客用来记录使用第三方插件安装及使用的时候采坑记录 electron 安装 npm install 报错 123Error: read ECONNRESET# 或者Error: Electron failed to install correctly ... 解决方式 1234// 设置镜像set &quot;ELECTRON_MIRROR=http://npm.taobao.org/mirrors/electron&quot;// 安装npm install","updated":"2020-08-19T09:16:20.000Z","categories":[],"tags":[{"name":"npm","slug":"npm","permalink":"https://lxx1997.github.io/tags/npm/"}]},{"title":"HOW TO 制作一个简易的弹幕demo","path":"2020/08/13/web/html-video-chat-bullet/","text":"闲来无事，对于bili上面的弹幕感兴趣，于是自己打算尝试制作一个简单的弹幕系统 页面布局 首先先创建一个容器用来存放video播放器和弹幕发射器,注意要有一个遮罩层设置透明度为0,用来显示我们输入的弹幕,位于视频的上方,为了使视频的显示不那么突兀,我们可以把存放视频的容器的背景颜色设置成深色或者黑色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .chat-bullet-container &#123; width: 400px; height: 300px; position: absolute; top: 40px; left: 50%; transform: translateX(-50%); &#125; .chat-bullet-video-container &#123; width: 400px; height: 250px; background-color: rgb(0, 0, 0); &#125; .chat-bullet-video-container video &#123; max-width: 100%; max-height: 100%; position: absolute; top: 50%; left: 50%; transform: translateX(-50%) translateY(-62%); &#125; .chat-bullet-video-container #chat-bullet-video-text &#123; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0); &#125; .chat-text &#123; position: absolute; top: 70px; left: 70px; color: #000000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;chat-bullet-container&quot;&gt; &lt;!-- 播放 --&gt; &lt;div id=&quot;chat-bullet-video-container&quot; class=&quot;chat-bullet-video-container&quot;&gt; &lt;video id=&quot;video&quot; src=&quot;./demo.mp4&quot; controls=&quot;true&quot;&gt;&lt;/video&gt; &lt;div id=&quot;chat-bullet-video-text&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;chat-bullet-video-method&quot;&gt; &lt;!-- &lt;input id=&quot;color&quot; type=&quot;color&quot;&gt; --&gt; &lt;input id=&quot;chat-input&quot; type=&quot;text&quot;&gt; &lt;button type=&quot;text&quot; onclick=&quot;handleSend()&quot;&gt;发送&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 功能实现 接下来给弹幕发射器添加点击事件，点击的时候让我们发送的文字显示在视频上面 获取遮罩层元素及其宽高,作为弹幕显示和滚动的限制条件 123const chatContainer = document.getElementById(&#x27;chat-bullet-video-text&#x27;)const height = chatContainer.offsetHeightconst width = chatContainer.offsetWidth 为发送弹幕按钮添加点击事件,生成随机颜色和位置的弹幕，然后通过appendChild方法将生成的弹幕放到 123456789101112function handleSend() &#123; const input = document.getElementById(&#x27;chat-input&#x27;) const msg = input.value const text = document.createElement(&#x27;span&#x27;) text.innerHTML = msg let style = `position: absolute; top: $&#123;Math.random() * height&#125;px; right: 30px; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element)&#125; 这个时候当我们在输入框中输入内容的时候，点击发送的时候就会发现我们写的内容随机显示在视频上面 接下来做的就是让弹幕能够动起来，本次实现的是从右向左移动 但是弹幕不可能只发送一个，弹幕通常来说是很多个的，这个时候如何用上述的方法来添加弹幕和控制弹幕的话显然是不合理。 这个时候我们应该做的是让每个添加的弹幕之间是独立的，互不影响的，能够独立运行，这时候我借鉴了之前学习canvas时使用的方法：创建一个class类，在这个类中实现弹幕的属性初始化，渲染，运行及删除事件 12345678910111213141516171819202122232425262728293031323334353637// 弹幕渲染及移动类class Chat &#123; constructor(element, chatContainer, data) &#123; this.element = element this.chatContainer = chatContainer this.init() &#125; init() &#123; this.ccx = this.chatContainer.offsetWidth this.ccy = this.chatContainer.offsetHeight // 弹幕速度 this.s = Math.random() + 4 &#125; // 渲染带有样式的弹幕 paint() &#123; let style = `position: absolute; top: $&#123;Math.random() * this.ccy&#125;px; right: $&#123;this.mx&#125;; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element) this.mx = -this.element.offsetWidth this.element.style.right = this.mx + &#x27;px&#x27; this.element.style.display = &#x27;none&#x27; &#125; // 移动弹幕，使弹幕从右向左移动 move() &#123; this.mx = this.mx + this.s this.element.style.display = &#x27;inline-block&#x27; this.element.style.right = this.mx + &#x27;px&#x27; &#125; delete(index) &#123; if(this.mx &gt;= this.ccx) &#123; this.element.style.display = &#x27;none&#x27; &#125; &#125;&#125; 点击事件也应该根据实际情况进行修改，同时定义一个数组用来存放我们添加的弹幕的类 12345678910const chartList = []function handleSend() &#123; const input = document.getElementById(&#x27;chat-input&#x27;) const msg = input.value const text = document.createElement(&#x27;span&#x27;) text.innerHTML = msg const chat = new Chat(text, chatContainer, &#123;color: &#x27;red&#x27;&#125;) chat.paint() chartList.push(chat)&#125; 但是想要让弹幕动起来可不是那么简单的事情，因为我们上述操作只是使弹幕渲染到了视频上面，并没有使弹幕动起来，这时我们可以定义一个定时器，时间间隔要短，在定时器中我们循环存放弹幕的数组，调用弹幕自身的移动事件及删除事件 123456setInterval(() =&gt; &#123; for(var i = 0; i &lt; chartList.length; i++) &#123; chartList[i].move() chartList[i].delete(i) &#125;&#125;, 100) 将弹幕与视频关联起来 想要做成根据视频播放来显示历史弹幕就要将弹幕和视频当前播放时间进行关联 12345678910111213// 给视频添加监听事件，监听视频运行// video ended functionvideo.addEventListener(&#x27;ended&#x27;, function() &#123; console.log(video_Status)&#125;)// 监听视频播放，获取当前播放时间video.addEventListener(&#x27;canplay&#x27;, function() &#123; console.log(this.duration)&#125;)// 监听视频播放，获取当前播放时间video.addEventListener(&#x27;timeupdate&#x27;, function() &#123; currentTime = this.currentTime&#125;) 获取到视频播放时间之后，接下来就是将时间和弹幕关联起来存储，如果没有后台的支持的话可以使用localStorage和indexedDB来存储数据，这里我推介使用indexedDB，因为可以练习一下indexedDB的知识，同时indexedDB的存储空间也比localStorage的存储空间要大很多 首先检测indexedDB是否启用，同时创建所需要使用的数据库和表，设置主键 1234567891011121314function checkIndexedDB(database, table) &#123; const request = window.indexedDB.open(database, 3) request.onupgradeneeded = function(e) &#123; const db = e.target.result if(!db.objectStoreNames.contains(table)) &#123; const tables = db.createObjectStore(table, &#123; keyPath: &#x27;id&#x27;, // 使用当前时间戳可以避免id重复 autoIncreament: true &#125;) &#125; console.log(123123) db.close() &#125;&#125; 然后连接数据库，向表中插入数据 123456789function linkIndexedDB(database, table) &#123; const request = window.indexedDB.open(database) return new Promise((resolve, reject) =&gt; &#123; request.onsuccess = function(e) &#123; const db = e.target.result resolve(db) &#125; &#125;)&#125; 同时将弹幕的print()进行修改，每创建一条弹幕就存储一次 12345678910111213141516171819202122// 渲染带有样式的弹幕 paint() &#123; console.log(currentTime, &#x27;chat&#x27;) let style = `position: absolute; top: $&#123;Math.random() * this.ccy&#125;px; right: $&#123;this.mx&#125;; color: rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;);` this.element.setAttribute(&#x27;style&#x27;, style) this.chatContainer.appendChild(this.element) this.mx = -this.element.offsetWidth this.element.style.right = this.mx + &#x27;px&#x27; this.element.style.display = &#x27;none&#x27; linkIndexedDB(&#x27;test&#x27;, &#x27;chat&#x27;).then(db =&gt; &#123; console.log(db) const request = db.transaction([&#x27;chat&#x27;], &#x27;readwrite&#x27;).objectStore(&#x27;chat&#x27;) .add(&#123;id: Date.now(), element: this.element.innerHTML, style: style, currentTime: currentTime, createUser: &#x27;lxx&#x27;, speed: this.s&#125;) request.onsuccess = function(e) &#123; console.log(&#x27;添加成功&#x27;) db.close() &#125; &#125;) &#125; 未完待续。。。。。","updated":"2020-08-13T07:21:48.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"HTML","slug":"HTML","permalink":"https://lxx1997.github.io/tags/HTML/"}]},{"title":"HTML 标签及函数","path":"2020/08/11/web/html-label-function/","text":"HTML全局属性 accesskey 规定激活元素的快捷键，使元素获得焦点（Opera浏览器不支持此选项） 以下元素支持accesskey a, area, button, input, label, legend 以及 textarea contenteditable 规定元素内容是否可编辑，如果元素未设置contenteditable 属性，那么元素将会从其父元素继承该属性 contenteditable = true | false contextmenu 规定 div 元素的上下文菜单。上下文菜单会在用户右键点击元素时出现，contextmenu 属性的值是要打开的 menu 元素的 id，目前只有fireFox支持 123456&lt;div contextmenu=&quot;mymenu&quot;&gt; &lt;menu type=&quot;context&quot; id=&quot;mymenu&quot;&gt; &lt;menuitem label=&quot;Refresh&quot;&gt;&lt;/menuitem&gt; &lt;menuitem label=&quot;Twitter&quot;&gt;&lt;/menuitem&gt; &lt;/menu&gt;&lt;/div&gt; data-* 用来嵌入自定义数据，赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力，属性名不应该包含任何大写字母，并且在前缀 “data-“ 之后必须有至少一个字符 dir 属性规定元素内容的文本方向 ltr: 从左到右 rtl: 从右到左 dir属性在以下标签中无效base, br, frame, frameset, hr, iframe, param 以及 script draggable 规定元素是否可拖拽 true|false|auto 在使用时要和函数连用ondragstart,ondragover,ondrop 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; width: 100%; height: 100%; &#125; #div&#123; position: absolute; top: 200px; border: 1px solid rebeccapurple; height: 20px; width: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body &gt; &lt;div id=&quot;div&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt; &lt;p id=&quot;drag&quot; draggable=&quot;true&quot; dropzone=&quot;link&quot; ondragstart=&quot;drag(event)&quot;&gt;3242342342&lt;/p&gt; &lt;script&gt; function drag(e) &#123; console.log(e) e.dataTransfer.setData(&#x27;Text&#x27;, e.target.id) &#125; function drop(e) &#123; var data = e.dataTransfer.getData(&quot;Text&quot;); e.target.appendChild(document.getElementById(data)); e.preventDefault(); &#125; function allowDrop(e) &#123; e.preventDefault(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在与contenteditable连用时不起作用 dropzone 拖动数据会产生被拖动数据的副本 copy 拖动数据会产生被拖动数据的副本。 move 拖动数据会导致被拖动数据被移动到新位置。 link 拖动数据会产生指向原始数据的链接。 暂无浏览器支持 hidden 规定元素是否显示 是布尔属性 hidden属性可以用于防止用户查看元素，知道匹配某些条件 在 XHTML 中，属性简写是禁止的，hidden 属性必须定义为 &lt;element hidden=&quot;hidden&quot;&gt; lang 规定了元素内容的语言 zh,en lang 属性在以下标签中无效：&lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt; 以及 &lt;script&gt;。 spellcheck 规定是否对元素进行拼写和语法检查 input 元素中的文本值（非密码） &lt;textarea&gt; 元素中的文本 可编辑元素中的文本 tabindex 规定元素的 tab 键控制次序（当 tab 键用于导航时） 以下元素支持 tabindex 属性：&lt;a&gt;, &lt;area&gt;, &lt;button&gt;, &lt;input&gt;, &lt;object&gt;, &lt;select&gt; 以及 &lt;textarea&gt;,几乎所有浏览器均 tabindex 属性，除了 Safari translate 规定不应翻译某些元素 所有主流浏览器都无法正确地支持 translate 属性,请使用 class=”notranslate” 替代 HTML事件属性 Window 事件属性 针对 window 对象触发的事件（应用到 标签） onload 页面结束加载之后触发 onresize 浏览器窗口被调整大小时触发 onunload 一旦页面已下载时触发（或者浏览器窗口已被关闭） Form 事件 由 HTML 表单内的动作触发的事件（应用到几乎所有 HTML 元素，但最常用在 form 元素中） onblur 元素失去焦点时运行的脚本 onchange 元素值被改变时运行的脚本 onfocus 当元素获得焦点时运行的脚本 onselect 在元素中文本被选中后触发 onsubmit 在提交表单时触发 keyboard 事件 onkeyup 用户释放按键时触发 onkeydown 用户按下按键时触发 onkeypress 用户敲击按钮时触发 mouse 事件 onclick 元素发生鼠标点击时触发 ondbclick 元素发生鼠标双击时触发 ondrag, ondragend, ondragstart ondrop, ondragenter, ondragerleave, ondragover 元素拖拽时触发 onmousedown 按下鼠标按钮时触发 onmouseup 释放鼠标按钮时触发 onmousemove 鼠标指针移动到元素上触发 onmouseover 鼠标指针移出到元素上触发 onmousewheel 鼠标滚轮正在滚动时运行的脚本 onscroll 当元素滚动条被滚动时运行的脚本 Media 事件 onabort 在退出时运行的脚本 oncanplay 当文件就绪可以开始播放时运行的脚本(缓冲已足够开始时) onwaiting 当媒介已停止播放单打算继续播放时 标签 base 标签 &lt;base href=&quot;http://www.baidu.com/static/&quot;&gt; &lt;base&gt; 标签为页面上所有链接规定默认地址和默认目标，在通常情况下浏览器会从单签文档的url中提取响应的元素来填写URL中的空白，但是&lt;base&gt;标签可以改变着一点，浏览器随后将不再使用当前文档的url，而是使用指定的基本url，包括&lt;a&gt;,&lt;img&gt;,&lt;link&gt;,&lt;form&gt;标签中的URL &lt;base&gt;标签必须位于head元素内部 basefont 标签 &lt;basefont color=&quot;red&quot; size=&quot;5&quot;&gt; 规定页面上默认字体颜色和字号, 主流浏览器暂不支持此标签 blockquote 标签 &lt;blockquote&gt; 标签定义块引用， 标签中的所有文本都会从常规文本中分离出去，经常左右两边有间距，而且有时会使用斜体，也就是说块引用拥有自己的空间 把页面作为 strict XHTML 进行验证，那么 &lt;blockquote&gt; 元素必须包含块级元素 datalist 标签 datalist 描述了input 标签的可能值 123456&lt;input id=&quot;myCar&quot; list=&quot;cars&quot;&gt;&lt;datalist id=cars&gt; &lt;option value=&quot;BMW&quot;&gt; &lt;option value=&quot;FORD&quot;&gt; &lt;option value=&quot;VOLVO&quot;&gt;&lt;/datalist&gt; datalist 标签标签定义选项列表，与input元素配合使用，定义input可能的值，datalist及其元素不会被显示出来，仅仅是合法输入值列表， 用input的list属性来绑定datalist del 删除线 details 标签 用于描述文档或者文档某个部分的细节 1234&lt;details&gt; &lt;summary&gt;Copyright 2011.&lt;/summary&gt; &lt;p&gt;All pages and graphics on this web site are the property of W3School.&lt;/p&gt;&lt;/details&gt; 目前只有 Chrome 支持 &lt;details&gt; 标签。 dialog 标签 dialog 标签定义对话框或窗口是HTML5的新标签 embed 标签 &lt;embed&gt; 标签定义嵌入的内容，比如插件。 1&lt;embed src=&quot;helloworld.swf&quot; type=&quot;MIME_type&quot; /&gt; fieldset 标签 1234567&lt;form&gt; &lt;fieldset&gt; &lt;legend&gt;health information&lt;/legend&gt; height: &lt;input type=&quot;text&quot; /&gt; weight: &lt;input type=&quot;text&quot; /&gt; &lt;/fieldset&gt;&lt;/form&gt; &lt;fieldset&gt; 元素可将表单内的相关元素分组，将表单内容的一部分打包，生成一组相关表单的字段 &lt;legend&gt; 标签为&lt;fieldset&gt; 元素定义标题。 figcaption 标签 用作文档中插图的图像，带有一个标题 1234&lt;figure&gt; &lt;figcaption&gt;黄浦江上的的卢浦大桥&lt;/figcaption&gt; &lt;img src=&quot;shanghai_lupu_bridge.jpg&quot; width=&quot;350&quot; height=&quot;234&quot; /&gt;&lt;/figure&gt; &lt;figcaption&gt; 标签定义 figure 元素的标题,应该被置于 “figure” 元素的第一个或最后一个子元素的位置 frame 标签 12345&lt;frameset cols=&quot;25%,50%,25%&quot;&gt; &lt;frame src=&quot;frame_a.htm&quot; /&gt; &lt;frame src=&quot;frame_b.htm&quot; /&gt; &lt;frame src=&quot;frame_c.htm&quot; /&gt;&lt;/frameset&gt; &lt;frame&gt; 标签定义 frameset 中的一个特定的窗口 frameset 标签 frameset 元素可定义一个框架集。它被用来组织多个窗口（框架）。每个框架存有独立的文档 cols 定义框架集中列的数目和尺寸 rows 定义框架集中行的数目和尺寸 iframe 标签 iframe 元素会创建包含另外一个文档的内联框架（即行内框架） frameborder 规定是否显示框架周围的边框 height 规定iframe的高度 width 定义 iframe 的宽度 marginheight 定义 iframe 的顶部和底部的边距 marginwidth 定义 iframe 的左侧和右侧的边距 name 规定 iframe 的名称 scrolling yes/no/auto 规定是否在 iframe 中显示滚动条 src 规定在 iframe 中显示的文档的 URL img 标签 alt 规定图像的替代文本 src 规定显示图像的 URL height 定义图像的高度 width 设置图像的宽度 ismap 将图像定义为服务器端图像映射 usemap 将图像定义为客户器端图像映射 input 标签 accept 规定通过文件上传来提交的文件的类型 alt 定义图像输入的替代文本 autocomplete on/off 规定是否使用输入字段的自动完成功能 autofocus 规定输入字段在页面加载时是否获得焦点，（不适用于 type=”hidden”） checked 规定此 input 元素首次加载时应当被选中 disabled 当 input 元素加载时禁用此元素 form 规定输入字段所属的一个或多个表单 list 引用包含输入字段的预定义选项的 datalist max 规定输入字段的最大值 min 规定输入字段的最小值 maxlength 规定输入字段中的字符的最大长度 multiple 如果使用该属性，则允许一个以上的值 name 定义 input 元素的名称 pattern 规定输入字段的值的模式或格式，通常用于表单输入内容验证是否规则 placeholder 规定帮助用户填写输入字段的提示 readonly 规定输入字段为只读 required 指示输入字段的值是必需的 size 定义输入字段的宽度 src 定义以提交按钮形式显示的图像的 URL type button/checkbox/file/hidden/image/password/radio/reset/submit/text/tel/email/teatarea/radio 规定 input 元素的类型 keygen 标签 12345&lt;form action=&quot;demo_keygen.asp&quot; method=&quot;get&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;usr_name&quot; /&gt; Encryption: &lt;keygen name=&quot;security&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; &lt;keygen&gt; 标签规定用于表单的密钥对生成器字段。当提交表单时，私钥存储在本地，公钥发送到服务器 link 标签 &lt;link&gt; 标签定义文档与外部资源的关系 href 规定被链接文档的位置 rel alternate/author/elp/icon/licence/next/pingback/prefetch/prev/search/sidebar/stylesheet/tag 规定当前文档与被链接文档之间的关系 type 规定被链接文档的 MIME 类型 map 标签 12345&lt;map name=&quot;planetmap&quot; id=&quot;planetmap&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;180,139,14&quot; href =&quot;venus.html&quot; alt=&quot;Venus&quot; /&gt; &lt;area shape=&quot;circle&quot; coords=&quot;129,161,10&quot; href =&quot;mercur.html&quot; alt=&quot;Mercury&quot; /&gt; &lt;area shape=&quot;rect&quot; coords=&quot;0,0,110,260&quot; href =&quot;sun.html&quot; alt=&quot;Sun&quot; /&gt;&lt;/map&gt; 定义一个客户端图像映射。图像映射（image-map）指带有可点击区域的一幅图像。 area 元素永远嵌套在 map 元素内部。area 元素可定义图像映射中的区域 mark 标签 &lt;mark&gt; 标签定义带有记号的文本。请在需要突出显示文本时使用 &lt;m&gt;标签 meta 标签 &lt;meta&gt; 元素可提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词,&lt;meta&gt; 标签位于文档的头部，不包含任何内容。&lt;meta&gt; 标签的属性定义了与文档相关联的名称/值对 content 定义与 http-equiv 或 name 属性相关的元信息 http-equiv content-type/expires/refresh/set-cookie 把 content 属性关联到 HTTP 头部 name author/description/keywords/generator/revised/others 把 content 属性关联到一个名称 scheme 定义用于翻译 content 属性值的格式 meter 标签 使用meter 元素来度量给定范围内的数据 1&lt;meter value=&quot;3&quot; min=&quot;0&quot; max=&quot;10&quot;&gt;十分之三&lt;/meter&gt; &lt;meter&gt; 标签定义已知范围或分数值内的标量测量。也被称为 gauge（尺度） object 标签 向 HTML 代码添加一个对象 1234567&lt;object classid=&quot;clsid:F08DF954-8592-11D1-B16A-00C0F0283628&quot; id=&quot;Slider1&quot; width=&quot;100&quot; height=&quot;50&quot;&gt; &lt;param name=&quot;BorderStyle&quot; value=&quot;1&quot; /&gt; &lt;param name=&quot;MousePointer&quot; value=&quot;0&quot; /&gt; &lt;param name=&quot;Enabled&quot; value=&quot;1&quot; /&gt; &lt;param name=&quot;Min&quot; value=&quot;0&quot; /&gt; &lt;param name=&quot;Max&quot; value=&quot;10&quot; /&gt;&lt;/object&gt;","updated":"2020-08-11T02:09:34.000Z","categories":[],"tags":[{"name":"html","slug":"html","permalink":"https://lxx1997.github.io/tags/html/"},{"name":"function","slug":"function","permalink":"https://lxx1997.github.io/tags/function/"}]},{"title":"使用js压缩图片","path":"2020/08/10/web/js-image-compression/","text":"压缩图片的方式主要是使用了canvas进行了一次转码和压缩 使用的方法 var fr = FileReader() fr.readAsDataURL(file) Image() canvas.toDataURL(imgType, quality) FileReader() 函数 使用 12345var reader = new FileReader()reader.onload = function(e) &#123; console.log(e.target.result)&#125;reader.readAsText(file) 属性 error 返回读取文件时的错误信息 onabort 包含在终止事件被触发时执行的事件处理程序，举例，当读取文件的过程中需要中止时。 onload 当FileReader读取文件的方式为readAsArrayBuffer,readAsBinaryString, readAsDataURL 或者 readAsText 的时候，会触发一个 load 事件。从而可以使用 FileReader.onload 属性对该事件进行处理。 readyState 提供 FileReader 读取操作时的当前状态 result 返回文件的内容。只有在读取操作完成后，此属性才有效，返回的数据的格式取决于是使用哪种读取方法来执行读取操作的。 一个字符串或者一个ArrayBuffer ，这取决于读取操作是使用哪种方法来进行的 方法 abort() abort方法可以取消FileReader的读写操作，触发之后readyState为已完成(DONE) readAsArrayBuffer() FileReader 接口提供的readAsArrayBuffer 用于启动读取指定的Blob或者File的内容，当操作完成时，readyState变成done并且触发loadend事件，result属性中将包含一个ArrayBuffer对象表示所读取文件的数据 readAsBinaryString() readAsBinaryString 方法读取指定的blob或者File的内容，当操作完成时，readyState变成done并且触发loadend事件，result属性中将包含一个ArrayBuffer对象表示所读取文件原始二进制格式 该方法已从 FileAPI 标准移除，请使用 FileReader.readAsArrayBuffer() 代替。 readAsDataURL() readAsDataURL 方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成DONE，并触发 loadend 事件，同时 result 属性将包含一个data:URL格式的字符串（base64编码）以表示所读取文件的内容 readAsText() readAsText 方法可以将 Blob 或者 File 对象转根据特殊的编码格式转化为内容(字符串形式) 这个方法是异步的，也就是说，只有当执行完成后才能够查看到结果，如果直接查看是无结果的，并返回undefined 必须要挂载 实例下的 onload 或 onloadend 的方法处理转化后的结果 转化完成后， readyState 这个参数就会转换 为 done 即完成态， event(“loadend”) 挂载的事件会被触发，并可以通过事件返回的形参得到中的 FileReader.result 属性得到转化后的结果 12// [encoding] 编码类型， 可选FileReader.readAsText(blob[, encoding]); 开始进行图片压缩 首先，创建一个input输入框用来上传文件 12&lt;input type=&quot;file&quot; multiple=&quot;&quot; id=&quot;file&quot; /&gt;&lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;handleChoose()&quot;&gt; 获取上传的文件 123456789101112131415161718192021222324252627282930const handleChoose = function() &#123; const file = Array.from(document.getElementById(&#x27;file&#x27;).files) const filePath = document.getElementById(&#x27;file&#x27;).value const imgBox = document.getElementById(&#x27;img&#x27;) const imgs = [] file.map(item =&gt; &#123; let reader = new FileReader() const img = document.createElement(&#x27;img&#x27;) // 将file文件 转码为base64 reader.readAsDataURL(item) // FileReader插件转码成功之后 reader.onload = function() &#123; img.src = reader[&#x27;result&#x27;] console.log(img.src, 123) const imgType = img.src.split(&#x27;;&#x27;)[0].split(&#x27;:&#x27;)[1] imgBox.appendChild(img) const callback = function(data) &#123; console.log(data, 456) &#125; scaleImage(img.src, imgType, callback) &#125; // FileReader插件转码失败 reader.onerror = function(e) &#123; console.log(e) &#125; // FileReader插件转码成功 reader.onloadend = function(e) &#123; &#125; &#125;)&#125; 进行图片压缩 123456789101112131415161718192021222324function scaleImage(base64Url, imgType, callback ) &#123; const img = new Image() img.src= base64Url img.onload = function() &#123; let _this = this let width = _this.width let height = _this.height let quality = 0.7 let canvas = document.createElement(&#x27;canvas&#x27;) let ctx = canvas.getContext(&#x27;2d&#x27;) let canvasW = document.createAttribute(&#x27;width&#x27;) let canvasH = document.createAttribute(&#x27;height&#x27;) canvasW.nodeValue = width canvasH.nodeValue = height canvas.setAttributeNode(canvasW) canvas.setAttributeNode(canvasH) ctx.drawImage(_this, 0, 0, width, height) let base64 = canvas.toDataURL(&quot;image/jpeg&quot;, quality) // toDataUrl // 图片格式默认为 image/png // 在指定格式为image/jpeg 或image.webp得情况下，可以从0,1的区间内压缩图片质量，如果超出取值范围，将会使用默认值0.92 callback(base64) &#125;&#125;","updated":"2020-08-10T02:17:32.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxx1997.github.io/tags/canvas/"}]},{"title":"矢量图形 SVG 学习之路 --- 进阶版","path":"2020/07/30/web/svg-study-02/","text":"SVG 滤镜 SVG可用的滤镜有以下几种 feBlend - 与图像相结合的滤镜 feColorMatrix - 用于彩色滤光片转换 feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset - 过滤阴影 feSpecularLighting feTile feTurbulence feDistantLight - 用于照明过滤 fePointLight - 用于照明过滤 feSpotLight - 用于照明过滤 您可以在每个 SVG 元素上使用多个滤镜！ SVG 模糊效果 和 所有互联网的SVG滤镜定义在元素中。元素定义短并含有特殊元素（如滤镜）定义。 标签用来定义SVG滤镜。标签使用必需的id属性来定义向图形应用哪个滤镜？ 用于创建模糊效果 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot;&gt; &lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;15&quot; /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt; filter 元素id属性属性定义了一个滤镜的唯一名称 元素定义模糊效果 in=&quot;SourceGraphic&quot; 这个部分定义了由整个图像创建效果 stdDeviation 属性定义模糊量 元素的滤镜属性用来把元素链接到&quot;f1&quot;滤镜 SVG 阴影 和 所有互联网的SVG滤镜定义在元素中。元素定义短并含有特殊元素（如滤镜）定义。 标签用来定义SVG滤镜。标签使用必需的id属性来定义向图形应用哪个滤镜？ feOffset 元素是用于创建阴影效果。我们的想法是采取一个SVG图形（图像或元素）并移动它在xy平面上一点儿。 第一个例子偏移一个矩形（带），然后混合偏移图像顶部（含） 12345678910&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;filter id=&quot;f1&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;200%&quot; height=&quot;200%&quot;&gt; &lt;feOffset result=&quot;offOut&quot; in=&quot;SourceGraphic&quot; dx=&quot;20&quot; dy=&quot;20&quot; /&gt; &lt;feBlend in=&quot;SourceGraphic&quot; in2=&quot;offOut&quot; mode=&quot;normal&quot; /&gt; &lt;/filter&gt; &lt;/defs&gt; &lt;rect width=&quot;90&quot; height=&quot;90&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;yellow&quot; filter=&quot;url(#f1)&quot; /&gt;&lt;/svg&gt; feColorMatrix 的 matrix 是一个 4*5 的矩阵。前面 4 列是颜色通道的比例系数，最后一列是常量偏移。 上面公式中的 rr 表示 red to red 系数，以此类推。c1~c4 表示常量偏移。 第一个 4*5 矩阵为变换矩阵，第二个单列矩阵为待变换对象的像素值。右侧单列矩阵为矩阵 1 和 2 的点积结果。 这个变换矩阵看起来比较复杂，在实践上常使用一个简化的对角矩阵，即除了 rr/gg/bb/aa 取值非零外，其余行列取值为 0，这就退化成了简单的各颜色通道的独立调整。 feColorMatrix的语法: 上述feColorMatrix过滤器的类型值为matrix，除此之外，还有saturate（饱和度）和hueRotate（色相旋转），取值比较简单，这里不做说明。 显然当变换矩阵为单位对角矩阵时，变换结果和原值相等。 SVG渐变 渐变是从一种颜色到另一种颜色的平滑过渡，另外把多个元素的过渡应用到同一个元素上 渐变主要有两种类型 linear Redial SVG线性渐变 linearGradient 泳衣定义线性渐变 linearGradient必须套嵌在defs标签内部， 线性渐变可定义水平、垂直、或角渐变 当y1和y2相等 x1和x2不同时，可创建水平渐变 当x1和x2相等 y1和y2不同时，可创建垂直渐变 当x1和x2不同 y1和y2不同时，可创建角形渐变 123456789&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;grad1&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;&gt; &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,0);stop-opacity:1&quot; /&gt; &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(255,0,0);stop-opacity:1&quot; /&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;&lt;/svg&gt; linearGradient 标签的id属性可为渐变定义一个唯一的名称 linearGradient 标签的x1，y1，x2，y2属性自定义渐变开始和结束位置 渐变颜色范围可由两种或多种颜色组成，每种颜色通过一个stop标签来规定，offset属性用来定义渐变开始和结束位置 填充属性吧ellipse元素连接到次渐变 text 元素用来添加一个文本 SVG放射性渐变 redialGradient 元素用于定义放射性渐变 redialGradient 标签必须嵌套在defs的内部，defs标签是definitions的缩写，他可对诸如渐变之类的特殊元素进行定义 12345678910&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;defs&gt; &lt;radialGradient id=&quot;grad1&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; r=&quot;50%&quot; fx=&quot;50%&quot; fy=&quot;50%&quot;&gt; &lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,255); stop-opacity:0&quot; /&gt; &lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(0,0,255);stop-opacity:1&quot; /&gt; &lt;/radialGradient&gt; &lt;/defs&gt; &lt;ellipse cx=&quot;200&quot; cy=&quot;70&quot; rx=&quot;85&quot; ry=&quot;55&quot; fill=&quot;url(#grad1)&quot; /&gt;&lt;/svg&gt; redialGradient 标签的id属性可为渐变定义一个唯一的名称 cx、cy和r属性定义最外层圆，fx和fy定义最内层圆 渐变颜色返回可有两个或两个以上的颜色组成，每种颜色用一个stop标签指定，offset标签用于定义渐变色开始和结束的位置 填充属性把ellipse元素连接到渐变","updated":"2020-07-30T06:42:26.000Z","categories":[],"tags":[{"name":"svg","slug":"svg","permalink":"https://lxx1997.github.io/tags/svg/"}]},{"title":"矢量图形 SVG 学习之路 --- 基础版","path":"2020/07/29/web/svg-study-01/","text":"SVG意为可缩放矢量图形（Scalable Vector Graphics） SVG使用XML格式定义图像 如何定义一个SVG图像 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;path d=&quot;M200 200 C153 334 151 334 151 334 C151 339 153 344 156 344 C164 344 171 339 171 334 C171 322 164 314 156 314 C142 314 131 322 131 334 C131 350 142 364 156 364 C175 364 191 350 191 334 C191 311 175 294 156 294 C131 294 111 311 111 334 C111 361 131 384 156 384 C186 384 211 361 211 334 C211 300 186 274 156 274&quot; style=&quot;fill:white;stroke:red;stroke-width:2;&quot;&gt;&lt;/path&gt;&lt;/svg&gt; 在HTML页面中使用SVG 使用embed标签 标签被所有主流的浏览器支持，并允许使用脚本。 当在 HTML 页面中嵌入 SVG 时使用 标签是 Adobe SVG Viewer 推荐的方法！然而，如果需要创建合法的 XHTML，就不能使用 。任何 HTML 规范中都没有 标签。 1234&lt;embed src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot; type=&quot;image/svg+xml&quot;pluginspage=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt;&lt;!-- pluginspage 属性指向下载插件的 URL。 --&gt; 使用object标签 标签是 HTML 4 的标准标签，被所有较新的浏览器支持。它的缺点是不允许使用脚本。 假如您安装了最新版本的 Adobe SVG Viewer，那么当使用 标签时 SVG 文件无法工作（至少不能在 IE 中工作）！ 1234&lt;object data=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot; type=&quot;image/svg+xml&quot; codebase=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&gt;&lt;!-- codebase 属性指向下载插件的 URL。 --&gt; 使用iframe标签 标签可工作在大部分的浏览器中 1&lt;iframe src=&quot;rect.svg&quot; width=&quot;300&quot; height=&quot;100&quot;&gt;&lt;/iframe&gt; SVG图像图形 svg矩形 svg圆形 svg椭圆 svg线 svg折线 svg多边形 svg路径 style 矩形样式 fill 定义矩形的填充颜色 stroke-width 矩形边框的宽度 stroke 矩形边框的颜色 fill-opacity 定义填充颜色透明度 合法范围 0 - 1 stroke-opacity 定义笔触颜色透明度 合法范围 0 - 1 SVG矩形 rect标签可以用来创建矩形，以及矩形的变种 1234567&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)&quot;/&gt;&lt;/svg&gt; width 矩形的高度和宽度 height 矩形的宽度 x 定义矩形的左侧位置 y 定义矩形的右侧位置 rx ry 属性可使矩形产生圆角 SVG圆形 circle 标签可用来创建一个圆 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt;&lt;/svg&gt; cx, cy 定义圆点的x和y坐标，如果省略cx和cy，圆的中心会被设置为（0,0） r 定义圆的半径 SVG椭圆 ellipse 标签用来创建一个椭圆 椭圆有不同的x和y半径，而圆的x和y的半径是相同的 12345&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;ellipse cx=&quot;240&quot; cy=&quot;100&quot; rx=&quot;220&quot; ry=&quot;30&quot; style=&quot;fill:purple&quot;/&gt; &lt;ellipse cx=&quot;220&quot; cy=&quot;70&quot; rx=&quot;190&quot; ry=&quot;20&quot; style=&quot;fill:lime&quot;/&gt; &lt;ellipse cx=&quot;210&quot; cy=&quot;45&quot; rx=&quot;170&quot; ry=&quot;15&quot; style=&quot;fill:yellow&quot;/&gt;&lt;/svg&gt; cx 定义椭圆中心的x坐标 cy 定义椭圆中心的y坐标 rx 定义椭圆水平半径 ry 定义椭圆垂直半径 SVG直线 line 元素用来创建一个直线 1234&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;200&quot; y2=&quot;200&quot; style=&quot;stroke:rgb(255,0,0);stroke-width:2&quot;/&gt;&lt;/svg&gt; x1 在x轴定义线条开始的地方 y1 在y轴定义线条开始的地方 x2 在x轴定义线条结束的地方 y2 在y轴定义线条结束的地方 SVG多边形 polyline 用来创建含有不少于三个边的图形，多边形是由直线组成的，其形状是封闭的 1234&lt;svg height=&quot;210&quot; width=&quot;500&quot;&gt; &lt;polygon points=&quot;200,10 250,190 160,210&quot; style=&quot;fill:lime;stroke:purple;stroke-width:1&quot;/&gt;&lt;/svg&gt; points 属性定义多边形的每个角的x和y坐标 fill-ruleSVG图片填充规则通过fill-rule来指定 fill-rule 用于指定使用哪一种算法去判断画布上的某区域是否属于该图形内部 nonzero 字面意思上是非零， 按照这个规则 要判断一个点是否在图形内，则从该点做任意方向的一条射线，然后检测射线与图形路径的交点情况，从零开始计数，如果从左向右穿过射线则计数加一，从右到左穿过射线则计数减1 如果结果为0则认为点在图形外部，否则认为在内部 evenodd 字面意思是“奇偶”。按该规则，要判断一个点是否在图形内，从该点作任意方向的一条射线，然后检测射线与图形路径的交点的数量。如果结果是奇数则认为点在内部，是偶数则认为点在外部。 SVG曲线 polyline 用于创建任何只有直线的形状 123456789&lt;!-- 折线型曲线 --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;20,20 40,25 60,40 80,120 120,140 200,180&quot; style=&quot;fill:none;stroke:black;stroke-width:3&quot; /&gt; &lt;/svg&gt;&lt;!-- 楼梯型曲线 --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;polyline points=&quot;0,40 40,40 40,80 80,80 80,120 120,120 120,160&quot; style=&quot;fill:white;stroke:red;stroke-width:4&quot; /&gt; &lt;/svg&gt; SVG路径 path 元素用于定义一个路径 M = moveto 移动到 L = lineto 线路到 H = horizontal lineto 水平线到 V = vertical lineto 垂直线到 C = curveto 曲线 S = smooth curveto 平滑曲线 Q = quadratic Bézier curve 二次Bézier曲线 T = smooth quadratic Bézier curveto 光滑二次Bézier曲线 A = elliptical Arc 椭圆弧 Z = closepath 闭合路径 以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位 1234567891011121314151617181920212223&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;path id=&quot;lineAB&quot; d=&quot;M 100 350 l 150 -300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path id=&quot;lineBC&quot; d=&quot;M 250 50 l 150 300&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 175 200 l 150 0&quot; stroke=&quot;green&quot; stroke-width=&quot;3&quot; fill=&quot;none&quot; /&gt; &lt;path d=&quot;M 100 350 q 150 -300 300 0&quot; stroke=&quot;blue&quot; stroke-width=&quot;5&quot; fill=&quot;none&quot; /&gt; &lt;!-- Mark relevant points --&gt; &lt;g stroke=&quot;black&quot; stroke-width=&quot;3&quot; fill=&quot;black&quot;&gt; &lt;circle id=&quot;pointA&quot; cx=&quot;100&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointB&quot; cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;3&quot; /&gt; &lt;circle id=&quot;pointC&quot; cx=&quot;400&quot; cy=&quot;350&quot; r=&quot;3&quot; /&gt; &lt;/g&gt; &lt;!-- Label the points --&gt; &lt;g font-size=&quot;30&quot; font=&quot;sans-serif&quot; fill=&quot;black&quot; stroke=&quot;none&quot; text-anchor=&quot;middle&quot;&gt; &lt;text x=&quot;100&quot; y=&quot;350&quot; dx=&quot;-30&quot;&gt;A&lt;/text&gt; &lt;text x=&quot;250&quot; y=&quot;50&quot; dy=&quot;-10&quot;&gt;B&lt;/text&gt; &lt;text x=&quot;400&quot; y=&quot;350&quot; dx=&quot;30&quot;&gt;C&lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; SVG文本 text 用于定义文本 123&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;I love SVG&lt;/text&gt;&lt;/svg&gt; x 表示x轴的起始点 y 表示y轴的起始点 transform 动画 SVG 样式设置 Stroke 属性 stroke stroke 属性定义了一条线，文本或元素轮廓颜色 stroke-width 属性定义了线 文本或者元素轮廓的厚度 stroke-linecap 属性定义了不同类型的开放路径的终结 可选参数 butt,round,square 1234567&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;6&quot;&gt; &lt;path stroke-linecap=&quot;butt&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;round&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-linecap=&quot;square&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt; stroke-dasharray 用于创建虚线 12345678&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt; &lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;4&quot;&gt; &lt;path stroke-dasharray=&quot;5,5&quot; d=&quot;M5 20 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;10,10&quot; d=&quot;M5 40 l215 0&quot; /&gt; &lt;path stroke-dasharray=&quot;20,10,5,5,5,10&quot; d=&quot;M5 60 l215 0&quot; /&gt; &lt;/g&gt;&lt;/svg&gt;&lt;!-- 注：stroke-dasharray: [实，虚，实，虚，实，虚，实，虚 ··· ···] --&gt;","updated":"2020-07-29T06:33:53.000Z","categories":[],"tags":[{"name":"svg","slug":"svg","permalink":"https://lxx1997.github.io/tags/svg/"}]},{"title":"浏览器存储方式学习  cookie, session, localstorage, indexedDB","path":"2020/07/22/web/browser-storage-study/","text":"浏览器存储方式 cookie： cookie相当于客户端和服务器之间进行信息交互的一个标识，每次客户端访问服务器的时候都会携带上cookie，这样服务器就可以知道是谁来访问了。 Storage: Storage 是专门为浏览器存储提供的数据存储机制，分为localStorage和sessionStorage, 保存的数据以键值对的形式存在，并且以文本格式保存 indexedDB: indexedDB是运行在浏览器上的非关系型数据库, 一般来说是没有存储上限的, 不仅可以存储字符串, 还可以存储二进制数据 Cookie cookie的本职工作并非本地存储,而是维持状态，它是浏览器存储在用户机器上的一个小文本，大小不能超过4K cookie根据过期时间分为两类：会话cookie和持久cookie 会话cookie是一种临时cookie，当用户退出浏览器，会话cookie就会被删除 持久cookie则会存储在硬盘中，保存时间更长，浏览器关闭并不会删除cookie，通常持久性cookie会维护某一个用户周期性访问服务器配置文件或者登陆信息 访问方式 通过document.cookie来设置或获取cookie的值 产生Cookie的服务器可以向set-Coolie响应首部添加一个domain属性来控制那些站点可以看到这个cookie 1Set-Cookie:name=&quot;losstie&quot;domain=&quot;m.baidu.com&quot; 属性 path参数告诉浏览器cokie的路径，默认情况下，cookie属于当前页面 secure 设置里secure，cookie只有在https协议加密的情况下才会发送给服务端 HttpOnly 禁止javascript操作cookie（避免跨域脚本xss攻击，通过javascript的document.cookie 无法访问带有HttpOnly标记的cookie） 第三方cookie 第三方cookie就是cookie的域和地址栏中的域，这种cookie通常悲痛在第三方广告网站，用于跟踪用户的浏览记录，并根据手机的用户浏览习惯，给用户推送相关广告 劣势 cookie 存储信息少，不能超过4K，当cookie超过4KB是，会面临被裁剪的命运 每次请求都会携带在http头中，过量的cookie会损耗性能 cookie会紧跟域名，同一个域名下的所有请求都会携带cookie 不安全，服务器没法分辨用户和攻击者，攻击者可以读取网络上其他用户信息，包含HTTP Cookie的所有内容，以便进行中间攻击，使用跨站点脚本技术可以窃取cookie Web Storage localStorage localStorage是持久化的本地存储，存储在其中的数据永远不会过期，只能手动删除，遵循同源策略 sessionStorage sessionStorage是临时性的本地存储，会话级别，当页面或者会话结束时，存储内容也随之被释放，遵循同源策略，但是要保证在同一个窗口，否则无法共享内容 12345678910111213// localStorage保存数据：localStorage.setItem(key, value)读取数据：localStorage.getItem(key)移除数据：localStorage.removeItem(key)清除所有数据：localStorage.clear()得到某个索引的key：localStorage.key(index)// sessionStorage保存数据：sessionStorage.setItem(key, value)读取数据：sessionStorage.getItem(key)移除数据：sessionStorage.removeItem(key)清除所有数据：sessionStorage.clear()得到某个索引的key：sessionStorage.key(index) web storage 存储容量大，根据浏览器的不同，存储容量乐意达到5~10M之间 chrome，Firefox，edge都是5M，而且仅位于浏览器端，不与服务端发生通信 indexedDB indexedDB是一个运行在浏览器上的非关系型数据库，一般来说是没有存储上限的，不仅可以存储字符串，还可以存储二进制数据 indexedDB 允许存入大量数据，提供查找接口，还能建立索引，就数据库类型而言，indexedDB 不属于关系型数据库（不支持sql查询语句），更接近NoSQL数据 特点 键值对储存， indexedDB内部采用对象仓库（object store）存放数据 异步，indexedDb操作时不会锁死浏览器，用户依然可以进行其他操作 支持事务，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在之改写一部分数据的情况 同源限制，每一个数据库对应创建他的域名，网页只能访问自身域名下的数据库，而不能访问跨域的数据库 存储空间大 支持二进制存储 操作 1234567891011// 建立打开 indexedDBwindow.indexedDB.open(&#x27;testDB&#x27;)// 关闭indexedDB indexdb.close()// 删除indexedDB indexedDB.deleteDatabase(indexdb) 基本概念 indexedDB是一个比较复杂的API,涉及不少概念，它把不同的实体，抽象成一个个对象接口 数据库 数据库是一系列相关的容器，每个域名（协议+端口+域名）都可以新建任意多个数据库， 同时indexedDB数据库有版本的概念，同一时刻只能有一个版本的数据库存在，如果要修改数据库结构，只能通过升级数据库版本完成 对象仓库 每个数据库包含若干个对象仓库， 类似于关系型数据库的表格 数据记录 对象仓库保存的数据记录，每个记录类似于关系型数据库的行，但是只有逐渐和数据体两部分，主键用来建立默认索引，必须是不同的 索引 为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引 事务 数据记录的读写和删改都要通过事务完成。事务对象提供error,about和complete三个事件，用来监听操作结果 操作流程 打开数据库 12345678910111213141516171819202122232425// 打开数据库var request = window.indexedDB.open(databaseName, version)// 改方法接受两个参数，第一个参数是字符串，表示数据库的名字，如果指定的数据不存在，就会创建新的数据库，第二个是整数，表示数据库版本，如果省略，// indexedDB.open()返回一个IDBRequest对象。这个对象通过三个事件error,success,upgradeneeded 处理数据库的操作结果// error 事件表示打开数据库失败request.onerror = function(event) &#123; console.log(&#x27;数据库打开失败&#x27;)&#125;// success 事件表示成功打开的数据var dbrequest.onsuccess = function(event) &#123; db.request.result console.log(&#x27;数据库打开成功&#x27;)&#125; // success 事件表示成功打开的数据 此时通过request对象的result属性拿到数据库对象var dbrequest.onsuccess = function(event) &#123; db.request.result console.log(&#x27;数据库打开成功&#x27;)&#125; // upgradeneeded 事件如果指定的版本号大于数据的实际版本号，就会发生数据库升级事件 此时通过request对象的result属性拿到数据库对象var db;request.onupgradeneeded = function (event) &#123; db = event.target.result;&#125; 新建数据库 新建数据库和打开数据库是同一个操作，如果指定的数据库不存在就会创建，后续的操作主要是在upgradeneeded事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件 通常新建数据库之后，第一件事是新建对象仓库（即新建表） 1234request.onupgradeneeded = function(event) &#123; db = event.target.result var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;)&#125; 上述代码，数据库新建成功之后，新增一张叫做person的表格，主键是id 更好的写法是先判断一下这张表格是否存在，如果不存在再新建 1234567request.onupgradeneeded = function (event) &#123; db = event.target.result var objectStore; if(!db.objectStoreNames.contains(&#x27;person&#x27;)) &#123; objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;) &#125;&#125; 如果数据记录里面没有适合主键的属性，那么可以让indexedDB自动生成主键 1var objectStore = db.createObjectStore(&#x27;person&#x27;, &#123;autoIncrement: true&#125;) 新建对象仓库之后，可以新建索引 123456request.onupgradeneeded = function(event) &#123; db = event.target.result var objectStore = db.createObejctStore(&#x27;person&#x27;, &#123;keyPath: &#x27;id&#x27;&#125;) objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123;unique: false&#125;) objectStore.createIndex(&#x27;email&#x27;, &#x27;email&#x27;, &#123;unique: false&#125;)&#125; 新增数据 新增数据指的是向对象仓库写入数据记录，这需要通过事务完成 1234567891011121314function add() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;).add(&#123;id: 1, name: &#x27;张三&#x27;, &#x27;age&#x27;: 24, email: &#x27;zhangsan@example.com&#x27;&#125;) request.onsuccess = function (event) &#123; console.log(&quot;数据写入成功&quot;) &#125; request.onerror = function(event) &#123; console.log(&quot;数据写入失败&quot;) &#125;&#125;add() 写入数据需要新建一个事务，新建事务时必须指定表格名称和操作模式(“只读”,”读写”)，新建事务后，通过IDBTransaction.objectStore(name)方法拿到IDBObjectStore对象，在通过表格对象的add()方法，向表格写入一条数据 写入是一个异步操作，通过监听连接对象的success事件和error事件，了解事件是否写入成功 读取数据 读取数据也是通过事务完成 1234567891011121314151617181920function read() &#123; var transaction = db.transaction([&#x27;person&#x27;]) var objectStore = transaction.objectStore(&#x27;person&#x27;) // objectStore.get(1) 参数是主键的值 var request = objectStore.get(1) request.onerror = function(event) &#123; console.log(&quot;事务失败&quot;) &#125; request.onsuccess = function(event) [ if(request.result) &#123; console.log(&#x27;name:&#x27; + request.result.name) console.log(&#x27;age:&#x27; + request.result.age) console.log(&#x27;email:&#x27; + request.result.email) &#125; else &#123; console.log(&#x27;没有获取到数据&#x27;) &#125; ]&#125; 遍历数据 遍历数据表格的所有记录，要使用指针对象IDBCursor 1234567891011121314151617function readAll() &#123; var objectStore = db.transaction(&#x27;person&#x27;).objectStore(&#x27;person&#x27;) objectStore.openCursor().onsuccess = function(event) &#123; var cursor = event.target.result if(cursor) &#123; console.log(&#x27;Id: &#x27; + cursor.key); console.log(&#x27;Name: &#x27; + cursor.value.name); console.log(&#x27;Age: &#x27; + cursor.value.age); console.log(&#x27;Email: &#x27; + cursor.value.email) cusor.continue() &#125; else &#123; console.log(&#x27;没有更多数据了！&#x27;) &#125; &#125;&#125;readAll() 上述代码中，新建指针对象的openCursor()方法是一个异步操作，所以要监听success时间 更新数据 更新数据用IDBObject.put()方法 1234567891011121314function update() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;) .put(&#123;id: 1, name: &#x27;李四&#x27;， age: 35, email: &#x27;lisi@example.com&#x27;&#125;) request.onsuccess = function (event) &#123; console.log(&#x27;数据更新成功&#x27;) &#125; request.onerror = function(event) &#123; console.log(&#x27;数据更新失败&#x27;) &#125;&#125;update() 删除数据 IDBOjectStore.delete()方法用于删除记录 123456789function remove() &#123; var request = db.transaction([&#x27;person&#x27;], &#x27;readwrite&#x27;) .objectStore(&#x27;person&#x27;) .delete(1) request.onsuccess = function (event) &#123; console.log(&#x27;数据删除成功&#x27;); &#125;&#125;remove() 使用索引索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值） 123456789101112131415objectStore.createIndex(&#x27;name&#x27;, &#x27;name&#x27;, &#123; unique: false &#125;);var transaction = db.transaction([&#x27;person&#x27;], &#x27;readonly&#x27;);var store = transaction.objectStore(&#x27;person&#x27;);var index = store.index(&#x27;name&#x27;);var request = index.get(&#x27;李四&#x27;);request.onsuccess = function (e) &#123; var result = e.target.result; if (result) &#123; // ... &#125; else &#123; // ... &#125;&#125; myself understand 使用 window.indexedDB.open(databaseName, version) 创建数据库的时候如果数据库不存在，会触发 onupgradeneeded 方法 如果 创建数据库的时候数据库已存在, 会触发 onsuccess方法 在实际应用中，我们应该先触发一次onupgradeneeded来创建数据库和我们所需要的表 然后在onsuccess方法中实现自己想要实现的方法 表格的增删一般在数据库版本变更的时候操作 即在onupgradeneeded方法中 数据的增删查等操作一般在onsuccess方法中实现，此时不能涉及到数据库版本变更，否则会报错","updated":"2020-07-22T07:27:33.000Z","categories":[],"tags":[{"name":"browser","slug":"browser","permalink":"https://lxx1997.github.io/tags/browser/"},{"name":"localStorage","slug":"localStorage","permalink":"https://lxx1997.github.io/tags/localStorage/"},{"name":"indexedDB","slug":"indexedDB","permalink":"https://lxx1997.github.io/tags/indexedDB/"}]},{"title":"TypeScript 学习之路进阶版 - 扩展","path":"2020/06/29/web/typescript-study-05/","text":"代码检查 eslint 能够发现一些tsc不会关心的错误，检查出一些潜在的问题 TypeScript中使用Eslint eslint安装 1npm install eslint -S 由于ESLint 默认使用Espree进行语法解析，无法识别TypeScript中的一些语法，因此我们需要安装@typescript-eslint/eslint-plugin, 他作为eslint默认规则的补充，提供了一些额外的适用于ts语法的规则 1npm install --save-dev @typescript-eslint/eslint-plugin 创建配置文件 ESLint 需要配置文件来决定对哪些规则进行检查配置文件的名称一般是.eslintrc.js或.eslintrc.json 当运行ESLint的时候检查一个文件，他会首先尝试读取到文件的目录下的配置文件，然后一级一级往上查找，将所找到的配置合并起来 在根目录创建一个.eslintrc.js 12345678910111213module.exports = &#123; parser: &#x27;@typesript-eslint/parser&#x27;, plugins: [&#x27;@typescript-eslint&#x27;], rules: &#123; // 禁止使用var &#x27;no-var&#x27;: &#x27;error&#x27;, // 优先使用interface 而不是type &#x27;@typescript-eslint/consistent-type-difinitions&#x27;: [ &#x27;error&#x27;, &#x27;interface&#x27; ] &#125;&#125; 以上配置中，指定了两个规则，其中no-var 是ESLint原生规则，@typescript-eslint/consistent-type-definitions 是 @typescript-eslint/elsint-plugin 新增的规则 规则的取值一般是一个数组，其中一项是 off,warn,error中的一个，表示关闭，警告和报错，后面的项都是该规则的其他配置 关闭、警告和报错的含义如下： 关闭： 禁用此规则 警告： 代码检查的时候输出错误信息，但是不会影响到exit code 报错： 发现错误时，不仅会输出错误信息而且exit code 将被设为 1（一般exit code 不为0 则表示执行出现错误）","updated":"2020-06-29T11:39:30.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"TypeScript 学习之路进阶版 - 泛型","path":"2020/06/28/web/typescript-study-04/","text":"泛型 泛型是指在定义函数、接口或者类的时候，不预选指定类的具体累心，而是在使用的时候在指定类型的一种特性 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 我们在函数名后添加了&lt;T&gt;, 其中T用来指代任意输入的类型，在后面的输入和输出都可以使用 在调用的时候可以指定他的具体的类型，也可以不指定，而让类型推论自动推算出来 多个类型参数 定义泛型的时候,可以一次定义多个类型参数 12345function swap&lt;T, U&gt;(tuple: [T, U]): [U, T] &#123; return [tuple[1], tuple[0]];&#125;swap([7, &#x27;seven&#x27;]); // [&#x27;seven&#x27;, 7] 输入的&lt;T, U&gt;是元组 泛型约束 在函数内部使用泛型变量的时候，由于事先不知道它是那种类型的，所以不能随意操作它的属性和方法 这时我们可以对泛型进行约束，只允许这个函数传入那些包含length属性的变量 12345678interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); return arg;&#125; 在上面的例子中，我们使用了extends约束了泛型T必须符合接口l的形状，也就是必须包含length属性 多个类型参数之间也可以互相约束 12345678910function copyFields&lt;T extends U, U&gt;(target: T, source: U): T &#123; for (let id in source) &#123; target[id] = (&lt;T&gt;source)[id]; &#125; return target;&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;copyFields(x, &#123; b: 10, d: 20 &#125;); 我们使用了两个类型参数，其中要求T继承于U，这样就保证了U中不会出现T中不存在的字段 泛型接口 1234567891011121314interface CreateArrayFunc&lt;T&gt; &#123; (length: number, value: T): Array&lt;T&gt;;&#125;let createArray: CreateArrayFunc&lt;any&gt;;createArray = function&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, &#x27;x&#x27;); // [&#x27;x&#x27;, &#x27;x&#x27;, &#x27;x&#x27;] 在使用泛型接口的时候，需要定义泛型的类型 泛型类 与泛型接口类似，泛型也可以用于类的类型定义 12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 泛型参数的默认类型 我们可以为泛型中的类型参数指定默认类型，从实际值参数中也无法推测出时，这个默认类型就会起作用 1234567function createArray&lt;T = string&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result: T[] = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125; 声明合并 如果定义了两个相同名字的函数、接口或类，那么它们会合并成一个类型 函数的合并 可以使用重载定义多个函数类型 123456789function reverse(x: number): numberfunction reverse(y:number): stringfunction reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)) &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125; &#125; 接口的合并 接口的属性在合并时会简单的合并到一个接口中 12345678910111213interface Alarm &#123; price: number&#125;interface Alarm &#123; weight: number&#125;// 相当于interface Alarm &#123; price：number; weight: number&#125; 合并的属性的类型必须是唯一的 1234567891011121314interface Alarm &#123; price: number&#125;interface Alarm &#123; price: number weight: number&#125;// 相当于interface Alarm &#123; price：number; weight: number&#125; 假如 price 的类型不一致就会报错 接口中方法的合并与函数的合并一样","updated":"2020-06-28T01:17:07.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"typescript 学习之路进阶版  -  2","path":"2020/06/22/web/typescript-study-03/","text":"类和接口 类实现接口 实现(implements)是面向对象中一个重要概念,一般来讲,一个类只能继承自另一个类,有时候不同类之间可以有一些共有特性,这时候可以把特新提取成接口(interfaces), 用implements关键字来实现,这个特新大大提高了面向对象的灵活性 1234567891011121314151617interface Alarm &#123; alert(): void&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log(&#x27;securityDoor) &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log(&#x27;car&#x27;) &#125;&#125; 一个类可以实现多个接口 12345678910interface Alarm &#123; alert(): void&#125;interface Light &#123; lightOn(): void; lightOff(): void;&#125;class Car implements Alarm, Light &#123;&#125; 接口继承接口 接口与接口之间也可以是继承关系,并拥有继承的方法 123456interface Alarm &#123; alert(): void;&#125;interface Light extends Alarm &#123;&#125; 接口继承类 常见的面向对象语言中,接口是不能继承类的,但是在TypeScript中是可以的 1234567891011121314class Point &#123; x: number; y: number; constructor(x: number, y: number) &#123; this.x = x; this.y = y; &#125;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 当我们在声明 class Point 时,除了会创建一个名为Point的类外,同时也创建了一个名为Point类型(实例的类型) 所以我们既可以将Point当作一个类来用 也可以将Point当作一个类型来用 (使用:Point表示参数的类型) 当我们声明 interface Point3d extends Point的时候,Point3d继承的实际上是类Point的实例的类型,定义了一个接口Point3d继承了另一个接口PointInstaneType 声明point类时创建的Point类型是不包含构造函数的,静态属性和静态方法也是不包含的","updated":"2020-06-22T08:31:39.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"Deno 学习","path":"2020/06/16/node/learn-Deno/","text":"首先我们先谈一下nodeJs的无法忽视的问题 nodeJs对于 ES6的新的语法特性 Promise接口 和async函数 和ES模块 的支持并不理想, NodeJs 必须支持回调函数(callback) 导致异步接口会有promise 和回调函数两种写法,同时NodeJs自己的模块格式 CommonJs和ES模块不兼容 nodeJs 的模块管理工具 npm 的逻辑越来越复杂, 模块安装目录极其庞大,难以管理, nodeJs 几乎没有安全措施,用户只要下载了外部模块,就只好任凭别人代码在本地运行,进行各种读写操作 什么是Deno Deno和nodeJs一样,也是一个服务器运行,但是支持多种语言,可以直接运行在JavaScript,TypeScript和WebAssembly程序 并且内置了V8引擎,用来解释JavaScript,同时,也内置了tsc引擎,解释TypeScript,使用Rust语言开发, 由于Rust原生支持WebAssemly, 所以它也能直接运行WebAssemly Rust 提供了许多现成的模块，对Deno项目来说，可以节约很多开发时间 Deno 只有一个可执行文件，所有操作都通过这个文件完成，支持跨平台 Deno具有安全控制，默认下脚本不具有读写权限，如果脚本未授权就读写文件系统或者网络就会报错，必须使用参数，显示打开权限才可以 1234--allow-read：打开读权限，可以指定可读的目录，比如--allow-read=/temp。--allow-write：打开写权限。--allow-net=google.com：允许网络通信，可以指定可请求的域，比如--allow-net=google.com。--allow-env：允许读取环境变量 Deno支持Web Api 尽量保持和浏览器一致，提供了window这个全局对象，同时支持fetch，webCrypto，worker等web标准，同时也支持onload，onunload，addEventListener等时间的操作函数，另外 Deon的所有异步操作都返回Promise Deno只支持ES模块。和浏览器的模块加载规则一致，没有npm和npm_modules目录，没有require()命令，也不需要package.json所有的模块通过URL加载，比如 import &#123; bar &#125; from &quot;https//foo.com/bar.ts&quot;(绝对URL)或者 import &#123; bar &#125; from &quot;./foo/bar.ts&quot;(相对URL)，因此Deno不需要一个中心化的模块储存系统，可以从任何方式加载模块Deno 下载模块以后，会有一个总的目录，在本地缓存模块，因此可以离线使用 Deno 只支持从URL 加载模块，导致nodeJs 的模块加载写法都会失效，Deno的所有模块都要通过入口脚本加载，不能通过模块名加载，所以必须带有脚本后缀名 Deno 原生支持TypeScript语言，可以直接运行，不必显示转码他的内部会根据文件名后缀判断，如果是.ts后缀名，就先调用TS编译器，将其编译成JavaScript 如果是.js后缀名，就直接传入V8引擎运行 Deno内置了开发中需要的各种功能，不需要外部工具，打包、格式清理、测试、安装、文档生成、liniting、脚本编辑成可执行文件 12345678910deno bundle：将脚本和依赖打包deno eval：执行代码deno fetch：将依赖抓取到本地deno fmt：代码的格式美化deno help：等同于-h参数deno info：显示本地的依赖缓存deno install：将脚本安装为可执行文件deno repl：进入 REPL 环境deno run：运行脚本deno test：运行测试 安装DenoShell (Mac, Linux): 1curl -fsSL https://deno.land/x/install/install.sh | sh PowerShell (Windows): 1iwr https://deno.land/x/install/install.ps1 -useb | iex Homebrew (Mac): 1brew install deno Chocolatey (Windows): 1choco install deno Scoop (Windows): 1scoop install deno Build and install from source using Cargo 1cargo install deno 查看版本 1deno --version 命令行直接deno 就会进入 REPL环境 12345deno&gt; console.log(1,2,3)1 2 3undefined&gt; 运行脚本 123$ deno run \\https://deno.land/std/examples/curl.ts \\https://example.com 上面的例子中， Deno执行远程脚本curl.ts,用这个脚本去抓取网址example.com,但是会提示没有网络通讯权限，给予Deno网络通信权限，就可以顺利执行 123$ deno run --allow-net \\https://deno.land/std/examples/curl.ts \\https://example.com","updated":"2020-06-16T08:25:19.000Z","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://lxx1997.github.io/categories/nodejs/"},{"name":"deno","slug":"deno","permalink":"https://lxx1997.github.io/categories/deno/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://lxx1997.github.io/tags/nodejs/"},{"name":"deno","slug":"deno","permalink":"https://lxx1997.github.io/tags/deno/"}]},{"title":"typescript 学习之路进阶版","path":"2020/06/10/web/typescript-study-02/","text":"类型别名12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === &#x27;string&#x27;) &#123; return n; &#125; else &#123; return n(); &#125;&#125; 类型别名为类型创建新名称。类型别名有时类似于接口，但是可以命名原语，并集，元祖和其他必须手动编写的其他类型。 别名实际上并不会创建新的类型，他会创建一个新名称来引用该类型123456789101112131415161718192021222324type Container&lt;T&gt; = &#123;value: T&#125;// 也可以在属性中使用类型别名来引用自身type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125;// 与交叉点类型一起使用type LinkedList&lt;T&gt; = T &amp; &#123;next: LinkedList&lt;T&gt;&#125;interface Person &#123; name: string&#125;var people: LinkedList&lt;Person&gt;var s = people.namevar s = people.next.namevar s = people.next.next.namevar s = people.next.next.next.name// 但是类型别名不可能出现在声明右侧的任何其他位置 字符串字面量类型123456type EventNames = &#x27;click&#x27; | &#x27;scroll&#x27; | &#x27;mousemove&#x27;function handleEvent(ele: Element, event: EventNames) &#123; // do someting&#125;handleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;scroll&#x27;) // successhandleEvent(document.getElementById(&#x27;hello&#x27;), &#x27;dblclick&#x27;) // error 我们使用type定了一个字符串字面量类型EventNames, 它只能取三种字符串中的一种类型别名与字符串字面量类型都是使用type进行定义 可以使用相同的方式使用字符串文字类型来区分重载12345function createElement(tagName: &#x27;img&#x27;): HTMLImageElementfunction createElement(tagName: &#x27;input&#x27;): HTMLIputElementfunction createElement(tagName: &#x27;string&#x27;): Element &#123;&#125; 元组数组合并了相同类型的对象，而元组(Tuple)合并了不同类型的对象 eg:1let tom: [string, number] = [&#x27;Tom&#x27;, 25]当赋值或访问一个已知的索引元素时,会得到正确的类型也可以只赋值其中一项 12let tom: [string, number]tom[0] = &#x27;Tom&#x27; 如果直接对元组类型的变量进行初始化或者赋值的时候,需要提供所有的元组类型中指定的项 当添加越界的元素时,它的类型会被限制为元组的每个类型的联合类型 枚举 Enum枚举类型用于取值被限定在一定范围内的场景,比如一周只能有七天,颜色限定为红绿蓝等 eg:枚举定义 使用enum定义1234567enum Days &#123;Sun, Mon, Tue, Web, Thu, Fri, Sat&#125;// 枚举成员会被赋值从0开始递增的数字,同时也会对枚举值到枚举名进行反向映射Days[&#x27;Sun&#x27;] === 0 // trueDays[0] === &#x27;Sun&#x27; // true 手动赋值 我们也可以手动给枚举项赋值 12enum Days &#123;Sun = 7, Mon = 1, Tue, Wed, Thu, Fri, Sat&#125;// 未手动赋值的枚举项会接着上一个枚举项递增 如果手动赋值的枚举项与自动赋值的枚举项重复了,并不会报错 手动赋值的枚举项可以不是数字,但是需要使用类型断言来无视类型检查 常数项和计算所得项 枚举有两种类型: 常数项和计算所得项 1enum Color &#123;Red, Green, Blue = &#x27;blue&#x27;.length&#125; 上面 &#39;blue&#39;.length就是一个计算所得项 如果紧接在计算所得项后面是未手动赋值的项,那么会因为无法获得初始值而报错 常数枚举 1234567const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Direction.Left, Direction.Down] 常数枚举与普通枚举的区别是,它会在编译阶段被删除,并且不能包含计算成员 上述编译的结果是: 1var directions = [0 /* Up */ , 1 /* Up */, 2 /* Up */, 3 /* Up */] 如果在定义的时候包含了计算成员,则会在编译阶段报错 外部枚举 外部枚举 是使用declare enum 定义的枚举类型 1234567declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Direction.Left, Direction.Down] 同时使用declare 和const也是可以的 类类的概念 类：定义了一件事物的抽象特点，包含他的属性和方法 对象：类的实例，通过new生成 面对对象（OPP）三大特性： 封装、继承、多态 封装（Encapsulation）：将对数据的操作细节隐藏起来，质保楼对外的接口，外界调用端不需要知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Poluymorphism）：由继承而产生的不同的类，对同一个方法可以有不同的响应，程序会自动判断应该如何执行 存取器(getter &amp; setter): 用于改变属性的读取和赋值行为 修饰符(Modifiers): 修饰符是一些关键字,用于限定成员或类型的性质,比如public表示共有属性和方法 抽象类(Abstract Class): 抽象类是供其他继承的基类,抽象类不允许被实例化,抽象类中的抽象方法必须在子类中被实现 接口(interface): 不同类之间巩固偶的属性和方法可以抽象成一个接口,接口可以被类实现,一个类只能继承自另一个类,但是可以实现多个接口 ES6中类的用法 属性和方法 使用class定义类,使用constructor定义构造函数 通过new 生成新实例的时候,会自动带调用构造函数 类的继承 使用extends 关键字实现继承,子类通过super关键字调用父类的构造函数和方法 123456789class Cat extends Animal &#123; constructor(name) &#123; super(name); console.log(this.name) &#125; sayHi() &#123; return super.sayHi() &#125;&#125; 存取器 使用getter和setter可以改变属性的赋值和读取行为 1234567891011class Animal &#123; constructor(name) &#123; this.name = name &#125; get name() &#123; return &#x27;jack&#x27; &#125; set name(value) &#123; console.log(&#x27;setter:&#x27; + value) &#125;&#125; 静态方法 使用static修饰符修饰的方法称为静态方法,不需要实例化,而是直接通过类来调用 12345678class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal &#125;&#125;let a = new Animal(&#x27;Jack)Animal.isAnimal(a) // truea.isAnimal(a) // TypeError ES7中类的用法 实例属性 ES6中实例的属性只能通过构造函数中的this.xxx来定义,ES7可以直接在类里面定义 123456789// ES7class Animal &#123; name = &#x27;Jack&#x27;; constructor() &#123; // TODO something &#125; let a = new Animal()&#125; 静态属性 可以用static 定义一个静态属性 12345678// ES7class Animal &#123; static name = &#x27;Jack&#x27;; constructor() &#123; // TODO something &#125; let a = new Animal()&#125; TypeScript中使用类 public private和protect TypeScript中可以使用三种访问修饰符分别是public,private,protected public修饰的属性或方法是共有的,可以在任何地方被访问,默认所有的属性和方法都是public的 private修饰的属性和方法是私有的,不能在声明它的类的访问’ protected修饰的属性和方法是受保护的,它和private类似,区别是在子类中也是允许被访问的 当构造函数constructor修饰为private时,该类不允许被继承或者实例化当构造函数constructor修饰为protected时, 该类只允许被继承 参数属性 修饰符和readonly还可以使用构造函数参数中,等同于类中定义该属性的同时给该属性赋值,使代码更简洁 12345class Animal &#123; public construtor(public name) &#123; // 等同于 this.name = name &#125;&#125; readonly 只读属性关键字,只允许出现在属性声明或索引签名或构造函数中如果readonly和其他修饰符同时存在的话,需要写在后面 抽象类 abstract用于定义抽象类和其中的抽象方法 抽象类是不允许被实例化的 如果定义了一个抽象类,并且定义了一个抽象方法sayHi, 在实例化抽象类的时候报错 抽象类中的抽象方法必须被子类实现,如果继承了抽象类,却没有实现抽象类中的抽象方法,就是编译报错 正确使用抽象类 123456789101112131415abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;class Cat extends Animal &#123; public sayHi() &#123; console.log(`Meow, My name is $&#123;this.name&#125;`); &#125;&#125;let cat = new Cat(&#x27;Tom&#x27;); 类的类型给类加上TypeScript的类型 123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal(&#x27;Jack&#x27;);console.log(a.sayHi()); // My name is Jack","updated":"2020-06-10T02:57:48.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"python学习之路----制作小游戏","path":"2020/06/04/use-python-create-game/","text":"安装pygame 1pip install pygame 引入12import pygamefrom pygame.locals import *初始化1pygame.init() 创建一个窗口12screen = pygame.display.set_mode([800,600])// 生成一个 宽800 高600大小的窗口使窗口正常工作1234567// pygame的作用就是为了创建游戏,需要与玩家不断互动,所以需要一个事件一直循环运行,使用while 执行事件循环while True:// 接下来增加事件处理器,pygame包含多种模块,使用paygame.event.get()方法获取所有事件的一个列表,使用for循环迭代处理这个列表中的每一个事件,如果看到quit事件,将while 判断设为false 结束while循环for event in pygame.event.get(): if event.type == pygame.QUIT: mRuning = False pygame.quit() 翻转 flip对于pygame窗口显示的内容，screen对象中都会有这些内容的两个副本，可以看做一个当前屏和一个下一屏，当前屏使我们现在看到的，下一屏是完成翻转之后看到的,完成下一屏上的所有修改,再反转到下一屏,就能看到所有的改变,这样,我们对图形多次修改后flip到图形的新版本,而不是每次对图形做小小修改都更新提示,从而让动画更流程,更新速度更快 12screen.fill([255,255,255])pygame.display.flip() 插入图片 pygame.image 1234imageRect = pygame.image.load(imageUrl)# 图片加载完成之后,我们需要将像素从一个地方复制到另一个地方,像素复制在编程中叫做 快移(blitting),帮助我们将一个图像从一个地方复制到另一个地方screen.blit(imageRect, [0,0]) 音乐播放器 pygame中有一个处理声音的模块,叫 pygame.mixer (混音器)12soundTrack = pygame.mixer.music.load(wavFileName)pygame.mixer.music.play() 事件处理器 在上面通过pygame,event.get() 获取到当前事件集 12345678# 退出event.type == pygame.QUIT# 键盘事件event.type == pygame.KEYDOWN or pygame.KEYUP # 判断键盘值 eg: d键 event.key == K_d # 鼠标事件 鼠标点击事件event.type == pygame.MOUSEBUTTONDOWN pygame 模块模块名 | 功能pygame.down | 访问光驱pygame.cursors | 加载光标pygame.display | 访问设备显示问题pygame.draw | 绘制形状,线和点pygame.event | 管理事件pygame.font | 使用字体pygame.image | 加载和存储图片pygame.joystick | 使用手柄或类似的东西pygame.key | 读取键盘按键pygame.mixer | 读取声音pygame.mouse | 鼠标pygame.movie | 播放视频pygame.music | 播放音频pygame.overlay | 访问高级视频叠加pygame.rect | 管理矩形区域pygame.sndarray | 操作声音数据pygame.sprite | 操作移动图像pygame.surface | 管理图像和屏幕pygame.time | 管理时间和帧消息pygame.transform | 缩放和移动图像 有些模块可能在某些平台上不存在,可以用None来测试123if pygame.transform is None: print &#x27;The transform module is not available&#x27; exit()","updated":"2020-06-04T09:38:00.000Z","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://lxx1997.github.io/tags/python/"},{"name":"pygame","slug":"pygame","permalink":"https://lxx1997.github.io/tags/pygame/"}]},{"title":"用typescript来写eggjs","path":"2020/05/27/node/egg-typescript/","text":"由于用javasript的某种限制和不足，所以决定使用typescript来写eggjs 初始化typescript1npm init egg --type=ts 使用数据库1npm i --save egg-sequelize mysql2 /config/plugins.ts1234sequlize: &#123; enable: true, package: &#x27;egg-sequelize&#x27;, &#125;,/config/config.default.ts12345678config.sequelize = &#123; dialect: &#x27;mysql&#x27;, host: &#x27;localhost&#x27;, port: 3306, password: &#x27;123456&#x27;, database: &#x27;eic-egg&#x27;, timezone: &#x27;+08:00&#x27;, &#125;;","updated":"2020-05-27T01:41:28.000Z","categories":[],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/tags/eggjs/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"eggjs 配置swagger-ui","path":"2020/05/26/node/egg-swagger-ui/","text":"如何在eggjs中搭建一个swagger-ui接口预览文档?下面这篇文章将会教你如何搭建swagger-ui参考文章 安装egg-swagger-doc 插件1npm install egg-swagger-doc -S 配置egg-swagger-doc 默认配置 1234567891011121314151617181920212223242526272829303132333435363738394041// plugin.js or plugin.tsconfig.swaggerdoc: &#123; enable: true, // 是否启用。 package: &#x27;egg-swagger-doc&#x27;, // 指定包名称。 &#125;// config.default.js or config.default.ts// egg-swagger-doc 配置信息。 exports.swaggerdoc = &#123; dirScanner: &#x27;./app/controller&#x27;, // 配置自动扫描的控制器路径。 // 接口文档的标题，描述或其它。 apiInfo: &#123; title: &#x27;NAPI&#x27;, // 接口文档的标题。 description: &#x27;swagger-ui for NAPI document.&#x27;, // 接口文档描述。 version: &#x27;1.0.0&#x27;, // 接口文档版本。 &#125;, schemes: [ &#x27;http&#x27;, &#x27;https&#x27; ], // 配置支持的协议。 consumes: [ &#x27;application/json&#x27; ], // 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html。 produces: [ &#x27;application/json&#x27; ], // 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。 securityDefinitions: &#123; // 配置接口安全授权方式。 // apikey: &#123; // type: &#x27;apiKey&#x27;, // name: &#x27;clientkey&#x27;, // in: &#x27;header&#x27;, // &#125;, // oauth2: &#123; // type: &#x27;oauth2&#x27;, // tokenUrl: &#x27;http://petstore.swagger.io/oauth/dialog&#x27;, // flow: &#x27;password&#x27;, // scopes: &#123; // &#x27;write:access_token&#x27;: &#x27;write access_token&#x27;, // &#x27;read:access_token&#x27;: &#x27;read access_token&#x27;, // &#125;, // &#125;, &#125;, enableSecurity: false, // 是否启用授权，默认 false（不启用）。 // enableValidate: true, // 是否启用参数校验，默认 true（启用）。 routerMap: true, // 是否启用自动生成路由，默认 true (启用)。 enable: true, // 默认 true (启用)。 &#125;; 配置忽略token验证1234config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/login&#x27;, &#x27;/public/&#x27;, &#x27;/api/v1/register&#x27;, &#x27;/swagger-ui.html&#x27;, &#x27;/swagger-doc&#x27;, &#x27;/swagger-ui.css&#x27;, &#x27;/swagger-ui-bundle.js&#x27;, &#x27;/swagger-ui-standalone-preset.js&#x27; ], &#125; 接口配置123456789101112131415161718192021/** * @summary 添加小说。 * @description 添加小说接口. * @Router post /api/v1/novels * @Request query string name 文章名 * @Request query string sex 性别分类 * @Request query string type 文章分类 * @Request query string desc 小说简介 */ public async create() &#123; const &#123; ctx &#125; = this; const userid = await ctx.service.users.getIdFromToken(ctx); // const index = await ctx.service.chapters.getChapterIndex(); const body = ctx.request.body; const result = await ctx.service.novels.createNovel(&#123; ...body, userid &#125;); if (result) &#123; ctx.body = Object.assign(&#123;&#125;, Code.SUCCESS, &#123; data: result &#125;); &#125; else &#123; ctx.body = Object.assign(&#123;&#125;, Code.NORMAL_ERROR(&#x27;小说保存失败&#x27;)); &#125; &#125;查看结果","updated":"2020-05-26T02:00:40.000Z","categories":[],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/tags/eggjs/"},{"name":"swagger-ui","slug":"swagger-ui","permalink":"https://lxx1997.github.io/tags/swagger-ui/"}]},{"title":"D3.js的学习之路","path":"2020/05/07/d3-study-20200507/","text":"引入html中引入1&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/d3/5.16.0/d3.js&quot;&gt;&lt;/script&gt; 核心函数d3.js是链式操作,和promise结构类似,函数执行的返回值都是函数本身 选择器选择元素 D3提供了两种方法来选择元素 d3.select() 返回单元素选择结果,没有匹配的则返回空,多个匹配只返回第一个匹配的元素 d3.select(selector) d3.select(node) 选中指定节点,如果已经引用了一个节点.例如时间监听器的d3.select(this),或者一个全局对象,例如document.body,这个函数不会便利DOM树 d3.selectAll() 返回选中的所有元素,按照文档的遍历顺序,从上到下选择,如果文档中没有匹配的元素则返回空的选择 d3.selectAll(selector) d3.selectAll(nodes) 如果有元素已被引用,例如事件监听器中的d3.selectAll(this.childNodes),或者一个全局的document.links,节点参数不用恰好是数组,任何可以被转换为数据的伪数组都可以,这个函数不会遍历DOM树 操作选择 选择是一组元素,D3绑定额外的方法到数组上面,可以在选中的元素上进行操作,每一个细微的差别都是选择结果的分组,每一个选择都是元素数组中的一个数组,一个单一的元素选择看起来像[[node]] 而不是[node] selection.attr(name[,value])如果指定了value参数,将为所有选中的元素通过指定的name为指定的value设置属性,如果value是一个常数,那么所有的元素都将设置为同样的属性值;如果value是一个函数,那么将会为没有选中的元素计算,入参是当前元素d和当前索引i以及代表当前DOM元素的this上下文,这个函数的返回值接下来用来设置每个元素的属性,null值将一处指定的属性.如果value参数没有指定，就会返回为选择中第一个非空（null）元素所指定的属性值。一般来说，只有当你知道选择中恰好包含一个元素时才有用指定的name参数也会含有一个前缀，例如xlink:href是用来指定Xlink命名空间中href属性的。默认情况下，D3支持svg、xhtml、xlink、xml和 xmlns命名空间。可以添加d3.ns.prefix来注册其他的命名空间 selection.classed(name[,value])selection.classed(&#39;foo&#39;, true)selection.classed(&#39;foo bar&#39;, true)selection.classed(&#123;&#39;foo&#39;, true, &#39;bar&#39;: true&#125;)设置class属性值的便捷程序,他能识别class属性是一个按照空格分隔的标记集合,这样就能使用classList来方便地添加,移除,和切换css类 selection.style(name[,value[,priority]])selection.style(&#123;&#39;stroke&#39;: &#39;black&#39;, &#39;stroke-width&#39;: 2&#125;) selection.property(name[,value])selection.property(&#123;&#39;checked&#39;:true,&#39;disabled&#39;: false&#125;); selection.text([value]) selection.html([value]) selection.appent(name)在当前选择的每个元素最后追加具有指定名称的新元素,返回包含追加元素的新选择 selection.inser(name[,before])在当前选择和指定的before选择器匹配的每个元素之前插入具有指定name的心愿,返回包含插入的元素的新的选择,如果before选择器不匹配任何元素,将会用append追加为最后一个子元素,子元素继承当前元素的数据 selection.remove()删除当前文档当前选中该的元素,返回屏幕外的当前选择,从DOM分离,但是目前被删除的元素无法重新添加,但是可以用append和insert重新添加元素 数据 selection.data([values,[,keys]]) 链接指定的一组数据和当前选择,指定的values是一组数据值,或者一个函数返回的一组值,如果没有指定key函数,则values的第一个数据被分配到当前选择中的第一个元素,第二个数据分配给但钱选择的第二个元素,依次类推.12345678910111213141516171819202122232425262728 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/d3/5.16.0/d3.js&quot;&gt;&lt;/script&gt; &lt;title&gt;d3.js - 图形操作工具&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var matrix = [ [11975, 5871, 8916, 2868], [ 1951, 10048, 2060, 6171], [ 8010, 16145, 8090, 8045], [ 1013, 990, 940, 6907]];var tr = d3.select(&quot;body&quot;).append(&quot;table&quot;).selectAll(&quot;tr&quot;) .data(matrix) .enter().append(&quot;tr&quot;);var td = tr.selectAll(&quot;td&quot;) .data(function(d) &#123; return d; &#125;) .enter().append(&quot;td&quot;) .text(function(d) &#123; return d; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; selection.enter()返回输入(enter)选择:当前选择中存在但是当前DOM元素中还不存在的每个数据元素的占位符节点,此方法只由data运算符返回的更新选择中定义,输入选择只定义了append,insert,select,call,你必须在使用这些操作符修改任何内容之前实例化输入元素 123456789101112 d3.select(&quot;body&quot;).selectAll(&quot;div&quot;) .data([4, 8, 15, 16, 23, 42]) .enter().append(&quot;div&quot;) .text(function(d) &#123; return d; &#125;);// 效果&lt;div&gt;4&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;div&gt;15&lt;/div&gt;&lt;div&gt;16&lt;/div&gt;&lt;div&gt;23&lt;/div&gt;&lt;div&gt;42&lt;/div&gt; 另一种方式考虑进入的占位符节点,他们是执行父节点,但是只支持追加和插入 12345var update_sel = svg.selectAll(&quot;circle&quot;).data(data)update_sel.attr(/* operate on old elements only */)update_sel.enter().append(&quot;circle&quot;).attr(/* operate on new elements only */)update_sel.attr(/* operate on old and new elements */)update_sel.exit().remove() /* complete the enter-update-exit pattern */ selection.exit()返回退出选择,找出在当前选择存在的DOM元素中没有新的数据方法,将现有的元素数组和一个含有新的和旧的新数组绑定1var div = d3.select(&quot;body&quot;).selectAll(&quot;div&quot;).data([1,2,4,8,16,32], function (d) &#123;return d&#125;) 离开这些元素原样,我们可以实例化并使用enter选择添加新的元素[1,2,32] 1div.enter().append(&quot;div&quot;).text(function(d) &#123;return d&#125;) 删除退出的元素: div.exit().remove() 123456 &lt;div&gt;4&lt;/div&gt;&lt;div&gt;8&lt;/div&gt;&lt;div&gt;16&lt;/div&gt;&lt;div&gt;1&lt;/div&gt;&lt;div&gt;2&lt;/div&gt;&lt;div&gt;32&lt;/div&gt; 使用索引将生成的元素和序列对上 1div.selectAll(&quot;div&quot;).attr(&quot;index&quot;, function(d,i) =&gt; &#123;return i&#125;) 运行结果 123456 &lt;div index=&quot;2&quot;&gt;4&lt;/div&gt;&lt;div index=&quot;3&quot;&gt;8&lt;/div&gt;&lt;div index=&quot;4&quot;&gt;16&lt;/div&gt;&lt;div index=&quot;0&quot;&gt;1&lt;/div&gt;&lt;div index=&quot;1&quot;&gt;2&lt;/div&gt;&lt;div index=&quot;5&quot;&gt;32&lt;/div&gt; selection.filter(selector) 1var odds = selection.filter(function(d, i) &#123; return i &amp; 1; &#125;); selection.sort([comparator]) selection.order()","updated":"2020-05-07T01:22:16.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"d3.js","slug":"d3-js","permalink":"https://lxx1997.github.io/tags/d3-js/"},{"name":"html","slug":"html","permalink":"https://lxx1997.github.io/tags/html/"}]},{"title":"使用canvas绘制碰撞球","path":"2020/05/06/web/js-canvas-bubble/","text":"实现步骤 绘制canvas，并将canvas的宽高设置为品目的宽高 由于canvas是行内元素，行内元素一般都有自己的行高等，所以一般会出现横向滚动条，此时需要将canvas设置为块级元素或者行内块状元素 设置canvas的宽高跟随屏幕大小的变化而变化，使用window.onresize监听屏幕变化 设置画布属性(canvas.getContext() 2d or 3d) 填充颜色 (canvas.fillStyle()) 首先绘制出一个圆形，设置圆心位置，半径，和园的角度 canvas.arc(x,y,r,deg1,deg2,true/false) canvas.fillStyle() 填充颜色 将绘制圆形的方法进行封装成一个类，通过调用这个类来循环生成圆形 绘制圆形的运行轨迹，在封装好的类的基础上添加一个移动方法，然后设置定时器，每隔固定时间清除canvas并重新绘制 调整圆形运行轨迹，当圆形触边的时候，使圆形发生反弹 触及x轴，y的移动方向相反，触及y轴，x轴的移动方向相反 实现代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;canvas-球体运动&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #canvas &#123; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt; &lt;script&gt; const canvas = document.querySelector(&#x27;#canvas&#x27;) const w = window.innerWidth const h = window.innerHeight canvas.width = w canvas.height = h const ct = canvas.getContext(&quot;2d&quot;) ct.fillStyle=&quot;white&quot; ct.fillRect(0,0,w,h) let bubbleArray = [] class Bubble &#123; constructor() &#123; this.init() &#125; init() &#123; this.r = Math.random() * 5 + 3 this.x = Math.random() * w this.y = Math.random() * h this.xt = Math.random() * 2 &lt; 1 ? -Math.random() * 2 - 1 : Math.random() * 2 + 1 this.yt = Math.random() * 2 &lt; 1 ? -Math.random() * 2 - 1 : Math.random() * 2 + 1 this.color = `rgb($&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;,$&#123;Math.random() * 255&#125;)` &#125; drawer() &#123; ct.beginPath() ct.arc(this.x,this.y,this.r,0, Math.PI*2) ct.fillStyle=this.color ct.fill() &#125; move() &#123; if(this.x+this.r &gt;= w || this.x - this.r &lt; 0) &#123; this.xt = -this.xt &#125; if(this.y+this.r &gt;= h || this.y - this.r &lt; 0) &#123; this.yt = -this.yt &#125; this.x += this.xt this.y += this.yt this.drawer() &#125; &#125; for (let i = 0; i &lt; 500; i++) &#123; const buble = new Bubble() buble.init() buble.drawer() bubbleArray.push(buble) &#125; setInterval(() =&gt; &#123; ct.clearRect(0,0,w,h) for (let i = 0; i &lt; bubbleArray.length; i++) &#123; bubbleArray[i].move() &#125; &#125;,10) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","updated":"2020-05-06T02:48:06.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"canvas","slug":"canvas","permalink":"https://lxx1997.github.io/tags/canvas/"}]},{"title":"javascript之arguments.callee","path":"2020/05/05/web/js-arguments-callee/","text":"arguments.callee 在哪个函数中执行，它就代表哪个函数，通常用于匿名函数中在匿名函数中，有时需要自己调用自己，但是由于是匿名函数，没有名字，无法调用，这时可以用arguments.callee来代替匿名的函数 1234567(function(n) =&gt; &#123; if(n &gt; 1) &#123; return n * arguments.callee(n-1) &#125; else &#123; return n &#125;&#125;)() or123456789// 也是立执行函数的一种~~function(n) =&gt; &#123; if(n &gt; 1) &#123; return n * arguments.callee(n-1) &#125; else &#123; return n &#125;&#125;() 计算n的阶乘","updated":"2020-05-05T02:59:56.000Z","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"js 判断图片是否完全加载完成","path":"2020/05/05/web/js-img-onload/","text":"原文网址在日常写代码的时候，我们有时候会遇到当图片未加载完成时，会发生高度塌陷，如果这个时候我们获取元素高度的时候获取到的不是元素真正的高度，会造成样式紊乱 window.onload 和ready的区别图片从网络环境下载到本地是需要时间的，当图片灭有下载完的时候，使用js获取到元素的宽高将是0 jquery中的ready方法只是dom元素结构加载完成，便视为完全加载完成，但是此时图片并未加载完成，此时宽高还是0 js的window.onload是指dom生成和资源加载出来后才会执行onload函数 方法一123$(&#x27;img&#x27;).load(function() &#123;&#125;) 缺点是每加载一个图片，回调函数就会执行一次 方法二123456var imgNum = $(&#x27;img&#x27;).length$(&#x27;img&#x27;).load(function() &#123; if(imgNum) &#123; // 加载完成执行方法 &#125;&#125;) 缺点是由于图片是从缓存文件里面拿，load方法根本不执行，只有请求新图片的时候才会走load 方法三利用图片未加载完成时宽高为0来判断图片加载情况123456789101112131415161718192021222324252627282930var t_img; // 定时器var isLoad = true; // 控制变量// 判断图片加载状况，加载完成后回调isImgLoad(function()&#123; // 加载完成&#125;);// 判断图片加载的函数function isImgLoad(callback)&#123; // 注意我的图片类名都是cover，因为我只需要处理cover。其它图片可以不管。 // 查找所有封面图，迭代处理 $(&#x27;.cover&#x27;).each(function()&#123; // 找到为0就将isLoad设为false，并退出each if(this.height === 0)&#123; isLoad = false; return false; &#125; &#125;); // 为true，没有发现为0的。加载完毕 if(isLoad)&#123; clearTimeout(t_img); // 清除定时器 // 回调函数 callback(); // 为false，因为找到了没有加载完成的图，将调用定时器递归 &#125;else&#123; isLoad = true; t_img = setTimeout(function()&#123; isImgLoad(callback); // 递归扫描 &#125;,500); // 我这里设置的是500毫秒就扫描一次，可以自己调整 &#125;&#125;","updated":"2020-05-05T02:01:12.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"}]},{"title":"javascript 全局函数","path":"2020/05/05/web/js-global-function/","text":"全局函数 decodeURI() 解码某个编码的URI encodeURI() 把字符串编码为URI decodeURIComponent() 解码一个编码的URI组件 encodeURIComponent() 把字符串编码为URI组件 escape() 对字符串进行编码 eval() 计算javascript字符串并把它作为脚本来执行 isFinite() 检查某个值是否为有穷大的数 isNaN() 检查某个值是否是数字 Number() 把对象的值转化为数字 parseFloat() 解析一个字符串并返回一个浮点数 parseInt() 解析一个字符串并返回一个整数 String() 把对象的值转为字符串 unescape() 对由escape()编码的字符串进行解码","updated":"2020-05-04T16:38:13.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"decode","slug":"decode","permalink":"https://lxx1997.github.io/tags/decode/"}]},{"title":"Array 数组操作","path":"2020/05/05/web/js-array-method/","text":"Array 对象方法 concat() 连接两个或者更多的数组，并返回结果 copyWithin(target, start, end) 将数组的指定位置拷贝元素到数组的另一个指定位置中 （target 指的是元素复制的位数， start指的是元素开始复制的位置，end指的是元素结束复制的位数） entries() 返回一个数组的迭代对象，包含数组的键值对[index, vlaue] every() 检测数组元素的每个元素是否符合条件，如果都满足条件， 返回true，如果不满足返回false some() 检测数值中某个元素是否符合条件，如果有一个符合，返回true，如果全不符合，返回false fill() 使用一个固定值来填充数组 filter() 用于筛选数组，返回符合条件的一个新的数组 find() 返回符合传入测试的数组元素 findIndex() 返回符合传入测试数组元素的索引 forEach() 数组的每一个元素都执行一次回调函数 map() 循环遍历数组中的每一个值，可以用于修改数组 from() Array.from() 通过给定的对象创建一个数组 indexOf() 搜索数组中国的元素，并返回所在位置 includes() 判断一个数组是否包含一个指定的值 isArray() 判断对象是否是数组 join() 把数组中的元素以某个标识拼接为字符串 keys() 返回数组的可迭代对象，包含原始数组的键(key) lastIndexOf() 搜索数组中的元素，并返回它最后出现的位置 pop() 删除数组中的最后一个元素，并返回删除的元素 push() 向数组的末尾添加一个或多个元素，并返回新的长度 reduce() 计算元素，可以用于计算数组，筛选，遍历，从左到右 reduceRight() 计算元素，可以用于计算数组，筛选，遍历，从右到左 reverse() 反转数组的元素顺序 shift() 删除并返回数组的第一个元素 slice(start, end) 选取数组的一部分，并选取一个新数组 sort() 对元素数组进行排序， 可以自定义排序规则 splice(index, many, item) 从数组中添加和删除元素 toString() 将数组转化为字符串，并返回结果 unshift() 向数组开头添加一个或多个元素，并返回新的长度 valueOf() 返回数组对象的原始值","updated":"2020-05-04T16:36:09.000Z","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://lxx1997.github.io/tags/JavaScript/"},{"name":"array","slug":"array","permalink":"https://lxx1997.github.io/tags/array/"}]},{"title":"从零开始搭建vue的webpack运行环境","path":"2020/05/05/vue/vue-webpack-build/","text":"初始化 运行环境12npm init -y// 初始化package.json文件 安装 (webpack和webpack-dev-server)12// 安装webpack和webpack-dev-servernpm install -S webpack webapck-dev-server 配置package.json 和webpack.config.js1234567// package.json&quot;script&quot;: &#123; // 本地运行环境 执行命令 npm run dev &quot;dev&quot;: &quot;webpack-dev-server --open --config webpack-dev-server&quot;, // 打包命令 npm run build &quot;build&quot;: &quot;webpack&quot;&#125; 入口配置和出口环境配置12345678910111213// webpack.config.jsconst path = require(&quot;path&quot;)const config = &#123; entry: &#123; // 入口js配置 app: &#x27;./mian.js&#x27; &#125;, output: &#123; path: path.join(__dirname, &#x27;./dist&#x27;), pubilcPath: &#x27;/dist/&#x27;, filename: &#x27;./app.js&#x27; &#125;&#125; css样式输出配置123456789101112// 安装css-loader style-loadernpm install -S css-loader style-loader// webpack.config.jsmodule: &#123; rules:[ &#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;] &#125; ]&#125; 温馨提示： 在配置文件中的modules对象的rules属性中，可以指定一系列的loaders,每个loader都必须包含test和use两个选项，当webpack编译过程中遇到require和import语句导入一个为.css的文件，将它通过css-loader转换，再通过style-loader转换，然后继续打包，use选项的值可以是数组或者字符串，如果是数组，编译顺序就是从后往前编译 配置 将css整合并生成main.css文件1234567891011121314151617181920212223242526272829// 安装 extract-text-webpack-plugin插件npm install -S extract-text-webpack-plugin// webpack.config.js 配置extract-text-webpack-plugin&#123; // 引入extract-text-webpack-plugin const ExtractTextPlugin = require(&quot;extract-text-webpack-plugin&quot;) module: &#123; rules:[ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;style-loader&#x27; &#125;) &#125; ] &#125; plugins: [ // 将整合后的css全部集中到dist目录下的mian.css文件中 new ExtractTextPlugin(&quot;mian.css&quot;) ]&#125;// 问题解决error： Use Chunks.groupsIterable and filter by instanceof Entrypoint insteadmethod： extract-text-webpack-plugin版本过低，安装最新版本的extract-text-webpack-plugin// 安装命令npm install --save-dev extract-text-webpack-plugin@4.0.0-beta.0 在webpack中配置vue-loader对.vue格式的文件进行处理​ .vue文件需要安装vue-loader, vye-style-loader ​ es6语法需要安装babel-loader和babel 123456789101112// 安装配置文件npm install --save vuenpm install --save-dev vue-loadernpm install --save-dev vue-style-loadernpm install --save-dev vue-template-compilernpm install --save-dev vue-hot-reload-apinpm install --save-dev babelnpm install --save-dev babel-loadernpm install --save-dev babel-corenpm install --save-dev babel-plugin-transform-runtimenpm install --save-dev babel-preset-es2015npm install --save-dev babel-runtime 123456789101112131415161718192021222324252627282930313233// webpack.config.js 进行配置const VueLoaderPlugin = require(&#x27;vue-loader/lib/plugin&#x27;)module: &#123; rules: [ &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;style-loader&#x27; &#125;) &#125;, &#123; test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loader: &#123; css: ExtractTextPlugin.extract(&#123; use: &#x27;css-loader&#x27;, fallback: &#x27;vue-style-loader&#x27; &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125; ] &#125;, plugins:[ new VueLoaderPlugin() ] vue文件注意事项123456789101112131415 // index.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/main.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; // type=&quot;text/javascript&quot; 必须填写，负责会有部分代码无法识别 &lt;script type=&quot;text/javascript&quot; src=&quot;/dist/main.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 设置文件导入省略后缀12345678resolve: &#123; // js,vue,json 文件可以省略后缀，会自动识别 extensions: [&#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], // 设置别名 /src 可以直接用@代替 alias: &#123; &#x27;@&#x27;: resolve(&#x27;src&#x27;) &#125;&#125; 配置url-loader和file-loader来支持图片、字体等文件1234567891011121314// 安装url-loader和file-loadernpm install -D url-loader file-loader// webpack.config.jsrules: [ &#123; test: /\\.(gif|jpg|png|woff|svg|ect|ttf)\\??.*$/, loader: &#x27;url-loader?limit=1024&#x27; &#125;]// limit=1024 指小于1024b就以base64的形式加载// vue中使用最好使用变量承载图片路径 项目打包依赖123456789101112131415161718192021222324252627282930313233343536373839404142// 安装 webpack-merge 和 htm-webpack-pluginnpm install -D webpack-merge html-webpack-plugin// 新建一个webpack.prod.config.js文件var webpack=require(&#x27;webpack&#x27;);var HtmlwebpackPlugin=require(&#x27;html-webpack-plugin&#x27;);var ExtractTextPlugin=require(&#x27;extract-text-webpack-plugin&#x27;);var merge=require(&#x27;webpack-merge&#x27;);var webpackBaseConfig=require(&#x27;./webpack.config.js&#x27;);const UglifyJsPlugin = require(&#x27;uglifyjs-webpack-plugin&#x27;)//清空基本配置的插件列表module.exports=merge(webpackBaseConfig,&#123;output:&#123;publicPath:&#x27;/dist/&#x27;,// 将入口文件重命名为带有20位hash值的唯一文件filename:&#x27;[name].[hash].js&#x27;&#125;,plugins:[new ExtractTextPlugin(&#123;// 提取css，并重命名为带有20位hash值的唯一文件filename:&#x27;[name].[hash].css&#x27;,allChunks:true&#125;),// 定义当前node环境为生产环境new webpack.DefinePlugin(&#123;&#x27;process.env&#x27;:&#123;NODE_ENV:&#x27;&quot;production&quot;&#x27;&#125;&#125;),// 压缩jsnew UglifyJsPlugin(),// 提取模板，并保存入口html文件new HtmlwebpackPlugin(&#123;filename:&#x27;index.html&#x27;,template:&#x27;./index.html&#x27;,inject:true&#125;),]&#125;);// package.json 添加build设置&quot;build&quot;:&quot;webpack --progress --hide-modules --config webpack.prod.config.js&quot; 报错解决123htmlwebpackPlugin is not defined报错是因为ejs文件的htmlwebpackPlugin拼写错误，换成htmlWebpackPlugin","updated":"2020-05-04T16:29:21.000Z","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://lxx1997.github.io/tags/webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://lxx1997.github.io/tags/Vue/"}]},{"title":"关于在eggjs中使用mysql进行数据处理","path":"2020/04/12/node/eggjs-mysql/","text":"使用docker 安装mysql 数据库1234567docker pull mysql // 默认拉取最新版本的mysql mysql:5.7 拉取版本号为5.7的mysqldocker docker run -p 3306:3306 --name mysql-test mysql:5.7 // 创建mysql容器 并启动docker start mysql-test //开启mysql 服务docker stop mysql-test // 关闭mysql 服务docker restart mysql-test // 重启mysql 服务 eggjs 使用mysql 安装mysql插件 1npm install egg-mysql --save 在plugin.js 和 config.default.js 配置mysql 1234567891011121314151617181920212223242526272829303132333435// plugin.jsmodule.exports = &#123; mysql: &#123; enable: true, package: &#x27;egg-mysql&#x27;, &#125;,&#125;;// config.default.jsmodule.exports = appInfo =&gt; &#123; const config = exports = &#123;&#125;; config.mysql = &#123; client: &#123; host: &#x27;localhost&#x27;, //链接地址 port: &#x27;3306&#x27;, // 端口号 user: &#x27;root&#x27;, // 用户名 password: &#x27;123456&#x27;, // 密码 database: &#x27;eic-egg&#x27;, // 数据库 &#125;, &#125;; // 解决跨域问题 config.cors = &#123; origin: &#x27;*&#x27;, allowMethods: &#x27;GET,HEAD,PUT,POST,DELETE,PATCH,OPTIONS&#x27;, &#125;; // add your user config here const userConfig = &#123; // myAppName: &#x27;egg&#x27;, &#125;; return &#123; ...config, ...userConfig, &#125;;&#125;; 在项目中使用mysql 查询 1234// 支持自定义查询语句 变量使用?代替app.mysql.query(&#x27;sql语句&#x27;, [value1, value2, ...])eg: app.mysql.query(&#x27;select * from `user` where id = ? &amp; name = ?&#x27;, [id, name]) 插入 1app.mysql.insert(&#x27;table&#x27;, Object)","updated":"2020-04-12T04:05:35.000Z","categories":[],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/tags/eggjs/"},{"name":"mysql","slug":"mysql","permalink":"https://lxx1997.github.io/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"https://lxx1997.github.io/tags/docker/"}]},{"title":"eggjs token验证(redis & jsonwebtoken)","path":"2020/04/10/node/egg-jwt/","text":"redis 使用安装radislinux环境下安装radis sudo apt-get install redis-server 检查redis服务器系统进程 ps -aux|grep redis 查看redis端口状态 netstat -nlt|grep 6379 123456// 启动/etc/init.d/redis-server start// 停用/etc/init.d/redis-server stop// 重启/etc/init.d/redis-server restart 使用docker 安装redis123456789101112// 下载版本docker pull redis // 默认会拉取最新版本的redis docker images // 查看镜像是否安装成功docker run -itd --name redis-test -p 6379:6379 redis // 启动redis容器 端口号为6379docker start redis-test // 启动redisdocker stop redis-test // 关闭redisdocker restart redis-test // 重启redis eggjs 环境下使用redis和jsonwebtoken实现token验证1npm install jsonwebtoken middleware中间件​ jwt.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#x27;use strict&#x27;const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const jwt = require(&#x27;jsonwebtoken&#x27;) //引入jsonwebtokenmodule.exports = (options, app) =&gt; &#123; return async function userInterceptor(ctx, next) &#123; let authToken = ctx.header.authorization // 获取header里的authorization if (authToken) &#123; authToken = authToken.substring(7) const res = verifyToken(authToken) // 解密获取的Token if (res.corpid &amp;&amp; res.userid) &#123; // 如果需要限制单端登陆或者使用过程中废止某个token，或者更改token的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效 // 此处使用redis进行保存 const redis_token = await app.redis.get(&#x27;loginToken&#x27;).get(res.corpid + res.userid) // 获取保存的token if (authToken === redis_token) &#123; ctx.locals.corpid = res.corpid ctx.locals.userid = res.userid await next() &#125; else &#123; ctx.body = &#123; code: 50012, msg: &#x27;您的账号已在其他地方登录&#x27; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: 50012, msg: &#x27;登录状态已过期&#x27; &#125; &#125; &#125; else &#123; ctx.body = &#123; code: 50008, msg: &#x27;请登陆后再进行操作&#x27; &#125; &#125; &#125;&#125;// 解密，验证function verifyToken(token) &#123; const cert = fs.readFileSync(path.join(__dirname, &#x27;../public/rsa_public_key.pem&#x27;)) // 公钥，看后面生成方法 let res = &#x27;&#x27; try &#123; const result = jwt.verify(token, cert, &#123; algorithms: [ &#x27;RS256&#x27; ] &#125;) || &#123;&#125; const &#123; exp &#125; = result, current = Math.floor(Date.now() / 1000) if (current &lt;= exp) res = result.data || &#123;&#125; &#125; catch (e) &#123; console.log(e) &#125; return res&#125; 使用中间件12345678910111213// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; 生成token​ 写在helper里面，方便调用 1234567891011121314151617181920// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;config.redis = &#123; client: &#123; host: &#x27;127.0.0.1&#x27;, port: &#x27;6379&#x27;, password: &#x27;&#x27;, db: 0, &#125;, &#125;;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; ​ 调用token生成方式 12345678910111213// 方法一：在应用中使用中间件config.middleware = [ &#x27;jwt&#x27; ]config.jwt = &#123; enable: true, ignore: [ &#x27;/api/v1/test/&#x27;, &#x27;/public/&#x27; ], // 哪些请求不需要认证&#125;// 方法二：router中使用中间件module.exports = app =&gt; &#123; const jwt = app.middleware.jwt(); app.router.get(&#x27;/api/v1/test/&#x27;, jwt, app.controller.test.test);&#125;; 利用openssl生成私钥和公钥12生成公钥：openssl genrsa -out rsa_private_key.pem 1024 生成私钥: openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem","updated":"2020-04-09T17:33:58.000Z","categories":[],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/tags/eggjs/"},{"name":"jsonwebtoken","slug":"jsonwebtoken","permalink":"https://lxx1997.github.io/tags/jsonwebtoken/"},{"name":"redis","slug":"redis","permalink":"https://lxx1997.github.io/tags/redis/"},{"name":"deepin","slug":"deepin","permalink":"https://lxx1997.github.io/tags/deepin/"}]},{"title":"typescript 学习质量 - 01","path":"2020/04/08/web/typescript-study-01/","text":"参考文章:廖雪峰 typescript入门教程 数据类型原始数据类型 boolean 布尔值1234567let isDone: boolean = false;// 注意:使用构造函数Boolean创建的对象不是布尔值let createdByNewBoolean: boolean = new Boolean(1);// Type &#x27;Boolean&#x27; is not assignable to type &#x27;boolean&#x27;.// &#x27;boolean&#x27; is a primitive, but &#x27;Boolean&#x27; is a wrapper object. Prefer using &#x27;boolean&#x27; when possible.// 实际上new Boolean 返回的是一个boolean对象 number 数值定义 string 字符串定义 void 空值声明一个void类型的变量 只能赋值为undefined和null null undefinednull 和 undefined 是所有类型的子类型 任意值 any 如果是一个普通类型,在复制过程中改变变量类型是不允许的,但是any类型允许被赋值为任意类型. 在任意值上访问任何属性都是允许的,也可以调用任何方法 变量如果在声明时,未指定类型,将会被识别为任意值 如果没有明确指定类型,typescript会按照类型推论的规则，推断出一个类型如果定义的时候没有复制，不管之后有没有复制，都会被推断成any类型而不被检查 联合类型 12let myFavoriteNumber: string | number;// myFavoritNumber 可以取字符串类型和数值类型的一种 当typescript不确定一个联合类型的变量是哪个变量的时候，只能访问此联合类型的所有类型里共有的属性和方法123function getString(something: string | number): string &#123; return something.toString();&#125;定义的联合类型的变量在被赋值的时候，会根据类型推论规则推断出一个类型 接口什么是接口接口是对行为的抽象，具体如何行动需要由类(classes)去实现(implement)typescript 中的接口是一个十分灵活的概念，除了可以用于对类的一部分行为进行抽象以外，也常用于对[对象的形状(shape)]进行描述 123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, age: 25&#125;; 接口一般首字母大写，建议接口的名称上加上I前缀定义的变量和接口属性不同是不允许的 可选属性又是完美希望不要完全匹配一个形状，那么可用可选属性 12345678interface Person &#123; name: string; age?: number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;&#125;; 可选属性的含义是该属性可以不存在这是仍然不允许添加未定义的属性 任意属性 如果希望一个接口允许有任意属性，可以使用如下方式12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, gender: &#x27;male&#x27;&#125;;使用[propNmae: string]定义了任意属性去string类型的值一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集 也就是值的属性需要和任意值的属性相同，如果不同则会报错 一个接口只能定义一个任意属性，如果接口中有多个类型的属性，则可以在任意属性中使用联合类型1234567891011interface Person &#123; name: string; age?: number; [propName: string]: string | number;&#125;let tom: Person = &#123; name: &#x27;Tom&#x27;, age: 25, gender: &#x27;male&#x27;&#125;;只读属性 readonly readonly 属性需要在初始化对象的时候赋值只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候 数组1let list: any[] = [&#x27;lxx&#x27;, 24, &#123;age: 30&#125;] 函数类型在javascript中有两种常见的定义函数的方式—-函数声明和函数表达式 1234567// 函数声明 Function Declarationfunction sum(x,y) &#123;&#125;// 函数表达式let one = function() &#123;&#125; 一个函数有输入和输出，要在TypeScript 中对其进行约束，需要把输入和输出都考虑到，其中函数声明的类型比较简单。输入多余的(或者少于要求的)参数是不被允许的 函数表达式 123456789 // 第一种 let sum = function(x: number, y number): number &#123; &#125; // 第一种方法只对等号右侧的匿名函数进行了类型定义，而等号左边的mysum，是通过复制操作进行类型推论而推断出来的 // 第二种 推介 let sum: (x: number, y:number) =&gt; number = function(x: number, y number): number &#123;&#125; typescript中的 =&gt; 和es6中的=&gt; 代表的含义不同typescript中 =&gt;表示函数的定义，左侧是输入类型，需要用括号括起来，右边是输出类型 接口定义函数 1234567interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: SearchFuncmySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 采用函数表达式|接口定义函数的方式时，对等号左侧进行类型限制，可以保证以后对函数名赋值时保证参数个数，参数类型，返回值类型不变 可选参数用?表示可选参数 123456789function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + &#x27; &#x27; + lastName; &#125; else &#123; return firstName; &#125;&#125;let tomcat = buildName(&#x27;Tom&#x27;, &#x27;Cat&#x27;);let tom = buildName(&#x27;Tom&#x27;); 可选参数必须就在必需参数后面，可选参数后面不允许在出现必须参数 参数默认值typescript 会将添加了默认值的参数识别为可选参数，如果不传参，将会设置为默认值 剩余参数ES6中可以使用...rest 方式 获取函数中的剩余参数 剩余参数只能是最后一个参数 重载 1234567function reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125; 表达不够精确，输入为数字的时候，输出也应该是数字这时可以使用重载定义多个reverse的函数类型123456789function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string &#123; if (typeof x === &#x27;number&#x27;) &#123; return Number(x.toString().split(&#x27;&#x27;).reverse().join(&#x27;&#x27;)); &#125; else if (typeof x === &#x27;string&#x27;) &#123; return x.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;); &#125; &#125;TypeScript会有限从最前面的函数定义开始匹配，多个函数定义如果有包含关系，需要优先把精确的定义写在前面 类型断言123值 as 类型or&lt;类型&gt;值 类型断言可以用来手动指定一个值的类型 将一个联合类型断言为其中一个类型 当typescript不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型的共有的属性和方法 如果我们需要在还不确定类型的时候就访问其中一个类型特有的属性和方法此时可以使用类型断言，将animal断言成fish123456789101112131415interface Cat &#123; name: string, run(): void&#125;interface Fish&#123; name: String, swim(): void&#125;function isFish(animal: Cat|Fish) &#123; if(typeof (animal as Fish).swim === &#x27;function&#x27;) &#123; return true &#125; return false&#125; 注意：类型断言只能欺骗typescript编译器，无法避免运行时的错误，反而滥用类型断言可能会导致运行时错误在使用类型断言的时候，如果没有使用公共方法，如果传入类型变化，就会导致运行错误使用类型断言的时候要格外小心，尽量避免断言后调用方法或者引用深层属性，减少不必要的运行时错误 将一个父类断言为更加具体的子类123456789101112class ApiError extends Error &#123; code: number = 0;&#125;class HttpError extends Error &#123; code: number = 200;&#125;function isApiError(error:Error) &#123; if(typeof (error as ApiError).code === &#x27;number&#x27;) &#123; return true &#125; return false&#125; 上面的例子 因为ApiError 和HttpError是一个类 还可以通过instanceof 来判断error是否是它的实例 但是有的时候ApiError 和HttpError不是一个类，而是一个接口(interface) 接口是一个类型，不是一个真正的值，在编译的结果中会被删除，无法使用instanceof 来做运行时判断 将任何一个类型断言为any 当我们引用一个在此类型上不存在的属性和方法时，就会报错，这时可以使用as any 临时断言为any类型在any类型的变量上，访问任何属性都是允许的，将一个变量断言为any 是解决typescript中类型问题的最后一个手段， 它极有可能掩盖了真正的类型错误 将any断言为一个具体的类型在日常代码操作时，遇到any类型的变量，可以选择无视它，任由滋生更多的any，也可以选择改进它，通过类型断言及时吧any断言为精确的类型，使我们的代码向着高可维护性的目标发展 1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run() 类型断言限制 联合类型可以被断言为其中一个类型 父类可以被断言为子类 任何类型都可以被断言为any any可以被断言为任何类型 要使得A能被断言为B，只需要A兼容B或B兼容A但是并不是任何一类型都可以被断言为任何另一个类型eg:12345678910111213interface Animal &#123; name: string;&#125;interface Cat &#123; name: string; run(): void;&#125;let tom: Cat = &#123; name: &#x27;Tom&#x27;, run: () =&gt; &#123;console.log(&#x27;run&#x27;)&#125;&#125;let animal: Animal = tom typescript 是结构类型系统，类型之间的对比只会比较最终的结构，而会忽略他们定义时的关系上面的这个例子，Cat包含了 Animal中的所有属性，除此之外，还有一个额外的方法run，typescript并不关心Cat和Animal之间定义的时是什么关系，智慧看他们最终的结构有什么关系，所以与Cat extends Animal是等价的 如果animal 兼容 Cat时，他们就可以互相进行类型断言 允许Animal as Cat是因为父类可以被断言为子类 允许Cat as Animal因为既然子类拥有父类的属性和方法，那么被断言为父类，获取父类的属性，调用父类的方法不会出现问题，故子类可以被断言为父类 双重断言 任何类型都可以被断言为any any可以被断言为任何类型12345678910interface Cat &#123; run(): void;&#125;interface Fish &#123; swim(): void;&#125;function testCat(cat: Cat) &#123; return (cat as any as Fish);&#125; 上面这个例子中，如果直接使用cat as Fish,肯定会报错,因为Cat和Fish不兼容 这时候如果使用双重断言 价格任何一个类型断言为任何另一个类型但是双重断言可能会导致运行时错误除非迫不得已,千万不要使用双重断言 类型断言 VS 类型转换类型断言智慧影响TypeScript编译时的类型,编译完成后,类型断言语句会被删除 123456function toBoolean(something: any): boolean &#123; return something as boolean;&#125;toBoolean(1);// 返回值为 1 所以类型断言不是类型转换,不会影响到变量的类型如果要进行类型转换,直接调用类型转换方法123456function toBoolean(something: any): boolean &#123; return Boolean(something);&#125;toBoolean(1);// 返回值为 true 类型断言 VS类型声明1234567891011function getCacheData(key: string): any &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData(&#x27;tom&#x27;) as Cat;tom.run(); 使用as Cat 将any类型断言为Cat类型也可以通过类型声明的方法将tom声明为Cat，然后再将ay类型的getCacheData(&#39;tom&#39;)赋值给Cat类型的tom类型声明比类型断言更加严格，因此为了增加代码质量，优先使用类型声明，这也比类型断言的as语法更加优雅 类型断言 VS 泛型我们还有第三种方式可以解决这个问题，那就是泛型：1234567891011function getCacheData&lt;T&gt;(key: string): T &#123; return (window as any).cache[key];&#125;interface Cat &#123; name: string; run(): void;&#125;const tom = getCacheData&lt;Cat&gt;(&#x27;tom&#x27;);tom.run();通过给 getCacheData 函数添加了一个泛型 ，我们可以更加规范的实现对 getCacheData 返回值的约束，这也同时去除掉了代码中的 any，是最优的一个解决方案。 声明文件 declare var 声明全局变量 declare function 声明全局方法 declare class 声明全局类 declare enum 声明全局枚举 declare namespace 声明（含有子属性的）全局对象 interface和type声明全局类型 export 导出变量 export namespace 导出（含有子属性的）对象 export default ES6默认导出 export = commonjs导出模块 export as namespace UMD库声明全局变量 declare global 扩展全局变量 declare module 扩展模块 /// 三斜线指令 什么是声明语句eg：当我们要使用一些第三方库的时候，在ts中，编译器并不知道他们是什么东西，这时候就需要使用declare var 来定义他的类型 123declare var jQuery: (selector: string) =&gt; anyjQuery(&#x27;#foo&#x27;) declare var 并没有真正的定义一个变量，只是定义了全局变量jQuery的类型，仅仅会用于编译时的检查，在编译结果中会被删除 什么是声明文件 通常会把声明语句放到一个单独的文件（jQuery.d.ts）中，这就是声明文件 12345// jquery.d.tsdeclare var jQuery: (selector: string) =&gt; any// index.tsjQuery(&#x27;#foo&#x27;) 声明文件必须以.d.ts为后缀ts会解析项目中所有的*.ts文件，当然也包含以.d.ts结尾的文件。所以我们将jQuery.d.ts放到项目中，其他所有*.ts文件就可以获得jQuery的类型定义 第三方声明文件 推介使用@types统一管理第三方库的声明文件,直接用npm安装对应的声明模块即可1npm install @types/jquery --save-dev 全局变量 declare var 用来定义给全局变量的类型 declare let declare const 同理,声明语句中只能定义类型，切勿在声明语句中定义具体的实现declare const 不允许再次修改值 declare function 定义全局函数的类型在函数类型的声明语句中,函数重载也是支持的12345678910// src/jQuery.d.tsdeclare function jQuery(selector: string): any;declare function jQuery(domReadyCallback: () =&gt; any): any;// src/index.tsjQuery(&#x27;#foo&#x27;);jQuery(function() &#123; alert(&#x27;Dom Ready!&#x27;);&#125;); declare class 当全局变量是一个类,我们用declare class 来定义他的类型declare class 语句也只能用来定义类型,不能用来定义具体的体现 12345678910// src/Animal.d.tsdeclare class Animal &#123; name: string; constructor(name: string); sayHi(): string;&#125;// src/index.tslet cat = new Animal(&#x27;Tom&#x27;); *declare enum 外部枚举 1234567891011// src/Directions.d.tsdeclare enum Directions &#123; Up, Down, Left, Right&#125;// src/index.tslet directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 与全局变量类型声明一致,declare enum 仅用来定义类型,而不是具体的值 declare namespacenamespace 是ts早期为了解决模块化而创造的关键字,中文称命名空间我们应该使用declare namespace jQuery 来声明拥有多个子属性的全局变量12345678// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void;&#125;// src/index.tsjQuery.ajax(&#x27;/api/get_something&#x27;); 在delcare namespace 内部,我们也可以直接使用function ajax来声明哈数,而不是使用delcare function ajax 也可以使用const, class, enum等语句嵌套的命名空间如果对象拥有深层的层级,则需要使用嵌套的namespace来声明深层的属性类型 12345678910111213141516// src/jQuery.d.tsdeclare namespace jQuery &#123; function ajax(url: string, settings?: any): void; namespace fn &#123; function extend(object: any): void; &#125;&#125;// src/index.tsjQuery.ajax(&#x27;/api/get_something&#x27;);jQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); 当然,如果jQuery下仅有fn这一个属性 则不需要嵌套namespace 123456789101112// src/jQuery.d.tsdeclare namespace jQuery.fn &#123; function extend(object: any): void;&#125;// src/index.tsjQuery.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;); &#125;&#125;); interface &amp;&amp; type 使用interface和type来声明一个全局的接口或者类型","updated":"2020-04-08T01:10:06.000Z","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/categories/TypeScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://lxx1997.github.io/tags/ES6/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://lxx1997.github.io/tags/TypeScript/"}]},{"title":"eggjs-start","path":"2020/03/25/node/eggjs-start/","text":"eggjs 定义设计原则​ egg的产检机制有很高的可扩展性，一个插件只做意见事情，egg通过框架聚合这些插件，并根据自己的业务场景定制配置，可以降低应用的开发成本 其他框架的差异express​ express是node.js社区广泛使用的框架，简单且扩展性强，适合做个人项目，但框架本身缺少约定，标准的MVC模型会有各种千奇百怪的写法，egg按照约定进行开发，奉行约定优先配置，团队协作成本低 sails​ sails和egg一样奉行【约定优与配置】的框架，扩展性也非常好，但是相比egg，sails支持Blueprint REST API、WhaterLine这样可扩展的ORM、前端集成、websocket等，但是这些功能都是优Sails提供的，但egg不直接提供功能，只是集成各种功能插件，比如实现egg’-blueprint,egg-waterline这样的插件，在使用sails-egg框架整合这些插件 特性 提供基于egg定制上层框架的能力 高度可扩展的插件机制 内置多进程管理 基于Koa开发，性能优异 框架稳定，测试覆盖率高 渐进式开发 异步编程模型​ nodejs是一个异步的世界，官方API支持的都是以callback的形式的异步编程模型，这种会存在一些问题 callback hell: 最臭名昭著的callback嵌套问题 release zalgo: 异步函数中可能同步调用callback返回数据，带来不一致性 ​ 异步解决方案 promise async function 在async function中，我们可以通过await关键字等待一个Promise被resolve 123456const fn = async function() &#123; const user = await getUser(); const posts = await fetchPosts(user.id); return &#123; user, posts &#125;;&#125;;fn().then(res =&gt; console.log(res)).catch(err =&gt; console.error(err.stack)); Koa​ koa 是一个新的web框架，由express幕后原班人马打造，致力于成为web应用和api开发领域中的一个更小更富有表现力更健壮基石 middleware​ 中间件，所有请求经过一个中间件的时候都会执行两次，koa模型可以非常方便的实现后置处理逻辑 context​ 和express只有request和response两个对象不同，koa增加了一个context的对象，作为这次请求的上下文对象，我们可以把一次请求相关的上下文都挂载到这个对象上 ​ 同时context上也挂在了request和response两个对象，提供了大量的便捷方式辅助开发 1234get request.queryget request.hostnameset response.bodyset response.status 异常处理​ 通过同步方式编写异步代码带来的另外一个非常大的好处就是异常处理，使用try…catch就可以将按照规范编写的代码的所有错误都可以捕获到，这样我们可以很便捷的编写一个自定义的错误处理中间件 123456789async function onerror(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit(&#x27;error&#x27;, err); ctx.body = &#x27;server error&#x27;; ctx.status = err.status || 500; &#125;&#125; ​ 只需要将这个中间件放到其他中间件之前，就可以捕获它们所有的同步或者异步代码中抛出的异常 扩展​ 在基于egg的框架或者应用中，我们可以通过定义 app/extend/{application,content,request,response}.js来扩展koa中对应的四个对象圆形，可以快速增加更多的辅助方法，列入在app/extend/context.js中写入一下代码 1234567// app/extend/context.jsmodule.exports = &#123; get isIOS() &#123; const iosReg = /iphone|ipad|ipod/i; return iosReg.test(this.get(&#x27;user-agent&#x27;)); &#125;,&#125;; ​ 在controller中，我们就可以使用到刚才定义的这个便捷属性了 123456// app/controller/home.jsexports.handler = ctx =&gt; &#123; ctx.body = ctx.isIOS ? &#x27;Your operating system is iOS.&#x27; : &#x27;Your operating system is not iOS.&#x27;;&#125;; 插件​ 在express和koa中，经常会引入许许多多的中间件来提供各种各样的功能，列入引入koa-session提供session的支持，引入koa-bodyparser来解析请求body，egg提供一共更加强大的插件机制，让这些地理领域的功能模块可以更加容易编写 extend：扩展基础对象上下文，提供各种工具类和属性 middleware：增加一共或多个中间件，提供请求的前置和后置处理逻辑 config：配置各个环境下插件自身的默认配置项","updated":"2020-03-25T11:41:08.000Z","categories":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/categories/eggjs/"}],"tags":[{"name":"eggjs","slug":"eggjs","permalink":"https://lxx1997.github.io/tags/eggjs/"},{"name":"nodejs","slug":"nodejs","permalink":"https://lxx1997.github.io/tags/nodejs/"},{"name":"backEnd","slug":"backEnd","permalink":"https://lxx1997.github.io/tags/backEnd/"}]}]}